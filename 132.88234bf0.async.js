(self["webpackChunk"] = self["webpackChunk"] || []).push([[132],{

/***/ 80882:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: function() { return /* binding */ icons_DownOutlined; }
});

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(87462);
// EXTERNAL MODULE: ./node_modules/@umijs/preset-umi/node_modules/react/index.js
var react = __webpack_require__(62435);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons-svg/es/asn/DownOutlined.js
// This icon file is generated automatically.
var DownOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, "name": "down", "theme": "outlined" };
/* harmony default export */ var asn_DownOutlined = (DownOutlined);

// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/components/AntdIcon.js + 3 modules
var AntdIcon = __webpack_require__(42135);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons/es/icons/DownOutlined.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY




var DownOutlined_DownOutlined = function DownOutlined(props, ref) {
  return /*#__PURE__*/react.createElement(AntdIcon/* default */.Z, (0,esm_extends/* default */.Z)({}, props, {
    ref: ref,
    icon: asn_DownOutlined
  }));
};

/**![down](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg4NCAyNTZoLTc1Yy01LjEgMC05LjkgMi41LTEyLjkgNi42TDUxMiA2NTQuMiAyMjcuOSAyNjIuNmMtMy00LjEtNy44LTYuNi0xMi45LTYuNmgtNzVjLTYuNSAwLTEwLjMgNy40LTYuNSAxMi43bDM1Mi42IDQ4Ni4xYzEyLjggMTcuNiAzOSAxNy42IDUxLjcgMGwzNTIuNi00ODYuMWMzLjktNS4zLjEtMTIuNy02LjQtMTIuN3oiIC8+PC9zdmc+) */
var RefIcon = /*#__PURE__*/react.forwardRef(DownOutlined_DownOutlined);
if (false) {}
/* harmony default export */ var icons_DownOutlined = (RefIcon);

/***/ }),

/***/ 68795:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: function() { return /* binding */ icons_SearchOutlined; }
});

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(87462);
// EXTERNAL MODULE: ./node_modules/@umijs/preset-umi/node_modules/react/index.js
var react = __webpack_require__(62435);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons-svg/es/asn/SearchOutlined.js
// This icon file is generated automatically.
var SearchOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
/* harmony default export */ var asn_SearchOutlined = (SearchOutlined);

// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/components/AntdIcon.js + 3 modules
var AntdIcon = __webpack_require__(42135);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons/es/icons/SearchOutlined.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY




var SearchOutlined_SearchOutlined = function SearchOutlined(props, ref) {
  return /*#__PURE__*/react.createElement(AntdIcon/* default */.Z, (0,esm_extends/* default */.Z)({}, props, {
    ref: ref,
    icon: asn_SearchOutlined
  }));
};

/**![search](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTkwOS42IDg1NC41TDY0OS45IDU5NC44QzY5MC4yIDU0Mi43IDcxMiA0NzkgNzEyIDQxMmMwLTgwLjItMzEuMy0xNTUuNC04Ny45LTIxMi4xLTU2LjYtNTYuNy0xMzItODcuOS0yMTIuMS04Ny45cy0xNTUuNSAzMS4zLTIxMi4xIDg3LjlDMTQzLjIgMjU2LjUgMTEyIDMzMS44IDExMiA0MTJjMCA4MC4xIDMxLjMgMTU1LjUgODcuOSAyMTIuMUMyNTYuNSA2ODAuOCAzMzEuOCA3MTIgNDEyIDcxMmM2NyAwIDEzMC42LTIxLjggMTgyLjctNjJsMjU5LjcgMjU5LjZhOC4yIDguMiAwIDAwMTEuNiAwbDQzLjYtNDMuNWE4LjIgOC4yIDAgMDAwLTExLjZ6TTU3MC40IDU3MC40QzUyOCA2MTIuNyA0NzEuOCA2MzYgNDEyIDYzNnMtMTE2LTIzLjMtMTU4LjQtNjUuNkMyMTEuMyA1MjggMTg4IDQ3MS44IDE4OCA0MTJzMjMuMy0xMTYuMSA2NS42LTE1OC40QzI5NiAyMTEuMyAzNTIuMiAxODggNDEyIDE4OHMxMTYuMSAyMy4yIDE1OC40IDY1LjZTNjM2IDM1Mi4yIDYzNiA0MTJzLTIzLjMgMTE2LjEtNjUuNiAxNTguNHoiIC8+PC9zdmc+) */
var RefIcon = /*#__PURE__*/react.forwardRef(SearchOutlined_SearchOutlined);
if (false) {}
/* harmony default export */ var icons_SearchOutlined = (RefIcon);

/***/ }),

/***/ 27320:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`positive integer expected, not ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`boolean expected, not ${b}`);
}
exports.bool = bool;
// copied from utils
function isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
exports.isBytes = isBytes;
function bytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(h.outputLen);
    number(h.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
exports.output = output;
const assert = { number, bool, bytes, hash, exists, output };
exports["default"] = assert;
//# sourceMappingURL=_assert.js.map

/***/ }),

/***/ 75457:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HashMD = exports.Maj = exports.Chi = void 0;
const _assert_js_1 = __webpack_require__(27320);
const utils_js_1 = __webpack_require__(98089);
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
exports.Chi = Chi;
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
exports.Maj = Maj;
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */
class HashMD extends utils_js_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
    }
    update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_js_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}
exports.HashMD = HashMD;
//# sourceMappingURL=_md.js.map

/***/ }),

/***/ 31945:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;
//# sourceMappingURL=crypto.js.map

/***/ }),

/***/ 70830:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ripemd160 = exports.RIPEMD160 = void 0;
const _md_js_1 = __webpack_require__(75457);
const utils_js_1 = __webpack_require__(98089);
// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((_, i) => i));
const Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i = 0; i < 4; i++)
    for (let j of [idxL, idxR])
        j.push(j[i].map((k) => Rho[k]));
const shifts = /* @__PURE__ */ [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
].map((i) => new Uint8Array(i));
const shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
const shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
const Kl = /* @__PURE__ */ new Uint32Array([
    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,
]);
const Kr = /* @__PURE__ */ new Uint32Array([
    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,
]);
// It's called f() in spec.
function f(group, x, y, z) {
    if (group === 0)
        return x ^ y ^ z;
    else if (group === 1)
        return (x & y) | (~x & z);
    else if (group === 2)
        return (x | ~y) ^ z;
    else if (group === 3)
        return (x & z) | (y & ~z);
    else
        return x ^ (y | ~z);
}
// Temporary buffer, not used to store anything between runs
const R_BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _md_js_1.HashMD {
    constructor() {
        super(64, 20, 8, true);
        this.h0 = 0x67452301 | 0;
        this.h1 = 0xefcdab89 | 0;
        this.h2 = 0x98badcfe | 0;
        this.h3 = 0x10325476 | 0;
        this.h4 = 0xc3d2e1f0 | 0;
    }
    get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            R_BUF[i] = view.getUint32(offset, true);
        // prettier-ignore
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore
            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore
            for (let i = 0; i < 16; i++) {
                const tl = ((0, utils_js_1.rotl)(al + f(group, bl, cl, dl) + R_BUF[rl[i]] + hbl, sl[i]) + el) | 0;
                al = el, el = dl, dl = (0, utils_js_1.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for (let i = 0; i < 16; i++) {
                const tr = ((0, utils_js_1.rotl)(ar + f(rGroup, br, cr, dr) + R_BUF[rr[i]] + hbr, sr[i]) + er) | 0;
                ar = er, er = dr, dr = (0, utils_js_1.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);
    }
    roundClean() {
        R_BUF.fill(0);
    }
    destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
    }
}
exports.RIPEMD160 = RIPEMD160;
/**
 * RIPEMD-160 - a hash function from 1990s.
 * @param message - msg that would be hashed
 */
exports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());
//# sourceMappingURL=ripemd160.js.map

/***/ }),

/***/ 73963:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha1 = void 0;
const _md_js_1 = __webpack_require__(75457);
const utils_js_1 = __webpack_require__(98089);
// SHA1 (RFC 3174) was cryptographically broken. It's still used. Don't use it for a new protocol.
// Initial state
const SHA1_IV = /* @__PURE__ */ new Uint32Array([
    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA1_W = /* @__PURE__ */ new Uint32Array(80);
class SHA1 extends _md_js_1.HashMD {
    constructor() {
        super(64, 20, 8, false);
        this.A = SHA1_IV[0] | 0;
        this.B = SHA1_IV[1] | 0;
        this.C = SHA1_IV[2] | 0;
        this.D = SHA1_IV[3] | 0;
        this.E = SHA1_IV[4] | 0;
    }
    get() {
        const { A, B, C, D, E } = this;
        return [A, B, C, D, E];
    }
    set(A, B, C, D, E) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            SHA1_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 80; i++)
            SHA1_W[i] = (0, utils_js_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
        // Compression function main loop, 80 rounds
        let { A, B, C, D, E } = this;
        for (let i = 0; i < 80; i++) {
            let F, K;
            if (i < 20) {
                F = (0, _md_js_1.Chi)(B, C, D);
                K = 0x5a827999;
            }
            else if (i < 40) {
                F = B ^ C ^ D;
                K = 0x6ed9eba1;
            }
            else if (i < 60) {
                F = (0, _md_js_1.Maj)(B, C, D);
                K = 0x8f1bbcdc;
            }
            else {
                F = B ^ C ^ D;
                K = 0xca62c1d6;
            }
            const T = ((0, utils_js_1.rotl)(A, 5) + F + E + K + SHA1_W[i]) | 0;
            E = D;
            D = C;
            C = (0, utils_js_1.rotl)(B, 30);
            B = A;
            A = T;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        this.set(A, B, C, D, E);
    }
    roundClean() {
        SHA1_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
exports.sha1 = (0, utils_js_1.wrapConstructor)(() => new SHA1());
//# sourceMappingURL=sha1.js.map

/***/ }),

/***/ 23061:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha224 = exports.sha256 = void 0;
const _md_js_1 = __webpack_require__(75457);
const utils_js_1 = __webpack_require__(98089);
// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state:
// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
// prettier-ignore
const SHA256_IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_js_1.HashMD {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = (H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = (sigma0 + (0, _md_js_1.Maj)(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor() {
        super();
        this.A = 0xc1059ed8 | 0;
        this.B = 0x367cd507 | 0;
        this.C = 0x3070dd17 | 0;
        this.D = 0xf70e5939 | 0;
        this.E = 0xffc00b31 | 0;
        this.F = 0x68581511 | 0;
        this.G = 0x64f98fa7 | 0;
        this.H = 0xbefa4fa4 | 0;
        this.outputLen = 28;
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
//# sourceMappingURL=sha256.js.map

/***/ }),

/***/ 98089:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = __webpack_require__(31945);
const _assert_js_1 = __webpack_require__(27320);
// export { isBytes } from './_assert.js';
// We can't reuse isBytes from _assert, because somehow this causes huge perf issues
function isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
exports.isBytes = isBytes;
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
exports.rotr = rotr;
// The rotate left (circular left shift) operation for uint32
const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);
exports.rotl = rotl;
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// The byte swap operation for uint32
const byteSwap = (word) => ((word << 24) & 0xff000000) |
    ((word << 8) & 0xff0000) |
    ((word >>> 8) & 0xff00) |
    ((word >>> 24) & 0xff);
exports.byteSwap = byteSwap;
// Conditionally byte swap if on a big-endian platform
exports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);
// In place byte swap for Uint32Array
function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
        arr[i] = (0, exports.byteSwap)(arr[i]);
    }
}
exports.byteSwap32 = byteSwap32;
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    (0, _assert_js_1.bytes)(bytes);
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
    return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
exports.asyncLoop = asyncLoop;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    (0, _assert_js_1.bytes)(data);
    return data;
}
exports.toBytes = toBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        (0, _assert_js_1.bytes)(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
const toStr = {}.toString;
function checkOpts(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== '[object Object]')
        throw new Error('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
exports.randomBytes = randomBytes;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 40228:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: function() { return /* binding */ trigger_es; }
});

// UNUSED EXPORTS: generateTrigger

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__(1413);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js + 1 modules
var slicedToArray = __webpack_require__(97685);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js + 1 modules
var objectWithoutProperties = __webpack_require__(91);
// EXTERNAL MODULE: ./node_modules/@rc-component/portal/es/index.js + 7 modules
var es = __webpack_require__(54535);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(93967);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/rc-resize-observer/es/index.js + 5 modules
var rc_resize_observer_es = __webpack_require__(9220);
// EXTERNAL MODULE: ./node_modules/rc-util/es/Dom/findDOMNode.js
var findDOMNode = __webpack_require__(34203);
// EXTERNAL MODULE: ./node_modules/rc-util/es/Dom/shadow.js
var shadow = __webpack_require__(27571);
// EXTERNAL MODULE: ./node_modules/rc-util/es/hooks/useEvent.js
var useEvent = __webpack_require__(66680);
// EXTERNAL MODULE: ./node_modules/rc-util/es/hooks/useId.js
var useId = __webpack_require__(7028);
// EXTERNAL MODULE: ./node_modules/rc-util/es/hooks/useLayoutEffect.js
var useLayoutEffect = __webpack_require__(8410);
// EXTERNAL MODULE: ./node_modules/rc-util/es/isMobile.js
var isMobile = __webpack_require__(31131);
// EXTERNAL MODULE: ./node_modules/@umijs/preset-umi/node_modules/react/index.js
var react = __webpack_require__(62435);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(87462);
// EXTERNAL MODULE: ./node_modules/rc-motion/es/index.js + 12 modules
var rc_motion_es = __webpack_require__(82225);
// EXTERNAL MODULE: ./node_modules/rc-util/es/ref.js
var es_ref = __webpack_require__(42550);
;// CONCATENATED MODULE: ./node_modules/@rc-component/trigger/es/Popup/Arrow.js


function Arrow(props) {
  var prefixCls = props.prefixCls,
    align = props.align,
    arrow = props.arrow,
    arrowPos = props.arrowPos;
  var _ref = arrow || {},
    className = _ref.className,
    content = _ref.content;
  var _arrowPos$x = arrowPos.x,
    x = _arrowPos$x === void 0 ? 0 : _arrowPos$x,
    _arrowPos$y = arrowPos.y,
    y = _arrowPos$y === void 0 ? 0 : _arrowPos$y;
  var arrowRef = react.useRef();

  // Skip if no align
  if (!align || !align.points) {
    return null;
  }
  var alignStyle = {
    position: 'absolute'
  };

  // Skip if no need to align
  if (align.autoArrow !== false) {
    var popupPoints = align.points[0];
    var targetPoints = align.points[1];
    var popupTB = popupPoints[0];
    var popupLR = popupPoints[1];
    var targetTB = targetPoints[0];
    var targetLR = targetPoints[1];

    // Top & Bottom
    if (popupTB === targetTB || !['t', 'b'].includes(popupTB)) {
      alignStyle.top = y;
    } else if (popupTB === 't') {
      alignStyle.top = 0;
    } else {
      alignStyle.bottom = 0;
    }

    // Left & Right
    if (popupLR === targetLR || !['l', 'r'].includes(popupLR)) {
      alignStyle.left = x;
    } else if (popupLR === 'l') {
      alignStyle.left = 0;
    } else {
      alignStyle.right = 0;
    }
  }
  return /*#__PURE__*/react.createElement("div", {
    ref: arrowRef,
    className: classnames_default()("".concat(prefixCls, "-arrow"), className),
    style: alignStyle
  }, content);
}
;// CONCATENATED MODULE: ./node_modules/@rc-component/trigger/es/Popup/Mask.js




function Mask(props) {
  var prefixCls = props.prefixCls,
    open = props.open,
    zIndex = props.zIndex,
    mask = props.mask,
    motion = props.motion;
  if (!mask) {
    return null;
  }
  return /*#__PURE__*/react.createElement(rc_motion_es/* default */.ZP, (0,esm_extends/* default */.Z)({}, motion, {
    motionAppear: true,
    visible: open,
    removeOnLeave: true
  }), function (_ref) {
    var className = _ref.className;
    return /*#__PURE__*/react.createElement("div", {
      style: {
        zIndex: zIndex
      },
      className: classnames_default()("".concat(prefixCls, "-mask"), className)
    });
  });
}
;// CONCATENATED MODULE: ./node_modules/@rc-component/trigger/es/Popup/PopupContent.js

var PopupContent = /*#__PURE__*/react.memo(function (_ref) {
  var children = _ref.children;
  return children;
}, function (_, next) {
  return next.cache;
});
if (false) {}
/* harmony default export */ var Popup_PopupContent = (PopupContent);
;// CONCATENATED MODULE: ./node_modules/@rc-component/trigger/es/Popup/index.js












var Popup = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var popup = props.popup,
    className = props.className,
    prefixCls = props.prefixCls,
    style = props.style,
    target = props.target,
    _onVisibleChanged = props.onVisibleChanged,
    open = props.open,
    keepDom = props.keepDom,
    fresh = props.fresh,
    onClick = props.onClick,
    mask = props.mask,
    arrow = props.arrow,
    arrowPos = props.arrowPos,
    align = props.align,
    motion = props.motion,
    maskMotion = props.maskMotion,
    forceRender = props.forceRender,
    getPopupContainer = props.getPopupContainer,
    autoDestroy = props.autoDestroy,
    Portal = props.portal,
    zIndex = props.zIndex,
    onMouseEnter = props.onMouseEnter,
    onMouseLeave = props.onMouseLeave,
    onPointerEnter = props.onPointerEnter,
    ready = props.ready,
    offsetX = props.offsetX,
    offsetY = props.offsetY,
    offsetR = props.offsetR,
    offsetB = props.offsetB,
    onAlign = props.onAlign,
    onPrepare = props.onPrepare,
    stretch = props.stretch,
    targetWidth = props.targetWidth,
    targetHeight = props.targetHeight;
  var childNode = typeof popup === 'function' ? popup() : popup;

  // We can not remove holder only when motion finished.
  var isNodeVisible = open || keepDom;

  // ======================= Container ========================
  var getPopupContainerNeedParams = (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.length) > 0;
  var _React$useState = react.useState(!getPopupContainer || !getPopupContainerNeedParams),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    show = _React$useState2[0],
    setShow = _React$useState2[1];

  // Delay to show since `getPopupContainer` need target element
  (0,useLayoutEffect/* default */.Z)(function () {
    if (!show && getPopupContainerNeedParams && target) {
      setShow(true);
    }
  }, [show, getPopupContainerNeedParams, target]);

  // ========================= Render =========================
  if (!show) {
    return null;
  }

  // >>>>> Offset
  var AUTO = 'auto';
  var offsetStyle = {
    left: '-1000vw',
    top: '-1000vh',
    right: AUTO,
    bottom: AUTO
  };

  // Set align style
  if (ready || !open) {
    var _experimental;
    var points = align.points;
    var dynamicInset = align.dynamicInset || ((_experimental = align._experimental) === null || _experimental === void 0 ? void 0 : _experimental.dynamicInset);
    var alignRight = dynamicInset && points[0][1] === 'r';
    var alignBottom = dynamicInset && points[0][0] === 'b';
    if (alignRight) {
      offsetStyle.right = offsetR;
      offsetStyle.left = AUTO;
    } else {
      offsetStyle.left = offsetX;
      offsetStyle.right = AUTO;
    }
    if (alignBottom) {
      offsetStyle.bottom = offsetB;
      offsetStyle.top = AUTO;
    } else {
      offsetStyle.top = offsetY;
      offsetStyle.bottom = AUTO;
    }
  }

  // >>>>> Misc
  var miscStyle = {};
  if (stretch) {
    if (stretch.includes('height') && targetHeight) {
      miscStyle.height = targetHeight;
    } else if (stretch.includes('minHeight') && targetHeight) {
      miscStyle.minHeight = targetHeight;
    }
    if (stretch.includes('width') && targetWidth) {
      miscStyle.width = targetWidth;
    } else if (stretch.includes('minWidth') && targetWidth) {
      miscStyle.minWidth = targetWidth;
    }
  }
  if (!open) {
    miscStyle.pointerEvents = 'none';
  }
  return /*#__PURE__*/react.createElement(Portal, {
    open: forceRender || isNodeVisible,
    getContainer: getPopupContainer && function () {
      return getPopupContainer(target);
    },
    autoDestroy: autoDestroy
  }, /*#__PURE__*/react.createElement(Mask, {
    prefixCls: prefixCls,
    open: open,
    zIndex: zIndex,
    mask: mask,
    motion: maskMotion
  }), /*#__PURE__*/react.createElement(rc_resize_observer_es/* default */.Z, {
    onResize: onAlign,
    disabled: !open
  }, function (resizeObserverRef) {
    return /*#__PURE__*/react.createElement(rc_motion_es/* default */.ZP, (0,esm_extends/* default */.Z)({
      motionAppear: true,
      motionEnter: true,
      motionLeave: true,
      removeOnLeave: false,
      forceRender: forceRender,
      leavedClassName: "".concat(prefixCls, "-hidden")
    }, motion, {
      onAppearPrepare: onPrepare,
      onEnterPrepare: onPrepare,
      visible: open,
      onVisibleChanged: function onVisibleChanged(nextVisible) {
        var _motion$onVisibleChan;
        motion === null || motion === void 0 || (_motion$onVisibleChan = motion.onVisibleChanged) === null || _motion$onVisibleChan === void 0 || _motion$onVisibleChan.call(motion, nextVisible);
        _onVisibleChanged(nextVisible);
      }
    }), function (_ref, motionRef) {
      var motionClassName = _ref.className,
        motionStyle = _ref.style;
      var cls = classnames_default()(prefixCls, motionClassName, className);
      return /*#__PURE__*/react.createElement("div", {
        ref: (0,es_ref/* composeRef */.sQ)(resizeObserverRef, ref, motionRef),
        className: cls,
        style: (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({
          '--arrow-x': "".concat(arrowPos.x || 0, "px"),
          '--arrow-y': "".concat(arrowPos.y || 0, "px")
        }, offsetStyle), miscStyle), motionStyle), {}, {
          boxSizing: 'border-box',
          zIndex: zIndex
        }, style),
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onPointerEnter: onPointerEnter,
        onClick: onClick
      }, arrow && /*#__PURE__*/react.createElement(Arrow, {
        prefixCls: prefixCls,
        arrow: arrow,
        arrowPos: arrowPos,
        align: align
      }), /*#__PURE__*/react.createElement(Popup_PopupContent, {
        cache: !open && !fresh
      }, childNode));
    });
  }));
});
if (false) {}
/* harmony default export */ var es_Popup = (Popup);
;// CONCATENATED MODULE: ./node_modules/@rc-component/trigger/es/TriggerWrapper.js


var TriggerWrapper = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var children = props.children,
    getTriggerDOMNode = props.getTriggerDOMNode;
  var canUseRef = (0,es_ref/* supportRef */.Yr)(children);

  // When use `getTriggerDOMNode`, we should do additional work to get the real dom
  var setRef = react.useCallback(function (node) {
    (0,es_ref/* fillRef */.mH)(ref, getTriggerDOMNode ? getTriggerDOMNode(node) : node);
  }, [getTriggerDOMNode]);
  var mergedRef = (0,es_ref/* useComposeRef */.x1)(setRef, children.ref);
  return canUseRef ? /*#__PURE__*/react.cloneElement(children, {
    ref: mergedRef
  }) : children;
});
if (false) {}
/* harmony default export */ var es_TriggerWrapper = (TriggerWrapper);
;// CONCATENATED MODULE: ./node_modules/@rc-component/trigger/es/context.js

var TriggerContext = /*#__PURE__*/react.createContext(null);
/* harmony default export */ var es_context = (TriggerContext);
;// CONCATENATED MODULE: ./node_modules/@rc-component/trigger/es/hooks/useAction.js

function toArray(val) {
  return val ? Array.isArray(val) ? val : [val] : [];
}
function useAction(mobile, action, showAction, hideAction) {
  return react.useMemo(function () {
    var mergedShowAction = toArray(showAction !== null && showAction !== void 0 ? showAction : action);
    var mergedHideAction = toArray(hideAction !== null && hideAction !== void 0 ? hideAction : action);
    var showActionSet = new Set(mergedShowAction);
    var hideActionSet = new Set(mergedHideAction);
    if (mobile) {
      if (showActionSet.has('hover')) {
        showActionSet.delete('hover');
        showActionSet.add('click');
      }
      if (hideActionSet.has('hover')) {
        hideActionSet.delete('hover');
        hideActionSet.add('click');
      }
    }
    return [showActionSet, hideActionSet];
  }, [mobile, action, showAction, hideAction]);
}
// EXTERNAL MODULE: ./node_modules/rc-util/es/Dom/isVisible.js
var isVisible = __webpack_require__(5110);
;// CONCATENATED MODULE: ./node_modules/@rc-component/trigger/es/util.js

function isPointsEq() {
  var a1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var a2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var isAlignPoint = arguments.length > 2 ? arguments[2] : undefined;
  if (isAlignPoint) {
    return a1[0] === a2[0];
  }
  return a1[0] === a2[0] && a1[1] === a2[1];
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
  var points = align.points;
  var placements = Object.keys(builtinPlacements);
  for (var i = 0; i < placements.length; i += 1) {
    var _builtinPlacements$pl;
    var placement = placements[i];
    if (isPointsEq((_builtinPlacements$pl = builtinPlacements[placement]) === null || _builtinPlacements$pl === void 0 ? void 0 : _builtinPlacements$pl.points, points, isAlignPoint)) {
      return "".concat(prefixCls, "-placement-").concat(placement);
    }
  }
  return '';
}

/** @deprecated We should not use this if we can refactor all deps */
function getMotion(prefixCls, motion, animation, transitionName) {
  if (motion) {
    return motion;
  }
  if (animation) {
    return {
      motionName: "".concat(prefixCls, "-").concat(animation)
    };
  }
  if (transitionName) {
    return {
      motionName: transitionName
    };
  }
  return null;
}
function getWin(ele) {
  return ele.ownerDocument.defaultView;
}

/**
 * Get all the scrollable parent elements of the element
 * @param ele       The element to be detected
 * @param areaOnly  Only return the parent which will cut visible area
 */
function collectScroller(ele) {
  var scrollerList = [];
  var current = ele === null || ele === void 0 ? void 0 : ele.parentElement;
  var scrollStyle = ['hidden', 'scroll', 'clip', 'auto'];
  while (current) {
    var _getWin$getComputedSt = getWin(current).getComputedStyle(current),
      overflowX = _getWin$getComputedSt.overflowX,
      overflowY = _getWin$getComputedSt.overflowY,
      overflow = _getWin$getComputedSt.overflow;
    if ([overflowX, overflowY, overflow].some(function (o) {
      return scrollStyle.includes(o);
    })) {
      scrollerList.push(current);
    }
    current = current.parentElement;
  }
  return scrollerList;
}
function toNum(num) {
  var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  return Number.isNaN(num) ? defaultValue : num;
}
function getPxValue(val) {
  return toNum(parseFloat(val), 0);
}
/**
 *
 *
 *  **************************************
 *  *              Border                *
 *  *     **************************     *
 *  *     *                  *     *     *
 *  *  B  *                  *  S  *  B  *
 *  *  o  *                  *  c  *  o  *
 *  *  r  *      Content     *  r  *  r  *
 *  *  d  *                  *  o  *  d  *
 *  *  e  *                  *  l  *  e  *
 *  *  r  ********************  l  *  r  *
 *  *     *        Scroll          *     *
 *  *     **************************     *
 *  *              Border                *
 *  **************************************
 *
 */
/**
 * Get visible area of element
 */
function getVisibleArea(initArea, scrollerList) {
  var visibleArea = (0,objectSpread2/* default */.Z)({}, initArea);
  (scrollerList || []).forEach(function (ele) {
    if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) {
      return;
    }

    // Skip if static position which will not affect visible area
    var _getWin$getComputedSt2 = getWin(ele).getComputedStyle(ele),
      overflow = _getWin$getComputedSt2.overflow,
      overflowClipMargin = _getWin$getComputedSt2.overflowClipMargin,
      borderTopWidth = _getWin$getComputedSt2.borderTopWidth,
      borderBottomWidth = _getWin$getComputedSt2.borderBottomWidth,
      borderLeftWidth = _getWin$getComputedSt2.borderLeftWidth,
      borderRightWidth = _getWin$getComputedSt2.borderRightWidth;
    var eleRect = ele.getBoundingClientRect();
    var eleOutHeight = ele.offsetHeight,
      eleInnerHeight = ele.clientHeight,
      eleOutWidth = ele.offsetWidth,
      eleInnerWidth = ele.clientWidth;
    var borderTopNum = getPxValue(borderTopWidth);
    var borderBottomNum = getPxValue(borderBottomWidth);
    var borderLeftNum = getPxValue(borderLeftWidth);
    var borderRightNum = getPxValue(borderRightWidth);
    var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1000) / 1000);
    var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1000) / 1000);

    // Original visible area
    var eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;
    var eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;

    // Cut border size
    var scaledBorderTopWidth = borderTopNum * scaleY;
    var scaledBorderBottomWidth = borderBottomNum * scaleY;
    var scaledBorderLeftWidth = borderLeftNum * scaleX;
    var scaledBorderRightWidth = borderRightNum * scaleX;

    // Clip margin
    var clipMarginWidth = 0;
    var clipMarginHeight = 0;
    if (overflow === 'clip') {
      var clipNum = getPxValue(overflowClipMargin);
      clipMarginWidth = clipNum * scaleX;
      clipMarginHeight = clipNum * scaleY;
    }

    // Region
    var eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;
    var eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;
    var eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;
    var eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;
    visibleArea.left = Math.max(visibleArea.left, eleLeft);
    visibleArea.top = Math.max(visibleArea.top, eleTop);
    visibleArea.right = Math.min(visibleArea.right, eleRight);
    visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
  });
  return visibleArea;
}
;// CONCATENATED MODULE: ./node_modules/@rc-component/trigger/es/hooks/useAlign.js








function getUnitOffset(size) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var offsetStr = "".concat(offset);
  var cells = offsetStr.match(/^(.*)\%$/);
  if (cells) {
    return size * (parseFloat(cells[1]) / 100);
  }
  return parseFloat(offsetStr);
}
function getNumberOffset(rect, offset) {
  var _ref = offset || [],
    _ref2 = (0,slicedToArray/* default */.Z)(_ref, 2),
    offsetX = _ref2[0],
    offsetY = _ref2[1];
  return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];
}
function splitPoints() {
  var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return [points[0], points[1]];
}
function getAlignPoint(rect, points) {
  var topBottom = points[0];
  var leftRight = points[1];
  var x;
  var y;

  // Top & Bottom
  if (topBottom === 't') {
    y = rect.y;
  } else if (topBottom === 'b') {
    y = rect.y + rect.height;
  } else {
    y = rect.y + rect.height / 2;
  }

  // Left & Right
  if (leftRight === 'l') {
    x = rect.x;
  } else if (leftRight === 'r') {
    x = rect.x + rect.width;
  } else {
    x = rect.x + rect.width / 2;
  }
  return {
    x: x,
    y: y
  };
}
function reversePoints(points, index) {
  var reverseMap = {
    t: 'b',
    b: 't',
    l: 'r',
    r: 'l'
  };
  return points.map(function (point, i) {
    if (i === index) {
      return reverseMap[point] || 'c';
    }
    return point;
  }).join('');
}
function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {
  var _React$useState = react.useState({
      ready: false,
      offsetX: 0,
      offsetY: 0,
      offsetR: 0,
      offsetB: 0,
      arrowX: 0,
      arrowY: 0,
      scaleX: 1,
      scaleY: 1,
      align: builtinPlacements[placement] || {}
    }),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    offsetInfo = _React$useState2[0],
    setOffsetInfo = _React$useState2[1];
  var alignCountRef = react.useRef(0);
  var scrollerList = react.useMemo(function () {
    if (!popupEle) {
      return [];
    }
    return collectScroller(popupEle);
  }, [popupEle]);

  // ========================= Flip ==========================
  // We will memo flip info.
  // If size change to make flip, it will memo the flip info and use it in next align.
  var prevFlipRef = react.useRef({});
  var resetFlipCache = function resetFlipCache() {
    prevFlipRef.current = {};
  };
  if (!open) {
    resetFlipCache();
  }

  // ========================= Align =========================
  var onAlign = (0,useEvent/* default */.Z)(function () {
    if (popupEle && target && open) {
      var _popupElement$parentE, _popupElement$parentE2;
      var popupElement = popupEle;
      var doc = popupElement.ownerDocument;
      var win = getWin(popupElement);
      var _win$getComputedStyle = win.getComputedStyle(popupElement),
        width = _win$getComputedStyle.width,
        height = _win$getComputedStyle.height,
        popupPosition = _win$getComputedStyle.position;
      var originLeft = popupElement.style.left;
      var originTop = popupElement.style.top;
      var originRight = popupElement.style.right;
      var originBottom = popupElement.style.bottom;
      var originOverflow = popupElement.style.overflow;

      // Placement
      var placementInfo = (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, builtinPlacements[placement]), popupAlign);

      // placeholder element
      var placeholderElement = doc.createElement('div');
      (_popupElement$parentE = popupElement.parentElement) === null || _popupElement$parentE === void 0 || _popupElement$parentE.appendChild(placeholderElement);
      placeholderElement.style.left = "".concat(popupElement.offsetLeft, "px");
      placeholderElement.style.top = "".concat(popupElement.offsetTop, "px");
      placeholderElement.style.position = popupPosition;
      placeholderElement.style.height = "".concat(popupElement.offsetHeight, "px");
      placeholderElement.style.width = "".concat(popupElement.offsetWidth, "px");

      // Reset first
      popupElement.style.left = '0';
      popupElement.style.top = '0';
      popupElement.style.right = 'auto';
      popupElement.style.bottom = 'auto';
      popupElement.style.overflow = 'hidden';

      // Calculate align style, we should consider `transform` case
      var targetRect;
      if (Array.isArray(target)) {
        targetRect = {
          x: target[0],
          y: target[1],
          width: 0,
          height: 0
        };
      } else {
        var rect = target.getBoundingClientRect();
        targetRect = {
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        };
      }
      var popupRect = popupElement.getBoundingClientRect();
      var _doc$documentElement = doc.documentElement,
        clientWidth = _doc$documentElement.clientWidth,
        clientHeight = _doc$documentElement.clientHeight,
        scrollWidth = _doc$documentElement.scrollWidth,
        scrollHeight = _doc$documentElement.scrollHeight,
        scrollTop = _doc$documentElement.scrollTop,
        scrollLeft = _doc$documentElement.scrollLeft;
      var popupHeight = popupRect.height;
      var popupWidth = popupRect.width;
      var targetHeight = targetRect.height;
      var targetWidth = targetRect.width;

      // Get bounding of visible area
      var visibleRegion = {
        left: 0,
        top: 0,
        right: clientWidth,
        bottom: clientHeight
      };
      var scrollRegion = {
        left: -scrollLeft,
        top: -scrollTop,
        right: scrollWidth - scrollLeft,
        bottom: scrollHeight - scrollTop
      };
      var htmlRegion = placementInfo.htmlRegion;
      var VISIBLE = 'visible';
      var VISIBLE_FIRST = 'visibleFirst';
      if (htmlRegion !== 'scroll' && htmlRegion !== VISIBLE_FIRST) {
        htmlRegion = VISIBLE;
      }
      var isVisibleFirst = htmlRegion === VISIBLE_FIRST;
      var scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);
      var visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);
      var visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;

      // When set to `visibleFirst`,
      // the check `adjust` logic will use `visibleRegion` for check first.
      var adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;

      // Record right & bottom align data
      popupElement.style.left = 'auto';
      popupElement.style.top = 'auto';
      popupElement.style.right = '0';
      popupElement.style.bottom = '0';
      var popupMirrorRect = popupElement.getBoundingClientRect();

      // Reset back
      popupElement.style.left = originLeft;
      popupElement.style.top = originTop;
      popupElement.style.right = originRight;
      popupElement.style.bottom = originBottom;
      popupElement.style.overflow = originOverflow;
      (_popupElement$parentE2 = popupElement.parentElement) === null || _popupElement$parentE2 === void 0 || _popupElement$parentE2.removeChild(placeholderElement);

      // Calculate scale
      var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1000) / 1000);
      var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1000) / 1000);

      // No need to align since it's not visible in view
      if (_scaleX === 0 || _scaleY === 0 || (0,findDOMNode/* isDOM */.S)(target) && !(0,isVisible/* default */.Z)(target)) {
        return;
      }

      // Offset
      var offset = placementInfo.offset,
        targetOffset = placementInfo.targetOffset;
      var _getNumberOffset = getNumberOffset(popupRect, offset),
        _getNumberOffset2 = (0,slicedToArray/* default */.Z)(_getNumberOffset, 2),
        popupOffsetX = _getNumberOffset2[0],
        popupOffsetY = _getNumberOffset2[1];
      var _getNumberOffset3 = getNumberOffset(targetRect, targetOffset),
        _getNumberOffset4 = (0,slicedToArray/* default */.Z)(_getNumberOffset3, 2),
        targetOffsetX = _getNumberOffset4[0],
        targetOffsetY = _getNumberOffset4[1];
      targetRect.x -= targetOffsetX;
      targetRect.y -= targetOffsetY;

      // Points
      var _ref3 = placementInfo.points || [],
        _ref4 = (0,slicedToArray/* default */.Z)(_ref3, 2),
        popupPoint = _ref4[0],
        targetPoint = _ref4[1];
      var targetPoints = splitPoints(targetPoint);
      var popupPoints = splitPoints(popupPoint);
      var targetAlignPoint = getAlignPoint(targetRect, targetPoints);
      var popupAlignPoint = getAlignPoint(popupRect, popupPoints);

      // Real align info may not same as origin one
      var nextAlignInfo = (0,objectSpread2/* default */.Z)({}, placementInfo);

      // Next Offset
      var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;
      var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;

      // ============== Intersection ===============
      // Get area by position. Used for check if flip area is better
      function getIntersectionVisibleArea(offsetX, offsetY) {
        var area = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : visibleArea;
        var l = popupRect.x + offsetX;
        var t = popupRect.y + offsetY;
        var r = l + popupWidth;
        var b = t + popupHeight;
        var visibleL = Math.max(l, area.left);
        var visibleT = Math.max(t, area.top);
        var visibleR = Math.min(r, area.right);
        var visibleB = Math.min(b, area.bottom);
        return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));
      }
      var originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);

      // As `visibleFirst`, we prepare this for check
      var originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);

      // ========================== Overflow ===========================
      var targetAlignPointTL = getAlignPoint(targetRect, ['t', 'l']);
      var popupAlignPointTL = getAlignPoint(popupRect, ['t', 'l']);
      var targetAlignPointBR = getAlignPoint(targetRect, ['b', 'r']);
      var popupAlignPointBR = getAlignPoint(popupRect, ['b', 'r']);
      var overflow = placementInfo.overflow || {};
      var adjustX = overflow.adjustX,
        adjustY = overflow.adjustY,
        shiftX = overflow.shiftX,
        shiftY = overflow.shiftY;
      var supportAdjust = function supportAdjust(val) {
        if (typeof val === 'boolean') {
          return val;
        }
        return val >= 0;
      };

      // Prepare position
      var nextPopupY;
      var nextPopupBottom;
      var nextPopupX;
      var nextPopupRight;
      function syncNextPopupPosition() {
        nextPopupY = popupRect.y + nextOffsetY;
        nextPopupBottom = nextPopupY + popupHeight;
        nextPopupX = popupRect.x + nextOffsetX;
        nextPopupRight = nextPopupX + popupWidth;
      }
      syncNextPopupPosition();

      // >>>>>>>>>> Top & Bottom
      var needAdjustY = supportAdjust(adjustY);
      var sameTB = popupPoints[0] === targetPoints[0];

      // Bottom to Top
      if (needAdjustY && popupPoints[0] === 't' && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {
        var tmpNextOffsetY = nextOffsetY;
        if (sameTB) {
          tmpNextOffsetY -= popupHeight - targetHeight;
        } else {
          tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
        }
        var newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);
        var newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
        if (
        // Of course use larger one
        newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||
        // Choose recommend one
        newVisibleRecommendArea >= originIntersectionRecommendArea)) {
          prevFlipRef.current.bt = true;
          nextOffsetY = tmpNextOffsetY;
          popupOffsetY = -popupOffsetY;
          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
        } else {
          prevFlipRef.current.bt = false;
        }
      }

      // Top to Bottom
      if (needAdjustY && popupPoints[0] === 'b' && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {
        var _tmpNextOffsetY = nextOffsetY;
        if (sameTB) {
          _tmpNextOffsetY += popupHeight - targetHeight;
        } else {
          _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
        }
        var _newVisibleArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY);
        var _newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY, visibleRegionArea);
        if (
        // Of course use larger one
        _newVisibleArea > originIntersectionVisibleArea || _newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst ||
        // Choose recommend one
        _newVisibleRecommendArea >= originIntersectionRecommendArea)) {
          prevFlipRef.current.tb = true;
          nextOffsetY = _tmpNextOffsetY;
          popupOffsetY = -popupOffsetY;
          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
        } else {
          prevFlipRef.current.tb = false;
        }
      }

      // >>>>>>>>>> Left & Right
      var needAdjustX = supportAdjust(adjustX);

      // >>>>> Flip
      var sameLR = popupPoints[1] === targetPoints[1];

      // Right to Left
      if (needAdjustX && popupPoints[1] === 'l' && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {
        var tmpNextOffsetX = nextOffsetX;
        if (sameLR) {
          tmpNextOffsetX -= popupWidth - targetWidth;
        } else {
          tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
        }
        var _newVisibleArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);
        var _newVisibleRecommendArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
        if (
        // Of course use larger one
        _newVisibleArea2 > originIntersectionVisibleArea || _newVisibleArea2 === originIntersectionVisibleArea && (!isVisibleFirst ||
        // Choose recommend one
        _newVisibleRecommendArea2 >= originIntersectionRecommendArea)) {
          prevFlipRef.current.rl = true;
          nextOffsetX = tmpNextOffsetX;
          popupOffsetX = -popupOffsetX;
          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
        } else {
          prevFlipRef.current.rl = false;
        }
      }

      // Left to Right
      if (needAdjustX && popupPoints[1] === 'r' && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {
        var _tmpNextOffsetX = nextOffsetX;
        if (sameLR) {
          _tmpNextOffsetX += popupWidth - targetWidth;
        } else {
          _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
        }
        var _newVisibleArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY);
        var _newVisibleRecommendArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY, visibleRegionArea);
        if (
        // Of course use larger one
        _newVisibleArea3 > originIntersectionVisibleArea || _newVisibleArea3 === originIntersectionVisibleArea && (!isVisibleFirst ||
        // Choose recommend one
        _newVisibleRecommendArea3 >= originIntersectionRecommendArea)) {
          prevFlipRef.current.lr = true;
          nextOffsetX = _tmpNextOffsetX;
          popupOffsetX = -popupOffsetX;
          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
        } else {
          prevFlipRef.current.lr = false;
        }
      }

      // ============================ Shift ============================
      syncNextPopupPosition();
      var numShiftX = shiftX === true ? 0 : shiftX;
      if (typeof numShiftX === 'number') {
        // Left
        if (nextPopupX < visibleRegionArea.left) {
          nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;
          if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {
            nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;
          }
        }

        // Right
        if (nextPopupRight > visibleRegionArea.right) {
          nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;
          if (targetRect.x > visibleRegionArea.right - numShiftX) {
            nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;
          }
        }
      }
      var numShiftY = shiftY === true ? 0 : shiftY;
      if (typeof numShiftY === 'number') {
        // Top
        if (nextPopupY < visibleRegionArea.top) {
          nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;

          // When target if far away from visible area
          // Stop shift
          if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {
            nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;
          }
        }

        // Bottom
        if (nextPopupBottom > visibleRegionArea.bottom) {
          nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;
          if (targetRect.y > visibleRegionArea.bottom - numShiftY) {
            nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;
          }
        }
      }

      // ============================ Arrow ============================
      // Arrow center align
      var popupLeft = popupRect.x + nextOffsetX;
      var popupRight = popupLeft + popupWidth;
      var popupTop = popupRect.y + nextOffsetY;
      var popupBottom = popupTop + popupHeight;
      var targetLeft = targetRect.x;
      var targetRight = targetLeft + targetWidth;
      var targetTop = targetRect.y;
      var targetBottom = targetTop + targetHeight;
      var maxLeft = Math.max(popupLeft, targetLeft);
      var minRight = Math.min(popupRight, targetRight);
      var xCenter = (maxLeft + minRight) / 2;
      var nextArrowX = xCenter - popupLeft;
      var maxTop = Math.max(popupTop, targetTop);
      var minBottom = Math.min(popupBottom, targetBottom);
      var yCenter = (maxTop + minBottom) / 2;
      var nextArrowY = yCenter - popupTop;
      onPopupAlign === null || onPopupAlign === void 0 || onPopupAlign(popupEle, nextAlignInfo);

      // Additional calculate right & bottom position
      var offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);
      var offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);
      setOffsetInfo({
        ready: true,
        offsetX: nextOffsetX / _scaleX,
        offsetY: nextOffsetY / _scaleY,
        offsetR: offsetX4Right / _scaleX,
        offsetB: offsetY4Bottom / _scaleY,
        arrowX: nextArrowX / _scaleX,
        arrowY: nextArrowY / _scaleY,
        scaleX: _scaleX,
        scaleY: _scaleY,
        align: nextAlignInfo
      });
    }
  });
  var triggerAlign = function triggerAlign() {
    alignCountRef.current += 1;
    var id = alignCountRef.current;

    // Merge all align requirement into one frame
    Promise.resolve().then(function () {
      if (alignCountRef.current === id) {
        onAlign();
      }
    });
  };

  // Reset ready status when placement & open changed
  var resetReady = function resetReady() {
    setOffsetInfo(function (ori) {
      return (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, ori), {}, {
        ready: false
      });
    });
  };
  (0,useLayoutEffect/* default */.Z)(resetReady, [placement]);
  (0,useLayoutEffect/* default */.Z)(function () {
    if (!open) {
      resetReady();
    }
  }, [open]);
  return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 2 modules
var toConsumableArray = __webpack_require__(74902);
;// CONCATENATED MODULE: ./node_modules/@rc-component/trigger/es/hooks/useWatch.js



function useWatch(open, target, popup, onAlign, onScroll) {
  (0,useLayoutEffect/* default */.Z)(function () {
    if (open && target && popup) {
      var targetElement = target;
      var popupElement = popup;
      var targetScrollList = collectScroller(targetElement);
      var popupScrollList = collectScroller(popupElement);
      var win = getWin(popupElement);
      var mergedList = new Set([win].concat((0,toConsumableArray/* default */.Z)(targetScrollList), (0,toConsumableArray/* default */.Z)(popupScrollList)));
      function notifyScroll() {
        onAlign();
        onScroll();
      }
      mergedList.forEach(function (scroller) {
        scroller.addEventListener('scroll', notifyScroll, {
          passive: true
        });
      });
      win.addEventListener('resize', notifyScroll, {
        passive: true
      });

      // First time always do align
      onAlign();
      return function () {
        mergedList.forEach(function (scroller) {
          scroller.removeEventListener('scroll', notifyScroll);
          win.removeEventListener('resize', notifyScroll);
        });
      };
    }
  }, [open, target, popup]);
}
// EXTERNAL MODULE: ./node_modules/rc-util/es/warning.js
var warning = __webpack_require__(80334);
;// CONCATENATED MODULE: ./node_modules/@rc-component/trigger/es/hooks/useWinClick.js




function useWinClick(open, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen) {
  var openRef = react.useRef(open);
  openRef.current = open;

  // Click to hide is special action since click popup element should not hide
  react.useEffect(function () {
    if (clickToHide && popupEle && (!mask || maskClosable)) {
      var onTriggerClose = function onTriggerClose(_ref) {
        var target = _ref.target;
        if (openRef.current && !inPopupOrChild(target)) {
          triggerOpen(false);
        }
      };
      var win = getWin(popupEle);
      win.addEventListener('mousedown', onTriggerClose, true);
      win.addEventListener('contextmenu', onTriggerClose, true);

      // shadow root
      var targetShadowRoot = (0,shadow/* getShadowRoot */.A)(targetEle);
      if (targetShadowRoot) {
        targetShadowRoot.addEventListener('mousedown', onTriggerClose, true);
        targetShadowRoot.addEventListener('contextmenu', onTriggerClose, true);
      }

      // Warning if target and popup not in same root
      if (false) { var popupRoot, targetRoot, _targetEle$getRootNod, _popupEle$getRootNode; }
      return function () {
        win.removeEventListener('mousedown', onTriggerClose, true);
        win.removeEventListener('contextmenu', onTriggerClose, true);
        if (targetShadowRoot) {
          targetShadowRoot.removeEventListener('mousedown', onTriggerClose, true);
          targetShadowRoot.removeEventListener('contextmenu', onTriggerClose, true);
        }
      };
    }
  }, [clickToHide, targetEle, popupEle, mask, maskClosable]);
}
;// CONCATENATED MODULE: ./node_modules/@rc-component/trigger/es/index.js



var _excluded = ["prefixCls", "children", "action", "showAction", "hideAction", "popupVisible", "defaultPopupVisible", "onPopupVisibleChange", "afterPopupVisibleChange", "mouseEnterDelay", "mouseLeaveDelay", "focusDelay", "blurDelay", "mask", "maskClosable", "getPopupContainer", "forceRender", "autoDestroy", "destroyPopupOnHide", "popup", "popupClassName", "popupStyle", "popupPlacement", "builtinPlacements", "popupAlign", "zIndex", "stretch", "getPopupClassNameFromAlign", "fresh", "alignPoint", "onPopupClick", "onPopupAlign", "arrow", "popupMotion", "maskMotion", "popupTransitionName", "popupAnimation", "maskTransitionName", "maskAnimation", "className", "getTriggerDOMNode"];



















// Removed Props List
// Seems this can be auto
// getDocument?: (element?: HTMLElement) => Document;

// New version will not wrap popup with `rc-trigger-popup-content` when multiple children

function generateTrigger() {
  var PortalComponent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : es/* default */.Z;
  var Trigger = /*#__PURE__*/react.forwardRef(function (props, ref) {
    var _props$prefixCls = props.prefixCls,
      prefixCls = _props$prefixCls === void 0 ? 'rc-trigger-popup' : _props$prefixCls,
      children = props.children,
      _props$action = props.action,
      action = _props$action === void 0 ? 'hover' : _props$action,
      showAction = props.showAction,
      hideAction = props.hideAction,
      popupVisible = props.popupVisible,
      defaultPopupVisible = props.defaultPopupVisible,
      onPopupVisibleChange = props.onPopupVisibleChange,
      afterPopupVisibleChange = props.afterPopupVisibleChange,
      mouseEnterDelay = props.mouseEnterDelay,
      _props$mouseLeaveDela = props.mouseLeaveDelay,
      mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela,
      focusDelay = props.focusDelay,
      blurDelay = props.blurDelay,
      mask = props.mask,
      _props$maskClosable = props.maskClosable,
      maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable,
      getPopupContainer = props.getPopupContainer,
      forceRender = props.forceRender,
      autoDestroy = props.autoDestroy,
      destroyPopupOnHide = props.destroyPopupOnHide,
      popup = props.popup,
      popupClassName = props.popupClassName,
      popupStyle = props.popupStyle,
      popupPlacement = props.popupPlacement,
      _props$builtinPlaceme = props.builtinPlacements,
      builtinPlacements = _props$builtinPlaceme === void 0 ? {} : _props$builtinPlaceme,
      popupAlign = props.popupAlign,
      zIndex = props.zIndex,
      stretch = props.stretch,
      getPopupClassNameFromAlign = props.getPopupClassNameFromAlign,
      fresh = props.fresh,
      alignPoint = props.alignPoint,
      onPopupClick = props.onPopupClick,
      onPopupAlign = props.onPopupAlign,
      arrow = props.arrow,
      popupMotion = props.popupMotion,
      maskMotion = props.maskMotion,
      popupTransitionName = props.popupTransitionName,
      popupAnimation = props.popupAnimation,
      maskTransitionName = props.maskTransitionName,
      maskAnimation = props.maskAnimation,
      className = props.className,
      getTriggerDOMNode = props.getTriggerDOMNode,
      restProps = (0,objectWithoutProperties/* default */.Z)(props, _excluded);
    var mergedAutoDestroy = autoDestroy || destroyPopupOnHide || false;

    // =========================== Mobile ===========================
    var _React$useState = react.useState(false),
      _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
      mobile = _React$useState2[0],
      setMobile = _React$useState2[1];
    (0,useLayoutEffect/* default */.Z)(function () {
      setMobile((0,isMobile/* default */.Z)());
    }, []);

    // ========================== Context ===========================
    var subPopupElements = react.useRef({});
    var parentContext = react.useContext(es_context);
    var context = react.useMemo(function () {
      return {
        registerSubPopup: function registerSubPopup(id, subPopupEle) {
          subPopupElements.current[id] = subPopupEle;
          parentContext === null || parentContext === void 0 || parentContext.registerSubPopup(id, subPopupEle);
        }
      };
    }, [parentContext]);

    // =========================== Popup ============================
    var id = (0,useId/* default */.Z)();
    var _React$useState3 = react.useState(null),
      _React$useState4 = (0,slicedToArray/* default */.Z)(_React$useState3, 2),
      popupEle = _React$useState4[0],
      setPopupEle = _React$useState4[1];

    // Used for forwardRef popup. Not use internal
    var externalPopupRef = react.useRef(null);
    var setPopupRef = (0,useEvent/* default */.Z)(function (node) {
      externalPopupRef.current = node;
      if ((0,findDOMNode/* isDOM */.S)(node) && popupEle !== node) {
        setPopupEle(node);
      }
      parentContext === null || parentContext === void 0 || parentContext.registerSubPopup(id, node);
    });

    // =========================== Target ===========================
    // Use state to control here since `useRef` update not trigger render
    var _React$useState5 = react.useState(null),
      _React$useState6 = (0,slicedToArray/* default */.Z)(_React$useState5, 2),
      targetEle = _React$useState6[0],
      setTargetEle = _React$useState6[1];

    // Used for forwardRef target. Not use internal
    var externalForwardRef = react.useRef(null);
    var setTargetRef = (0,useEvent/* default */.Z)(function (node) {
      if ((0,findDOMNode/* isDOM */.S)(node) && targetEle !== node) {
        setTargetEle(node);
        externalForwardRef.current = node;
      }
    });

    // ========================== Children ==========================
    var child = react.Children.only(children);
    var originChildProps = (child === null || child === void 0 ? void 0 : child.props) || {};
    var cloneProps = {};
    var inPopupOrChild = (0,useEvent/* default */.Z)(function (ele) {
      var _getShadowRoot, _getShadowRoot2;
      var childDOM = targetEle;
      return (childDOM === null || childDOM === void 0 ? void 0 : childDOM.contains(ele)) || ((_getShadowRoot = (0,shadow/* getShadowRoot */.A)(childDOM)) === null || _getShadowRoot === void 0 ? void 0 : _getShadowRoot.host) === ele || ele === childDOM || (popupEle === null || popupEle === void 0 ? void 0 : popupEle.contains(ele)) || ((_getShadowRoot2 = (0,shadow/* getShadowRoot */.A)(popupEle)) === null || _getShadowRoot2 === void 0 ? void 0 : _getShadowRoot2.host) === ele || ele === popupEle || Object.values(subPopupElements.current).some(function (subPopupEle) {
        return (subPopupEle === null || subPopupEle === void 0 ? void 0 : subPopupEle.contains(ele)) || ele === subPopupEle;
      });
    });

    // =========================== Motion ===========================
    var mergePopupMotion = getMotion(prefixCls, popupMotion, popupAnimation, popupTransitionName);
    var mergeMaskMotion = getMotion(prefixCls, maskMotion, maskAnimation, maskTransitionName);

    // ============================ Open ============================
    var _React$useState7 = react.useState(defaultPopupVisible || false),
      _React$useState8 = (0,slicedToArray/* default */.Z)(_React$useState7, 2),
      internalOpen = _React$useState8[0],
      setInternalOpen = _React$useState8[1];

    // Render still use props as first priority
    var mergedOpen = popupVisible !== null && popupVisible !== void 0 ? popupVisible : internalOpen;

    // We use effect sync here in case `popupVisible` back to `undefined`
    var setMergedOpen = (0,useEvent/* default */.Z)(function (nextOpen) {
      if (popupVisible === undefined) {
        setInternalOpen(nextOpen);
      }
    });
    (0,useLayoutEffect/* default */.Z)(function () {
      setInternalOpen(popupVisible || false);
    }, [popupVisible]);
    var openRef = react.useRef(mergedOpen);
    openRef.current = mergedOpen;
    var lastTriggerRef = react.useRef([]);
    lastTriggerRef.current = [];
    var internalTriggerOpen = (0,useEvent/* default */.Z)(function (nextOpen) {
      var _lastTriggerRef$curre;
      setMergedOpen(nextOpen);

      // Enter or Pointer will both trigger open state change
      // We only need take one to avoid duplicated change event trigger
      // Use `lastTriggerRef` to record last open type
      if (((_lastTriggerRef$curre = lastTriggerRef.current[lastTriggerRef.current.length - 1]) !== null && _lastTriggerRef$curre !== void 0 ? _lastTriggerRef$curre : mergedOpen) !== nextOpen) {
        lastTriggerRef.current.push(nextOpen);
        onPopupVisibleChange === null || onPopupVisibleChange === void 0 || onPopupVisibleChange(nextOpen);
      }
    });

    // Trigger for delay
    var delayRef = react.useRef();
    var clearDelay = function clearDelay() {
      clearTimeout(delayRef.current);
    };
    var triggerOpen = function triggerOpen(nextOpen) {
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      clearDelay();
      if (delay === 0) {
        internalTriggerOpen(nextOpen);
      } else {
        delayRef.current = setTimeout(function () {
          internalTriggerOpen(nextOpen);
        }, delay * 1000);
      }
    };
    react.useEffect(function () {
      return clearDelay;
    }, []);

    // ========================== Motion ============================
    var _React$useState9 = react.useState(false),
      _React$useState10 = (0,slicedToArray/* default */.Z)(_React$useState9, 2),
      inMotion = _React$useState10[0],
      setInMotion = _React$useState10[1];
    (0,useLayoutEffect/* default */.Z)(function (firstMount) {
      if (!firstMount || mergedOpen) {
        setInMotion(true);
      }
    }, [mergedOpen]);
    var _React$useState11 = react.useState(null),
      _React$useState12 = (0,slicedToArray/* default */.Z)(_React$useState11, 2),
      motionPrepareResolve = _React$useState12[0],
      setMotionPrepareResolve = _React$useState12[1];

    // =========================== Align ============================
    var _React$useState13 = react.useState([0, 0]),
      _React$useState14 = (0,slicedToArray/* default */.Z)(_React$useState13, 2),
      mousePos = _React$useState14[0],
      setMousePos = _React$useState14[1];
    var setMousePosByEvent = function setMousePosByEvent(event) {
      setMousePos([event.clientX, event.clientY]);
    };
    var _useAlign = useAlign(mergedOpen, popupEle, alignPoint ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign),
      _useAlign2 = (0,slicedToArray/* default */.Z)(_useAlign, 11),
      ready = _useAlign2[0],
      offsetX = _useAlign2[1],
      offsetY = _useAlign2[2],
      offsetR = _useAlign2[3],
      offsetB = _useAlign2[4],
      arrowX = _useAlign2[5],
      arrowY = _useAlign2[6],
      scaleX = _useAlign2[7],
      scaleY = _useAlign2[8],
      alignInfo = _useAlign2[9],
      onAlign = _useAlign2[10];
    var _useAction = useAction(mobile, action, showAction, hideAction),
      _useAction2 = (0,slicedToArray/* default */.Z)(_useAction, 2),
      showActions = _useAction2[0],
      hideActions = _useAction2[1];
    var clickToShow = showActions.has('click');
    var clickToHide = hideActions.has('click') || hideActions.has('contextMenu');
    var triggerAlign = (0,useEvent/* default */.Z)(function () {
      if (!inMotion) {
        onAlign();
      }
    });
    var onScroll = function onScroll() {
      if (openRef.current && alignPoint && clickToHide) {
        triggerOpen(false);
      }
    };
    useWatch(mergedOpen, targetEle, popupEle, triggerAlign, onScroll);
    (0,useLayoutEffect/* default */.Z)(function () {
      triggerAlign();
    }, [mousePos, popupPlacement]);

    // When no builtinPlacements and popupAlign changed
    (0,useLayoutEffect/* default */.Z)(function () {
      if (mergedOpen && !(builtinPlacements !== null && builtinPlacements !== void 0 && builtinPlacements[popupPlacement])) {
        triggerAlign();
      }
    }, [JSON.stringify(popupAlign)]);
    var alignedClassName = react.useMemo(function () {
      var baseClassName = getAlignPopupClassName(builtinPlacements, prefixCls, alignInfo, alignPoint);
      return classnames_default()(baseClassName, getPopupClassNameFromAlign === null || getPopupClassNameFromAlign === void 0 ? void 0 : getPopupClassNameFromAlign(alignInfo));
    }, [alignInfo, getPopupClassNameFromAlign, builtinPlacements, prefixCls, alignPoint]);

    // ============================ Refs ============================
    react.useImperativeHandle(ref, function () {
      return {
        nativeElement: externalForwardRef.current,
        popupElement: externalPopupRef.current,
        forceAlign: triggerAlign
      };
    });

    // ========================== Stretch ===========================
    var _React$useState15 = react.useState(0),
      _React$useState16 = (0,slicedToArray/* default */.Z)(_React$useState15, 2),
      targetWidth = _React$useState16[0],
      setTargetWidth = _React$useState16[1];
    var _React$useState17 = react.useState(0),
      _React$useState18 = (0,slicedToArray/* default */.Z)(_React$useState17, 2),
      targetHeight = _React$useState18[0],
      setTargetHeight = _React$useState18[1];
    var syncTargetSize = function syncTargetSize() {
      if (stretch && targetEle) {
        var rect = targetEle.getBoundingClientRect();
        setTargetWidth(rect.width);
        setTargetHeight(rect.height);
      }
    };
    var onTargetResize = function onTargetResize() {
      syncTargetSize();
      triggerAlign();
    };

    // ========================== Motion ============================
    var onVisibleChanged = function onVisibleChanged(visible) {
      setInMotion(false);
      onAlign();
      afterPopupVisibleChange === null || afterPopupVisibleChange === void 0 || afterPopupVisibleChange(visible);
    };

    // We will trigger align when motion is in prepare
    var onPrepare = function onPrepare() {
      return new Promise(function (resolve) {
        syncTargetSize();
        setMotionPrepareResolve(function () {
          return resolve;
        });
      });
    };
    (0,useLayoutEffect/* default */.Z)(function () {
      if (motionPrepareResolve) {
        onAlign();
        motionPrepareResolve();
        setMotionPrepareResolve(null);
      }
    }, [motionPrepareResolve]);

    // =========================== Action ===========================
    /**
     * Util wrapper for trigger action
     */
    function wrapperAction(eventName, nextOpen, delay, preEvent) {
      cloneProps[eventName] = function (event) {
        var _originChildProps$eve;
        preEvent === null || preEvent === void 0 || preEvent(event);
        triggerOpen(nextOpen, delay);

        // Pass to origin
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        (_originChildProps$eve = originChildProps[eventName]) === null || _originChildProps$eve === void 0 || _originChildProps$eve.call.apply(_originChildProps$eve, [originChildProps, event].concat(args));
      };
    }

    // ======================= Action: Click ========================
    if (clickToShow || clickToHide) {
      cloneProps.onClick = function (event) {
        var _originChildProps$onC;
        if (openRef.current && clickToHide) {
          triggerOpen(false);
        } else if (!openRef.current && clickToShow) {
          setMousePosByEvent(event);
          triggerOpen(true);
        }

        // Pass to origin
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        (_originChildProps$onC = originChildProps.onClick) === null || _originChildProps$onC === void 0 || _originChildProps$onC.call.apply(_originChildProps$onC, [originChildProps, event].concat(args));
      };
    }

    // Click to hide is special action since click popup element should not hide
    useWinClick(mergedOpen, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen);

    // ======================= Action: Hover ========================
    var hoverToShow = showActions.has('hover');
    var hoverToHide = hideActions.has('hover');
    var onPopupMouseEnter;
    var onPopupMouseLeave;
    if (hoverToShow) {
      // Compatible with old browser which not support pointer event
      wrapperAction('onMouseEnter', true, mouseEnterDelay, function (event) {
        setMousePosByEvent(event);
      });
      wrapperAction('onPointerEnter', true, mouseEnterDelay, function (event) {
        setMousePosByEvent(event);
      });
      onPopupMouseEnter = function onPopupMouseEnter(event) {
        // Only trigger re-open when popup is visible
        if ((mergedOpen || inMotion) && popupEle !== null && popupEle !== void 0 && popupEle.contains(event.target)) {
          triggerOpen(true, mouseEnterDelay);
        }
      };

      // Align Point
      if (alignPoint) {
        cloneProps.onMouseMove = function (event) {
          var _originChildProps$onM;
          // setMousePosByEvent(event);
          (_originChildProps$onM = originChildProps.onMouseMove) === null || _originChildProps$onM === void 0 || _originChildProps$onM.call(originChildProps, event);
        };
      }
    }
    if (hoverToHide) {
      wrapperAction('onMouseLeave', false, mouseLeaveDelay);
      wrapperAction('onPointerLeave', false, mouseLeaveDelay);
      onPopupMouseLeave = function onPopupMouseLeave() {
        triggerOpen(false, mouseLeaveDelay);
      };
    }

    // ======================= Action: Focus ========================
    if (showActions.has('focus')) {
      wrapperAction('onFocus', true, focusDelay);
    }
    if (hideActions.has('focus')) {
      wrapperAction('onBlur', false, blurDelay);
    }

    // ==================== Action: ContextMenu =====================
    if (showActions.has('contextMenu')) {
      cloneProps.onContextMenu = function (event) {
        var _originChildProps$onC2;
        if (openRef.current && hideActions.has('contextMenu')) {
          triggerOpen(false);
        } else {
          setMousePosByEvent(event);
          triggerOpen(true);
        }
        event.preventDefault();

        // Pass to origin
        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }
        (_originChildProps$onC2 = originChildProps.onContextMenu) === null || _originChildProps$onC2 === void 0 || _originChildProps$onC2.call.apply(_originChildProps$onC2, [originChildProps, event].concat(args));
      };
    }

    // ========================= ClassName ==========================
    if (className) {
      cloneProps.className = classnames_default()(originChildProps.className, className);
    }

    // =========================== Render ===========================
    var mergedChildrenProps = (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, originChildProps), cloneProps);

    // Pass props into cloneProps for nest usage
    var passedProps = {};
    var passedEventList = ['onContextMenu', 'onClick', 'onMouseDown', 'onTouchStart', 'onMouseEnter', 'onMouseLeave', 'onFocus', 'onBlur'];
    passedEventList.forEach(function (eventName) {
      if (restProps[eventName]) {
        passedProps[eventName] = function () {
          var _mergedChildrenProps$;
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          (_mergedChildrenProps$ = mergedChildrenProps[eventName]) === null || _mergedChildrenProps$ === void 0 || _mergedChildrenProps$.call.apply(_mergedChildrenProps$, [mergedChildrenProps].concat(args));
          restProps[eventName].apply(restProps, args);
        };
      }
    });

    // Child Node
    var triggerNode = /*#__PURE__*/react.cloneElement(child, (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, mergedChildrenProps), passedProps));
    var arrowPos = {
      x: arrowX,
      y: arrowY
    };
    var innerArrow = arrow ? (0,objectSpread2/* default */.Z)({}, arrow !== true ? arrow : {}) : null;

    // Render
    return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(rc_resize_observer_es/* default */.Z, {
      disabled: !mergedOpen,
      ref: setTargetRef,
      onResize: onTargetResize
    }, /*#__PURE__*/react.createElement(es_TriggerWrapper, {
      getTriggerDOMNode: getTriggerDOMNode
    }, triggerNode)), /*#__PURE__*/react.createElement(es_context.Provider, {
      value: context
    }, /*#__PURE__*/react.createElement(es_Popup, {
      portal: PortalComponent,
      ref: setPopupRef,
      prefixCls: prefixCls,
      popup: popup,
      className: classnames_default()(popupClassName, alignedClassName),
      style: popupStyle,
      target: targetEle,
      onMouseEnter: onPopupMouseEnter,
      onMouseLeave: onPopupMouseLeave
      // https://github.com/ant-design/ant-design/issues/43924
      ,
      onPointerEnter: onPopupMouseEnter,
      zIndex: zIndex
      // Open
      ,
      open: mergedOpen,
      keepDom: inMotion,
      fresh: fresh
      // Click
      ,
      onClick: onPopupClick
      // Mask
      ,
      mask: mask
      // Motion
      ,
      motion: mergePopupMotion,
      maskMotion: mergeMaskMotion,
      onVisibleChanged: onVisibleChanged,
      onPrepare: onPrepare
      // Portal
      ,
      forceRender: forceRender,
      autoDestroy: mergedAutoDestroy,
      getPopupContainer: getPopupContainer
      // Arrow
      ,
      align: alignInfo,
      arrow: innerArrow,
      arrowPos: arrowPos
      // Align
      ,
      ready: ready,
      offsetX: offsetX,
      offsetY: offsetY,
      offsetR: offsetR,
      offsetB: offsetB,
      onAlign: triggerAlign
      // Stretch
      ,
      stretch: stretch,
      targetWidth: targetWidth / scaleX,
      targetHeight: targetHeight / scaleY
    })));
  });
  if (false) {}
  return Trigger;
}
/* harmony default export */ var trigger_es = (generateTrigger(es/* default */.Z));

/***/ }),

/***/ 98065:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: function() { return /* binding */ isValidGapNumber; },
/* harmony export */   n: function() { return /* binding */ isPresetSize; }
/* harmony export */ });
function isPresetSize(size) {
  return ['small', 'middle', 'large'].includes(size);
}
function isValidGapNumber(size) {
  if (!size) {
    // The case of size = 0 is deliberately excluded here, because the default value of the gap attribute in CSS is 0, so if the user passes 0 in, we can directly ignore it.
    return false;
  }
  return typeof size === 'number' && !Number.isNaN(size);
}

/***/ }),

/***/ 9708:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: function() { return /* binding */ getMergedStatus; },
/* harmony export */   Z: function() { return /* binding */ getStatusClassNames; }
/* harmony export */ });
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(93967);
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_0__);

const InputStatuses = (/* unused pure expression or super */ null && (['warning', 'error', '']));
function getStatusClassNames(prefixCls, status, hasFeedback) {
  return classnames__WEBPACK_IMPORTED_MODULE_0___default()({
    [`${prefixCls}-status-success`]: status === 'success',
    [`${prefixCls}-status-warning`]: status === 'warning',
    [`${prefixCls}-status-error`]: status === 'error',
    [`${prefixCls}-status-validating`]: status === 'validating',
    [`${prefixCls}-has-feedback`]: hasFeedback
  });
}
const getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;

/***/ }),

/***/ 43863:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  C: function() { return /* binding */ es_avatar; }
});

// UNUSED EXPORTS: Group

// EXTERNAL MODULE: ./node_modules/@umijs/preset-umi/node_modules/react/index.js
var react = __webpack_require__(62435);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(93967);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/rc-resize-observer/es/index.js + 5 modules
var es = __webpack_require__(9220);
// EXTERNAL MODULE: ./node_modules/rc-util/es/ref.js
var es_ref = __webpack_require__(42550);
// EXTERNAL MODULE: ./node_modules/antd/es/_util/responsiveObserver.js
var responsiveObserver = __webpack_require__(74443);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/context.js
var context = __webpack_require__(53124);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/hooks/useCSSVarCls.js
var useCSSVarCls = __webpack_require__(35792);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/hooks/useSize.js
var useSize = __webpack_require__(98675);
// EXTERNAL MODULE: ./node_modules/antd/es/grid/hooks/useBreakpoint.js + 1 modules
var useBreakpoint = __webpack_require__(68821);
;// CONCATENATED MODULE: ./node_modules/antd/es/avatar/AvatarContext.js

const AvatarContext = /*#__PURE__*/react.createContext({});
/* harmony default export */ var avatar_AvatarContext = (AvatarContext);
// EXTERNAL MODULE: ./node_modules/@ant-design/cssinjs/es/index.js + 35 modules
var cssinjs_es = __webpack_require__(54548);
// EXTERNAL MODULE: ./node_modules/antd/es/style/index.js
var style = __webpack_require__(14747);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/genComponentStyleHook.js + 6 modules
var genComponentStyleHook = __webpack_require__(92030);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/statistic.js
var statistic = __webpack_require__(45503);
;// CONCATENATED MODULE: ./node_modules/antd/es/avatar/style/index.js



const genBaseStyle = token => {
  const {
    antCls,
    componentCls,
    iconCls,
    avatarBg,
    avatarColor,
    containerSize,
    containerSizeLG,
    containerSizeSM,
    textFontSize,
    textFontSizeLG,
    textFontSizeSM,
    borderRadius,
    borderRadiusLG,
    borderRadiusSM,
    lineWidth,
    lineType
  } = token;
  // Avatar size style
  const avatarSizeStyle = (size, fontSize, radius) => ({
    width: size,
    height: size,
    borderRadius: '50%',
    [`&${componentCls}-square`]: {
      borderRadius: radius
    },
    [`&${componentCls}-icon`]: {
      fontSize,
      [`> ${iconCls}`]: {
        margin: 0
      }
    }
  });
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, (0,style/* resetComponent */.Wf)(token)), {
      position: 'relative',
      display: 'inline-flex',
      justifyContent: 'center',
      alignItems: 'center',
      overflow: 'hidden',
      color: avatarColor,
      whiteSpace: 'nowrap',
      textAlign: 'center',
      verticalAlign: 'middle',
      background: avatarBg,
      border: `${(0,cssinjs_es/* unit */.bf)(lineWidth)} ${lineType} transparent`,
      [`&-image`]: {
        background: 'transparent'
      },
      [`${antCls}-image-img`]: {
        display: 'block'
      }
    }), avatarSizeStyle(containerSize, textFontSize, borderRadius)), {
      [`&-lg`]: Object.assign({}, avatarSizeStyle(containerSizeLG, textFontSizeLG, borderRadiusLG)),
      [`&-sm`]: Object.assign({}, avatarSizeStyle(containerSizeSM, textFontSizeSM, borderRadiusSM)),
      '> img': {
        display: 'block',
        width: '100%',
        height: '100%',
        objectFit: 'cover'
      }
    })
  };
};
const genGroupStyle = token => {
  const {
    componentCls,
    groupBorderColor,
    groupOverlapping,
    groupSpace
  } = token;
  return {
    [`${componentCls}-group`]: {
      display: 'inline-flex',
      [`${componentCls}`]: {
        borderColor: groupBorderColor
      },
      [`> *:not(:first-child)`]: {
        marginInlineStart: groupOverlapping
      }
    },
    [`${componentCls}-group-popover`]: {
      [`${componentCls} + ${componentCls}`]: {
        marginInlineStart: groupSpace
      }
    }
  };
};
const prepareComponentToken = token => {
  const {
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    fontSize,
    fontSizeLG,
    fontSizeXL,
    fontSizeHeading3,
    marginXS,
    marginXXS,
    colorBorderBg
  } = token;
  return {
    containerSize: controlHeight,
    containerSizeLG: controlHeightLG,
    containerSizeSM: controlHeightSM,
    textFontSize: Math.round((fontSizeLG + fontSizeXL) / 2),
    textFontSizeLG: fontSizeHeading3,
    textFontSizeSM: fontSize,
    groupSpace: marginXXS,
    groupOverlapping: -marginXS,
    groupBorderColor: colorBorderBg
  };
};
/* harmony default export */ var avatar_style = ((0,genComponentStyleHook/* genStyleHooks */.I$)('Avatar', token => {
  const {
    colorTextLightSolid,
    colorTextPlaceholder
  } = token;
  const avatarToken = (0,statistic/* merge */.TS)(token, {
    avatarBg: colorTextPlaceholder,
    avatarColor: colorTextLightSolid
  });
  return [genBaseStyle(avatarToken), genGroupStyle(avatarToken)];
}, prepareComponentToken));
;// CONCATENATED MODULE: ./node_modules/antd/es/avatar/avatar.js
"use client";

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};












const InternalAvatar = (props, ref) => {
  const [scale, setScale] = react.useState(1);
  const [mounted, setMounted] = react.useState(false);
  const [isImgExist, setIsImgExist] = react.useState(true);
  const avatarNodeRef = react.useRef(null);
  const avatarChildrenRef = react.useRef(null);
  const avatarNodeMergedRef = (0,es_ref/* composeRef */.sQ)(ref, avatarNodeRef);
  const {
    getPrefixCls,
    avatar
  } = react.useContext(context/* ConfigContext */.E_);
  const avatarCtx = react.useContext(avatar_AvatarContext);
  const setScaleParam = () => {
    if (!avatarChildrenRef.current || !avatarNodeRef.current) {
      return;
    }
    const childrenWidth = avatarChildrenRef.current.offsetWidth; // offsetWidth avoid affecting be transform scale
    const nodeWidth = avatarNodeRef.current.offsetWidth;
    // denominator is 0 is no meaning
    if (childrenWidth !== 0 && nodeWidth !== 0) {
      const {
        gap = 4
      } = props;
      if (gap * 2 < nodeWidth) {
        setScale(nodeWidth - gap * 2 < childrenWidth ? (nodeWidth - gap * 2) / childrenWidth : 1);
      }
    }
  };
  react.useEffect(() => {
    setMounted(true);
  }, []);
  react.useEffect(() => {
    setIsImgExist(true);
    setScale(1);
  }, [props.src]);
  react.useEffect(setScaleParam, [props.gap]);
  const handleImgLoadError = () => {
    const {
      onError
    } = props;
    const errorFlag = onError === null || onError === void 0 ? void 0 : onError();
    if (errorFlag !== false) {
      setIsImgExist(false);
    }
  };
  const {
      prefixCls: customizePrefixCls,
      shape,
      size: customSize,
      src,
      srcSet,
      icon,
      className,
      rootClassName,
      alt,
      draggable,
      children,
      crossOrigin
    } = props,
    others = __rest(props, ["prefixCls", "shape", "size", "src", "srcSet", "icon", "className", "rootClassName", "alt", "draggable", "children", "crossOrigin"]);
  const size = (0,useSize/* default */.Z)(ctxSize => {
    var _a, _b;
    return (_b = (_a = customSize !== null && customSize !== void 0 ? customSize : avatarCtx === null || avatarCtx === void 0 ? void 0 : avatarCtx.size) !== null && _a !== void 0 ? _a : ctxSize) !== null && _b !== void 0 ? _b : 'default';
  });
  const needResponsive = Object.keys(typeof size === 'object' ? size || {} : {}).some(key => ['xs', 'sm', 'md', 'lg', 'xl', 'xxl'].includes(key));
  const screens = (0,useBreakpoint/* default */.Z)(needResponsive);
  const responsiveSizeStyle = react.useMemo(() => {
    if (typeof size !== 'object') {
      return {};
    }
    const currentBreakpoint = responsiveObserver/* responsiveArray */.c4.find(screen => screens[screen]);
    const currentSize = size[currentBreakpoint];
    return currentSize ? {
      width: currentSize,
      height: currentSize,
      fontSize: currentSize && (icon || children) ? currentSize / 2 : 18
    } : {};
  }, [screens, size]);
  if (false) {}
  const prefixCls = getPrefixCls('avatar', customizePrefixCls);
  const rootCls = (0,useCSSVarCls/* default */.Z)(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = avatar_style(prefixCls, rootCls);
  const sizeCls = classnames_default()({
    [`${prefixCls}-lg`]: size === 'large',
    [`${prefixCls}-sm`]: size === 'small'
  });
  const hasImageElement = /*#__PURE__*/react.isValidElement(src);
  const mergedShape = shape || (avatarCtx === null || avatarCtx === void 0 ? void 0 : avatarCtx.shape) || 'circle';
  const classString = classnames_default()(prefixCls, sizeCls, avatar === null || avatar === void 0 ? void 0 : avatar.className, `${prefixCls}-${mergedShape}`, {
    [`${prefixCls}-image`]: hasImageElement || src && isImgExist,
    [`${prefixCls}-icon`]: !!icon
  }, cssVarCls, rootCls, className, rootClassName, hashId);
  const sizeStyle = typeof size === 'number' ? {
    width: size,
    height: size,
    fontSize: icon ? size / 2 : 18
  } : {};
  let childrenToRender;
  if (typeof src === 'string' && isImgExist) {
    childrenToRender = /*#__PURE__*/react.createElement("img", {
      src: src,
      draggable: draggable,
      srcSet: srcSet,
      onError: handleImgLoadError,
      alt: alt,
      crossOrigin: crossOrigin
    });
  } else if (hasImageElement) {
    childrenToRender = src;
  } else if (icon) {
    childrenToRender = icon;
  } else if (mounted || scale !== 1) {
    const transformString = `scale(${scale})`;
    const childrenStyle = {
      msTransform: transformString,
      WebkitTransform: transformString,
      transform: transformString
    };
    childrenToRender = /*#__PURE__*/react.createElement(es/* default */.Z, {
      onResize: setScaleParam
    }, /*#__PURE__*/react.createElement("span", {
      className: `${prefixCls}-string`,
      ref: avatarChildrenRef,
      style: Object.assign({}, childrenStyle)
    }, children));
  } else {
    childrenToRender = /*#__PURE__*/react.createElement("span", {
      className: `${prefixCls}-string`,
      style: {
        opacity: 0
      },
      ref: avatarChildrenRef
    }, children);
  }
  // The event is triggered twice from bubbling up the DOM tree.
  // see https://codesandbox.io/s/kind-snow-9lidz
  delete others.onError;
  delete others.gap;
  return wrapCSSVar( /*#__PURE__*/react.createElement("span", Object.assign({}, others, {
    style: Object.assign(Object.assign(Object.assign(Object.assign({}, sizeStyle), responsiveSizeStyle), avatar === null || avatar === void 0 ? void 0 : avatar.style), others.style),
    className: classString,
    ref: avatarNodeMergedRef
  }), childrenToRender));
};
const Avatar = /*#__PURE__*/react.forwardRef(InternalAvatar);
if (false) {}
/* harmony default export */ var avatar = (Avatar);
// EXTERNAL MODULE: ./node_modules/rc-util/es/Children/toArray.js
var toArray = __webpack_require__(50344);
// EXTERNAL MODULE: ./node_modules/antd/es/_util/reactNode.js
var reactNode = __webpack_require__(96159);
// EXTERNAL MODULE: ./node_modules/rc-util/es/hooks/useMergedState.js
var useMergedState = __webpack_require__(21770);
// EXTERNAL MODULE: ./node_modules/rc-util/es/KeyCode.js
var KeyCode = __webpack_require__(15105);
;// CONCATENATED MODULE: ./node_modules/antd/es/_util/getRenderPropValue.js
const getRenderPropValue = propValue => {
  if (!propValue) {
    return null;
  }
  return typeof propValue === 'function' ? propValue() : propValue;
};
// EXTERNAL MODULE: ./node_modules/antd/es/_util/motion.js
var motion = __webpack_require__(33603);
;// CONCATENATED MODULE: ./node_modules/rc-tooltip/es/Popup.js


function Popup(props) {
  var children = props.children,
    prefixCls = props.prefixCls,
    id = props.id,
    overlayInnerStyle = props.overlayInnerStyle,
    className = props.className,
    style = props.style;
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()("".concat(prefixCls, "-content"), className),
    style: style
  }, /*#__PURE__*/react.createElement("div", {
    className: "".concat(prefixCls, "-inner"),
    id: id,
    role: "tooltip",
    style: overlayInnerStyle
  }, typeof children === 'function' ? children() : children));
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(87462);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__(1413);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js + 1 modules
var objectWithoutProperties = __webpack_require__(91);
// EXTERNAL MODULE: ./node_modules/@rc-component/trigger/es/index.js + 11 modules
var trigger_es = __webpack_require__(40228);
;// CONCATENATED MODULE: ./node_modules/rc-tooltip/es/placements.js
var autoAdjustOverflowTopBottom = {
  shiftX: 64,
  adjustY: 1
};
var autoAdjustOverflowLeftRight = {
  adjustX: 1,
  shiftY: true
};
var targetOffset = [0, 0];
var placements = {
  left: {
    points: ['cr', 'cl'],
    overflow: autoAdjustOverflowLeftRight,
    offset: [-4, 0],
    targetOffset: targetOffset
  },
  right: {
    points: ['cl', 'cr'],
    overflow: autoAdjustOverflowLeftRight,
    offset: [4, 0],
    targetOffset: targetOffset
  },
  top: {
    points: ['bc', 'tc'],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  bottom: {
    points: ['tc', 'bc'],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  topLeft: {
    points: ['bl', 'tl'],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  leftTop: {
    points: ['tr', 'tl'],
    overflow: autoAdjustOverflowLeftRight,
    offset: [-4, 0],
    targetOffset: targetOffset
  },
  topRight: {
    points: ['br', 'tr'],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  rightTop: {
    points: ['tl', 'tr'],
    overflow: autoAdjustOverflowLeftRight,
    offset: [4, 0],
    targetOffset: targetOffset
  },
  bottomRight: {
    points: ['tr', 'br'],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  rightBottom: {
    points: ['bl', 'br'],
    overflow: autoAdjustOverflowLeftRight,
    offset: [4, 0],
    targetOffset: targetOffset
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: autoAdjustOverflowTopBottom,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  leftBottom: {
    points: ['br', 'bl'],
    overflow: autoAdjustOverflowLeftRight,
    offset: [-4, 0],
    targetOffset: targetOffset
  }
};
/* harmony default export */ var es_placements = ((/* unused pure expression or super */ null && (placements)));
;// CONCATENATED MODULE: ./node_modules/rc-tooltip/es/Tooltip.js



var _excluded = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"];





var Tooltip = function Tooltip(props, ref) {
  var overlayClassName = props.overlayClassName,
    _props$trigger = props.trigger,
    trigger = _props$trigger === void 0 ? ['hover'] : _props$trigger,
    _props$mouseEnterDela = props.mouseEnterDelay,
    mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela,
    _props$mouseLeaveDela = props.mouseLeaveDelay,
    mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela,
    overlayStyle = props.overlayStyle,
    _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-tooltip' : _props$prefixCls,
    children = props.children,
    onVisibleChange = props.onVisibleChange,
    afterVisibleChange = props.afterVisibleChange,
    transitionName = props.transitionName,
    animation = props.animation,
    motion = props.motion,
    _props$placement = props.placement,
    placement = _props$placement === void 0 ? 'right' : _props$placement,
    _props$align = props.align,
    align = _props$align === void 0 ? {} : _props$align,
    _props$destroyTooltip = props.destroyTooltipOnHide,
    destroyTooltipOnHide = _props$destroyTooltip === void 0 ? false : _props$destroyTooltip,
    defaultVisible = props.defaultVisible,
    getTooltipContainer = props.getTooltipContainer,
    overlayInnerStyle = props.overlayInnerStyle,
    arrowContent = props.arrowContent,
    overlay = props.overlay,
    id = props.id,
    _props$showArrow = props.showArrow,
    showArrow = _props$showArrow === void 0 ? true : _props$showArrow,
    restProps = (0,objectWithoutProperties/* default */.Z)(props, _excluded);
  var triggerRef = (0,react.useRef)(null);
  (0,react.useImperativeHandle)(ref, function () {
    return triggerRef.current;
  });
  var extraProps = (0,objectSpread2/* default */.Z)({}, restProps);
  if ('visible' in props) {
    extraProps.popupVisible = props.visible;
  }
  var getPopupElement = function getPopupElement() {
    return /*#__PURE__*/react.createElement(Popup, {
      key: "content",
      prefixCls: prefixCls,
      id: id,
      overlayInnerStyle: overlayInnerStyle
    }, overlay);
  };
  return /*#__PURE__*/react.createElement(trigger_es/* default */.Z, (0,esm_extends/* default */.Z)({
    popupClassName: overlayClassName,
    prefixCls: prefixCls,
    popup: getPopupElement,
    action: trigger,
    builtinPlacements: placements,
    popupPlacement: placement,
    ref: triggerRef,
    popupAlign: align,
    getPopupContainer: getTooltipContainer,
    onPopupVisibleChange: onVisibleChange,
    afterPopupVisibleChange: afterVisibleChange,
    popupTransitionName: transitionName,
    popupAnimation: animation,
    popupMotion: motion,
    defaultPopupVisible: defaultVisible,
    autoDestroy: destroyTooltipOnHide,
    mouseLeaveDelay: mouseLeaveDelay,
    popupStyle: overlayStyle,
    mouseEnterDelay: mouseEnterDelay,
    arrow: showArrow
  }, extraProps), children);
};
/* harmony default export */ var es_Tooltip = (/*#__PURE__*/(0,react.forwardRef)(Tooltip));
;// CONCATENATED MODULE: ./node_modules/rc-tooltip/es/index.js



/* harmony default export */ var rc_tooltip_es = (es_Tooltip);
// EXTERNAL MODULE: ./node_modules/antd/es/_util/hooks/useZIndex.js
var useZIndex = __webpack_require__(87263);
;// CONCATENATED MODULE: ./node_modules/antd/es/style/roundedArrow.js

function getArrowToken(token) {
  const {
    sizePopupArrow,
    borderRadiusXS,
    borderRadiusOuter
  } = token;
  const unitWidth = sizePopupArrow / 2;
  const ax = 0;
  const ay = unitWidth;
  const bx = borderRadiusOuter * 1 / Math.sqrt(2);
  const by = unitWidth - borderRadiusOuter * (1 - 1 / Math.sqrt(2));
  const cx = unitWidth - borderRadiusXS * (1 / Math.sqrt(2));
  const cy = borderRadiusOuter * (Math.sqrt(2) - 1) + borderRadiusXS * (1 / Math.sqrt(2));
  const dx = 2 * unitWidth - cx;
  const dy = cy;
  const ex = 2 * unitWidth - bx;
  const ey = by;
  const fx = 2 * unitWidth - ax;
  const fy = ay;
  const shadowWidth = unitWidth * Math.sqrt(2) + borderRadiusOuter * (Math.sqrt(2) - 2);
  const polygonOffset = borderRadiusOuter * (Math.sqrt(2) - 1);
  const arrowPolygon = `polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`;
  const arrowPath = `path('M ${ax} ${ay} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${borderRadiusXS} ${borderRadiusXS} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${fx} ${fy} Z')`;
  return {
    arrowShadowWidth: shadowWidth,
    arrowPath,
    arrowPolygon
  };
}
const genRoundedArrow = (token, bgColor, boxShadow) => {
  const {
    sizePopupArrow,
    arrowPolygon,
    arrowPath,
    arrowShadowWidth,
    borderRadiusXS,
    calc
  } = token;
  return {
    pointerEvents: 'none',
    width: sizePopupArrow,
    height: sizePopupArrow,
    overflow: 'hidden',
    '&::before': {
      position: 'absolute',
      bottom: 0,
      insetInlineStart: 0,
      width: sizePopupArrow,
      height: calc(sizePopupArrow).div(2).equal(),
      background: bgColor,
      clipPath: {
        _multi_value_: true,
        value: [arrowPolygon, arrowPath]
      },
      content: '""'
    },
    '&::after': {
      content: '""',
      position: 'absolute',
      width: arrowShadowWidth,
      height: arrowShadowWidth,
      bottom: 0,
      insetInline: 0,
      margin: 'auto',
      borderRadius: {
        _skip_check_: true,
        value: `0 0 ${(0,cssinjs_es/* unit */.bf)(borderRadiusXS)} 0`
      },
      transform: 'translateY(50%) rotate(-135deg)',
      boxShadow,
      zIndex: 0,
      background: 'transparent'
    }
  };
};
;// CONCATENATED MODULE: ./node_modules/antd/es/style/placementArrow.js

const MAX_VERTICAL_CONTENT_RADIUS = 8;
function getArrowOffsetToken(options) {
  const {
    contentRadius,
    limitVerticalRadius
  } = options;
  const arrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
  const arrowOffsetVertical = limitVerticalRadius ? MAX_VERTICAL_CONTENT_RADIUS : arrowOffset;
  return {
    arrowOffsetHorizontal: arrowOffset,
    arrowOffsetVertical
  };
}
function isInject(valid, code) {
  if (!valid) {
    return {};
  }
  return code;
}
function getArrowStyle(token, colorBg, options) {
  const {
    componentCls,
    boxShadowPopoverArrow,
    arrowOffsetVertical,
    arrowOffsetHorizontal
  } = token;
  const {
    arrowDistance = 0,
    arrowPlacement = {
      left: true,
      right: true,
      top: true,
      bottom: true
    }
  } = options || {};
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({
      // ============================ Basic ============================
      [`${componentCls}-arrow`]: [Object.assign(Object.assign({
        position: 'absolute',
        zIndex: 1,
        display: 'block'
      }, genRoundedArrow(token, colorBg, boxShadowPopoverArrow)), {
        '&:before': {
          background: colorBg
        }
      })]
    }, isInject(!!arrowPlacement.top, {
      [[`&-placement-top > ${componentCls}-arrow`, `&-placement-topLeft > ${componentCls}-arrow`, `&-placement-topRight > ${componentCls}-arrow`].join(',')]: {
        bottom: arrowDistance,
        transform: 'translateY(100%) rotate(180deg)'
      },
      [`&-placement-top > ${componentCls}-arrow`]: {
        left: {
          _skip_check_: true,
          value: '50%'
        },
        transform: 'translateX(-50%) translateY(100%) rotate(180deg)'
      },
      [`&-placement-topLeft > ${componentCls}-arrow`]: {
        left: {
          _skip_check_: true,
          value: arrowOffsetHorizontal
        }
      },
      [`&-placement-topRight > ${componentCls}-arrow`]: {
        right: {
          _skip_check_: true,
          value: arrowOffsetHorizontal
        }
      }
    })), isInject(!!arrowPlacement.bottom, {
      [[`&-placement-bottom > ${componentCls}-arrow`, `&-placement-bottomLeft > ${componentCls}-arrow`, `&-placement-bottomRight > ${componentCls}-arrow`].join(',')]: {
        top: arrowDistance,
        transform: `translateY(-100%)`
      },
      [`&-placement-bottom > ${componentCls}-arrow`]: {
        left: {
          _skip_check_: true,
          value: '50%'
        },
        transform: `translateX(-50%) translateY(-100%)`
      },
      [`&-placement-bottomLeft > ${componentCls}-arrow`]: {
        left: {
          _skip_check_: true,
          value: arrowOffsetHorizontal
        }
      },
      [`&-placement-bottomRight > ${componentCls}-arrow`]: {
        right: {
          _skip_check_: true,
          value: arrowOffsetHorizontal
        }
      }
    })), isInject(!!arrowPlacement.left, {
      [[`&-placement-left > ${componentCls}-arrow`, `&-placement-leftTop > ${componentCls}-arrow`, `&-placement-leftBottom > ${componentCls}-arrow`].join(',')]: {
        right: {
          _skip_check_: true,
          value: arrowDistance
        },
        transform: 'translateX(100%) rotate(90deg)'
      },
      [`&-placement-left > ${componentCls}-arrow`]: {
        top: {
          _skip_check_: true,
          value: '50%'
        },
        transform: 'translateY(-50%) translateX(100%) rotate(90deg)'
      },
      [`&-placement-leftTop > ${componentCls}-arrow`]: {
        top: arrowOffsetVertical
      },
      [`&-placement-leftBottom > ${componentCls}-arrow`]: {
        bottom: arrowOffsetVertical
      }
    })), isInject(!!arrowPlacement.right, {
      [[`&-placement-right > ${componentCls}-arrow`, `&-placement-rightTop > ${componentCls}-arrow`, `&-placement-rightBottom > ${componentCls}-arrow`].join(',')]: {
        left: {
          _skip_check_: true,
          value: arrowDistance
        },
        transform: 'translateX(-100%) rotate(-90deg)'
      },
      [`&-placement-right > ${componentCls}-arrow`]: {
        top: {
          _skip_check_: true,
          value: '50%'
        },
        transform: 'translateY(-50%) translateX(-100%) rotate(-90deg)'
      },
      [`&-placement-rightTop > ${componentCls}-arrow`]: {
        top: arrowOffsetVertical
      },
      [`&-placement-rightBottom > ${componentCls}-arrow`]: {
        bottom: arrowOffsetVertical
      }
    }))
  };
}
;// CONCATENATED MODULE: ./node_modules/antd/es/_util/placements.js

function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow) {
  if (autoAdjustOverflow === false) {
    return {
      adjustX: false,
      adjustY: false
    };
  }
  const overflow = autoAdjustOverflow && typeof autoAdjustOverflow === 'object' ? autoAdjustOverflow : {};
  const baseOverflow = {};
  switch (placement) {
    case 'top':
    case 'bottom':
      baseOverflow.shiftX = arrowOffset.arrowOffsetHorizontal * 2 + arrowWidth;
      baseOverflow.shiftY = true;
      baseOverflow.adjustY = true;
      break;
    case 'left':
    case 'right':
      baseOverflow.shiftY = arrowOffset.arrowOffsetVertical * 2 + arrowWidth;
      baseOverflow.shiftX = true;
      baseOverflow.adjustX = true;
      break;
  }
  const mergedOverflow = Object.assign(Object.assign({}, baseOverflow), overflow);
  // Support auto shift
  if (!mergedOverflow.shiftX) {
    mergedOverflow.adjustX = true;
  }
  if (!mergedOverflow.shiftY) {
    mergedOverflow.adjustY = true;
  }
  return mergedOverflow;
}
const PlacementAlignMap = {
  left: {
    points: ['cr', 'cl']
  },
  right: {
    points: ['cl', 'cr']
  },
  top: {
    points: ['bc', 'tc']
  },
  bottom: {
    points: ['tc', 'bc']
  },
  topLeft: {
    points: ['bl', 'tl']
  },
  leftTop: {
    points: ['tr', 'tl']
  },
  topRight: {
    points: ['br', 'tr']
  },
  rightTop: {
    points: ['tl', 'tr']
  },
  bottomRight: {
    points: ['tr', 'br']
  },
  rightBottom: {
    points: ['bl', 'br']
  },
  bottomLeft: {
    points: ['tl', 'bl']
  },
  leftBottom: {
    points: ['br', 'bl']
  }
};
const ArrowCenterPlacementAlignMap = {
  topLeft: {
    points: ['bl', 'tc']
  },
  leftTop: {
    points: ['tr', 'cl']
  },
  topRight: {
    points: ['br', 'tc']
  },
  rightTop: {
    points: ['tl', 'cr']
  },
  bottomRight: {
    points: ['tr', 'bc']
  },
  rightBottom: {
    points: ['bl', 'cr']
  },
  bottomLeft: {
    points: ['tl', 'bc']
  },
  leftBottom: {
    points: ['br', 'cl']
  }
};
const DisableAutoArrowList = new Set(['topLeft', 'topRight', 'bottomLeft', 'bottomRight', 'leftTop', 'leftBottom', 'rightTop', 'rightBottom']);
function getPlacements(config) {
  const {
    arrowWidth,
    autoAdjustOverflow,
    arrowPointAtCenter,
    offset,
    borderRadius,
    visibleFirst
  } = config;
  const halfArrowWidth = arrowWidth / 2;
  const placementMap = {};
  Object.keys(PlacementAlignMap).forEach(key => {
    const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key];
    const placementInfo = Object.assign(Object.assign({}, template), {
      offset: [0, 0],
      dynamicInset: true
    });
    placementMap[key] = placementInfo;
    // Disable autoArrow since design is fixed position
    if (DisableAutoArrowList.has(key)) {
      placementInfo.autoArrow = false;
    }
    // Static offset
    switch (key) {
      case 'top':
      case 'topLeft':
      case 'topRight':
        placementInfo.offset[1] = -halfArrowWidth - offset;
        break;
      case 'bottom':
      case 'bottomLeft':
      case 'bottomRight':
        placementInfo.offset[1] = halfArrowWidth + offset;
        break;
      case 'left':
      case 'leftTop':
      case 'leftBottom':
        placementInfo.offset[0] = -halfArrowWidth - offset;
        break;
      case 'right':
      case 'rightTop':
      case 'rightBottom':
        placementInfo.offset[0] = halfArrowWidth + offset;
        break;
    }
    // Dynamic offset
    const arrowOffset = getArrowOffsetToken({
      contentRadius: borderRadius,
      limitVerticalRadius: true
    });
    if (arrowPointAtCenter) {
      switch (key) {
        case 'topLeft':
        case 'bottomLeft':
          placementInfo.offset[0] = -arrowOffset.arrowOffsetHorizontal - halfArrowWidth;
          break;
        case 'topRight':
        case 'bottomRight':
          placementInfo.offset[0] = arrowOffset.arrowOffsetHorizontal + halfArrowWidth;
          break;
        case 'leftTop':
        case 'rightTop':
          placementInfo.offset[1] = -arrowOffset.arrowOffsetHorizontal - halfArrowWidth;
          break;
        case 'leftBottom':
        case 'rightBottom':
          placementInfo.offset[1] = arrowOffset.arrowOffsetHorizontal + halfArrowWidth;
          break;
      }
    }
    // Overflow
    placementInfo.overflow = getOverflowOptions(key, arrowOffset, arrowWidth, autoAdjustOverflow);
    // VisibleFirst
    if (visibleFirst) {
      placementInfo.htmlRegion = 'visibleFirst';
    }
  });
  return placementMap;
}
// EXTERNAL MODULE: ./node_modules/antd/es/_util/warning.js
var _util_warning = __webpack_require__(27288);
// EXTERNAL MODULE: ./node_modules/antd/es/_util/zindexContext.js
var zindexContext = __webpack_require__(43945);
// EXTERNAL MODULE: ./node_modules/antd/es/space/Compact.js
var Compact = __webpack_require__(4173);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/useToken.js + 2 modules
var useToken = __webpack_require__(25976);
// EXTERNAL MODULE: ./node_modules/antd/es/style/motion/zoom.js
var zoom = __webpack_require__(50438);
;// CONCATENATED MODULE: ./node_modules/antd/es/theme/interface/presetColors.js
const PresetColors = ['blue', 'purple', 'cyan', 'green', 'magenta', 'pink', 'red', 'orange', 'yellow', 'volcano', 'geekblue', 'lime', 'gold'];
;// CONCATENATED MODULE: ./node_modules/antd/es/theme/util/genPresetColor.js

function genPresetColor(token, genCss) {
  return PresetColors.reduce((prev, colorKey) => {
    const lightColor = token[`${colorKey}1`];
    const lightBorderColor = token[`${colorKey}3`];
    const darkColor = token[`${colorKey}6`];
    const textColor = token[`${colorKey}7`];
    return Object.assign(Object.assign({}, prev), genCss(colorKey, {
      lightColor,
      lightBorderColor,
      darkColor,
      textColor
    }));
  }, {});
}
;// CONCATENATED MODULE: ./node_modules/antd/es/tooltip/style/index.js






const genTooltipStyle = token => {
  const {
    componentCls,
    // ant-tooltip
    tooltipMaxWidth,
    tooltipColor,
    tooltipBg,
    tooltipBorderRadius,
    zIndexPopup,
    controlHeight,
    boxShadowSecondary,
    paddingSM,
    paddingXS
  } = token;
  return [{
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, (0,style/* resetComponent */.Wf)(token)), {
      position: 'absolute',
      zIndex: zIndexPopup,
      display: 'block',
      width: 'max-content',
      maxWidth: tooltipMaxWidth,
      visibility: 'visible',
      transformOrigin: `var(--arrow-x, 50%) var(--arrow-y, 50%)`,
      '&-hidden': {
        display: 'none'
      },
      '--antd-arrow-background-color': tooltipBg,
      // Wrapper for the tooltip content
      [`${componentCls}-inner`]: {
        minWidth: controlHeight,
        minHeight: controlHeight,
        padding: `${(0,cssinjs_es/* unit */.bf)(token.calc(paddingSM).div(2).equal())} ${(0,cssinjs_es/* unit */.bf)(paddingXS)}`,
        color: tooltipColor,
        textAlign: 'start',
        textDecoration: 'none',
        wordWrap: 'break-word',
        backgroundColor: tooltipBg,
        borderRadius: tooltipBorderRadius,
        boxShadow: boxShadowSecondary,
        boxSizing: 'border-box'
      },
      // Limit left and right placement radius
      [[`&-placement-left`, `&-placement-leftTop`, `&-placement-leftBottom`, `&-placement-right`, `&-placement-rightTop`, `&-placement-rightBottom`].join(',')]: {
        [`${componentCls}-inner`]: {
          borderRadius: token.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
        }
      },
      [`${componentCls}-content`]: {
        position: 'relative'
      }
    }), genPresetColor(token, (colorKey, _ref) => {
      let {
        darkColor
      } = _ref;
      return {
        [`&${componentCls}-${colorKey}`]: {
          [`${componentCls}-inner`]: {
            backgroundColor: darkColor
          },
          [`${componentCls}-arrow`]: {
            '--antd-arrow-background-color': darkColor
          }
        }
      };
    })), {
      // RTL
      '&-rtl': {
        direction: 'rtl'
      }
    })
  },
  // Arrow Style
  getArrowStyle(token, 'var(--antd-arrow-background-color)'),
  // Pure Render
  {
    [`${componentCls}-pure`]: {
      position: 'relative',
      maxWidth: 'none',
      margin: token.sizePopupArrow
    }
  }];
};
// ============================== Export ==============================
const style_prepareComponentToken = token => Object.assign(Object.assign({
  zIndexPopup: token.zIndexPopupBase + 70
}, getArrowOffsetToken({
  contentRadius: token.borderRadius,
  limitVerticalRadius: true
})), getArrowToken((0,statistic/* merge */.TS)(token, {
  borderRadiusOuter: Math.min(token.borderRadiusOuter, 4)
})));
/* harmony default export */ var tooltip_style = (function (prefixCls) {
  let injectStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  const useStyle = (0,genComponentStyleHook/* genStyleHooks */.I$)('Tooltip', token => {
    const {
      borderRadius,
      colorTextLightSolid,
      colorBgSpotlight
    } = token;
    const TooltipToken = (0,statistic/* merge */.TS)(token, {
      // default variables
      tooltipMaxWidth: 250,
      tooltipColor: colorTextLightSolid,
      tooltipBorderRadius: borderRadius,
      tooltipBg: colorBgSpotlight
    });
    return [genTooltipStyle(TooltipToken), (0,zoom/* initZoomMotion */._y)(token, 'zoom-big-fast')];
  }, style_prepareComponentToken, {
    resetStyle: false,
    // Popover use Tooltip as internal component. We do not need to handle this.
    injectStyle
  });
  return useStyle(prefixCls);
});
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 2 modules
var toConsumableArray = __webpack_require__(74902);
;// CONCATENATED MODULE: ./node_modules/antd/es/_util/colors.js


const inverseColors = PresetColors.map(color => `${color}-inverse`);
const PresetStatusColorTypes = (/* unused pure expression or super */ null && (['success', 'processing', 'error', 'default', 'warning']));
/**
 * determine if the color keyword belongs to the `Ant Design` {@link PresetColors}.
 * @param color color to be judged
 * @param includeInverse whether to include reversed colors
 */
function isPresetColor(color) {
  let includeInverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (includeInverse) {
    return [].concat((0,toConsumableArray/* default */.Z)(inverseColors), (0,toConsumableArray/* default */.Z)(PresetColors)).includes(color);
  }
  return PresetColors.includes(color);
}
function isPresetStatusColor(color) {
  return PresetStatusColorTypes.includes(color);
}
;// CONCATENATED MODULE: ./node_modules/antd/es/tooltip/util.js
/* eslint-disable import/prefer-default-export */


function parseColor(prefixCls, color) {
  const isInternalColor = isPresetColor(color);
  const className = classnames_default()({
    [`${prefixCls}-${color}`]: color && isInternalColor
  });
  const overlayStyle = {};
  const arrowStyle = {};
  if (color && !isInternalColor) {
    overlayStyle.background = color;
    // @ts-ignore
    arrowStyle['--antd-arrow-background-color'] = color;
  }
  return {
    className,
    overlayStyle,
    arrowStyle
  };
}
;// CONCATENATED MODULE: ./node_modules/antd/es/tooltip/PurePanel.js
"use client";







/** @private Internal Component. Do not use in your production. */
const PurePanel = props => {
  const {
    prefixCls: customizePrefixCls,
    className,
    placement = 'top',
    title,
    color,
    overlayInnerStyle
  } = props;
  const {
    getPrefixCls
  } = react.useContext(context/* ConfigContext */.E_);
  const prefixCls = getPrefixCls('tooltip', customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = tooltip_style(prefixCls);
  // Color
  const colorInfo = parseColor(prefixCls, color);
  const arrowContentStyle = colorInfo.arrowStyle;
  const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
  const cls = classnames_default()(hashId, cssVarCls, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className, colorInfo.className);
  return wrapCSSVar( /*#__PURE__*/react.createElement("div", {
    className: cls,
    style: arrowContentStyle
  }, /*#__PURE__*/react.createElement("div", {
    className: `${prefixCls}-arrow`
  }), /*#__PURE__*/react.createElement(Popup, Object.assign({}, props, {
    className: hashId,
    prefixCls: prefixCls,
    overlayInnerStyle: formattedOverlayInnerStyle
  }), title)));
};
/* harmony default export */ var tooltip_PurePanel = (PurePanel);
;// CONCATENATED MODULE: ./node_modules/antd/es/tooltip/index.js
"use client";

var tooltip_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
















const InternalTooltip = /*#__PURE__*/react.forwardRef((props, ref) => {
  var _a, _b;
  const {
    prefixCls: customizePrefixCls,
    openClassName,
    getTooltipContainer,
    overlayClassName,
    color,
    overlayInnerStyle,
    children,
    afterOpenChange,
    afterVisibleChange,
    destroyTooltipOnHide,
    arrow = true,
    title,
    overlay,
    builtinPlacements,
    arrowPointAtCenter = false,
    autoAdjustOverflow = true
  } = props;
  const mergedShowArrow = !!arrow;
  const [, token] = (0,useToken/* default */.ZP)();
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction
  } = react.useContext(context/* ConfigContext */.E_);
  // ============================== Ref ===============================
  const warning = (0,_util_warning/* devUseWarning */.ln)('Tooltip');
  const tooltipRef = react.useRef(null);
  const forceAlign = () => {
    var _a;
    (_a = tooltipRef.current) === null || _a === void 0 ? void 0 : _a.forceAlign();
  };
  react.useImperativeHandle(ref, () => ({
    forceAlign,
    forcePopupAlign: () => {
      warning.deprecated(false, 'forcePopupAlign', 'forceAlign');
      forceAlign();
    }
  }));
  // ============================== Warn ==============================
  if (false) {}
  // ============================== Open ==============================
  const [open, setOpen] = (0,useMergedState/* default */.Z)(false, {
    value: (_a = props.open) !== null && _a !== void 0 ? _a : props.visible,
    defaultValue: (_b = props.defaultOpen) !== null && _b !== void 0 ? _b : props.defaultVisible
  });
  const noTitle = !title && !overlay && title !== 0; // overlay for old version compatibility
  const onOpenChange = vis => {
    var _a, _b;
    setOpen(noTitle ? false : vis);
    if (!noTitle) {
      (_a = props.onOpenChange) === null || _a === void 0 ? void 0 : _a.call(props, vis);
      (_b = props.onVisibleChange) === null || _b === void 0 ? void 0 : _b.call(props, vis);
    }
  };
  const tooltipPlacements = react.useMemo(() => {
    var _a, _b;
    let mergedArrowPointAtCenter = arrowPointAtCenter;
    if (typeof arrow === 'object') {
      mergedArrowPointAtCenter = (_b = (_a = arrow.pointAtCenter) !== null && _a !== void 0 ? _a : arrow.arrowPointAtCenter) !== null && _b !== void 0 ? _b : arrowPointAtCenter;
    }
    return builtinPlacements || getPlacements({
      arrowPointAtCenter: mergedArrowPointAtCenter,
      autoAdjustOverflow,
      arrowWidth: mergedShowArrow ? token.sizePopupArrow : 0,
      borderRadius: token.borderRadius,
      offset: token.marginXXS,
      visibleFirst: true
    });
  }, [arrowPointAtCenter, arrow, builtinPlacements, token]);
  const memoOverlay = react.useMemo(() => {
    if (title === 0) {
      return title;
    }
    return overlay || title || '';
  }, [overlay, title]);
  const memoOverlayWrapper = /*#__PURE__*/react.createElement(Compact/* NoCompactStyle */.BR, null, typeof memoOverlay === 'function' ? memoOverlay() : memoOverlay);
  const {
      getPopupContainer,
      placement = 'top',
      mouseEnterDelay = 0.1,
      mouseLeaveDelay = 0.1,
      overlayStyle,
      rootClassName
    } = props,
    otherProps = tooltip_rest(props, ["getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName"]);
  const prefixCls = getPrefixCls('tooltip', customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const injectFromPopover = props['data-popover-inject'];
  let tempOpen = open;
  // Hide tooltip when there is no title
  if (!('open' in props) && !('visible' in props) && noTitle) {
    tempOpen = false;
  }
  // ============================= Render =============================
  const child = /*#__PURE__*/react.isValidElement(children) && !(0,reactNode/* isFragment */.M2)(children) ? children : /*#__PURE__*/react.createElement("span", null, children);
  const childProps = child.props;
  const childCls = !childProps.className || typeof childProps.className === 'string' ? classnames_default()(childProps.className, openClassName || `${prefixCls}-open`) : childProps.className;
  // Style
  const [wrapCSSVar, hashId, cssVarCls] = tooltip_style(prefixCls, !injectFromPopover);
  // Color
  const colorInfo = parseColor(prefixCls, color);
  const arrowContentStyle = colorInfo.arrowStyle;
  const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
  const customOverlayClassName = classnames_default()(overlayClassName, {
    [`${prefixCls}-rtl`]: direction === 'rtl'
  }, colorInfo.className, rootClassName, hashId, cssVarCls);
  // ============================ zIndex ============================
  const [zIndex, contextZIndex] = (0,useZIndex/* useZIndex */.Cn)('Tooltip', otherProps.zIndex);
  const content = /*#__PURE__*/react.createElement(rc_tooltip_es, Object.assign({}, otherProps, {
    zIndex: zIndex,
    showArrow: mergedShowArrow,
    placement: placement,
    mouseEnterDelay: mouseEnterDelay,
    mouseLeaveDelay: mouseLeaveDelay,
    prefixCls: prefixCls,
    overlayClassName: customOverlayClassName,
    overlayStyle: Object.assign(Object.assign({}, arrowContentStyle), overlayStyle),
    getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
    ref: tooltipRef,
    builtinPlacements: tooltipPlacements,
    overlay: memoOverlayWrapper,
    visible: tempOpen,
    onVisibleChange: onOpenChange,
    afterVisibleChange: afterOpenChange !== null && afterOpenChange !== void 0 ? afterOpenChange : afterVisibleChange,
    overlayInnerStyle: formattedOverlayInnerStyle,
    arrowContent: /*#__PURE__*/react.createElement("span", {
      className: `${prefixCls}-arrow-content`
    }),
    motion: {
      motionName: (0,motion/* getTransitionName */.m)(rootPrefixCls, 'zoom-big-fast', props.transitionName),
      motionDeadline: 1000
    },
    destroyTooltipOnHide: !!destroyTooltipOnHide
  }), tempOpen ? (0,reactNode/* cloneElement */.Tm)(child, {
    className: childCls
  }) : child);
  return wrapCSSVar( /*#__PURE__*/react.createElement(zindexContext/* default */.Z.Provider, {
    value: contextZIndex
  }, content));
});
const tooltip_Tooltip = InternalTooltip;
if (false) {}
tooltip_Tooltip._InternalPanelDoNotUseOrYouWillBeFired = tooltip_PurePanel;
/* harmony default export */ var tooltip = (tooltip_Tooltip);
;// CONCATENATED MODULE: ./node_modules/antd/es/popover/style/index.js





const style_genBaseStyle = token => {
  const {
    componentCls,
    popoverColor,
    titleMinWidth,
    fontWeightStrong,
    innerPadding,
    boxShadowSecondary,
    colorTextHeading,
    borderRadiusLG,
    zIndexPopup,
    titleMarginBottom,
    colorBgElevated,
    popoverBg,
    titleBorderBottom,
    innerContentPadding,
    titlePadding
  } = token;
  return [{
    [componentCls]: Object.assign(Object.assign({}, (0,style/* resetComponent */.Wf)(token)), {
      position: 'absolute',
      top: 0,
      // use `left` to fix https://github.com/ant-design/ant-design/issues/39195
      left: {
        _skip_check_: true,
        value: 0
      },
      zIndex: zIndexPopup,
      fontWeight: 'normal',
      whiteSpace: 'normal',
      textAlign: 'start',
      cursor: 'auto',
      userSelect: 'text',
      transformOrigin: `var(--arrow-x, 50%) var(--arrow-y, 50%)`,
      '--antd-arrow-background-color': colorBgElevated,
      '&-rtl': {
        direction: 'rtl'
      },
      '&-hidden': {
        display: 'none'
      },
      [`${componentCls}-content`]: {
        position: 'relative'
      },
      [`${componentCls}-inner`]: {
        backgroundColor: popoverBg,
        backgroundClip: 'padding-box',
        borderRadius: borderRadiusLG,
        boxShadow: boxShadowSecondary,
        padding: innerPadding
      },
      [`${componentCls}-title`]: {
        minWidth: titleMinWidth,
        marginBottom: titleMarginBottom,
        color: colorTextHeading,
        fontWeight: fontWeightStrong,
        borderBottom: titleBorderBottom,
        padding: titlePadding
      },
      [`${componentCls}-inner-content`]: {
        color: popoverColor,
        padding: innerContentPadding
      }
    })
  },
  // Arrow Style
  getArrowStyle(token, 'var(--antd-arrow-background-color)'),
  // Pure Render
  {
    [`${componentCls}-pure`]: {
      position: 'relative',
      maxWidth: 'none',
      margin: token.sizePopupArrow,
      display: 'inline-block',
      [`${componentCls}-content`]: {
        display: 'inline-block'
      }
    }
  }];
};
const genColorStyle = token => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: PresetColors.map(colorKey => {
      const lightColor = token[`${colorKey}6`];
      return {
        [`&${componentCls}-${colorKey}`]: {
          '--antd-arrow-background-color': lightColor,
          [`${componentCls}-inner`]: {
            backgroundColor: lightColor
          },
          [`${componentCls}-arrow`]: {
            background: 'transparent'
          }
        }
      };
    })
  };
};
const popover_style_prepareComponentToken = token => {
  const {
    lineWidth,
    controlHeight,
    fontHeight,
    padding,
    wireframe,
    zIndexPopupBase,
    borderRadiusLG,
    marginXS,
    lineType,
    colorSplit,
    paddingSM
  } = token;
  const titlePaddingBlockDist = controlHeight - fontHeight;
  const popoverTitlePaddingBlockTop = titlePaddingBlockDist / 2;
  const popoverTitlePaddingBlockBottom = titlePaddingBlockDist / 2 - lineWidth;
  const popoverPaddingHorizontal = padding;
  return Object.assign(Object.assign(Object.assign({
    titleMinWidth: 177,
    zIndexPopup: zIndexPopupBase + 30
  }, getArrowToken(token)), getArrowOffsetToken({
    contentRadius: borderRadiusLG,
    limitVerticalRadius: true
  })), {
    // internal
    innerPadding: wireframe ? 0 : 12,
    titleMarginBottom: wireframe ? 0 : marginXS,
    titlePadding: wireframe ? `${popoverTitlePaddingBlockTop}px ${popoverPaddingHorizontal}px ${popoverTitlePaddingBlockBottom}px` : 0,
    titleBorderBottom: wireframe ? `${lineWidth}px ${lineType} ${colorSplit}` : 'none',
    innerContentPadding: wireframe ? `${paddingSM}px ${popoverPaddingHorizontal}px` : 0
  });
};
/* harmony default export */ var popover_style = ((0,genComponentStyleHook/* genStyleHooks */.I$)('Popover', token => {
  const {
    colorBgElevated,
    colorText
  } = token;
  const popoverToken = (0,statistic/* merge */.TS)(token, {
    popoverBg: colorBgElevated,
    popoverColor: colorText
  });
  return [style_genBaseStyle(popoverToken), genColorStyle(popoverToken), (0,zoom/* initZoomMotion */._y)(popoverToken, 'zoom-big')];
}, popover_style_prepareComponentToken, {
  resetStyle: false,
  deprecatedTokens: [['width', 'titleMinWidth'], ['minWidth', 'titleMinWidth']]
}));
;// CONCATENATED MODULE: ./node_modules/antd/es/popover/PurePanel.js
"use client";

var PurePanel_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};






const getOverlay = (prefixCls, title, content) => {
  if (!title && !content) {
    return null;
  }
  return /*#__PURE__*/react.createElement(react.Fragment, null, title && /*#__PURE__*/react.createElement("div", {
    className: `${prefixCls}-title`
  }, getRenderPropValue(title)), /*#__PURE__*/react.createElement("div", {
    className: `${prefixCls}-inner-content`
  }, getRenderPropValue(content)));
};
const RawPurePanel = props => {
  const {
    hashId,
    prefixCls,
    className,
    style,
    placement = 'top',
    title,
    content,
    children
  } = props;
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(hashId, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className),
    style: style
  }, /*#__PURE__*/react.createElement("div", {
    className: `${prefixCls}-arrow`
  }), /*#__PURE__*/react.createElement(Popup, Object.assign({}, props, {
    className: hashId,
    prefixCls: prefixCls
  }), children || getOverlay(prefixCls, title, content)));
};
const PurePanel_PurePanel = props => {
  const {
      prefixCls: customizePrefixCls,
      className
    } = props,
    restProps = PurePanel_rest(props, ["prefixCls", "className"]);
  const {
    getPrefixCls
  } = react.useContext(context/* ConfigContext */.E_);
  const prefixCls = getPrefixCls('popover', customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = popover_style(prefixCls);
  return wrapCSSVar( /*#__PURE__*/react.createElement(RawPurePanel, Object.assign({}, restProps, {
    prefixCls: prefixCls,
    hashId: hashId,
    className: classnames_default()(className, cssVarCls)
  })));
};
/* harmony default export */ var popover_PurePanel = (PurePanel_PurePanel);
;// CONCATENATED MODULE: ./node_modules/antd/es/popover/index.js
"use client";

var popover_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};










// CSSINJS

const Overlay = _ref => {
  let {
    title,
    content,
    prefixCls
  } = _ref;
  return /*#__PURE__*/react.createElement(react.Fragment, null, title && /*#__PURE__*/react.createElement("div", {
    className: `${prefixCls}-title`
  }, getRenderPropValue(title)), /*#__PURE__*/react.createElement("div", {
    className: `${prefixCls}-inner-content`
  }, getRenderPropValue(content)));
};
const InternalPopover = /*#__PURE__*/react.forwardRef((props, ref) => {
  var _a, _b;
  const {
      prefixCls: customizePrefixCls,
      title,
      content,
      overlayClassName,
      placement = 'top',
      trigger = 'hover',
      children,
      mouseEnterDelay = 0.1,
      mouseLeaveDelay = 0.1,
      onOpenChange,
      overlayStyle = {}
    } = props,
    otherProps = popover_rest(props, ["prefixCls", "title", "content", "overlayClassName", "placement", "trigger", "children", "mouseEnterDelay", "mouseLeaveDelay", "onOpenChange", "overlayStyle"]);
  const {
    getPrefixCls
  } = react.useContext(context/* ConfigContext */.E_);
  const prefixCls = getPrefixCls('popover', customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = popover_style(prefixCls);
  const rootPrefixCls = getPrefixCls();
  const overlayCls = classnames_default()(overlayClassName, hashId, cssVarCls);
  const [open, setOpen] = (0,useMergedState/* default */.Z)(false, {
    value: (_a = props.open) !== null && _a !== void 0 ? _a : props.visible,
    defaultValue: (_b = props.defaultOpen) !== null && _b !== void 0 ? _b : props.defaultVisible
  });
  const settingOpen = (value, e) => {
    setOpen(value, true);
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(value, e);
  };
  const onKeyDown = e => {
    if (e.keyCode === KeyCode/* default */.Z.ESC) {
      settingOpen(false, e);
    }
  };
  const onInternalOpenChange = value => {
    settingOpen(value);
  };
  return wrapCSSVar( /*#__PURE__*/react.createElement(tooltip, Object.assign({
    placement: placement,
    trigger: trigger,
    mouseEnterDelay: mouseEnterDelay,
    mouseLeaveDelay: mouseLeaveDelay,
    overlayStyle: overlayStyle
  }, otherProps, {
    prefixCls: prefixCls,
    overlayClassName: overlayCls,
    ref: ref,
    open: open,
    onOpenChange: onInternalOpenChange,
    overlay: title || content ? /*#__PURE__*/react.createElement(Overlay, {
      prefixCls: prefixCls,
      title: title,
      content: content
    }) : null,
    transitionName: (0,motion/* getTransitionName */.m)(rootPrefixCls, 'zoom-big', otherProps.transitionName),
    "data-popover-inject": true
  }), (0,reactNode/* cloneElement */.Tm)(children, {
    onKeyDown: e => {
      var _a, _b;
      if ( /*#__PURE__*/react.isValidElement(children)) {
        (_b = children === null || children === void 0 ? void 0 : (_a = children.props).onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, e);
      }
      onKeyDown(e);
    }
  })));
});
const Popover = InternalPopover;
Popover._InternalPanelDoNotUseOrYouWillBeFired = popover_PurePanel;
if (false) {}
/* harmony default export */ var popover = (Popover);
;// CONCATENATED MODULE: ./node_modules/antd/es/avatar/group.js
"use client";











const AvatarContextProvider = props => {
  const {
    size,
    shape
  } = react.useContext(avatar_AvatarContext);
  const avatarContextValue = react.useMemo(() => ({
    size: props.size || size,
    shape: props.shape || shape
  }), [props.size, props.shape, size, shape]);
  return /*#__PURE__*/react.createElement(avatar_AvatarContext.Provider, {
    value: avatarContextValue
  }, props.children);
};
const Group = props => {
  const {
    getPrefixCls,
    direction
  } = react.useContext(context/* ConfigContext */.E_);
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style,
    maxCount,
    maxStyle,
    size,
    shape,
    maxPopoverPlacement = 'top',
    maxPopoverTrigger = 'hover',
    children
  } = props;
  const prefixCls = getPrefixCls('avatar', customizePrefixCls);
  const groupPrefixCls = `${prefixCls}-group`;
  const rootCls = (0,useCSSVarCls/* default */.Z)(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = avatar_style(prefixCls, rootCls);
  const cls = classnames_default()(groupPrefixCls, {
    [`${groupPrefixCls}-rtl`]: direction === 'rtl'
  }, cssVarCls, rootCls, className, rootClassName, hashId);
  const childrenWithProps = (0,toArray/* default */.Z)(children).map((child, index) => (0,reactNode/* cloneElement */.Tm)(child, {
    key: `avatar-key-${index}`
  }));
  const numOfChildren = childrenWithProps.length;
  if (maxCount && maxCount < numOfChildren) {
    const childrenShow = childrenWithProps.slice(0, maxCount);
    const childrenHidden = childrenWithProps.slice(maxCount, numOfChildren);
    childrenShow.push( /*#__PURE__*/react.createElement(popover, {
      key: "avatar-popover-key",
      content: childrenHidden,
      trigger: maxPopoverTrigger,
      placement: maxPopoverPlacement,
      overlayClassName: `${groupPrefixCls}-popover`,
      destroyTooltipOnHide: true
    }, /*#__PURE__*/react.createElement(avatar, {
      style: maxStyle
    }, `+${numOfChildren - maxCount}`)));
    return wrapCSSVar( /*#__PURE__*/react.createElement(AvatarContextProvider, {
      shape: shape,
      size: size
    }, /*#__PURE__*/react.createElement("div", {
      className: cls,
      style: style
    }, childrenShow)));
  }
  return wrapCSSVar( /*#__PURE__*/react.createElement(AvatarContextProvider, {
    shape: shape,
    size: size
  }, /*#__PURE__*/react.createElement("div", {
    className: cls,
    style: style
  }, childrenWithProps)));
};
/* harmony default export */ var group = (Group);
;// CONCATENATED MODULE: ./node_modules/antd/es/avatar/index.js
"use client";




const avatar_Avatar = avatar;
avatar_Avatar.Group = group;
/* harmony default export */ var es_avatar = (avatar_Avatar);

/***/ }),

/***/ 4393:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: function() { return /* binding */ card; }
});

// EXTERNAL MODULE: ./node_modules/@umijs/preset-umi/node_modules/react/index.js
var react = __webpack_require__(62435);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(93967);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/rc-util/es/omit.js
var omit = __webpack_require__(98423);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/context.js
var context = __webpack_require__(53124);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/hooks/useSize.js
var useSize = __webpack_require__(98675);
// EXTERNAL MODULE: ./node_modules/antd/es/skeleton/index.js + 12 modules
var skeleton = __webpack_require__(21687);
// EXTERNAL MODULE: ./node_modules/antd/es/tabs/index.js + 68 modules
var es_tabs = __webpack_require__(7168);
;// CONCATENATED MODULE: ./node_modules/antd/es/card/Grid.js
"use client";

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



const Grid = _a => {
  var {
      prefixCls,
      className,
      hoverable = true
    } = _a,
    props = __rest(_a, ["prefixCls", "className", "hoverable"]);
  const {
    getPrefixCls
  } = react.useContext(context/* ConfigContext */.E_);
  const prefix = getPrefixCls('card', prefixCls);
  const classString = classnames_default()(`${prefix}-grid`, className, {
    [`${prefix}-grid-hoverable`]: hoverable
  });
  return /*#__PURE__*/react.createElement("div", Object.assign({}, props, {
    className: classString
  }));
};
/* harmony default export */ var card_Grid = (Grid);
// EXTERNAL MODULE: ./node_modules/@ant-design/cssinjs/es/index.js + 35 modules
var es = __webpack_require__(54548);
// EXTERNAL MODULE: ./node_modules/antd/es/style/index.js
var style = __webpack_require__(14747);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/genComponentStyleHook.js + 6 modules
var genComponentStyleHook = __webpack_require__(92030);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/statistic.js
var statistic = __webpack_require__(45503);
;// CONCATENATED MODULE: ./node_modules/antd/es/card/style/index.js



// ============================== Styles ==============================
// ============================== Head ==============================
const genCardHeadStyle = token => {
  const {
    antCls,
    componentCls,
    headerHeight,
    cardPaddingBase,
    tabsMarginBottom
  } = token;
  return Object.assign(Object.assign({
    display: 'flex',
    justifyContent: 'center',
    flexDirection: 'column',
    minHeight: headerHeight,
    marginBottom: -1,
    padding: `0 ${(0,es/* unit */.bf)(cardPaddingBase)}`,
    color: token.colorTextHeading,
    fontWeight: token.fontWeightStrong,
    fontSize: token.headerFontSize,
    background: token.headerBg,
    borderBottom: `${(0,es/* unit */.bf)(token.lineWidth)} ${token.lineType} ${token.colorBorderSecondary}`,
    borderRadius: `${(0,es/* unit */.bf)(token.borderRadiusLG)} ${(0,es/* unit */.bf)(token.borderRadiusLG)} 0 0`
  }, (0,style/* clearFix */.dF)()), {
    '&-wrapper': {
      width: '100%',
      display: 'flex',
      alignItems: 'center'
    },
    '&-title': Object.assign(Object.assign({
      display: 'inline-block',
      flex: 1
    }, style/* textEllipsis */.vS), {
      [`
          > ${componentCls}-typography,
          > ${componentCls}-typography-edit-content
        `]: {
        insetInlineStart: 0,
        marginTop: 0,
        marginBottom: 0
      }
    }),
    [`${antCls}-tabs-top`]: {
      clear: 'both',
      marginBottom: tabsMarginBottom,
      color: token.colorText,
      fontWeight: 'normal',
      fontSize: token.fontSize,
      '&-bar': {
        borderBottom: `${(0,es/* unit */.bf)(token.lineWidth)} ${token.lineType} ${token.colorBorderSecondary}`
      }
    }
  });
};
// ============================== Grid ==============================
const genCardGridStyle = token => {
  const {
    cardPaddingBase,
    colorBorderSecondary,
    cardShadow,
    lineWidth
  } = token;
  return {
    width: '33.33%',
    padding: cardPaddingBase,
    border: 0,
    borderRadius: 0,
    boxShadow: `
      ${(0,es/* unit */.bf)(lineWidth)} 0 0 0 ${colorBorderSecondary},
      0 ${(0,es/* unit */.bf)(lineWidth)} 0 0 ${colorBorderSecondary},
      ${(0,es/* unit */.bf)(lineWidth)} ${(0,es/* unit */.bf)(lineWidth)} 0 0 ${colorBorderSecondary},
      ${(0,es/* unit */.bf)(lineWidth)} 0 0 0 ${colorBorderSecondary} inset,
      0 ${(0,es/* unit */.bf)(lineWidth)} 0 0 ${colorBorderSecondary} inset;
    `,
    transition: `all ${token.motionDurationMid}`,
    '&-hoverable:hover': {
      position: 'relative',
      zIndex: 1,
      boxShadow: cardShadow
    }
  };
};
// ============================== Actions ==============================
const genCardActionsStyle = token => {
  const {
    componentCls,
    iconCls,
    actionsLiMargin,
    cardActionsIconSize,
    colorBorderSecondary,
    actionsBg
  } = token;
  return Object.assign(Object.assign({
    margin: 0,
    padding: 0,
    listStyle: 'none',
    background: actionsBg,
    borderTop: `${(0,es/* unit */.bf)(token.lineWidth)} ${token.lineType} ${colorBorderSecondary}`,
    display: 'flex',
    borderRadius: `0 0 ${(0,es/* unit */.bf)(token.borderRadiusLG)} ${(0,es/* unit */.bf)(token.borderRadiusLG)}`
  }, (0,style/* clearFix */.dF)()), {
    '& > li': {
      margin: actionsLiMargin,
      color: token.colorTextDescription,
      textAlign: 'center',
      '> span': {
        position: 'relative',
        display: 'block',
        minWidth: token.calc(token.cardActionsIconSize).mul(2).equal(),
        fontSize: token.fontSize,
        lineHeight: token.lineHeight,
        cursor: 'pointer',
        '&:hover': {
          color: token.colorPrimary,
          transition: `color ${token.motionDurationMid}`
        },
        [`a:not(${componentCls}-btn), > ${iconCls}`]: {
          display: 'inline-block',
          width: '100%',
          color: token.colorTextDescription,
          lineHeight: (0,es/* unit */.bf)(token.fontHeight),
          transition: `color ${token.motionDurationMid}`,
          '&:hover': {
            color: token.colorPrimary
          }
        },
        [`> ${iconCls}`]: {
          fontSize: cardActionsIconSize,
          lineHeight: (0,es/* unit */.bf)(token.calc(cardActionsIconSize).mul(token.lineHeight).equal())
        }
      },
      '&:not(:last-child)': {
        borderInlineEnd: `${(0,es/* unit */.bf)(token.lineWidth)} ${token.lineType} ${colorBorderSecondary}`
      }
    }
  });
};
// ============================== Meta ==============================
const genCardMetaStyle = token => Object.assign(Object.assign({
  margin: `${(0,es/* unit */.bf)(token.calc(token.marginXXS).mul(-1).equal())} 0`,
  display: 'flex'
}, (0,style/* clearFix */.dF)()), {
  '&-avatar': {
    paddingInlineEnd: token.padding
  },
  '&-detail': {
    overflow: 'hidden',
    flex: 1,
    '> div:not(:last-child)': {
      marginBottom: token.marginXS
    }
  },
  '&-title': Object.assign({
    color: token.colorTextHeading,
    fontWeight: token.fontWeightStrong,
    fontSize: token.fontSizeLG
  }, style/* textEllipsis */.vS),
  '&-description': {
    color: token.colorTextDescription
  }
});
// ============================== Inner ==============================
const genCardTypeInnerStyle = token => {
  const {
    componentCls,
    cardPaddingBase,
    colorFillAlter
  } = token;
  return {
    [`${componentCls}-head`]: {
      padding: `0 ${(0,es/* unit */.bf)(cardPaddingBase)}`,
      background: colorFillAlter,
      '&-title': {
        fontSize: token.fontSize
      }
    },
    [`${componentCls}-body`]: {
      padding: `${(0,es/* unit */.bf)(token.padding)} ${(0,es/* unit */.bf)(cardPaddingBase)}`
    }
  };
};
// ============================== Loading ==============================
const genCardLoadingStyle = token => {
  const {
    componentCls
  } = token;
  return {
    overflow: 'hidden',
    [`${componentCls}-body`]: {
      userSelect: 'none'
    }
  };
};
// ============================== Basic ==============================
const genCardStyle = token => {
  const {
    antCls,
    componentCls,
    cardShadow,
    cardHeadPadding,
    colorBorderSecondary,
    boxShadowTertiary,
    cardPaddingBase,
    extraColor
  } = token;
  return {
    [componentCls]: Object.assign(Object.assign({}, (0,style/* resetComponent */.Wf)(token)), {
      position: 'relative',
      background: token.colorBgContainer,
      borderRadius: token.borderRadiusLG,
      [`&:not(${componentCls}-bordered)`]: {
        boxShadow: boxShadowTertiary
      },
      [`${componentCls}-head`]: genCardHeadStyle(token),
      [`${componentCls}-extra`]: {
        // https://stackoverflow.com/a/22429853/3040605
        marginInlineStart: 'auto',
        color: extraColor,
        fontWeight: 'normal',
        fontSize: token.fontSize
      },
      [`${componentCls}-body`]: Object.assign({
        padding: cardPaddingBase,
        borderRadius: `0 0 ${(0,es/* unit */.bf)(token.borderRadiusLG)} ${(0,es/* unit */.bf)(token.borderRadiusLG)}`
      }, (0,style/* clearFix */.dF)()),
      [`${componentCls}-grid`]: genCardGridStyle(token),
      [`${componentCls}-cover`]: {
        '> *': {
          display: 'block',
          width: '100%'
        },
        [`img, img + ${antCls}-image-mask`]: {
          borderRadius: `${(0,es/* unit */.bf)(token.borderRadiusLG)} ${(0,es/* unit */.bf)(token.borderRadiusLG)} 0 0`
        }
      },
      [`${componentCls}-actions`]: genCardActionsStyle(token),
      [`${componentCls}-meta`]: genCardMetaStyle(token)
    }),
    [`${componentCls}-bordered`]: {
      border: `${(0,es/* unit */.bf)(token.lineWidth)} ${token.lineType} ${colorBorderSecondary}`,
      [`${componentCls}-cover`]: {
        marginTop: -1,
        marginInlineStart: -1,
        marginInlineEnd: -1
      }
    },
    [`${componentCls}-hoverable`]: {
      cursor: 'pointer',
      transition: `box-shadow ${token.motionDurationMid}, border-color ${token.motionDurationMid}`,
      '&:hover': {
        borderColor: 'transparent',
        boxShadow: cardShadow
      }
    },
    [`${componentCls}-contain-grid`]: {
      borderRadius: `${(0,es/* unit */.bf)(token.borderRadiusLG)} ${(0,es/* unit */.bf)(token.borderRadiusLG)} 0 0 `,
      [`${componentCls}-body`]: {
        display: 'flex',
        flexWrap: 'wrap'
      },
      [`&:not(${componentCls}-loading) ${componentCls}-body`]: {
        marginBlockStart: token.calc(token.lineWidth).mul(-1).equal(),
        marginInlineStart: token.calc(token.lineWidth).mul(-1).equal(),
        padding: 0
      }
    },
    [`${componentCls}-contain-tabs`]: {
      [`> ${componentCls}-head`]: {
        minHeight: 0,
        [`${componentCls}-head-title, ${componentCls}-extra`]: {
          paddingTop: cardHeadPadding
        }
      }
    },
    [`${componentCls}-type-inner`]: genCardTypeInnerStyle(token),
    [`${componentCls}-loading`]: genCardLoadingStyle(token),
    [`${componentCls}-rtl`]: {
      direction: 'rtl'
    }
  };
};
// ============================== Size ==============================
const genCardSizeStyle = token => {
  const {
    componentCls,
    cardPaddingSM,
    headerHeightSM,
    headerFontSizeSM
  } = token;
  return {
    [`${componentCls}-small`]: {
      [`> ${componentCls}-head`]: {
        minHeight: headerHeightSM,
        padding: `0 ${(0,es/* unit */.bf)(cardPaddingSM)}`,
        fontSize: headerFontSizeSM,
        [`> ${componentCls}-head-wrapper`]: {
          [`> ${componentCls}-extra`]: {
            fontSize: token.fontSize
          }
        }
      },
      [`> ${componentCls}-body`]: {
        padding: cardPaddingSM
      }
    },
    [`${componentCls}-small${componentCls}-contain-tabs`]: {
      [`> ${componentCls}-head`]: {
        [`${componentCls}-head-title, ${componentCls}-extra`]: {
          paddingTop: 0,
          display: 'flex',
          alignItems: 'center'
        }
      }
    }
  };
};
const prepareComponentToken = token => ({
  headerBg: 'transparent',
  headerFontSize: token.fontSizeLG,
  headerFontSizeSM: token.fontSize,
  headerHeight: token.fontSizeLG * token.lineHeightLG + token.padding * 2,
  headerHeightSM: token.fontSize * token.lineHeight + token.paddingXS * 2,
  actionsBg: token.colorBgContainer,
  actionsLiMargin: `${token.paddingSM}px 0`,
  tabsMarginBottom: -token.padding - token.lineWidth,
  extraColor: token.colorText
});
// ============================== Export ==============================
/* harmony default export */ var card_style = ((0,genComponentStyleHook/* genStyleHooks */.I$)('Card', token => {
  const cardToken = (0,statistic/* merge */.TS)(token, {
    cardShadow: token.boxShadowCard,
    cardHeadPadding: token.padding,
    cardPaddingBase: token.paddingLG,
    cardActionsIconSize: token.fontSize,
    cardPaddingSM: 12 // Fixed padding.
  });
  return [
  // Style
  genCardStyle(cardToken),
  // Size
  genCardSizeStyle(cardToken)];
}, prepareComponentToken));
;// CONCATENATED MODULE: ./node_modules/antd/es/card/Card.js
"use client";

var Card_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};










const ActionNode = props => {
  const {
    actionClasses,
    actions = [],
    actionStyle
  } = props;
  return /*#__PURE__*/react.createElement("ul", {
    className: actionClasses,
    style: actionStyle
  }, actions.map((action, index) => {
    // Move this out since eslint not allow index key
    // And eslint-disable makes conflict with rollup
    // ref https://github.com/ant-design/ant-design/issues/46022
    const key = `action-${index}`;
    return /*#__PURE__*/react.createElement("li", {
      style: {
        width: `${100 / actions.length}%`
      },
      key: key
    }, /*#__PURE__*/react.createElement("span", null, action));
  }));
};
const Card = /*#__PURE__*/react.forwardRef((props, ref) => {
  const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style,
      extra,
      headStyle = {},
      bodyStyle = {},
      title,
      loading,
      bordered = true,
      size: customizeSize,
      type,
      cover,
      actions,
      tabList,
      children,
      activeTabKey,
      defaultActiveTabKey,
      tabBarExtraContent,
      hoverable,
      tabProps = {},
      classNames: customClassNames,
      styles: customStyles
    } = props,
    others = Card_rest(props, ["prefixCls", "className", "rootClassName", "style", "extra", "headStyle", "bodyStyle", "title", "loading", "bordered", "size", "type", "cover", "actions", "tabList", "children", "activeTabKey", "defaultActiveTabKey", "tabBarExtraContent", "hoverable", "tabProps", "classNames", "styles"]);
  const {
    getPrefixCls,
    direction,
    card
  } = react.useContext(context/* ConfigContext */.E_);
  // =================Warning===================
  if (false) {}
  const onTabChange = key => {
    var _a;
    (_a = props.onTabChange) === null || _a === void 0 ? void 0 : _a.call(props, key);
  };
  const moduleClass = moduleName => {
    var _a;
    return classnames_default()((_a = card === null || card === void 0 ? void 0 : card.classNames) === null || _a === void 0 ? void 0 : _a[moduleName], customClassNames === null || customClassNames === void 0 ? void 0 : customClassNames[moduleName]);
  };
  const moduleStyle = moduleName => {
    var _a;
    return Object.assign(Object.assign({}, (_a = card === null || card === void 0 ? void 0 : card.styles) === null || _a === void 0 ? void 0 : _a[moduleName]), customStyles === null || customStyles === void 0 ? void 0 : customStyles[moduleName]);
  };
  const isContainGrid = react.useMemo(() => {
    let containGrid = false;
    react.Children.forEach(children, element => {
      if (element && element.type && element.type === card_Grid) {
        containGrid = true;
      }
    });
    return containGrid;
  }, [children]);
  const prefixCls = getPrefixCls('card', customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = card_style(prefixCls);
  const loadingBlock = /*#__PURE__*/react.createElement(skeleton/* default */.Z, {
    loading: true,
    active: true,
    paragraph: {
      rows: 4
    },
    title: false
  }, children);
  const hasActiveTabKey = activeTabKey !== undefined;
  const extraProps = Object.assign(Object.assign({}, tabProps), {
    [hasActiveTabKey ? 'activeKey' : 'defaultActiveKey']: hasActiveTabKey ? activeTabKey : defaultActiveTabKey,
    tabBarExtraContent
  });
  let head;
  const mergedSize = (0,useSize/* default */.Z)(customizeSize);
  const tabSize = !mergedSize || mergedSize === 'default' ? 'large' : mergedSize;
  const tabs = tabList ? ( /*#__PURE__*/react.createElement(es_tabs/* default */.Z, Object.assign({
    size: tabSize
  }, extraProps, {
    className: `${prefixCls}-head-tabs`,
    onChange: onTabChange,
    items: tabList.map(_a => {
      var {
          tab
        } = _a,
        item = Card_rest(_a, ["tab"]);
      return Object.assign({
        label: tab
      }, item);
    })
  }))) : null;
  if (title || extra || tabs) {
    const headClasses = classnames_default()(`${prefixCls}-head`, moduleClass('header'));
    const titleClasses = classnames_default()(`${prefixCls}-head-title`, moduleClass('title'));
    const extraClasses = classnames_default()(`${prefixCls}-extra`, moduleClass('extra'));
    const mergedHeadStyle = Object.assign(Object.assign({}, headStyle), moduleStyle('header'));
    head = /*#__PURE__*/react.createElement("div", {
      className: headClasses,
      style: mergedHeadStyle
    }, /*#__PURE__*/react.createElement("div", {
      className: `${prefixCls}-head-wrapper`
    }, title && ( /*#__PURE__*/react.createElement("div", {
      className: titleClasses,
      style: moduleStyle('title')
    }, title)), extra && ( /*#__PURE__*/react.createElement("div", {
      className: extraClasses,
      style: moduleStyle('extra')
    }, extra))), tabs);
  }
  const coverClasses = classnames_default()(`${prefixCls}-cover`, moduleClass('cover'));
  const coverDom = cover ? ( /*#__PURE__*/react.createElement("div", {
    className: coverClasses,
    style: moduleStyle('cover')
  }, cover)) : null;
  const bodyClasses = classnames_default()(`${prefixCls}-body`, moduleClass('body'));
  const mergedBodyStyle = Object.assign(Object.assign({}, bodyStyle), moduleStyle('body'));
  const body = /*#__PURE__*/react.createElement("div", {
    className: bodyClasses,
    style: mergedBodyStyle
  }, loading ? loadingBlock : children);
  const actionClasses = classnames_default()(`${prefixCls}-actions`, moduleClass('actions'));
  const actionDom = actions && actions.length ? ( /*#__PURE__*/react.createElement(ActionNode, {
    actionClasses: actionClasses,
    actionStyle: moduleStyle('actions'),
    actions: actions
  })) : null;
  const divProps = (0,omit/* default */.Z)(others, ['onTabChange']);
  const classString = classnames_default()(prefixCls, card === null || card === void 0 ? void 0 : card.className, {
    [`${prefixCls}-loading`]: loading,
    [`${prefixCls}-bordered`]: bordered,
    [`${prefixCls}-hoverable`]: hoverable,
    [`${prefixCls}-contain-grid`]: isContainGrid,
    [`${prefixCls}-contain-tabs`]: tabList && tabList.length,
    [`${prefixCls}-${mergedSize}`]: mergedSize,
    [`${prefixCls}-type-${type}`]: !!type,
    [`${prefixCls}-rtl`]: direction === 'rtl'
  }, className, rootClassName, hashId, cssVarCls);
  const mergedStyle = Object.assign(Object.assign({}, card === null || card === void 0 ? void 0 : card.style), style);
  return wrapCSSVar( /*#__PURE__*/react.createElement("div", Object.assign({
    ref: ref
  }, divProps, {
    className: classString,
    style: mergedStyle
  }), head, coverDom, body, actionDom));
});
/* harmony default export */ var card_Card = (Card);
;// CONCATENATED MODULE: ./node_modules/antd/es/card/Meta.js
"use client";

var Meta_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



const Meta = props => {
  const {
      prefixCls: customizePrefixCls,
      className,
      avatar,
      title,
      description
    } = props,
    others = Meta_rest(props, ["prefixCls", "className", "avatar", "title", "description"]);
  const {
    getPrefixCls
  } = react.useContext(context/* ConfigContext */.E_);
  const prefixCls = getPrefixCls('card', customizePrefixCls);
  const classString = classnames_default()(`${prefixCls}-meta`, className);
  const avatarDom = avatar ? ( /*#__PURE__*/react.createElement("div", {
    className: `${prefixCls}-meta-avatar`
  }, avatar)) : null;
  const titleDom = title ? ( /*#__PURE__*/react.createElement("div", {
    className: `${prefixCls}-meta-title`
  }, title)) : null;
  const descriptionDom = description ? ( /*#__PURE__*/react.createElement("div", {
    className: `${prefixCls}-meta-description`
  }, description)) : null;
  const MetaDetail = titleDom || descriptionDom ? ( /*#__PURE__*/react.createElement("div", {
    className: `${prefixCls}-meta-detail`
  }, titleDom, descriptionDom)) : null;
  return /*#__PURE__*/react.createElement("div", Object.assign({}, others, {
    className: classString
  }), avatarDom, MetaDetail);
};
/* harmony default export */ var card_Meta = (Meta);
;// CONCATENATED MODULE: ./node_modules/antd/es/card/index.js
"use client";




const es_card_Card = card_Card;
es_card_Card.Grid = card_Grid;
es_card_Card.Meta = card_Meta;
if (false) {}
/* harmony default export */ var card = (es_card_Card);

/***/ }),

/***/ 32983:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: function() { return /* binding */ es_empty; }
});

// EXTERNAL MODULE: ./node_modules/@umijs/preset-umi/node_modules/react/index.js
var react = __webpack_require__(62435);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(93967);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/context.js
var context = __webpack_require__(53124);
// EXTERNAL MODULE: ./node_modules/antd/es/locale/useLocale.js
var useLocale = __webpack_require__(10110);
// EXTERNAL MODULE: ./node_modules/@ctrl/tinycolor/dist/module/index.js
var dist_module = __webpack_require__(10274);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/useToken.js + 2 modules
var useToken = __webpack_require__(25976);
;// CONCATENATED MODULE: ./node_modules/antd/es/empty/empty.js
"use client";




const Empty = () => {
  const [, token] = (0,useToken/* default */.ZP)();
  const bgColor = new dist_module/* TinyColor */.C(token.colorBgBase);
  // Dark Theme need more dark of this
  const themeStyle = bgColor.toHsl().l < 0.5 ? {
    opacity: 0.65
  } : {};
  return /*#__PURE__*/react.createElement("svg", {
    style: themeStyle,
    width: "184",
    height: "152",
    viewBox: "0 0 184 152",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/react.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /*#__PURE__*/react.createElement("g", {
    transform: "translate(24 31.67)"
  }, /*#__PURE__*/react.createElement("ellipse", {
    fillOpacity: ".8",
    fill: "#F5F5F7",
    cx: "67.797",
    cy: "106.89",
    rx: "67.797",
    ry: "12.668"
  }), /*#__PURE__*/react.createElement("path", {
    d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
    fill: "#AEB8C2"
  }), /*#__PURE__*/react.createElement("path", {
    d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
    fill: "url(#linearGradient-1)",
    transform: "translate(13.56)"
  }), /*#__PURE__*/react.createElement("path", {
    d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
    fill: "#F5F5F7"
  }), /*#__PURE__*/react.createElement("path", {
    d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
    fill: "#DCE0E6"
  })), /*#__PURE__*/react.createElement("path", {
    d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
    fill: "#DCE0E6"
  }), /*#__PURE__*/react.createElement("g", {
    transform: "translate(149.65 15.383)",
    fill: "#FFF"
  }, /*#__PURE__*/react.createElement("ellipse", {
    cx: "20.654",
    cy: "3.167",
    rx: "2.849",
    ry: "2.815"
  }), /*#__PURE__*/react.createElement("path", {
    d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
  }))));
};
if (false) {}
/* harmony default export */ var empty = (Empty);
;// CONCATENATED MODULE: ./node_modules/antd/es/empty/simple.js
"use client";





const Simple = () => {
  const [, token] = (0,useToken/* default */.ZP)();
  const {
    colorFill,
    colorFillTertiary,
    colorFillQuaternary,
    colorBgContainer
  } = token;
  const {
    borderColor,
    shadowColor,
    contentColor
  } = (0,react.useMemo)(() => ({
    borderColor: new dist_module/* TinyColor */.C(colorFill).onBackground(colorBgContainer).toHexShortString(),
    shadowColor: new dist_module/* TinyColor */.C(colorFillTertiary).onBackground(colorBgContainer).toHexShortString(),
    contentColor: new dist_module/* TinyColor */.C(colorFillQuaternary).onBackground(colorBgContainer).toHexShortString()
  }), [colorFill, colorFillTertiary, colorFillQuaternary, colorBgContainer]);
  return /*#__PURE__*/react.createElement("svg", {
    width: "64",
    height: "41",
    viewBox: "0 0 64 41",
    xmlns: "http://www.w3.org/2000/svg"
  }, /*#__PURE__*/react.createElement("g", {
    transform: "translate(0 1)",
    fill: "none",
    fillRule: "evenodd"
  }, /*#__PURE__*/react.createElement("ellipse", {
    fill: shadowColor,
    cx: "32",
    cy: "33",
    rx: "32",
    ry: "7"
  }), /*#__PURE__*/react.createElement("g", {
    fillRule: "nonzero",
    stroke: borderColor
  }, /*#__PURE__*/react.createElement("path", {
    d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
  }), /*#__PURE__*/react.createElement("path", {
    d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
    fill: contentColor
  }))));
};
if (false) {}
/* harmony default export */ var simple = (Simple);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/genComponentStyleHook.js + 6 modules
var genComponentStyleHook = __webpack_require__(92030);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/statistic.js
var statistic = __webpack_require__(45503);
;// CONCATENATED MODULE: ./node_modules/antd/es/empty/style/index.js

// ============================== Shared ==============================
const genSharedEmptyStyle = token => {
  const {
    componentCls,
    margin,
    marginXS,
    marginXL,
    fontSize,
    lineHeight
  } = token;
  return {
    [componentCls]: {
      marginInline: marginXS,
      fontSize,
      lineHeight,
      textAlign: 'center',
      // 原来 &-image 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
      [`${componentCls}-image`]: {
        height: token.emptyImgHeight,
        marginBottom: marginXS,
        opacity: token.opacityImage,
        img: {
          height: '100%'
        },
        svg: {
          maxWidth: '100%',
          height: '100%',
          margin: 'auto'
        }
      },
      [`${componentCls}-description`]: {
        color: token.colorText
      },
      // 原来 &-footer 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
      [`${componentCls}-footer`]: {
        marginTop: margin
      },
      '&-normal': {
        marginBlock: marginXL,
        color: token.colorTextDescription,
        [`${componentCls}-description`]: {
          color: token.colorTextDescription
        },
        [`${componentCls}-image`]: {
          height: token.emptyImgHeightMD
        }
      },
      '&-small': {
        marginBlock: marginXS,
        color: token.colorTextDescription,
        [`${componentCls}-image`]: {
          height: token.emptyImgHeightSM
        }
      }
    }
  };
};
// ============================== Export ==============================
/* harmony default export */ var empty_style = ((0,genComponentStyleHook/* genStyleHooks */.I$)('Empty', token => {
  const {
    componentCls,
    controlHeightLG,
    calc
  } = token;
  const emptyToken = (0,statistic/* merge */.TS)(token, {
    emptyImgCls: `${componentCls}-img`,
    emptyImgHeight: calc(controlHeightLG).mul(2.5).equal(),
    emptyImgHeightMD: controlHeightLG,
    emptyImgHeightSM: calc(controlHeightLG).mul(0.875).equal()
  });
  return [genSharedEmptyStyle(emptyToken)];
}));
;// CONCATENATED MODULE: ./node_modules/antd/es/empty/index.js
"use client";

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};







const defaultEmptyImg = /*#__PURE__*/react.createElement(empty, null);
const simpleEmptyImg = /*#__PURE__*/react.createElement(simple, null);
const empty_Empty = _a => {
  var {
      className,
      rootClassName,
      prefixCls: customizePrefixCls,
      image = defaultEmptyImg,
      description,
      children,
      imageStyle,
      style
    } = _a,
    restProps = __rest(_a, ["className", "rootClassName", "prefixCls", "image", "description", "children", "imageStyle", "style"]);
  const {
    getPrefixCls,
    direction,
    empty
  } = react.useContext(context/* ConfigContext */.E_);
  const prefixCls = getPrefixCls('empty', customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = empty_style(prefixCls);
  const [locale] = (0,useLocale/* default */.Z)('Empty');
  const des = typeof description !== 'undefined' ? description : locale === null || locale === void 0 ? void 0 : locale.description;
  const alt = typeof des === 'string' ? des : 'empty';
  let imageNode = null;
  if (typeof image === 'string') {
    imageNode = /*#__PURE__*/react.createElement("img", {
      alt: alt,
      src: image
    });
  } else {
    imageNode = image;
  }
  return wrapCSSVar( /*#__PURE__*/react.createElement("div", Object.assign({
    className: classnames_default()(hashId, cssVarCls, prefixCls, empty === null || empty === void 0 ? void 0 : empty.className, {
      [`${prefixCls}-normal`]: image === simpleEmptyImg,
      [`${prefixCls}-rtl`]: direction === 'rtl'
    }, className, rootClassName),
    style: Object.assign(Object.assign({}, empty === null || empty === void 0 ? void 0 : empty.style), style)
  }, restProps), /*#__PURE__*/react.createElement("div", {
    className: `${prefixCls}-image`,
    style: imageStyle
  }, imageNode), des && /*#__PURE__*/react.createElement("div", {
    className: `${prefixCls}-description`
  }, des), children && /*#__PURE__*/react.createElement("div", {
    className: `${prefixCls}-footer`
  }, children)));
};
empty_Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
empty_Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
if (false) {}
/* harmony default export */ var es_empty = (empty_Empty);

/***/ }),

/***/ 86250:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: function() { return /* binding */ flex; }
});

// EXTERNAL MODULE: ./node_modules/@umijs/preset-umi/node_modules/react/index.js
var react = __webpack_require__(62435);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(93967);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/rc-util/es/omit.js
var omit = __webpack_require__(98423);
// EXTERNAL MODULE: ./node_modules/antd/es/_util/gapSize.js
var gapSize = __webpack_require__(98065);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/context.js
var context = __webpack_require__(53124);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/genComponentStyleHook.js + 6 modules
var genComponentStyleHook = __webpack_require__(92030);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/statistic.js
var statistic = __webpack_require__(45503);
;// CONCATENATED MODULE: ./node_modules/antd/es/flex/utils.js

const flexWrapValues = ['wrap', 'nowrap', 'wrap-reverse'];
const justifyContentValues = ['flex-start', 'flex-end', 'start', 'end', 'center', 'space-between', 'space-around', 'space-evenly', 'stretch', 'normal', 'left', 'right'];
const alignItemsValues = ['center', 'start', 'end', 'flex-start', 'flex-end', 'self-start', 'self-end', 'baseline', 'normal', 'stretch'];
const genClsWrap = (prefixCls, props) => {
  const wrapCls = {};
  flexWrapValues.forEach(cssKey => {
    wrapCls[`${prefixCls}-wrap-${cssKey}`] = props.wrap === cssKey;
  });
  return wrapCls;
};
const genClsAlign = (prefixCls, props) => {
  const alignCls = {};
  alignItemsValues.forEach(cssKey => {
    alignCls[`${prefixCls}-align-${cssKey}`] = props.align === cssKey;
  });
  alignCls[`${prefixCls}-align-stretch`] = !props.align && !!props.vertical;
  return alignCls;
};
const genClsJustify = (prefixCls, props) => {
  const justifyCls = {};
  justifyContentValues.forEach(cssKey => {
    justifyCls[`${prefixCls}-justify-${cssKey}`] = props.justify === cssKey;
  });
  return justifyCls;
};
function createFlexClassNames(prefixCls, props) {
  return classnames_default()(Object.assign(Object.assign(Object.assign({}, genClsWrap(prefixCls, props)), genClsAlign(prefixCls, props)), genClsJustify(prefixCls, props)));
}
/* harmony default export */ var utils = (createFlexClassNames);
;// CONCATENATED MODULE: ./node_modules/antd/es/flex/style/index.js


const genFlexStyle = token => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: {
      display: 'flex',
      '&-vertical': {
        flexDirection: 'column'
      },
      '&-rtl': {
        direction: 'rtl'
      },
      '&:empty': {
        display: 'none'
      }
    }
  };
};
const genFlexGapStyle = token => {
  const {
    componentCls
  } = token;
  return {
    [componentCls]: {
      '&-gap-small': {
        gap: token.flexGapSM
      },
      '&-gap-middle': {
        gap: token.flexGap
      },
      '&-gap-large': {
        gap: token.flexGapLG
      }
    }
  };
};
const genFlexWrapStyle = token => {
  const {
    componentCls
  } = token;
  const wrapStyle = {};
  flexWrapValues.forEach(value => {
    wrapStyle[`${componentCls}-wrap-${value}`] = {
      flexWrap: value
    };
  });
  return wrapStyle;
};
const genAlignItemsStyle = token => {
  const {
    componentCls
  } = token;
  const alignStyle = {};
  alignItemsValues.forEach(value => {
    alignStyle[`${componentCls}-align-${value}`] = {
      alignItems: value
    };
  });
  return alignStyle;
};
const genJustifyContentStyle = token => {
  const {
    componentCls
  } = token;
  const justifyStyle = {};
  justifyContentValues.forEach(value => {
    justifyStyle[`${componentCls}-justify-${value}`] = {
      justifyContent: value
    };
  });
  return justifyStyle;
};
const prepareComponentToken = () => ({});
/* harmony default export */ var flex_style = ((0,genComponentStyleHook/* genStyleHooks */.I$)('Flex', token => {
  const {
    paddingXS,
    padding,
    paddingLG
  } = token;
  const flexToken = (0,statistic/* merge */.TS)(token, {
    flexGapSM: paddingXS,
    flexGap: padding,
    flexGapLG: paddingLG
  });
  return [genFlexStyle(flexToken), genFlexGapStyle(flexToken), genFlexWrapStyle(flexToken), genAlignItemsStyle(flexToken), genJustifyContentStyle(flexToken)];
}, prepareComponentToken, {
  // Flex component don't apply extra font style
  // https://github.com/ant-design/ant-design/issues/46403
  resetStyle: false
}));
;// CONCATENATED MODULE: ./node_modules/antd/es/flex/index.js
"use client";

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};







const Flex = /*#__PURE__*/react.forwardRef((props, ref) => {
  const {
      prefixCls: customizePrefixCls,
      rootClassName,
      className,
      style,
      flex,
      gap,
      children,
      vertical = false,
      component: Component = 'div'
    } = props,
    othersProps = __rest(props, ["prefixCls", "rootClassName", "className", "style", "flex", "gap", "children", "vertical", "component"]);
  const {
    flex: ctxFlex,
    direction: ctxDirection,
    getPrefixCls
  } = react.useContext(context/* ConfigContext */.E_);
  const prefixCls = getPrefixCls('flex', customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = flex_style(prefixCls);
  const mergedVertical = vertical !== null && vertical !== void 0 ? vertical : ctxFlex === null || ctxFlex === void 0 ? void 0 : ctxFlex.vertical;
  const mergedCls = classnames_default()(className, rootClassName, ctxFlex === null || ctxFlex === void 0 ? void 0 : ctxFlex.className, prefixCls, hashId, cssVarCls, utils(prefixCls, props), {
    [`${prefixCls}-rtl`]: ctxDirection === 'rtl',
    [`${prefixCls}-gap-${gap}`]: (0,gapSize/* isPresetSize */.n)(gap),
    [`${prefixCls}-vertical`]: mergedVertical
  });
  const mergedStyle = Object.assign(Object.assign({}, ctxFlex === null || ctxFlex === void 0 ? void 0 : ctxFlex.style), style);
  if (flex) {
    mergedStyle.flex = flex;
  }
  if (gap && !(0,gapSize/* isPresetSize */.n)(gap)) {
    mergedStyle.gap = gap;
  }
  return wrapCSSVar( /*#__PURE__*/react.createElement(Component, Object.assign({
    ref: ref,
    className: mergedCls,
    style: mergedStyle
  }, (0,omit/* default */.Z)(othersProps, ['justify', 'wrap', 'align'])), children));
});
if (false) {}
/* harmony default export */ var flex = (Flex);

/***/ }),

/***/ 27833:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Variants */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62435);
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52706);


const Variants = ['outlined', 'borderless', 'filled'];
/**
 * Compatible for legacy `bordered` prop.
 */
const useVariant = function (variant) {
  let legacyBordered = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  const ctxVariant = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_context__WEBPACK_IMPORTED_MODULE_1__/* .VariantContext */ .pg);
  let mergedVariant;
  if (typeof variant !== 'undefined') {
    mergedVariant = variant;
  } else if (legacyBordered === false) {
    mergedVariant = 'borderless';
  } else {
    mergedVariant = ctxVariant !== null && ctxVariant !== void 0 ? ctxVariant : 'outlined';
  }
  const enableVariantCls = Variants.includes(mergedVariant);
  return [mergedVariant, enableVariantCls];
};
/* harmony default export */ __webpack_exports__.Z = (useVariant);

/***/ }),

/***/ 10418:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: function() { return /* binding */ input_number; }
});

// EXTERNAL MODULE: ./node_modules/@umijs/preset-umi/node_modules/react/index.js
var react = __webpack_require__(62435);
// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/DownOutlined.js + 1 modules
var DownOutlined = __webpack_require__(80882);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(87462);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons-svg/es/asn/UpOutlined.js
// This icon file is generated automatically.
var UpOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M890.5 755.3L537.9 269.2c-12.8-17.6-39-17.6-51.7 0L133.5 755.3A8 8 0 00140 768h75c5.1 0 9.9-2.5 12.9-6.6L512 369.8l284.1 391.6c3 4.1 7.8 6.6 12.9 6.6h75c6.5 0 10.3-7.4 6.5-12.7z" } }] }, "name": "up", "theme": "outlined" };
/* harmony default export */ var asn_UpOutlined = (UpOutlined);

// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/components/AntdIcon.js + 3 modules
var AntdIcon = __webpack_require__(42135);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons/es/icons/UpOutlined.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY




var UpOutlined_UpOutlined = function UpOutlined(props, ref) {
  return /*#__PURE__*/react.createElement(AntdIcon/* default */.Z, (0,esm_extends/* default */.Z)({}, props, {
    ref: ref,
    icon: asn_UpOutlined
  }));
};

/**![up](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg5MC41IDc1NS4zTDUzNy45IDI2OS4yYy0xMi44LTE3LjYtMzktMTcuNi01MS43IDBMMTMzLjUgNzU1LjNBOCA4IDAgMDAxNDAgNzY4aDc1YzUuMSAwIDkuOS0yLjUgMTIuOS02LjZMNTEyIDM2OS44bDI4NC4xIDM5MS42YzMgNC4xIDcuOCA2LjYgMTIuOSA2LjZoNzVjNi41IDAgMTAuMy03LjQgNi41LTEyLjd6IiAvPjwvc3ZnPg==) */
var RefIcon = /*#__PURE__*/react.forwardRef(UpOutlined_UpOutlined);
if (false) {}
/* harmony default export */ var icons_UpOutlined = (RefIcon);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(93967);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(4942);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__(71002);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js + 1 modules
var slicedToArray = __webpack_require__(97685);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js + 1 modules
var objectWithoutProperties = __webpack_require__(91);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
var classCallCheck = __webpack_require__(15671);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
var createClass = __webpack_require__(43144);
;// CONCATENATED MODULE: ./node_modules/@rc-component/mini-decimal/es/supportUtil.js
function supportBigInt() {
  return typeof BigInt === 'function';
}
;// CONCATENATED MODULE: ./node_modules/@rc-component/mini-decimal/es/numberUtil.js

function isEmpty(value) {
  return !value && value !== 0 && !Number.isNaN(value) || !String(value).trim();
}

/**
 * Format string number to readable number
 */
function trimNumber(numStr) {
  var str = numStr.trim();
  var negative = str.startsWith('-');
  if (negative) {
    str = str.slice(1);
  }
  str = str
  // Remove decimal 0. `1.000` => `1.`, `1.100` => `1.1`
  .replace(/(\.\d*[^0])0*$/, '$1')
  // Remove useless decimal. `1.` => `1`
  .replace(/\.0*$/, '')
  // Remove integer 0. `0001` => `1`, 000.1' => `.1`
  .replace(/^0+/, '');
  if (str.startsWith('.')) {
    str = "0".concat(str);
  }
  var trimStr = str || '0';
  var splitNumber = trimStr.split('.');
  var integerStr = splitNumber[0] || '0';
  var decimalStr = splitNumber[1] || '0';
  if (integerStr === '0' && decimalStr === '0') {
    negative = false;
  }
  var negativeStr = negative ? '-' : '';
  return {
    negative: negative,
    negativeStr: negativeStr,
    trimStr: trimStr,
    integerStr: integerStr,
    decimalStr: decimalStr,
    fullStr: "".concat(negativeStr).concat(trimStr)
  };
}
function isE(number) {
  var str = String(number);
  return !Number.isNaN(Number(str)) && str.includes('e');
}

/**
 * [Legacy] Convert 1e-9 to 0.000000001.
 * This may lose some precision if user really want 1e-9.
 */
function getNumberPrecision(number) {
  var numStr = String(number);
  if (isE(number)) {
    var precision = Number(numStr.slice(numStr.indexOf('e-') + 2));
    var decimalMatch = numStr.match(/\.(\d+)/);
    if (decimalMatch !== null && decimalMatch !== void 0 && decimalMatch[1]) {
      precision += decimalMatch[1].length;
    }
    return precision;
  }
  return numStr.includes('.') && validateNumber(numStr) ? numStr.length - numStr.indexOf('.') - 1 : 0;
}

/**
 * Convert number (includes scientific notation) to -xxx.yyy format
 */
function num2str(number) {
  var numStr = String(number);
  if (isE(number)) {
    if (number > Number.MAX_SAFE_INTEGER) {
      return String(supportBigInt() ? BigInt(number).toString() : Number.MAX_SAFE_INTEGER);
    }
    if (number < Number.MIN_SAFE_INTEGER) {
      return String(supportBigInt() ? BigInt(number).toString() : Number.MIN_SAFE_INTEGER);
    }
    numStr = number.toFixed(getNumberPrecision(numStr));
  }
  return trimNumber(numStr).fullStr;
}
function validateNumber(num) {
  if (typeof num === 'number') {
    return !Number.isNaN(num);
  }

  // Empty
  if (!num) {
    return false;
  }
  return (
    // Normal type: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(num) ||
    // Pre-number: 1.
    /^\s*-?\d+\.\s*$/.test(num) ||
    // Post-number: .1
    /^\s*-?\.\d+\s*$/.test(num)
  );
}
;// CONCATENATED MODULE: ./node_modules/@rc-component/mini-decimal/es/BigIntDecimal.js




var BigIntDecimal = /*#__PURE__*/function () {
  /** BigInt will convert `0009` to `9`. We need record the len of decimal */

  function BigIntDecimal(value) {
    (0,classCallCheck/* default */.Z)(this, BigIntDecimal);
    (0,defineProperty/* default */.Z)(this, "origin", '');
    (0,defineProperty/* default */.Z)(this, "negative", void 0);
    (0,defineProperty/* default */.Z)(this, "integer", void 0);
    (0,defineProperty/* default */.Z)(this, "decimal", void 0);
    (0,defineProperty/* default */.Z)(this, "decimalLen", void 0);
    (0,defineProperty/* default */.Z)(this, "empty", void 0);
    (0,defineProperty/* default */.Z)(this, "nan", void 0);
    if (isEmpty(value)) {
      this.empty = true;
      return;
    }
    this.origin = String(value);

    // Act like Number convert
    if (value === '-' || Number.isNaN(value)) {
      this.nan = true;
      return;
    }
    var mergedValue = value;

    // We need convert back to Number since it require `toFixed` to handle this
    if (isE(mergedValue)) {
      mergedValue = Number(mergedValue);
    }
    mergedValue = typeof mergedValue === 'string' ? mergedValue : num2str(mergedValue);
    if (validateNumber(mergedValue)) {
      var trimRet = trimNumber(mergedValue);
      this.negative = trimRet.negative;
      var numbers = trimRet.trimStr.split('.');
      this.integer = BigInt(numbers[0]);
      var decimalStr = numbers[1] || '0';
      this.decimal = BigInt(decimalStr);
      this.decimalLen = decimalStr.length;
    } else {
      this.nan = true;
    }
  }
  (0,createClass/* default */.Z)(BigIntDecimal, [{
    key: "getMark",
    value: function getMark() {
      return this.negative ? '-' : '';
    }
  }, {
    key: "getIntegerStr",
    value: function getIntegerStr() {
      return this.integer.toString();
    }

    /**
     * @private get decimal string
     */
  }, {
    key: "getDecimalStr",
    value: function getDecimalStr() {
      return this.decimal.toString().padStart(this.decimalLen, '0');
    }

    /**
     * @private Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000
     * This is used for add function only.
     */
  }, {
    key: "alignDecimal",
    value: function alignDecimal(decimalLength) {
      var str = "".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr().padEnd(decimalLength, '0'));
      return BigInt(str);
    }
  }, {
    key: "negate",
    value: function negate() {
      var clone = new BigIntDecimal(this.toString());
      clone.negative = !clone.negative;
      return clone;
    }
  }, {
    key: "cal",
    value: function cal(offset, calculator, calDecimalLen) {
      var maxDecimalLength = Math.max(this.getDecimalStr().length, offset.getDecimalStr().length);
      var myAlignedDecimal = this.alignDecimal(maxDecimalLength);
      var offsetAlignedDecimal = offset.alignDecimal(maxDecimalLength);
      var valueStr = calculator(myAlignedDecimal, offsetAlignedDecimal).toString();
      var nextDecimalLength = calDecimalLen(maxDecimalLength);

      // We need fill string length back to `maxDecimalLength` to avoid parser failed
      var _trimNumber = trimNumber(valueStr),
        negativeStr = _trimNumber.negativeStr,
        trimStr = _trimNumber.trimStr;
      var hydrateValueStr = "".concat(negativeStr).concat(trimStr.padStart(nextDecimalLength + 1, '0'));
      return new BigIntDecimal("".concat(hydrateValueStr.slice(0, -nextDecimalLength), ".").concat(hydrateValueStr.slice(-nextDecimalLength)));
    }
  }, {
    key: "add",
    value: function add(value) {
      if (this.isInvalidate()) {
        return new BigIntDecimal(value);
      }
      var offset = new BigIntDecimal(value);
      if (offset.isInvalidate()) {
        return this;
      }
      return this.cal(offset, function (num1, num2) {
        return num1 + num2;
      }, function (len) {
        return len;
      });
    }
  }, {
    key: "multi",
    value: function multi(value) {
      var target = new BigIntDecimal(value);
      if (this.isInvalidate() || target.isInvalidate()) {
        return new BigIntDecimal(NaN);
      }
      return this.cal(target, function (num1, num2) {
        return num1 * num2;
      }, function (len) {
        return len * 2;
      });
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.empty;
    }
  }, {
    key: "isNaN",
    value: function isNaN() {
      return this.nan;
    }
  }, {
    key: "isInvalidate",
    value: function isInvalidate() {
      return this.isEmpty() || this.isNaN();
    }
  }, {
    key: "equals",
    value: function equals(target) {
      return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());
    }
  }, {
    key: "lessEquals",
    value: function lessEquals(target) {
      return this.add(target.negate().toString()).toNumber() <= 0;
    }
  }, {
    key: "toNumber",
    value: function toNumber() {
      if (this.isNaN()) {
        return NaN;
      }
      return Number(this.toString());
    }
  }, {
    key: "toString",
    value: function toString() {
      var safe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (!safe) {
        return this.origin;
      }
      if (this.isInvalidate()) {
        return '';
      }
      return trimNumber("".concat(this.getMark()).concat(this.getIntegerStr(), ".").concat(this.getDecimalStr())).fullStr;
    }
  }]);
  return BigIntDecimal;
}();

;// CONCATENATED MODULE: ./node_modules/@rc-component/mini-decimal/es/NumberDecimal.js





/**
 * We can remove this when IE not support anymore
 */
var NumberDecimal = /*#__PURE__*/function () {
  function NumberDecimal(value) {
    (0,classCallCheck/* default */.Z)(this, NumberDecimal);
    (0,defineProperty/* default */.Z)(this, "origin", '');
    (0,defineProperty/* default */.Z)(this, "number", void 0);
    (0,defineProperty/* default */.Z)(this, "empty", void 0);
    if (isEmpty(value)) {
      this.empty = true;
      return;
    }
    this.origin = String(value);
    this.number = Number(value);
  }
  (0,createClass/* default */.Z)(NumberDecimal, [{
    key: "negate",
    value: function negate() {
      return new NumberDecimal(-this.toNumber());
    }
  }, {
    key: "add",
    value: function add(value) {
      if (this.isInvalidate()) {
        return new NumberDecimal(value);
      }
      var target = Number(value);
      if (Number.isNaN(target)) {
        return this;
      }
      var number = this.number + target;

      // [Legacy] Back to safe integer
      if (number > Number.MAX_SAFE_INTEGER) {
        return new NumberDecimal(Number.MAX_SAFE_INTEGER);
      }
      if (number < Number.MIN_SAFE_INTEGER) {
        return new NumberDecimal(Number.MIN_SAFE_INTEGER);
      }
      var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
      return new NumberDecimal(number.toFixed(maxPrecision));
    }
  }, {
    key: "multi",
    value: function multi(value) {
      var target = Number(value);
      if (this.isInvalidate() || Number.isNaN(target)) {
        return new NumberDecimal(NaN);
      }
      var number = this.number * target;

      // [Legacy] Back to safe integer
      if (number > Number.MAX_SAFE_INTEGER) {
        return new NumberDecimal(Number.MAX_SAFE_INTEGER);
      }
      if (number < Number.MIN_SAFE_INTEGER) {
        return new NumberDecimal(Number.MIN_SAFE_INTEGER);
      }
      var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
      return new NumberDecimal(number.toFixed(maxPrecision));
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.empty;
    }
  }, {
    key: "isNaN",
    value: function isNaN() {
      return Number.isNaN(this.number);
    }
  }, {
    key: "isInvalidate",
    value: function isInvalidate() {
      return this.isEmpty() || this.isNaN();
    }
  }, {
    key: "equals",
    value: function equals(target) {
      return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());
    }
  }, {
    key: "lessEquals",
    value: function lessEquals(target) {
      return this.add(target.negate().toString()).toNumber() <= 0;
    }
  }, {
    key: "toNumber",
    value: function toNumber() {
      return this.number;
    }
  }, {
    key: "toString",
    value: function toString() {
      var safe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (!safe) {
        return this.origin;
      }
      if (this.isInvalidate()) {
        return '';
      }
      return num2str(this.number);
    }
  }]);
  return NumberDecimal;
}();

;// CONCATENATED MODULE: ./node_modules/@rc-component/mini-decimal/es/MiniDecimal.js
/* eslint-disable max-classes-per-file */






// Still support origin export

function getMiniDecimal(value) {
  // We use BigInt here.
  // Will fallback to Number if not support.
  if (supportBigInt()) {
    return new BigIntDecimal(value);
  }
  return new NumberDecimal(value);
}

/**
 * Align the logic of toFixed to around like 1.5 => 2.
 * If set `cutOnly`, will just remove the over decimal part.
 */
function toFixed(numStr, separatorStr, precision) {
  var cutOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  if (numStr === '') {
    return '';
  }
  var _trimNumber = trimNumber(numStr),
    negativeStr = _trimNumber.negativeStr,
    integerStr = _trimNumber.integerStr,
    decimalStr = _trimNumber.decimalStr;
  var precisionDecimalStr = "".concat(separatorStr).concat(decimalStr);
  var numberWithoutDecimal = "".concat(negativeStr).concat(integerStr);
  if (precision >= 0) {
    // We will get last + 1 number to check if need advanced number
    var advancedNum = Number(decimalStr[precision]);
    if (advancedNum >= 5 && !cutOnly) {
      var advancedDecimal = getMiniDecimal(numStr).add("".concat(negativeStr, "0.").concat('0'.repeat(precision)).concat(10 - advancedNum));
      return toFixed(advancedDecimal.toString(), separatorStr, precision, cutOnly);
    }
    if (precision === 0) {
      return numberWithoutDecimal;
    }
    return "".concat(numberWithoutDecimal).concat(separatorStr).concat(decimalStr.padEnd(precision, '0').slice(0, precision));
  }
  if (precisionDecimalStr === '.0') {
    return numberWithoutDecimal;
  }
  return "".concat(numberWithoutDecimal).concat(precisionDecimalStr);
}
;// CONCATENATED MODULE: ./node_modules/@rc-component/mini-decimal/es/index.js




/* harmony default export */ var es = (getMiniDecimal);
// EXTERNAL MODULE: ./node_modules/rc-input/es/index.js + 2 modules
var rc_input_es = __webpack_require__(67656);
// EXTERNAL MODULE: ./node_modules/rc-util/es/hooks/useLayoutEffect.js
var useLayoutEffect = __webpack_require__(8410);
// EXTERNAL MODULE: ./node_modules/rc-util/es/ref.js
var es_ref = __webpack_require__(42550);
// EXTERNAL MODULE: ./node_modules/rc-util/es/warning.js
var warning = __webpack_require__(80334);
;// CONCATENATED MODULE: ./node_modules/rc-input-number/es/hooks/useCursor.js


/**
 * Keep input cursor in the correct position if possible.
 * Is this necessary since we have `formatter` which may mass the content?
 */
function useCursor(input, focused) {
  var selectionRef = (0,react.useRef)(null);
  function recordCursor() {
    // Record position
    try {
      var start = input.selectionStart,
        end = input.selectionEnd,
        value = input.value;
      var beforeTxt = value.substring(0, start);
      var afterTxt = value.substring(end);
      selectionRef.current = {
        start: start,
        end: end,
        value: value,
        beforeTxt: beforeTxt,
        afterTxt: afterTxt
      };
    } catch (e) {
      // Fix error in Chrome:
      // Failed to read the 'selectionStart' property from 'HTMLInputElement'
      // http://stackoverflow.com/q/21177489/3040605
    }
  }

  /**
   * Restore logic:
   *  1. back string same
   *  2. start string same
   */
  function restoreCursor() {
    if (input && selectionRef.current && focused) {
      try {
        var value = input.value;
        var _selectionRef$current = selectionRef.current,
          beforeTxt = _selectionRef$current.beforeTxt,
          afterTxt = _selectionRef$current.afterTxt,
          start = _selectionRef$current.start;
        var startPos = value.length;
        if (value.endsWith(afterTxt)) {
          startPos = value.length - selectionRef.current.afterTxt.length;
        } else if (value.startsWith(beforeTxt)) {
          startPos = beforeTxt.length;
        } else {
          var beforeLastChar = beforeTxt[start - 1];
          var newIndex = value.indexOf(beforeLastChar, start - 1);
          if (newIndex !== -1) {
            startPos = newIndex + 1;
          }
        }
        input.setSelectionRange(startPos, startPos);
      } catch (e) {
        (0,warning/* default */.ZP)(false, "Something warning of cursor restore. Please fire issue about this: ".concat(e.message));
      }
    }
  }
  return [recordCursor, restoreCursor];
}
// EXTERNAL MODULE: ./node_modules/rc-util/es/isMobile.js
var isMobile = __webpack_require__(31131);
;// CONCATENATED MODULE: ./node_modules/rc-util/es/hooks/useMobile.js





/**
 * Hook to detect if the user is on a mobile device
 * Notice that this hook will only detect the device type in effect, so it will always be false in server side
 */
var useMobile = function useMobile() {
  var _useState = (0,react.useState)(false),
    _useState2 = (0,slicedToArray/* default */.Z)(_useState, 2),
    mobile = _useState2[0],
    setMobile = _useState2[1];
  (0,useLayoutEffect/* default */.Z)(function () {
    setMobile((0,isMobile/* default */.Z)());
  }, []);
  return mobile;
};
/* harmony default export */ var hooks_useMobile = (useMobile);
// EXTERNAL MODULE: ./node_modules/rc-util/es/raf.js
var raf = __webpack_require__(75164);
;// CONCATENATED MODULE: ./node_modules/rc-input-number/es/StepHandler.js


/* eslint-disable react/no-unknown-property */





/**
 * When click and hold on a button - the speed of auto changing the value.
 */
var STEP_INTERVAL = 200;

/**
 * When click and hold on a button - the delay before auto changing the value.
 */
var STEP_DELAY = 600;
function StepHandler(_ref) {
  var prefixCls = _ref.prefixCls,
    upNode = _ref.upNode,
    downNode = _ref.downNode,
    upDisabled = _ref.upDisabled,
    downDisabled = _ref.downDisabled,
    onStep = _ref.onStep;
  // ======================== Step ========================
  var stepTimeoutRef = react.useRef();
  var frameIds = react.useRef([]);
  var onStepRef = react.useRef();
  onStepRef.current = onStep;
  var onStopStep = function onStopStep() {
    clearTimeout(stepTimeoutRef.current);
  };

  // We will interval update step when hold mouse down
  var onStepMouseDown = function onStepMouseDown(e, up) {
    e.preventDefault();
    onStopStep();
    onStepRef.current(up);

    // Loop step for interval
    function loopStep() {
      onStepRef.current(up);
      stepTimeoutRef.current = setTimeout(loopStep, STEP_INTERVAL);
    }

    // First time press will wait some time to trigger loop step update
    stepTimeoutRef.current = setTimeout(loopStep, STEP_DELAY);
  };
  react.useEffect(function () {
    return function () {
      onStopStep();
      frameIds.current.forEach(function (id) {
        return raf/* default */.Z.cancel(id);
      });
    };
  }, []);

  // ======================= Render =======================
  var isMobile = hooks_useMobile();
  if (isMobile) {
    return null;
  }
  var handlerClassName = "".concat(prefixCls, "-handler");
  var upClassName = classnames_default()(handlerClassName, "".concat(handlerClassName, "-up"), (0,defineProperty/* default */.Z)({}, "".concat(handlerClassName, "-up-disabled"), upDisabled));
  var downClassName = classnames_default()(handlerClassName, "".concat(handlerClassName, "-down"), (0,defineProperty/* default */.Z)({}, "".concat(handlerClassName, "-down-disabled"), downDisabled));

  // fix: https://github.com/ant-design/ant-design/issues/43088
  // In Safari, When we fire onmousedown and onmouseup events in quick succession, 
  // there may be a problem that the onmouseup events are executed first, 
  // resulting in a disordered program execution.
  // So, we need to use requestAnimationFrame to ensure that the onmouseup event is executed after the onmousedown event.
  var safeOnStopStep = function safeOnStopStep() {
    return frameIds.current.push((0,raf/* default */.Z)(onStopStep));
  };
  var sharedHandlerProps = {
    unselectable: 'on',
    role: 'button',
    onMouseUp: safeOnStopStep,
    onMouseLeave: safeOnStopStep
  };
  return /*#__PURE__*/react.createElement("div", {
    className: "".concat(handlerClassName, "-wrap")
  }, /*#__PURE__*/react.createElement("span", (0,esm_extends/* default */.Z)({}, sharedHandlerProps, {
    onMouseDown: function onMouseDown(e) {
      onStepMouseDown(e, true);
    },
    "aria-label": "Increase Value",
    "aria-disabled": upDisabled,
    className: upClassName
  }), upNode || /*#__PURE__*/react.createElement("span", {
    unselectable: "on",
    className: "".concat(prefixCls, "-handler-up-inner")
  })), /*#__PURE__*/react.createElement("span", (0,esm_extends/* default */.Z)({}, sharedHandlerProps, {
    onMouseDown: function onMouseDown(e) {
      onStepMouseDown(e, false);
    },
    "aria-label": "Decrease Value",
    "aria-disabled": downDisabled,
    className: downClassName
  }), downNode || /*#__PURE__*/react.createElement("span", {
    unselectable: "on",
    className: "".concat(prefixCls, "-handler-down-inner")
  })));
}
;// CONCATENATED MODULE: ./node_modules/rc-input-number/es/utils/numberUtil.js

function getDecupleSteps(step) {
  var stepStr = typeof step === 'number' ? num2str(step) : trimNumber(step).fullStr;
  var hasPoint = stepStr.includes('.');
  if (!hasPoint) {
    return step + '0';
  }
  return trimNumber(stepStr.replace(/(\d)\.(\d)/g, '$1$2.')).fullStr;
}
// EXTERNAL MODULE: ./node_modules/rc-input/es/utils/commonUtils.js
var commonUtils = __webpack_require__(87887);
;// CONCATENATED MODULE: ./node_modules/rc-input-number/es/hooks/useFrame.js



/**
 * Always trigger latest once when call multiple time
 */
/* harmony default export */ var useFrame = (function () {
  var idRef = (0,react.useRef)(0);
  var cleanUp = function cleanUp() {
    raf/* default */.Z.cancel(idRef.current);
  };
  (0,react.useEffect)(function () {
    return cleanUp;
  }, []);
  return function (callback) {
    cleanUp();
    idRef.current = (0,raf/* default */.Z)(function () {
      callback();
    });
  };
});
;// CONCATENATED MODULE: ./node_modules/rc-input-number/es/InputNumber.js





var _excluded = ["prefixCls", "className", "style", "min", "max", "step", "defaultValue", "value", "disabled", "readOnly", "upHandler", "downHandler", "keyboard", "changeOnWheel", "controls", "classNames", "stringMode", "parser", "formatter", "precision", "decimalSeparator", "onChange", "onInput", "onPressEnter", "onStep", "changeOnBlur"],
  _excluded2 = ["disabled", "style", "prefixCls", "value", "prefix", "suffix", "addonBefore", "addonAfter", "className", "classNames"];











/**
 * We support `stringMode` which need handle correct type when user call in onChange
 * format max or min value
 * 1. if isInvalid return null
 * 2. if precision is undefined, return decimal
 * 3. format with precision
 *    I. if max > 0, round down with precision. Example: max= 3.5, precision=0  afterFormat: 3
 *    II. if max < 0, round up with precision. Example: max= -3.5, precision=0  afterFormat: -4
 *    III. if min > 0, round up with precision. Example: min= 3.5, precision=0  afterFormat: 4
 *    IV. if min < 0, round down with precision. Example: max= -3.5, precision=0  afterFormat: -3
 */
var getDecimalValue = function getDecimalValue(stringMode, decimalValue) {
  if (stringMode || decimalValue.isEmpty()) {
    return decimalValue.toString();
  }
  return decimalValue.toNumber();
};
var getDecimalIfValidate = function getDecimalIfValidate(value) {
  var decimal = es(value);
  return decimal.isInvalidate() ? null : decimal;
};
var InternalInputNumber = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var _clsx;
  var _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-input-number' : _props$prefixCls,
    className = props.className,
    style = props.style,
    min = props.min,
    max = props.max,
    _props$step = props.step,
    step = _props$step === void 0 ? 1 : _props$step,
    defaultValue = props.defaultValue,
    value = props.value,
    disabled = props.disabled,
    readOnly = props.readOnly,
    upHandler = props.upHandler,
    downHandler = props.downHandler,
    keyboard = props.keyboard,
    _props$changeOnWheel = props.changeOnWheel,
    changeOnWheel = _props$changeOnWheel === void 0 ? false : _props$changeOnWheel,
    _props$controls = props.controls,
    controls = _props$controls === void 0 ? true : _props$controls,
    classNames = props.classNames,
    stringMode = props.stringMode,
    parser = props.parser,
    formatter = props.formatter,
    precision = props.precision,
    decimalSeparator = props.decimalSeparator,
    onChange = props.onChange,
    onInput = props.onInput,
    onPressEnter = props.onPressEnter,
    onStep = props.onStep,
    _props$changeOnBlur = props.changeOnBlur,
    changeOnBlur = _props$changeOnBlur === void 0 ? true : _props$changeOnBlur,
    inputProps = (0,objectWithoutProperties/* default */.Z)(props, _excluded);
  var inputClassName = "".concat(prefixCls, "-input");
  var inputRef = react.useRef(null);
  var _React$useState = react.useState(false),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    focus = _React$useState2[0],
    setFocus = _React$useState2[1];
  var userTypingRef = react.useRef(false);
  var compositionRef = react.useRef(false);
  var shiftKeyRef = react.useRef(false);

  // ============================ Value =============================
  // Real value control
  var _React$useState3 = react.useState(function () {
      return es(value !== null && value !== void 0 ? value : defaultValue);
    }),
    _React$useState4 = (0,slicedToArray/* default */.Z)(_React$useState3, 2),
    decimalValue = _React$useState4[0],
    setDecimalValue = _React$useState4[1];
  function setUncontrolledDecimalValue(newDecimal) {
    if (value === undefined) {
      setDecimalValue(newDecimal);
    }
  }

  // ====================== Parser & Formatter ======================
  /**
   * `precision` is used for formatter & onChange.
   * It will auto generate by `value` & `step`.
   * But it will not block user typing.
   *
   * Note: Auto generate `precision` is used for legacy logic.
   * We should remove this since we already support high precision with BigInt.
   *
   * @param number  Provide which number should calculate precision
   * @param userTyping  Change by user typing
   */
  var getPrecision = react.useCallback(function (numStr, userTyping) {
    if (userTyping) {
      return undefined;
    }
    if (precision >= 0) {
      return precision;
    }
    return Math.max(getNumberPrecision(numStr), getNumberPrecision(step));
  }, [precision, step]);

  // >>> Parser
  var mergedParser = react.useCallback(function (num) {
    var numStr = String(num);
    if (parser) {
      return parser(numStr);
    }
    var parsedStr = numStr;
    if (decimalSeparator) {
      parsedStr = parsedStr.replace(decimalSeparator, '.');
    }

    // [Legacy] We still support auto convert `$ 123,456` to `123456`
    return parsedStr.replace(/[^\w.-]+/g, '');
  }, [parser, decimalSeparator]);

  // >>> Formatter
  var inputValueRef = react.useRef('');
  var mergedFormatter = react.useCallback(function (number, userTyping) {
    if (formatter) {
      return formatter(number, {
        userTyping: userTyping,
        input: String(inputValueRef.current)
      });
    }
    var str = typeof number === 'number' ? num2str(number) : number;

    // User typing will not auto format with precision directly
    if (!userTyping) {
      var mergedPrecision = getPrecision(str, userTyping);
      if (validateNumber(str) && (decimalSeparator || mergedPrecision >= 0)) {
        // Separator
        var separatorStr = decimalSeparator || '.';
        str = toFixed(str, separatorStr, mergedPrecision);
      }
    }
    return str;
  }, [formatter, getPrecision, decimalSeparator]);

  // ========================== InputValue ==========================
  /**
   * Input text value control
   *
   * User can not update input content directly. It updates with follow rules by priority:
   *  1. controlled `value` changed
   *    * [SPECIAL] Typing like `1.` should not immediately convert to `1`
   *  2. User typing with format (not precision)
   *  3. Blur or Enter trigger revalidate
   */
  var _React$useState5 = react.useState(function () {
      var initValue = defaultValue !== null && defaultValue !== void 0 ? defaultValue : value;
      if (decimalValue.isInvalidate() && ['string', 'number'].includes((0,esm_typeof/* default */.Z)(initValue))) {
        return Number.isNaN(initValue) ? '' : initValue;
      }
      return mergedFormatter(decimalValue.toString(), false);
    }),
    _React$useState6 = (0,slicedToArray/* default */.Z)(_React$useState5, 2),
    inputValue = _React$useState6[0],
    setInternalInputValue = _React$useState6[1];
  inputValueRef.current = inputValue;

  // Should always be string
  function setInputValue(newValue, userTyping) {
    setInternalInputValue(mergedFormatter(
    // Invalidate number is sometime passed by external control, we should let it go
    // Otherwise is controlled by internal interactive logic which check by userTyping
    // You can ref 'show limited value when input is not focused' test for more info.
    newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping), userTyping));
  }

  // >>> Max & Min limit
  var maxDecimal = react.useMemo(function () {
    return getDecimalIfValidate(max);
  }, [max, precision]);
  var minDecimal = react.useMemo(function () {
    return getDecimalIfValidate(min);
  }, [min, precision]);
  var upDisabled = react.useMemo(function () {
    if (!maxDecimal || !decimalValue || decimalValue.isInvalidate()) {
      return false;
    }
    return maxDecimal.lessEquals(decimalValue);
  }, [maxDecimal, decimalValue]);
  var downDisabled = react.useMemo(function () {
    if (!minDecimal || !decimalValue || decimalValue.isInvalidate()) {
      return false;
    }
    return decimalValue.lessEquals(minDecimal);
  }, [minDecimal, decimalValue]);

  // Cursor controller
  var _useCursor = useCursor(inputRef.current, focus),
    _useCursor2 = (0,slicedToArray/* default */.Z)(_useCursor, 2),
    recordCursor = _useCursor2[0],
    restoreCursor = _useCursor2[1];

  // ============================= Data =============================
  /**
   * Find target value closet within range.
   * e.g. [11, 28]:
   *    3  => 11
   *    23 => 23
   *    99 => 28
   */
  var getRangeValue = function getRangeValue(target) {
    // target > max
    if (maxDecimal && !target.lessEquals(maxDecimal)) {
      return maxDecimal;
    }

    // target < min
    if (minDecimal && !minDecimal.lessEquals(target)) {
      return minDecimal;
    }
    return null;
  };

  /**
   * Check value is in [min, max] range
   */
  var isInRange = function isInRange(target) {
    return !getRangeValue(target);
  };

  /**
   * Trigger `onChange` if value validated and not equals of origin.
   * Return the value that re-align in range.
   */
  var triggerValueUpdate = function triggerValueUpdate(newValue, userTyping) {
    var updateValue = newValue;
    var isRangeValidate = isInRange(updateValue) || updateValue.isEmpty();

    // Skip align value when trigger value is empty.
    // We just trigger onChange(null)
    // This should not block user typing
    if (!updateValue.isEmpty() && !userTyping) {
      // Revert value in range if needed
      updateValue = getRangeValue(updateValue) || updateValue;
      isRangeValidate = true;
    }
    if (!readOnly && !disabled && isRangeValidate) {
      var numStr = updateValue.toString();
      var mergedPrecision = getPrecision(numStr, userTyping);
      if (mergedPrecision >= 0) {
        updateValue = es(toFixed(numStr, '.', mergedPrecision));

        // When to fixed. The value may out of min & max range.
        // 4 in [0, 3.8] => 3.8 => 4 (toFixed)
        if (!isInRange(updateValue)) {
          updateValue = es(toFixed(numStr, '.', mergedPrecision, true));
        }
      }

      // Trigger event
      if (!updateValue.equals(decimalValue)) {
        setUncontrolledDecimalValue(updateValue);
        onChange === null || onChange === void 0 || onChange(updateValue.isEmpty() ? null : getDecimalValue(stringMode, updateValue));

        // Reformat input if value is not controlled
        if (value === undefined) {
          setInputValue(updateValue, userTyping);
        }
      }
      return updateValue;
    }
    return decimalValue;
  };

  // ========================== User Input ==========================
  var onNextPromise = useFrame();

  // >>> Collect input value
  var collectInputValue = function collectInputValue(inputStr) {
    recordCursor();

    // Update inputValue in case input can not parse as number
    // Refresh ref value immediately since it may used by formatter
    inputValueRef.current = inputStr;
    setInternalInputValue(inputStr);

    // Parse number
    if (!compositionRef.current) {
      var finalValue = mergedParser(inputStr);
      var finalDecimal = es(finalValue);
      if (!finalDecimal.isNaN()) {
        triggerValueUpdate(finalDecimal, true);
      }
    }

    // Trigger onInput later to let user customize value if they want to handle something after onChange
    onInput === null || onInput === void 0 || onInput(inputStr);

    // optimize for chinese input experience
    // https://github.com/ant-design/ant-design/issues/8196
    onNextPromise(function () {
      var nextInputStr = inputStr;
      if (!parser) {
        nextInputStr = inputStr.replace(/。/g, '.');
      }
      if (nextInputStr !== inputStr) {
        collectInputValue(nextInputStr);
      }
    });
  };

  // >>> Composition
  var onCompositionStart = function onCompositionStart() {
    compositionRef.current = true;
  };
  var onCompositionEnd = function onCompositionEnd() {
    compositionRef.current = false;
    collectInputValue(inputRef.current.value);
  };

  // >>> Input
  var onInternalInput = function onInternalInput(e) {
    collectInputValue(e.target.value);
  };

  // ============================= Step =============================
  var onInternalStep = function onInternalStep(up) {
    var _inputRef$current;
    // Ignore step since out of range
    if (up && upDisabled || !up && downDisabled) {
      return;
    }

    // Clear typing status since it may be caused by up & down key.
    // We should sync with input value.
    userTypingRef.current = false;
    var stepDecimal = es(shiftKeyRef.current ? getDecupleSteps(step) : step);
    if (!up) {
      stepDecimal = stepDecimal.negate();
    }
    var target = (decimalValue || es(0)).add(stepDecimal.toString());
    var updatedValue = triggerValueUpdate(target, false);
    onStep === null || onStep === void 0 || onStep(getDecimalValue(stringMode, updatedValue), {
      offset: shiftKeyRef.current ? getDecupleSteps(step) : step,
      type: up ? 'up' : 'down'
    });
    (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus();
  };

  // ============================ Flush =============================
  /**
   * Flush current input content to trigger value change & re-formatter input if needed.
   * This will always flush input value for update.
   * If it's invalidate, will fallback to last validate value.
   */
  var flushInputValue = function flushInputValue(userTyping) {
    var parsedValue = es(mergedParser(inputValue));
    var formatValue = parsedValue;
    if (!parsedValue.isNaN()) {
      // Only validate value or empty value can be re-fill to inputValue
      // Reassign the formatValue within ranged of trigger control
      formatValue = triggerValueUpdate(parsedValue, userTyping);
    } else {
      formatValue = triggerValueUpdate(decimalValue, userTyping);
    }
    if (value !== undefined) {
      // Reset back with controlled value first
      setInputValue(decimalValue, false);
    } else if (!formatValue.isNaN()) {
      // Reset input back since no validate value
      setInputValue(formatValue, false);
    }
  };

  // Solve the issue of the event triggering sequence when entering numbers in chinese input (Safari)
  var onBeforeInput = function onBeforeInput() {
    userTypingRef.current = true;
  };
  var onKeyDown = function onKeyDown(event) {
    var key = event.key,
      shiftKey = event.shiftKey;
    userTypingRef.current = true;
    shiftKeyRef.current = shiftKey;
    if (key === 'Enter') {
      if (!compositionRef.current) {
        userTypingRef.current = false;
      }
      flushInputValue(false);
      onPressEnter === null || onPressEnter === void 0 || onPressEnter(event);
    }
    if (keyboard === false) {
      return;
    }

    // Do step
    if (!compositionRef.current && ['Up', 'ArrowUp', 'Down', 'ArrowDown'].includes(key)) {
      onInternalStep(key === 'Up' || key === 'ArrowUp');
      event.preventDefault();
    }
  };
  var onKeyUp = function onKeyUp() {
    userTypingRef.current = false;
    shiftKeyRef.current = false;
  };
  react.useEffect(function () {
    if (changeOnWheel && focus) {
      var onWheel = function onWheel(event) {
        // moving mouse wheel rises wheel event with deltaY < 0
        // scroll value grows from top to bottom, as screen Y coordinate
        onInternalStep(event.deltaY < 0);
        event.preventDefault();
      };
      var input = inputRef.current;
      if (input) {
        // React onWheel is passive and we can't preventDefault() in it.
        // That's why we should subscribe with DOM listener
        // https://stackoverflow.com/questions/63663025/react-onwheel-handler-cant-preventdefault-because-its-a-passive-event-listenev
        input.addEventListener('wheel', onWheel, {
          passive: false
        });
        return function () {
          return input.removeEventListener('wheel', onWheel);
        };
      }
    }
  });

  // >>> Focus & Blur
  var onBlur = function onBlur() {
    if (changeOnBlur) {
      flushInputValue(false);
    }
    setFocus(false);
    userTypingRef.current = false;
  };

  // ========================== Controlled ==========================
  // Input by precision & formatter
  (0,useLayoutEffect/* useLayoutUpdateEffect */.o)(function () {
    if (!decimalValue.isInvalidate()) {
      setInputValue(decimalValue, false);
    }
  }, [precision, formatter]);

  // Input by value
  (0,useLayoutEffect/* useLayoutUpdateEffect */.o)(function () {
    var newValue = es(value);
    setDecimalValue(newValue);
    var currentParsedValue = es(mergedParser(inputValue));

    // When user typing from `1.2` to `1.`, we should not convert to `1` immediately.
    // But let it go if user set `formatter`
    if (!newValue.equals(currentParsedValue) || !userTypingRef.current || formatter) {
      // Update value as effect
      setInputValue(newValue, userTypingRef.current);
    }
  }, [value]);

  // ============================ Cursor ============================
  (0,useLayoutEffect/* useLayoutUpdateEffect */.o)(function () {
    if (formatter) {
      restoreCursor();
    }
  }, [inputValue]);

  // ============================ Render ============================
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(prefixCls, className, (_clsx = {}, (0,defineProperty/* default */.Z)(_clsx, "".concat(prefixCls, "-focused"), focus), (0,defineProperty/* default */.Z)(_clsx, "".concat(prefixCls, "-disabled"), disabled), (0,defineProperty/* default */.Z)(_clsx, "".concat(prefixCls, "-readonly"), readOnly), (0,defineProperty/* default */.Z)(_clsx, "".concat(prefixCls, "-not-a-number"), decimalValue.isNaN()), (0,defineProperty/* default */.Z)(_clsx, "".concat(prefixCls, "-out-of-range"), !decimalValue.isInvalidate() && !isInRange(decimalValue)), _clsx)),
    style: style,
    onFocus: function onFocus() {
      setFocus(true);
    },
    onBlur: onBlur,
    onKeyDown: onKeyDown,
    onKeyUp: onKeyUp,
    onCompositionStart: onCompositionStart,
    onCompositionEnd: onCompositionEnd,
    onBeforeInput: onBeforeInput
  }, controls && /*#__PURE__*/react.createElement(StepHandler, {
    prefixCls: prefixCls,
    upNode: upHandler,
    downNode: downHandler,
    upDisabled: upDisabled,
    downDisabled: downDisabled,
    onStep: onInternalStep
  }), /*#__PURE__*/react.createElement("div", {
    className: "".concat(inputClassName, "-wrap")
  }, /*#__PURE__*/react.createElement("input", (0,esm_extends/* default */.Z)({
    autoComplete: "off",
    role: "spinbutton",
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-valuenow": decimalValue.isInvalidate() ? null : decimalValue.toString(),
    step: step
  }, inputProps, {
    ref: (0,es_ref/* composeRef */.sQ)(inputRef, ref),
    className: inputClassName,
    value: inputValue,
    onChange: onInternalInput,
    disabled: disabled,
    readOnly: readOnly
  }))));
});
var InputNumber = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var disabled = props.disabled,
    style = props.style,
    prefixCls = props.prefixCls,
    value = props.value,
    prefix = props.prefix,
    suffix = props.suffix,
    addonBefore = props.addonBefore,
    addonAfter = props.addonAfter,
    className = props.className,
    classNames = props.classNames,
    rest = (0,objectWithoutProperties/* default */.Z)(props, _excluded2);
  var inputFocusRef = react.useRef(null);
  var focus = function focus(option) {
    if (inputFocusRef.current) {
      (0,commonUtils/* triggerFocus */.nH)(inputFocusRef.current, option);
    }
  };
  return /*#__PURE__*/react.createElement(rc_input_es/* BaseInput */.Q, {
    className: className,
    triggerFocus: focus,
    prefixCls: prefixCls,
    value: value,
    disabled: disabled,
    style: style,
    prefix: prefix,
    suffix: suffix,
    addonAfter: addonAfter,
    addonBefore: addonBefore,
    classNames: classNames,
    components: {
      affixWrapper: 'div',
      groupWrapper: 'div',
      wrapper: 'div',
      groupAddon: 'div'
    }
  }, /*#__PURE__*/react.createElement(InternalInputNumber, (0,esm_extends/* default */.Z)({
    prefixCls: prefixCls,
    disabled: disabled,
    ref: (0,es_ref/* composeRef */.sQ)(inputFocusRef, ref),
    className: classNames === null || classNames === void 0 ? void 0 : classNames.input
  }, rest)));
});
InputNumber.displayName = 'InputNumber';
/* harmony default export */ var es_InputNumber = (InputNumber);
;// CONCATENATED MODULE: ./node_modules/rc-input-number/es/index.js

/* harmony default export */ var rc_input_number_es = (es_InputNumber);
// EXTERNAL MODULE: ./node_modules/antd/es/_util/statusUtils.js
var statusUtils = __webpack_require__(9708);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/context.js
var context = __webpack_require__(53124);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/index.js + 8 modules
var config_provider = __webpack_require__(88929);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/DisabledContext.js
var DisabledContext = __webpack_require__(98866);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/hooks/useCSSVarCls.js
var useCSSVarCls = __webpack_require__(35792);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/hooks/useSize.js
var useSize = __webpack_require__(98675);
// EXTERNAL MODULE: ./node_modules/antd/es/form/context.js + 16 modules
var form_context = __webpack_require__(52706);
// EXTERNAL MODULE: ./node_modules/antd/es/form/hooks/useVariants.js
var useVariants = __webpack_require__(27833);
// EXTERNAL MODULE: ./node_modules/antd/es/space/Compact.js
var Compact = __webpack_require__(4173);
// EXTERNAL MODULE: ./node_modules/@ant-design/cssinjs/es/index.js + 35 modules
var cssinjs_es = __webpack_require__(54548);
// EXTERNAL MODULE: ./node_modules/antd/es/input/style/index.js
var style = __webpack_require__(47673);
// EXTERNAL MODULE: ./node_modules/antd/es/input/style/token.js
var style_token = __webpack_require__(20353);
// EXTERNAL MODULE: ./node_modules/antd/es/input/style/variants.js
var variants = __webpack_require__(93900);
// EXTERNAL MODULE: ./node_modules/antd/es/style/index.js
var es_style = __webpack_require__(14747);
// EXTERNAL MODULE: ./node_modules/antd/es/style/compact-item.js
var compact_item = __webpack_require__(80110);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/genComponentStyleHook.js + 6 modules
var genComponentStyleHook = __webpack_require__(92030);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/statistic.js
var statistic = __webpack_require__(45503);
// EXTERNAL MODULE: ./node_modules/@ctrl/tinycolor/dist/module/index.js
var dist_module = __webpack_require__(10274);
;// CONCATENATED MODULE: ./node_modules/antd/es/input-number/style/token.js


const prepareComponentToken = token => {
  var _a;
  const handleVisible = (_a = token.handleVisible) !== null && _a !== void 0 ? _a : 'auto';
  return Object.assign(Object.assign({}, (0,style_token/* initComponentToken */.T)(token)), {
    controlWidth: 90,
    handleWidth: token.controlHeightSM - token.lineWidth * 2,
    handleFontSize: token.fontSize / 2,
    handleVisible,
    handleActiveBg: token.colorFillAlter,
    handleBg: token.colorBgContainer,
    filledHandleBg: new dist_module/* TinyColor */.C(token.colorFillSecondary).onBackground(token.colorBgContainer).toHexString(),
    handleHoverColor: token.colorPrimary,
    handleBorderColor: token.colorBorder,
    handleOpacity: handleVisible === true ? 1 : 0
  });
};
;// CONCATENATED MODULE: ./node_modules/antd/es/input-number/style/index.js







const genRadiusStyle = (_ref, size) => {
  let {
    componentCls,
    borderRadiusSM,
    borderRadiusLG
  } = _ref;
  const borderRadius = size === 'lg' ? borderRadiusLG : borderRadiusSM;
  return {
    [`&-${size}`]: {
      [`${componentCls}-handler-wrap`]: {
        borderStartEndRadius: borderRadius,
        borderEndEndRadius: borderRadius
      },
      [`${componentCls}-handler-up`]: {
        borderStartEndRadius: borderRadius
      },
      [`${componentCls}-handler-down`]: {
        borderEndEndRadius: borderRadius
      }
    }
  };
};
const genInputNumberStyles = token => {
  const {
    componentCls,
    lineWidth,
    lineType,
    borderRadius,
    fontSizeLG,
    controlHeightLG,
    controlHeightSM,
    colorError,
    paddingInlineSM,
    paddingBlockSM,
    paddingBlockLG,
    paddingInlineLG,
    colorTextDescription,
    motionDurationMid,
    handleHoverColor,
    paddingInline,
    paddingBlock,
    handleBg,
    handleActiveBg,
    colorTextDisabled,
    borderRadiusSM,
    borderRadiusLG,
    controlWidth,
    handleOpacity,
    handleBorderColor,
    filledHandleBg,
    lineHeightLG,
    calc
  } = token;
  return [{
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (0,es_style/* resetComponent */.Wf)(token)), (0,style/* genBasicInputStyle */.ik)(token)), {
      display: 'inline-block',
      width: controlWidth,
      margin: 0,
      padding: 0,
      borderRadius
    }), (0,variants/* genOutlinedStyle */.qG)(token, {
      [`${componentCls}-handler-wrap`]: {
        background: handleBg,
        [`${componentCls}-handler-down`]: {
          borderBlockStart: `${(0,cssinjs_es/* unit */.bf)(lineWidth)} ${lineType} ${handleBorderColor}`
        }
      }
    })), (0,variants/* genFilledStyle */.H8)(token, {
      [`${componentCls}-handler-wrap`]: {
        background: filledHandleBg,
        [`${componentCls}-handler-down`]: {
          borderBlockStart: `${(0,cssinjs_es/* unit */.bf)(lineWidth)} ${lineType} ${handleBorderColor}`
        }
      },
      '&:focus-within': {
        [`${componentCls}-handler-wrap`]: {
          background: handleBg
        }
      }
    })), (0,variants/* genBorderlessStyle */.Mu)(token)), {
      '&-rtl': {
        direction: 'rtl',
        [`${componentCls}-input`]: {
          direction: 'rtl'
        }
      },
      '&-lg': {
        padding: 0,
        fontSize: fontSizeLG,
        lineHeight: lineHeightLG,
        borderRadius: borderRadiusLG,
        [`input${componentCls}-input`]: {
          height: calc(controlHeightLG).sub(calc(lineWidth).mul(2)).equal(),
          padding: `${(0,cssinjs_es/* unit */.bf)(paddingBlockLG)} ${(0,cssinjs_es/* unit */.bf)(paddingInlineLG)}`
        }
      },
      '&-sm': {
        padding: 0,
        borderRadius: borderRadiusSM,
        [`input${componentCls}-input`]: {
          height: calc(controlHeightSM).sub(calc(lineWidth).mul(2)).equal(),
          padding: `${(0,cssinjs_es/* unit */.bf)(paddingBlockSM)} ${(0,cssinjs_es/* unit */.bf)(paddingInlineSM)}`
        }
      },
      // ===================== Out Of Range =====================
      '&-out-of-range': {
        [`${componentCls}-input-wrap`]: {
          input: {
            color: colorError
          }
        }
      },
      // Style for input-group: input with label, with button or dropdown...
      '&-group': Object.assign(Object.assign(Object.assign({}, (0,es_style/* resetComponent */.Wf)(token)), (0,style/* genInputGroupStyle */.s7)(token)), {
        '&-wrapper': Object.assign(Object.assign(Object.assign({
          display: 'inline-block',
          textAlign: 'start',
          verticalAlign: 'top',
          [`${componentCls}-affix-wrapper`]: {
            width: '100%'
          },
          // Size
          '&-lg': {
            [`${componentCls}-group-addon`]: {
              borderRadius: borderRadiusLG,
              fontSize: token.fontSizeLG
            }
          },
          '&-sm': {
            [`${componentCls}-group-addon`]: {
              borderRadius: borderRadiusSM
            }
          }
        }, (0,variants/* genOutlinedGroupStyle */.ir)(token)), (0,variants/* genFilledGroupStyle */.S5)(token)), {
          // Fix the issue of using icons in Space Compact mode
          // https://github.com/ant-design/ant-design/issues/45764
          [`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
            [`${componentCls}, ${componentCls}-group-addon`]: {
              borderRadius: 0
            }
          },
          [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: {
            [`${componentCls}, ${componentCls}-group-addon`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: {
            [`${componentCls}, ${componentCls}-group-addon`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        })
      }),
      [`&-disabled ${componentCls}-input`]: {
        cursor: 'not-allowed'
      },
      [componentCls]: {
        '&-input': Object.assign(Object.assign(Object.assign(Object.assign({}, (0,es_style/* resetComponent */.Wf)(token)), {
          width: '100%',
          padding: `${(0,cssinjs_es/* unit */.bf)(paddingBlock)} ${(0,cssinjs_es/* unit */.bf)(paddingInline)}`,
          textAlign: 'start',
          backgroundColor: 'transparent',
          border: 0,
          borderRadius,
          outline: 0,
          transition: `all ${motionDurationMid} linear`,
          appearance: 'textfield',
          fontSize: 'inherit'
        }), (0,style/* genPlaceholderStyle */.nz)(token.colorTextPlaceholder)), {
          '&[type="number"]::-webkit-inner-spin-button, &[type="number"]::-webkit-outer-spin-button': {
            margin: 0,
            /* stylelint-disable-next-line property-no-vendor-prefix */
            webkitAppearance: 'none',
            appearance: 'none'
          }
        })
      }
    })
  },
  // Handler
  {
    [componentCls]: Object.assign(Object.assign(Object.assign({
      [`&:hover ${componentCls}-handler-wrap, &-focused ${componentCls}-handler-wrap`]: {
        opacity: 1
      },
      [`${componentCls}-handler-wrap`]: {
        position: 'absolute',
        insetBlockStart: 0,
        insetInlineEnd: 0,
        width: token.handleWidth,
        height: '100%',
        borderStartStartRadius: 0,
        borderStartEndRadius: borderRadius,
        borderEndEndRadius: borderRadius,
        borderEndStartRadius: 0,
        opacity: handleOpacity,
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'stretch',
        transition: `opacity ${motionDurationMid} linear ${motionDurationMid}`,
        // Fix input number inside Menu makes icon too large
        // We arise the selector priority by nest selector here
        // https://github.com/ant-design/ant-design/issues/14367
        [`${componentCls}-handler`]: {
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          flex: 'auto',
          height: '40%',
          [`
              ${componentCls}-handler-up-inner,
              ${componentCls}-handler-down-inner
            `]: {
            marginInlineEnd: 0,
            fontSize: token.handleFontSize
          }
        }
      },
      [`${componentCls}-handler`]: {
        height: '50%',
        overflow: 'hidden',
        color: colorTextDescription,
        fontWeight: 'bold',
        lineHeight: 0,
        textAlign: 'center',
        cursor: 'pointer',
        borderInlineStart: `${(0,cssinjs_es/* unit */.bf)(lineWidth)} ${lineType} ${handleBorderColor}`,
        transition: `all ${motionDurationMid} linear`,
        '&:active': {
          background: handleActiveBg
        },
        // Hover
        '&:hover': {
          height: `60%`,
          [`
              ${componentCls}-handler-up-inner,
              ${componentCls}-handler-down-inner
            `]: {
            color: handleHoverColor
          }
        },
        '&-up-inner, &-down-inner': Object.assign(Object.assign({}, (0,es_style/* resetIcon */.Ro)()), {
          color: colorTextDescription,
          transition: `all ${motionDurationMid} linear`,
          userSelect: 'none'
        })
      },
      [`${componentCls}-handler-up`]: {
        borderStartEndRadius: borderRadius
      },
      [`${componentCls}-handler-down`]: {
        borderEndEndRadius: borderRadius
      }
    }, genRadiusStyle(token, 'lg')), genRadiusStyle(token, 'sm')), {
      // Disabled
      '&-disabled, &-readonly': {
        [`${componentCls}-handler-wrap`]: {
          display: 'none'
        },
        [`${componentCls}-input`]: {
          color: 'inherit'
        }
      },
      [`
          ${componentCls}-handler-up-disabled,
          ${componentCls}-handler-down-disabled
        `]: {
        cursor: 'not-allowed'
      },
      [`
          ${componentCls}-handler-up-disabled:hover &-handler-up-inner,
          ${componentCls}-handler-down-disabled:hover &-handler-down-inner
        `]: {
        color: colorTextDisabled
      }
    })
  }];
};
const genAffixWrapperStyles = token => {
  const {
    componentCls,
    paddingBlock,
    paddingInline,
    inputAffixPadding,
    controlWidth,
    borderRadiusLG,
    borderRadiusSM,
    paddingInlineLG,
    paddingInlineSM,
    paddingBlockLG,
    paddingBlockSM
  } = token;
  return {
    [`${componentCls}-affix-wrapper`]: Object.assign(Object.assign({
      [`input${componentCls}-input`]: {
        padding: `${(0,cssinjs_es/* unit */.bf)(paddingBlock)} 0`
      }
    }, (0,style/* genBasicInputStyle */.ik)(token)), {
      // or number handler will cover form status
      position: 'relative',
      display: 'inline-flex',
      width: controlWidth,
      padding: 0,
      paddingInlineStart: paddingInline,
      '&-lg': {
        borderRadius: borderRadiusLG,
        paddingInlineStart: paddingInlineLG,
        [`input${componentCls}-input`]: {
          padding: `${(0,cssinjs_es/* unit */.bf)(paddingBlockLG)} 0`
        }
      },
      '&-sm': {
        borderRadius: borderRadiusSM,
        paddingInlineStart: paddingInlineSM,
        [`input${componentCls}-input`]: {
          padding: `${(0,cssinjs_es/* unit */.bf)(paddingBlockSM)} 0`
        }
      },
      [`&:not(${componentCls}-disabled):hover`]: {
        zIndex: 1
      },
      '&-focused, &:focus': {
        zIndex: 1
      },
      [`&-disabled > ${componentCls}-disabled`]: {
        background: 'transparent'
      },
      [`> div${componentCls}`]: {
        width: '100%',
        border: 'none',
        outline: 'none',
        [`&${componentCls}-focused`]: {
          boxShadow: 'none !important'
        }
      },
      '&::before': {
        display: 'inline-block',
        width: 0,
        visibility: 'hidden',
        content: '"\\a0"'
      },
      [`${componentCls}-handler-wrap`]: {
        zIndex: 2
      },
      [componentCls]: {
        color: 'inherit',
        '&-prefix, &-suffix': {
          display: 'flex',
          flex: 'none',
          alignItems: 'center',
          pointerEvents: 'none'
        },
        '&-prefix': {
          marginInlineEnd: inputAffixPadding
        },
        '&-suffix': {
          position: 'absolute',
          insetBlockStart: 0,
          insetInlineEnd: 0,
          zIndex: 1,
          height: '100%',
          marginInlineEnd: paddingInline,
          marginInlineStart: inputAffixPadding
        }
      }
    })
  };
};
/* harmony default export */ var input_number_style = ((0,genComponentStyleHook/* genStyleHooks */.I$)('InputNumber', token => {
  const inputNumberToken = (0,statistic/* merge */.TS)(token, (0,style_token/* initInputToken */.e)(token));
  return [genInputNumberStyles(inputNumberToken), genAffixWrapperStyles(inputNumberToken),
  // =====================================================
  // ==             Space Compact                       ==
  // =====================================================
  (0,compact_item/* genCompactItemStyle */.c)(inputNumberToken)];
}, prepareComponentToken, {
  unitless: {
    handleOpacity: true
  }
}));
;// CONCATENATED MODULE: ./node_modules/antd/es/input-number/index.js
"use client";

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};















const input_number_InputNumber = /*#__PURE__*/react.forwardRef((props, ref) => {
  if (false) {}
  const {
    getPrefixCls,
    direction
  } = react.useContext(context/* ConfigContext */.E_);
  const inputRef = react.useRef(null);
  react.useImperativeHandle(ref, () => inputRef.current);
  const {
      className,
      rootClassName,
      size: customizeSize,
      disabled: customDisabled,
      prefixCls: customizePrefixCls,
      addonBefore,
      addonAfter,
      prefix,
      bordered,
      readOnly,
      status: customStatus,
      controls,
      variant: customVariant
    } = props,
    others = __rest(props, ["className", "rootClassName", "size", "disabled", "prefixCls", "addonBefore", "addonAfter", "prefix", "bordered", "readOnly", "status", "controls", "variant"]);
  const prefixCls = getPrefixCls('input-number', customizePrefixCls);
  // Style
  const rootCls = (0,useCSSVarCls/* default */.Z)(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = input_number_style(prefixCls, rootCls);
  const {
    compactSize,
    compactItemClassnames
  } = (0,Compact/* useCompactItemContext */.ri)(prefixCls, direction);
  let upIcon = /*#__PURE__*/react.createElement(icons_UpOutlined, {
    className: `${prefixCls}-handler-up-inner`
  });
  let downIcon = /*#__PURE__*/react.createElement(DownOutlined/* default */.Z, {
    className: `${prefixCls}-handler-down-inner`
  });
  const controlsTemp = typeof controls === 'boolean' ? controls : undefined;
  if (typeof controls === 'object') {
    upIcon = typeof controls.upIcon === 'undefined' ? upIcon : ( /*#__PURE__*/react.createElement("span", {
      className: `${prefixCls}-handler-up-inner`
    }, controls.upIcon));
    downIcon = typeof controls.downIcon === 'undefined' ? downIcon : ( /*#__PURE__*/react.createElement("span", {
      className: `${prefixCls}-handler-down-inner`
    }, controls.downIcon));
  }
  const {
    hasFeedback,
    status: contextStatus,
    isFormItemInput,
    feedbackIcon
  } = react.useContext(form_context/* FormItemInputContext */.aM);
  const mergedStatus = (0,statusUtils/* getMergedStatus */.F)(contextStatus, customStatus);
  const mergedSize = (0,useSize/* default */.Z)(ctx => {
    var _a;
    return (_a = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
  });
  // ===================== Disabled =====================
  const disabled = react.useContext(DisabledContext/* default */.Z);
  const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
  const [variant, enableVariantCls] = (0,useVariants/* default */.Z)(customVariant, bordered);
  // eslint-disable-next-line react/jsx-no-useless-fragment
  const suffixNode = hasFeedback && /*#__PURE__*/react.createElement(react.Fragment, null, feedbackIcon);
  const inputNumberClass = classnames_default()({
    [`${prefixCls}-lg`]: mergedSize === 'large',
    [`${prefixCls}-sm`]: mergedSize === 'small',
    [`${prefixCls}-rtl`]: direction === 'rtl',
    [`${prefixCls}-in-form-item`]: isFormItemInput
  }, hashId);
  const wrapperClassName = `${prefixCls}-group`;
  const element = /*#__PURE__*/react.createElement(rc_input_number_es, Object.assign({
    ref: inputRef,
    disabled: mergedDisabled,
    className: classnames_default()(cssVarCls, rootCls, className, rootClassName, compactItemClassnames),
    upHandler: upIcon,
    downHandler: downIcon,
    prefixCls: prefixCls,
    readOnly: readOnly,
    controls: controlsTemp,
    prefix: prefix,
    suffix: suffixNode,
    addonAfter: addonAfter && ( /*#__PURE__*/react.createElement(Compact/* NoCompactStyle */.BR, null, /*#__PURE__*/react.createElement(form_context/* NoFormStyle */.Ux, {
      override: true,
      status: true
    }, addonAfter))),
    addonBefore: addonBefore && ( /*#__PURE__*/react.createElement(Compact/* NoCompactStyle */.BR, null, /*#__PURE__*/react.createElement(form_context/* NoFormStyle */.Ux, {
      override: true,
      status: true
    }, addonBefore))),
    classNames: {
      input: inputNumberClass,
      variant: classnames_default()({
        [`${prefixCls}-${variant}`]: enableVariantCls
      }, (0,statusUtils/* getStatusClassNames */.Z)(prefixCls, mergedStatus, hasFeedback)),
      affixWrapper: classnames_default()({
        [`${prefixCls}-affix-wrapper-sm`]: mergedSize === 'small',
        [`${prefixCls}-affix-wrapper-lg`]: mergedSize === 'large',
        [`${prefixCls}-affix-wrapper-rtl`]: direction === 'rtl'
      }, hashId),
      wrapper: classnames_default()({
        [`${wrapperClassName}-rtl`]: direction === 'rtl'
      }, hashId),
      groupWrapper: classnames_default()({
        [`${prefixCls}-group-wrapper-sm`]: mergedSize === 'small',
        [`${prefixCls}-group-wrapper-lg`]: mergedSize === 'large',
        [`${prefixCls}-group-wrapper-rtl`]: direction === 'rtl',
        [`${prefixCls}-group-wrapper-${variant}`]: enableVariantCls
      }, (0,statusUtils/* getStatusClassNames */.Z)(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
    }
  }, others));
  return wrapCSSVar(element);
});
const TypedInputNumber = input_number_InputNumber;
/** @private Internal Component. Do not use in your production. */
const PureInputNumber = props => ( /*#__PURE__*/react.createElement(config_provider/* default */.ZP, {
  theme: {
    components: {
      InputNumber: {
        handleVisible: true
      }
    }
  }
}, /*#__PURE__*/react.createElement(input_number_InputNumber, Object.assign({}, props))));
if (false) {}
TypedInputNumber._InternalPanelDoNotUseOrYouWillBeFired = PureInputNumber;
/* harmony default export */ var input_number = (TypedInputNumber);

/***/ }),

/***/ 56846:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: function() { return /* binding */ input; }
});

// EXTERNAL MODULE: ./node_modules/@umijs/preset-umi/node_modules/react/index.js
var react = __webpack_require__(62435);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(93967);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/context.js
var context = __webpack_require__(53124);
// EXTERNAL MODULE: ./node_modules/antd/es/form/context.js + 16 modules
var form_context = __webpack_require__(52706);
// EXTERNAL MODULE: ./node_modules/antd/es/input/style/index.js
var input_style = __webpack_require__(47673);
;// CONCATENATED MODULE: ./node_modules/antd/es/input/Group.js
"use client";








const Group = props => {
  const {
    getPrefixCls,
    direction
  } = (0,react.useContext)(context/* ConfigContext */.E_);
  const {
    prefixCls: customizePrefixCls,
    className
  } = props;
  const prefixCls = getPrefixCls('input-group', customizePrefixCls);
  const inputPrefixCls = getPrefixCls('input');
  const [wrapCSSVar, hashId] = (0,input_style/* default */.ZP)(inputPrefixCls);
  const cls = classnames_default()(prefixCls, {
    [`${prefixCls}-lg`]: props.size === 'large',
    [`${prefixCls}-sm`]: props.size === 'small',
    [`${prefixCls}-compact`]: props.compact,
    [`${prefixCls}-rtl`]: direction === 'rtl'
  }, hashId, className);
  const formItemContext = (0,react.useContext)(form_context/* FormItemInputContext */.aM);
  const groupFormItemContext = (0,react.useMemo)(() => Object.assign(Object.assign({}, formItemContext), {
    isFormItemInput: false
  }), [formItemContext]);
  if (false) {}
  return wrapCSSVar( /*#__PURE__*/react.createElement("span", {
    className: cls,
    style: props.style,
    onMouseEnter: props.onMouseEnter,
    onMouseLeave: props.onMouseLeave,
    onFocus: props.onFocus,
    onBlur: props.onBlur
  }, /*#__PURE__*/react.createElement(form_context/* FormItemInputContext */.aM.Provider, {
    value: groupFormItemContext
  }, props.children)));
};
/* harmony default export */ var input_Group = (Group);
// EXTERNAL MODULE: ./node_modules/rc-input/es/index.js + 2 modules
var es = __webpack_require__(67656);
// EXTERNAL MODULE: ./node_modules/rc-util/es/ref.js
var es_ref = __webpack_require__(42550);
// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/CloseCircleFilled.js + 1 modules
var CloseCircleFilled = __webpack_require__(4340);
;// CONCATENATED MODULE: ./node_modules/antd/es/_util/getAllowClear.js
"use client";



const getAllowClear = allowClear => {
  let mergedAllowClear;
  if (typeof allowClear === 'object' && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
    mergedAllowClear = allowClear;
  } else if (allowClear) {
    mergedAllowClear = {
      clearIcon: /*#__PURE__*/react.createElement(CloseCircleFilled/* default */.Z, null)
    };
  }
  return mergedAllowClear;
};
/* harmony default export */ var _util_getAllowClear = (getAllowClear);
// EXTERNAL MODULE: ./node_modules/antd/es/_util/statusUtils.js
var statusUtils = __webpack_require__(9708);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/DisabledContext.js
var DisabledContext = __webpack_require__(98866);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/hooks/useCSSVarCls.js
var useCSSVarCls = __webpack_require__(35792);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/hooks/useSize.js
var useSize = __webpack_require__(98675);
// EXTERNAL MODULE: ./node_modules/antd/es/form/hooks/useVariants.js
var useVariants = __webpack_require__(27833);
// EXTERNAL MODULE: ./node_modules/antd/es/space/Compact.js
var Compact = __webpack_require__(4173);
;// CONCATENATED MODULE: ./node_modules/antd/es/input/hooks/useRemovePasswordTimeout.js

function useRemovePasswordTimeout(inputRef, triggerOnMount) {
  const removePasswordTimeoutRef = (0,react.useRef)([]);
  const removePasswordTimeout = () => {
    removePasswordTimeoutRef.current.push(setTimeout(() => {
      var _a, _b, _c, _d;
      if (((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) && ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.input.getAttribute('type')) === 'password' && ((_c = inputRef.current) === null || _c === void 0 ? void 0 : _c.input.hasAttribute('value'))) {
        (_d = inputRef.current) === null || _d === void 0 ? void 0 : _d.input.removeAttribute('value');
      }
    }));
  };
  (0,react.useEffect)(() => {
    if (triggerOnMount) {
      removePasswordTimeout();
    }
    return () => removePasswordTimeoutRef.current.forEach(timer => {
      if (timer) {
        clearTimeout(timer);
      }
    });
  }, []);
  return removePasswordTimeout;
}
;// CONCATENATED MODULE: ./node_modules/antd/es/input/utils.js
// eslint-disable-next-line import/prefer-default-export
function hasPrefixSuffix(props) {
  return !!(props.prefix || props.suffix || props.allowClear || props.showCount);
}
;// CONCATENATED MODULE: ./node_modules/antd/es/input/Input.js
"use client";

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

















function triggerFocus(element, option) {
  if (!element) {
    return;
  }
  element.focus(option);
  // Selection content
  const {
    cursor
  } = option || {};
  if (cursor) {
    const len = element.value.length;
    switch (cursor) {
      case 'start':
        element.setSelectionRange(0, 0);
        break;
      case 'end':
        element.setSelectionRange(len, len);
        break;
      default:
        element.setSelectionRange(0, len);
        break;
    }
  }
}
const Input = /*#__PURE__*/(0,react.forwardRef)((props, ref) => {
  var _a;
  const {
      prefixCls: customizePrefixCls,
      bordered = true,
      status: customStatus,
      size: customSize,
      disabled: customDisabled,
      onBlur,
      onFocus,
      suffix,
      allowClear,
      addonAfter,
      addonBefore,
      className,
      style,
      styles,
      rootClassName,
      onChange,
      classNames: classes,
      variant: customVariant
    } = props,
    rest = __rest(props, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore", "className", "style", "styles", "rootClassName", "onChange", "classNames", "variant"]);
  if (false) {}
  const {
    getPrefixCls,
    direction,
    input
  } = react.useContext(context/* ConfigContext */.E_);
  const prefixCls = getPrefixCls('input', customizePrefixCls);
  const inputRef = (0,react.useRef)(null);
  // Style
  const rootCls = (0,useCSSVarCls/* default */.Z)(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = (0,input_style/* default */.ZP)(prefixCls, rootCls);
  // ===================== Compact Item =====================
  const {
    compactSize,
    compactItemClassnames
  } = (0,Compact/* useCompactItemContext */.ri)(prefixCls, direction);
  // ===================== Size =====================
  const mergedSize = (0,useSize/* default */.Z)(ctx => {
    var _a;
    return (_a = customSize !== null && customSize !== void 0 ? customSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
  });
  // ===================== Disabled =====================
  const disabled = react.useContext(DisabledContext/* default */.Z);
  const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
  // ===================== Status =====================
  const {
    status: contextStatus,
    hasFeedback,
    feedbackIcon
  } = (0,react.useContext)(form_context/* FormItemInputContext */.aM);
  const mergedStatus = (0,statusUtils/* getMergedStatus */.F)(contextStatus, customStatus);
  // ===================== Focus warning =====================
  const inputHasPrefixSuffix = hasPrefixSuffix(props) || !!hasFeedback;
  const prevHasPrefixSuffix = (0,react.useRef)(inputHasPrefixSuffix);
  /* eslint-disable react-hooks/rules-of-hooks */
  if (false) {}
  /* eslint-enable */
  // ===================== Remove Password value =====================
  const removePasswordTimeout = useRemovePasswordTimeout(inputRef, true);
  const handleBlur = e => {
    removePasswordTimeout();
    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
  };
  const handleFocus = e => {
    removePasswordTimeout();
    onFocus === null || onFocus === void 0 ? void 0 : onFocus(e);
  };
  const handleChange = e => {
    removePasswordTimeout();
    onChange === null || onChange === void 0 ? void 0 : onChange(e);
  };
  const suffixNode = (hasFeedback || suffix) && ( /*#__PURE__*/react.createElement(react.Fragment, null, suffix, hasFeedback && feedbackIcon));
  const mergedAllowClear = _util_getAllowClear(allowClear !== null && allowClear !== void 0 ? allowClear : input === null || input === void 0 ? void 0 : input.allowClear);
  const [variant, enableVariantCls] = (0,useVariants/* default */.Z)(customVariant, bordered);
  return wrapCSSVar( /*#__PURE__*/react.createElement(es/* default */.Z, Object.assign({
    ref: (0,es_ref/* composeRef */.sQ)(ref, inputRef),
    prefixCls: prefixCls,
    autoComplete: input === null || input === void 0 ? void 0 : input.autoComplete
  }, rest, {
    disabled: mergedDisabled,
    onBlur: handleBlur,
    onFocus: handleFocus,
    style: Object.assign(Object.assign({}, input === null || input === void 0 ? void 0 : input.style), style),
    styles: Object.assign(Object.assign({}, input === null || input === void 0 ? void 0 : input.styles), styles),
    suffix: suffixNode,
    allowClear: mergedAllowClear,
    className: classnames_default()(className, rootClassName, cssVarCls, rootCls, compactItemClassnames, input === null || input === void 0 ? void 0 : input.className),
    onChange: handleChange,
    addonAfter: addonAfter && ( /*#__PURE__*/react.createElement(Compact/* NoCompactStyle */.BR, null, /*#__PURE__*/react.createElement(form_context/* NoFormStyle */.Ux, {
      override: true,
      status: true
    }, addonAfter))),
    addonBefore: addonBefore && ( /*#__PURE__*/react.createElement(Compact/* NoCompactStyle */.BR, null, /*#__PURE__*/react.createElement(form_context/* NoFormStyle */.Ux, {
      override: true,
      status: true
    }, addonBefore))),
    classNames: Object.assign(Object.assign(Object.assign({}, classes), input === null || input === void 0 ? void 0 : input.classNames), {
      input: classnames_default()({
        [`${prefixCls}-sm`]: mergedSize === 'small',
        [`${prefixCls}-lg`]: mergedSize === 'large',
        [`${prefixCls}-rtl`]: direction === 'rtl'
      }, classes === null || classes === void 0 ? void 0 : classes.input, (_a = input === null || input === void 0 ? void 0 : input.classNames) === null || _a === void 0 ? void 0 : _a.input, hashId),
      variant: classnames_default()({
        [`${prefixCls}-${variant}`]: enableVariantCls
      }, (0,statusUtils/* getStatusClassNames */.Z)(prefixCls, mergedStatus)),
      affixWrapper: classnames_default()({
        [`${prefixCls}-affix-wrapper-sm`]: mergedSize === 'small',
        [`${prefixCls}-affix-wrapper-lg`]: mergedSize === 'large',
        [`${prefixCls}-affix-wrapper-rtl`]: direction === 'rtl'
      }, hashId),
      wrapper: classnames_default()({
        [`${prefixCls}-group-rtl`]: direction === 'rtl'
      }, hashId),
      groupWrapper: classnames_default()({
        [`${prefixCls}-group-wrapper-sm`]: mergedSize === 'small',
        [`${prefixCls}-group-wrapper-lg`]: mergedSize === 'large',
        [`${prefixCls}-group-wrapper-rtl`]: direction === 'rtl',
        [`${prefixCls}-group-wrapper-${variant}`]: enableVariantCls
      }, (0,statusUtils/* getStatusClassNames */.Z)(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
    })
  })));
});
if (false) {}
/* harmony default export */ var input_Input = (Input);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 2 modules
var toConsumableArray = __webpack_require__(74902);
// EXTERNAL MODULE: ./node_modules/rc-util/es/index.js
var rc_util_es = __webpack_require__(56790);
// EXTERNAL MODULE: ./node_modules/rc-util/es/pickAttrs.js
var pickAttrs = __webpack_require__(64217);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/genComponentStyleHook.js + 6 modules
var genComponentStyleHook = __webpack_require__(92030);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/statistic.js
var statistic = __webpack_require__(45503);
// EXTERNAL MODULE: ./node_modules/antd/es/input/style/token.js
var style_token = __webpack_require__(20353);
;// CONCATENATED MODULE: ./node_modules/antd/es/input/style/otp.js


// =============================== OTP ================================
const genOTPStyle = token => {
  const {
    componentCls,
    paddingXS
  } = token;
  return {
    [`${componentCls}`]: {
      display: 'inline-flex',
      alignItems: 'center',
      flexWrap: 'nowrap',
      columnGap: paddingXS,
      '&-rtl': {
        direction: 'rtl'
      },
      [`${componentCls}-input`]: {
        textAlign: 'center',
        paddingInline: token.paddingXXS
      },
      // ================= Size =================
      [`&${componentCls}-sm ${componentCls}-input`]: {
        paddingInline: token.calc(token.paddingXXS).div(2).equal()
      },
      [`&${componentCls}-lg ${componentCls}-input`]: {
        paddingInline: token.paddingXS
      }
    }
  };
};
// ============================== Export ==============================
/* harmony default export */ var otp = ((0,genComponentStyleHook/* genStyleHooks */.I$)(['Input', 'OTP'], token => {
  const inputToken = (0,statistic/* merge */.TS)(token, (0,style_token/* initInputToken */.e)(token));
  return [genOTPStyle(inputToken)];
}, style_token/* initComponentToken */.T));
// EXTERNAL MODULE: ./node_modules/rc-util/es/raf.js
var raf = __webpack_require__(75164);
;// CONCATENATED MODULE: ./node_modules/antd/es/input/OTP/OTPInput.js
"use client";

var OTPInput_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



const OTPInput = /*#__PURE__*/react.forwardRef((props, ref) => {
  const {
      value,
      onChange,
      onActiveChange,
      index
    } = props,
    restProps = OTPInput_rest(props, ["value", "onChange", "onActiveChange", "index"]);
  const onInternalChange = e => {
    onChange(index, e.target.value);
  };
  // ========================== Ref ===========================
  const inputRef = react.useRef(null);
  react.useImperativeHandle(ref, () => inputRef.current);
  // ========================= Focus ==========================
  const syncSelection = () => {
    (0,raf/* default */.Z)(() => {
      var _a;
      const inputEle = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input;
      if (document.activeElement === inputEle && inputEle) {
        inputEle.select();
      }
    });
  };
  // ======================== Keyboard ========================
  const onInternalKeyDown = _ref => {
    let {
      key
    } = _ref;
    if (key === 'ArrowLeft') {
      onActiveChange(index - 1);
    } else if (key === 'ArrowRight') {
      onActiveChange(index + 1);
    }
    syncSelection();
  };
  const onInternalKeyUp = e => {
    if (e.key === 'Backspace' && !value) {
      onActiveChange(index - 1);
    }
    syncSelection();
  };
  // ========================= Render =========================
  return /*#__PURE__*/react.createElement(input_Input, Object.assign({}, restProps, {
    ref: inputRef,
    value: value,
    onInput: onInternalChange,
    onFocus: syncSelection,
    onKeyDown: onInternalKeyDown,
    onKeyUp: onInternalKeyUp,
    onMouseDown: syncSelection,
    onMouseUp: syncSelection
  }));
});
/* harmony default export */ var OTP_OTPInput = (OTPInput);
;// CONCATENATED MODULE: ./node_modules/antd/es/input/OTP/index.js
"use client";


var OTP_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};











function strToArr(str) {
  return (str || '').split('');
}
const OTP = /*#__PURE__*/react.forwardRef((props, ref) => {
  const {
      prefixCls: customizePrefixCls,
      length = 6,
      size: customSize,
      defaultValue,
      value,
      onChange,
      formatter,
      variant,
      disabled,
      status: customStatus,
      autoFocus
    } = props,
    restProps = OTP_rest(props, ["prefixCls", "length", "size", "defaultValue", "value", "onChange", "formatter", "variant", "disabled", "status", "autoFocus"]);
  const {
    getPrefixCls,
    direction
  } = react.useContext(context/* ConfigContext */.E_);
  const prefixCls = getPrefixCls('otp', customizePrefixCls);
  const domAttrs = (0,pickAttrs/* default */.Z)(restProps, {
    aria: true,
    data: true,
    attr: true
  });
  // ========================= Root =========================
  // Style
  const rootCls = (0,useCSSVarCls/* default */.Z)(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = otp(prefixCls, rootCls);
  // ========================= Size =========================
  const mergedSize = (0,useSize/* default */.Z)(ctx => customSize !== null && customSize !== void 0 ? customSize : ctx);
  // ======================== Status ========================
  const formContext = react.useContext(form_context/* FormItemInputContext */.aM);
  const mergedStatus = (0,statusUtils/* getMergedStatus */.F)(formContext.status, customStatus);
  const proxyFormContext = react.useMemo(() => Object.assign(Object.assign({}, formContext), {
    status: mergedStatus,
    hasFeedback: false,
    feedbackIcon: null
  }), [formContext, mergedStatus]);
  // ========================= Refs =========================
  const containerRef = react.useRef(null);
  const refs = react.useRef({});
  react.useImperativeHandle(ref, () => ({
    focus: () => {
      var _a;
      (_a = refs.current[0]) === null || _a === void 0 ? void 0 : _a.focus();
    },
    blur: () => {
      var _a;
      for (let i = 0; i < length; i += 1) {
        (_a = refs.current[i]) === null || _a === void 0 ? void 0 : _a.blur();
      }
    },
    nativeElement: containerRef.current
  }));
  // ======================= Formatter ======================
  const internalFormatter = txt => formatter ? formatter(txt) : txt;
  // ======================== Values ========================
  const [valueCells, setValueCells] = react.useState(strToArr(internalFormatter(defaultValue || '')));
  react.useEffect(() => {
    if (value !== undefined) {
      setValueCells(strToArr(value));
    }
  }, [value]);
  const triggerValueCellsChange = (0,rc_util_es/* useEvent */.zX)(nextValueCells => {
    setValueCells(nextValueCells);
    // Trigger if all cells are filled
    if (onChange && nextValueCells.length === length && nextValueCells.every(c => c) && nextValueCells.some((c, index) => valueCells[index] !== c)) {
      onChange(nextValueCells.join(''));
    }
  });
  const patchValue = (0,rc_util_es/* useEvent */.zX)((index, txt) => {
    let nextCells = (0,toConsumableArray/* default */.Z)(valueCells);
    // Fill cells till index
    for (let i = 0; i < index; i += 1) {
      if (!nextCells[i]) {
        nextCells[i] = '';
      }
    }
    if (txt.length <= 1) {
      nextCells[index] = txt;
    } else {
      nextCells = nextCells.slice(0, index).concat(strToArr(txt));
    }
    nextCells = nextCells.slice(0, length);
    // Clean the last empty cell
    for (let i = nextCells.length - 1; i >= 0; i -= 1) {
      if (nextCells[i]) {
        break;
      }
      nextCells.pop();
    }
    // Format if needed
    const formattedValue = internalFormatter(nextCells.map(c => c || ' ').join(''));
    nextCells = strToArr(formattedValue).map((c, i) => {
      if (c === ' ' && !nextCells[i]) {
        return nextCells[i];
      }
      return c;
    });
    return nextCells;
  });
  // ======================== Change ========================
  const onInputChange = (index, txt) => {
    var _a;
    const nextCells = patchValue(index, txt);
    const nextIndex = Math.min(index + txt.length, length - 1);
    if (nextIndex !== index) {
      (_a = refs.current[nextIndex]) === null || _a === void 0 ? void 0 : _a.focus();
    }
    triggerValueCellsChange(nextCells);
  };
  const onInputActiveChange = nextIndex => {
    var _a;
    (_a = refs.current[nextIndex]) === null || _a === void 0 ? void 0 : _a.focus();
  };
  // ======================== Render ========================
  const inputSharedProps = {
    variant,
    disabled,
    status: mergedStatus
  };
  return wrapCSSVar( /*#__PURE__*/react.createElement("div", Object.assign({}, domAttrs, {
    ref: containerRef,
    className: classnames_default()(prefixCls, {
      [`${prefixCls}-sm`]: mergedSize === 'small',
      [`${prefixCls}-lg`]: mergedSize === 'large',
      [`${prefixCls}-rtl`]: direction === 'rtl'
    }, cssVarCls, hashId)
  }), /*#__PURE__*/react.createElement(form_context/* FormItemInputContext */.aM.Provider, {
    value: proxyFormContext
  }, new Array(length).fill(0).map((_, index) => {
    const key = `otp-${index}`;
    const singleValue = valueCells[index] || '';
    return /*#__PURE__*/react.createElement(OTP_OTPInput, Object.assign({
      ref: inputEle => {
        refs.current[index] = inputEle;
      },
      key: key,
      index: index,
      size: mergedSize,
      htmlSize: 1,
      className: `${prefixCls}-input`,
      onChange: onInputChange,
      value: singleValue,
      onActiveChange: onInputActiveChange,
      autoFocus: index === 0 && autoFocus
    }, inputSharedProps));
  }))));
});
/* harmony default export */ var input_OTP = (OTP);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(87462);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons-svg/es/asn/EyeInvisibleOutlined.js
// This icon file is generated automatically.
var EyeInvisibleOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { "tag": "path", "attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, "name": "eye-invisible", "theme": "outlined" };
/* harmony default export */ var asn_EyeInvisibleOutlined = (EyeInvisibleOutlined);

// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/components/AntdIcon.js + 3 modules
var AntdIcon = __webpack_require__(42135);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons/es/icons/EyeInvisibleOutlined.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY




var EyeInvisibleOutlined_EyeInvisibleOutlined = function EyeInvisibleOutlined(props, ref) {
  return /*#__PURE__*/react.createElement(AntdIcon/* default */.Z, (0,esm_extends/* default */.Z)({}, props, {
    ref: ref,
    icon: asn_EyeInvisibleOutlined
  }));
};

/**![eye-invisible](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTk0Mi4yIDQ4Ni4yUTg4OS40NyAzNzUuMTEgODE2LjcgMzA1bC01MC44OCA1MC44OEM4MDcuMzEgMzk1LjUzIDg0My40NSA0NDcuNCA4NzQuNyA1MTIgNzkxLjUgNjg0LjIgNjczLjQgNzY2IDUxMiA3NjZxLTcyLjY3IDAtMTMzLjg3LTIyLjM4TDMyMyA3OTguNzVRNDA4IDgzOCA1MTIgODM4cTI4OC4zIDAgNDMwLjItMzAwLjNhNjAuMjkgNjAuMjkgMCAwMDAtNTEuNXptLTYzLjU3LTMyMC42NEw4MzYgMTIyLjg4YTggOCAwIDAwLTExLjMyIDBMNzE1LjMxIDIzMi4yUTYyNC44NiAxODYgNTEyIDE4NnEtMjg4LjMgMC00MzAuMiAzMDAuM2E2MC4zIDYwLjMgMCAwMDAgNTEuNXE1Ni42OSAxMTkuNCAxMzYuNSAxOTEuNDFMMTEyLjQ4IDgzNWE4IDggMCAwMDAgMTEuMzFMMTU1LjE3IDg4OWE4IDggMCAwMDExLjMxIDBsNzEyLjE1LTcxMi4xMmE4IDggMCAwMDAtMTEuMzJ6TTE0OS4zIDUxMkMyMzIuNiAzMzkuOCAzNTAuNyAyNTggNTEyIDI1OGM1NC41NCAwIDEwNC4xMyA5LjM2IDE0OS4xMiAyOC4zOWwtNzAuMyA3MC4zYTE3NiAxNzYgMCAwMC0yMzguMTMgMjM4LjEzbC04My40MiA4My40MkMyMjMuMSA2MzcuNDkgMTgzLjMgNTgyLjI4IDE0OS4zIDUxMnptMjQ2LjcgMGExMTIuMTEgMTEyLjExIDAgMDExNDYuMi0xMDYuNjlMNDAxLjMxIDU0Ni4yQTExMiAxMTIgMCAwMTM5NiA1MTJ6IiAvPjxwYXRoIGQ9Ik01MDggNjI0Yy0zLjQ2IDAtNi44Ny0uMTYtMTAuMjUtLjQ3bC01Mi44MiA1Mi44MmExNzYuMDkgMTc2LjA5IDAgMDAyMjcuNDItMjI3LjQybC01Mi44MiA1Mi44MmMuMzEgMy4zOC40NyA2Ljc5LjQ3IDEwLjI1YTExMS45NCAxMTEuOTQgMCAwMS0xMTIgMTEyeiIgLz48L3N2Zz4=) */
var RefIcon = /*#__PURE__*/react.forwardRef(EyeInvisibleOutlined_EyeInvisibleOutlined);
if (false) {}
/* harmony default export */ var icons_EyeInvisibleOutlined = (RefIcon);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons-svg/es/asn/EyeOutlined.js
// This icon file is generated automatically.
var EyeOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
/* harmony default export */ var asn_EyeOutlined = (EyeOutlined);

;// CONCATENATED MODULE: ./node_modules/@ant-design/icons/es/icons/EyeOutlined.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY




var EyeOutlined_EyeOutlined = function EyeOutlined(props, ref) {
  return /*#__PURE__*/react.createElement(AntdIcon/* default */.Z, (0,esm_extends/* default */.Z)({}, props, {
    ref: ref,
    icon: asn_EyeOutlined
  }));
};

/**![eye](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTk0Mi4yIDQ4Ni4yQzg0Ny40IDI4Ni41IDcwNC4xIDE4NiA1MTIgMTg2Yy0xOTIuMiAwLTMzNS40IDEwMC41LTQzMC4yIDMwMC4zYTYwLjMgNjAuMyAwIDAwMCA1MS41QzE3Ni42IDczNy41IDMxOS45IDgzOCA1MTIgODM4YzE5Mi4yIDAgMzM1LjQtMTAwLjUgNDMwLjItMzAwLjMgNy43LTE2LjIgNy43LTM1IDAtNTEuNXpNNTEyIDc2NmMtMTYxLjMgMC0yNzkuNC04MS44LTM2Mi43LTI1NEMyMzIuNiAzMzkuOCAzNTAuNyAyNTggNTEyIDI1OGMxNjEuMyAwIDI3OS40IDgxLjggMzYyLjcgMjU0Qzc5MS41IDY4NC4yIDY3My40IDc2NiA1MTIgNzY2em0tNC00MzBjLTk3LjIgMC0xNzYgNzguOC0xNzYgMTc2czc4LjggMTc2IDE3NiAxNzYgMTc2LTc4LjggMTc2LTE3Ni03OC44LTE3Ni0xNzYtMTc2em0wIDI4OGMtNjEuOSAwLTExMi01MC4xLTExMi0xMTJzNTAuMS0xMTIgMTEyLTExMiAxMTIgNTAuMSAxMTIgMTEyLTUwLjEgMTEyLTExMiAxMTJ6IiAvPjwvc3ZnPg==) */
var EyeOutlined_RefIcon = /*#__PURE__*/react.forwardRef(EyeOutlined_EyeOutlined);
if (false) {}
/* harmony default export */ var icons_EyeOutlined = (EyeOutlined_RefIcon);
// EXTERNAL MODULE: ./node_modules/rc-util/es/omit.js
var omit = __webpack_require__(98423);
;// CONCATENATED MODULE: ./node_modules/antd/es/input/Password.js
"use client";

var Password_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};










const defaultIconRender = visible => visible ? /*#__PURE__*/react.createElement(icons_EyeOutlined, null) : /*#__PURE__*/react.createElement(icons_EyeInvisibleOutlined, null);
const actionMap = {
  click: 'onClick',
  hover: 'onMouseOver'
};
const Password = /*#__PURE__*/react.forwardRef((props, ref) => {
  const {
    visibilityToggle = true
  } = props;
  const visibilityControlled = typeof visibilityToggle === 'object' && visibilityToggle.visible !== undefined;
  const [visible, setVisible] = (0,react.useState)(() => visibilityControlled ? visibilityToggle.visible : false);
  const inputRef = (0,react.useRef)(null);
  react.useEffect(() => {
    if (visibilityControlled) {
      setVisible(visibilityToggle.visible);
    }
  }, [visibilityControlled, visibilityToggle]);
  // Remove Password value
  const removePasswordTimeout = useRemovePasswordTimeout(inputRef);
  const onVisibleChange = () => {
    const {
      disabled
    } = props;
    if (disabled) {
      return;
    }
    if (visible) {
      removePasswordTimeout();
    }
    setVisible(prevState => {
      var _a;
      const newState = !prevState;
      if (typeof visibilityToggle === 'object') {
        (_a = visibilityToggle.onVisibleChange) === null || _a === void 0 ? void 0 : _a.call(visibilityToggle, newState);
      }
      return newState;
    });
  };
  const getIcon = prefixCls => {
    const {
      action = 'click',
      iconRender = defaultIconRender
    } = props;
    const iconTrigger = actionMap[action] || '';
    const icon = iconRender(visible);
    const iconProps = {
      [iconTrigger]: onVisibleChange,
      className: `${prefixCls}-icon`,
      key: 'passwordIcon',
      onMouseDown: e => {
        // Prevent focused state lost
        // https://github.com/ant-design/ant-design/issues/15173
        e.preventDefault();
      },
      onMouseUp: e => {
        // Prevent caret position change
        // https://github.com/ant-design/ant-design/issues/23524
        e.preventDefault();
      }
    };
    return /*#__PURE__*/react.cloneElement( /*#__PURE__*/react.isValidElement(icon) ? icon : /*#__PURE__*/react.createElement("span", null, icon), iconProps);
  };
  const {
      className,
      prefixCls: customizePrefixCls,
      inputPrefixCls: customizeInputPrefixCls,
      size
    } = props,
    restProps = Password_rest(props, ["className", "prefixCls", "inputPrefixCls", "size"]);
  const {
    getPrefixCls
  } = react.useContext(context/* ConfigContext */.E_);
  const inputPrefixCls = getPrefixCls('input', customizeInputPrefixCls);
  const prefixCls = getPrefixCls('input-password', customizePrefixCls);
  const suffixIcon = visibilityToggle && getIcon(prefixCls);
  const inputClassName = classnames_default()(prefixCls, className, {
    [`${prefixCls}-${size}`]: !!size
  });
  const omittedProps = Object.assign(Object.assign({}, (0,omit/* default */.Z)(restProps, ['suffix', 'iconRender', 'visibilityToggle'])), {
    type: visible ? 'text' : 'password',
    className: inputClassName,
    prefixCls: inputPrefixCls,
    suffix: suffixIcon
  });
  if (size) {
    omittedProps.size = size;
  }
  return /*#__PURE__*/react.createElement(input_Input, Object.assign({
    ref: (0,es_ref/* composeRef */.sQ)(ref, inputRef)
  }, omittedProps));
});
if (false) {}
/* harmony default export */ var input_Password = (Password);
// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/SearchOutlined.js + 1 modules
var SearchOutlined = __webpack_require__(68795);
// EXTERNAL MODULE: ./node_modules/antd/es/_util/reactNode.js
var reactNode = __webpack_require__(96159);
// EXTERNAL MODULE: ./node_modules/antd/es/button/index.js + 15 modules
var es_button = __webpack_require__(45093);
;// CONCATENATED MODULE: ./node_modules/antd/es/input/Search.js
"use client";

var Search_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};










const Search = /*#__PURE__*/react.forwardRef((props, ref) => {
  const {
      prefixCls: customizePrefixCls,
      inputPrefixCls: customizeInputPrefixCls,
      className,
      size: customizeSize,
      suffix,
      enterButton = false,
      addonAfter,
      loading,
      disabled,
      onSearch: customOnSearch,
      onChange: customOnChange,
      onCompositionStart,
      onCompositionEnd
    } = props,
    restProps = Search_rest(props, ["prefixCls", "inputPrefixCls", "className", "size", "suffix", "enterButton", "addonAfter", "loading", "disabled", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd"]);
  const {
    getPrefixCls,
    direction
  } = react.useContext(context/* ConfigContext */.E_);
  const composedRef = react.useRef(false);
  const prefixCls = getPrefixCls('input-search', customizePrefixCls);
  const inputPrefixCls = getPrefixCls('input', customizeInputPrefixCls);
  const {
    compactSize
  } = (0,Compact/* useCompactItemContext */.ri)(prefixCls, direction);
  const size = (0,useSize/* default */.Z)(ctx => {
    var _a;
    return (_a = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
  });
  const inputRef = react.useRef(null);
  const onChange = e => {
    if (e && e.target && e.type === 'click' && customOnSearch) {
      customOnSearch(e.target.value, e, {
        source: 'clear'
      });
    }
    if (customOnChange) {
      customOnChange(e);
    }
  };
  const onMouseDown = e => {
    var _a;
    if (document.activeElement === ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input)) {
      e.preventDefault();
    }
  };
  const onSearch = e => {
    var _a, _b;
    if (customOnSearch) {
      customOnSearch((_b = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) === null || _b === void 0 ? void 0 : _b.value, e, {
        source: 'input'
      });
    }
  };
  const onPressEnter = e => {
    if (composedRef.current || loading) {
      return;
    }
    onSearch(e);
  };
  const searchIcon = typeof enterButton === 'boolean' ? /*#__PURE__*/react.createElement(SearchOutlined/* default */.Z, null) : null;
  const btnClassName = `${prefixCls}-button`;
  let button;
  const enterButtonAsElement = enterButton || {};
  const isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
  if (isAntdButton || enterButtonAsElement.type === 'button') {
    button = (0,reactNode/* cloneElement */.Tm)(enterButtonAsElement, Object.assign({
      onMouseDown,
      onClick: e => {
        var _a, _b;
        (_b = (_a = enterButtonAsElement === null || enterButtonAsElement === void 0 ? void 0 : enterButtonAsElement.props) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);
        onSearch(e);
      },
      key: 'enterButton'
    }, isAntdButton ? {
      className: btnClassName,
      size
    } : {}));
  } else {
    button = /*#__PURE__*/react.createElement(es_button/* default */.ZP, {
      className: btnClassName,
      type: enterButton ? 'primary' : undefined,
      size: size,
      disabled: disabled,
      key: "enterButton",
      onMouseDown: onMouseDown,
      onClick: onSearch,
      loading: loading,
      icon: searchIcon
    }, enterButton);
  }
  if (addonAfter) {
    button = [button, (0,reactNode/* cloneElement */.Tm)(addonAfter, {
      key: 'addonAfter'
    })];
  }
  const cls = classnames_default()(prefixCls, {
    [`${prefixCls}-rtl`]: direction === 'rtl',
    [`${prefixCls}-${size}`]: !!size,
    [`${prefixCls}-with-button`]: !!enterButton
  }, className);
  const handleOnCompositionStart = e => {
    composedRef.current = true;
    onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e);
  };
  const handleOnCompositionEnd = e => {
    composedRef.current = false;
    onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e);
  };
  return /*#__PURE__*/react.createElement(input_Input, Object.assign({
    ref: (0,es_ref/* composeRef */.sQ)(inputRef, ref),
    onPressEnter: onPressEnter
  }, restProps, {
    size: size,
    onCompositionStart: handleOnCompositionStart,
    onCompositionEnd: handleOnCompositionEnd,
    prefixCls: inputPrefixCls,
    addonAfter: button,
    suffix: suffix,
    onChange: onChange,
    className: cls,
    disabled: disabled
  }));
});
if (false) {}
/* harmony default export */ var input_Search = (Search);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(4942);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__(1413);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js + 1 modules
var slicedToArray = __webpack_require__(97685);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js + 1 modules
var objectWithoutProperties = __webpack_require__(91);
// EXTERNAL MODULE: ./node_modules/rc-input/es/hooks/useCount.js
var useCount = __webpack_require__(82234);
// EXTERNAL MODULE: ./node_modules/rc-input/es/utils/commonUtils.js
var commonUtils = __webpack_require__(87887);
// EXTERNAL MODULE: ./node_modules/rc-util/es/hooks/useMergedState.js
var useMergedState = __webpack_require__(21770);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__(71002);
// EXTERNAL MODULE: ./node_modules/rc-resize-observer/es/index.js + 5 modules
var rc_resize_observer_es = __webpack_require__(9220);
// EXTERNAL MODULE: ./node_modules/rc-util/es/hooks/useLayoutEffect.js
var useLayoutEffect = __webpack_require__(8410);
;// CONCATENATED MODULE: ./node_modules/rc-textarea/es/calculateNodeHeight.js
// Thanks to https://github.com/andreypopp/react-textarea-autosize/

/**
 * calculateNodeHeight(uiTextNode, useCache = false)
 */

var HIDDEN_TEXTAREA_STYLE = "\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important;\n  pointer-events: none !important;\n";
var SIZING_STYLE = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'font-variant', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing', 'word-break', 'white-space'];
var computedStyleCache = {};
var hiddenTextarea;
function calculateNodeStyling(node) {
  var useCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var nodeRef = node.getAttribute('id') || node.getAttribute('data-reactid') || node.getAttribute('name');
  if (useCache && computedStyleCache[nodeRef]) {
    return computedStyleCache[nodeRef];
  }
  var style = window.getComputedStyle(node);
  var boxSizing = style.getPropertyValue('box-sizing') || style.getPropertyValue('-moz-box-sizing') || style.getPropertyValue('-webkit-box-sizing');
  var paddingSize = parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top'));
  var borderSize = parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width'));
  var sizingStyle = SIZING_STYLE.map(function (name) {
    return "".concat(name, ":").concat(style.getPropertyValue(name));
  }).join(';');
  var nodeInfo = {
    sizingStyle: sizingStyle,
    paddingSize: paddingSize,
    borderSize: borderSize,
    boxSizing: boxSizing
  };
  if (useCache && nodeRef) {
    computedStyleCache[nodeRef] = nodeInfo;
  }
  return nodeInfo;
}
function calculateAutoSizeStyle(uiTextNode) {
  var useCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var minRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var maxRows = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement('textarea');
    hiddenTextarea.setAttribute('tab-index', '-1');
    hiddenTextarea.setAttribute('aria-hidden', 'true');
    document.body.appendChild(hiddenTextarea);
  }

  // Fix wrap="off" issue
  // https://github.com/ant-design/ant-design/issues/6577
  if (uiTextNode.getAttribute('wrap')) {
    hiddenTextarea.setAttribute('wrap', uiTextNode.getAttribute('wrap'));
  } else {
    hiddenTextarea.removeAttribute('wrap');
  }

  // Copy all CSS properties that have an impact on the height of the content in
  // the textbox
  var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache),
    paddingSize = _calculateNodeStyling.paddingSize,
    borderSize = _calculateNodeStyling.borderSize,
    boxSizing = _calculateNodeStyling.boxSizing,
    sizingStyle = _calculateNodeStyling.sizingStyle;

  // Need to have the overflow attribute to hide the scrollbar otherwise
  // text-lines will not calculated properly as the shadow will technically be
  // narrower for content
  hiddenTextarea.setAttribute('style', "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
  hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || '';
  var minHeight = undefined;
  var maxHeight = undefined;
  var overflowY;
  var height = hiddenTextarea.scrollHeight;
  if (boxSizing === 'border-box') {
    // border-box: add border, since height = content + padding + border
    height += borderSize;
  } else if (boxSizing === 'content-box') {
    // remove padding, since height = content
    height -= paddingSize;
  }
  if (minRows !== null || maxRows !== null) {
    // measure height of a textarea with a single row
    hiddenTextarea.value = ' ';
    var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
    if (minRows !== null) {
      minHeight = singleRowHeight * minRows;
      if (boxSizing === 'border-box') {
        minHeight = minHeight + paddingSize + borderSize;
      }
      height = Math.max(minHeight, height);
    }
    if (maxRows !== null) {
      maxHeight = singleRowHeight * maxRows;
      if (boxSizing === 'border-box') {
        maxHeight = maxHeight + paddingSize + borderSize;
      }
      overflowY = height > maxHeight ? '' : 'hidden';
      height = Math.min(maxHeight, height);
    }
  }
  var style = {
    height: height,
    overflowY: overflowY,
    resize: 'none'
  };
  if (minHeight) {
    style.minHeight = minHeight;
  }
  if (maxHeight) {
    style.maxHeight = maxHeight;
  }
  return style;
}
;// CONCATENATED MODULE: ./node_modules/rc-textarea/es/ResizableTextArea.js






var _excluded = ["prefixCls", "onPressEnter", "defaultValue", "value", "autoSize", "onResize", "className", "style", "disabled", "onChange", "onInternalAutoSize"];







var RESIZE_START = 0;
var RESIZE_MEASURING = 1;
var RESIZE_STABLE = 2;
var ResizableTextArea = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var _ref = props,
    prefixCls = _ref.prefixCls,
    onPressEnter = _ref.onPressEnter,
    defaultValue = _ref.defaultValue,
    value = _ref.value,
    autoSize = _ref.autoSize,
    onResize = _ref.onResize,
    className = _ref.className,
    style = _ref.style,
    disabled = _ref.disabled,
    onChange = _ref.onChange,
    onInternalAutoSize = _ref.onInternalAutoSize,
    restProps = (0,objectWithoutProperties/* default */.Z)(_ref, _excluded);

  // =============================== Value ================================
  var _useMergedState = (0,useMergedState/* default */.Z)(defaultValue, {
      value: value,
      postState: function postState(val) {
        return val !== null && val !== void 0 ? val : '';
      }
    }),
    _useMergedState2 = (0,slicedToArray/* default */.Z)(_useMergedState, 2),
    mergedValue = _useMergedState2[0],
    setMergedValue = _useMergedState2[1];
  var onInternalChange = function onInternalChange(event) {
    setMergedValue(event.target.value);
    onChange === null || onChange === void 0 || onChange(event);
  };

  // ================================ Ref =================================
  var textareaRef = react.useRef();
  react.useImperativeHandle(ref, function () {
    return {
      textArea: textareaRef.current
    };
  });

  // ============================== AutoSize ==============================
  var _React$useMemo = react.useMemo(function () {
      if (autoSize && (0,esm_typeof/* default */.Z)(autoSize) === 'object') {
        return [autoSize.minRows, autoSize.maxRows];
      }
      return [];
    }, [autoSize]),
    _React$useMemo2 = (0,slicedToArray/* default */.Z)(_React$useMemo, 2),
    minRows = _React$useMemo2[0],
    maxRows = _React$useMemo2[1];
  var needAutoSize = !!autoSize;

  // =============================== Scroll ===============================
  // https://github.com/ant-design/ant-design/issues/21870
  var fixFirefoxAutoScroll = function fixFirefoxAutoScroll() {
    try {
      // FF has bug with jump of scroll to top. We force back here.
      if (document.activeElement === textareaRef.current) {
        var _textareaRef$current = textareaRef.current,
          selectionStart = _textareaRef$current.selectionStart,
          selectionEnd = _textareaRef$current.selectionEnd,
          scrollTop = _textareaRef$current.scrollTop;

        // Fix Safari bug which not rollback when break line
        // This makes Chinese IME can't input. Do not fix this
        // const { value: tmpValue } = textareaRef.current;
        // textareaRef.current.value = '';
        // textareaRef.current.value = tmpValue;

        textareaRef.current.setSelectionRange(selectionStart, selectionEnd);
        textareaRef.current.scrollTop = scrollTop;
      }
    } catch (e) {
      // Fix error in Chrome:
      // Failed to read the 'selectionStart' property from 'HTMLInputElement'
      // http://stackoverflow.com/q/21177489/3040605
    }
  };

  // =============================== Resize ===============================
  var _React$useState = react.useState(RESIZE_STABLE),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    resizeState = _React$useState2[0],
    setResizeState = _React$useState2[1];
  var _React$useState3 = react.useState(),
    _React$useState4 = (0,slicedToArray/* default */.Z)(_React$useState3, 2),
    autoSizeStyle = _React$useState4[0],
    setAutoSizeStyle = _React$useState4[1];
  var startResize = function startResize() {
    setResizeState(RESIZE_START);
    if (false) {}
  };

  // Change to trigger resize measure
  (0,useLayoutEffect/* default */.Z)(function () {
    if (needAutoSize) {
      startResize();
    }
  }, [value, minRows, maxRows, needAutoSize]);
  (0,useLayoutEffect/* default */.Z)(function () {
    if (resizeState === RESIZE_START) {
      setResizeState(RESIZE_MEASURING);
    } else if (resizeState === RESIZE_MEASURING) {
      var textareaStyles = calculateAutoSizeStyle(textareaRef.current, false, minRows, maxRows);

      // Safari has bug that text will keep break line on text cut when it's prev is break line.
      // ZombieJ: This not often happen. So we just skip it.
      // const { selectionStart, selectionEnd, scrollTop } = textareaRef.current;
      // const { value: tmpValue } = textareaRef.current;
      // textareaRef.current.value = '';
      // textareaRef.current.value = tmpValue;

      // if (document.activeElement === textareaRef.current) {
      //   textareaRef.current.scrollTop = scrollTop;
      //   textareaRef.current.setSelectionRange(selectionStart, selectionEnd);
      // }

      setResizeState(RESIZE_STABLE);
      setAutoSizeStyle(textareaStyles);
    } else {
      fixFirefoxAutoScroll();
    }
  }, [resizeState]);

  // We lock resize trigger by raf to avoid Safari warning
  var resizeRafRef = react.useRef();
  var cleanRaf = function cleanRaf() {
    raf/* default */.Z.cancel(resizeRafRef.current);
  };
  var onInternalResize = function onInternalResize(size) {
    if (resizeState === RESIZE_STABLE) {
      onResize === null || onResize === void 0 || onResize(size);
      if (autoSize) {
        cleanRaf();
        resizeRafRef.current = (0,raf/* default */.Z)(function () {
          startResize();
        });
      }
    }
  };
  react.useEffect(function () {
    return cleanRaf;
  }, []);

  // =============================== Render ===============================
  var mergedAutoSizeStyle = needAutoSize ? autoSizeStyle : null;
  var mergedStyle = (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, style), mergedAutoSizeStyle);
  if (resizeState === RESIZE_START || resizeState === RESIZE_MEASURING) {
    mergedStyle.overflowY = 'hidden';
    mergedStyle.overflowX = 'hidden';
  }
  return /*#__PURE__*/react.createElement(rc_resize_observer_es/* default */.Z, {
    onResize: onInternalResize,
    disabled: !(autoSize || onResize)
  }, /*#__PURE__*/react.createElement("textarea", (0,esm_extends/* default */.Z)({}, restProps, {
    ref: textareaRef,
    style: mergedStyle,
    className: classnames_default()(prefixCls, className, (0,defineProperty/* default */.Z)({}, "".concat(prefixCls, "-disabled"), disabled)),
    disabled: disabled,
    value: mergedValue,
    onChange: onInternalChange
  })));
});
/* harmony default export */ var es_ResizableTextArea = (ResizableTextArea);
;// CONCATENATED MODULE: ./node_modules/rc-textarea/es/TextArea.js






var TextArea_excluded = ["defaultValue", "value", "onFocus", "onBlur", "onChange", "allowClear", "maxLength", "onCompositionStart", "onCompositionEnd", "suffix", "prefixCls", "showCount", "count", "className", "style", "disabled", "hidden", "classNames", "styles", "onResize"];







var TextArea = /*#__PURE__*/react.forwardRef(function (_ref, ref) {
  var _countConfig$max, _clsx;
  var defaultValue = _ref.defaultValue,
    customValue = _ref.value,
    onFocus = _ref.onFocus,
    onBlur = _ref.onBlur,
    onChange = _ref.onChange,
    allowClear = _ref.allowClear,
    maxLength = _ref.maxLength,
    onCompositionStart = _ref.onCompositionStart,
    onCompositionEnd = _ref.onCompositionEnd,
    suffix = _ref.suffix,
    _ref$prefixCls = _ref.prefixCls,
    prefixCls = _ref$prefixCls === void 0 ? 'rc-textarea' : _ref$prefixCls,
    showCount = _ref.showCount,
    count = _ref.count,
    className = _ref.className,
    style = _ref.style,
    disabled = _ref.disabled,
    hidden = _ref.hidden,
    classNames = _ref.classNames,
    styles = _ref.styles,
    onResize = _ref.onResize,
    rest = (0,objectWithoutProperties/* default */.Z)(_ref, TextArea_excluded);
  var _useMergedState = (0,useMergedState/* default */.Z)(defaultValue, {
      value: customValue,
      defaultValue: defaultValue
    }),
    _useMergedState2 = (0,slicedToArray/* default */.Z)(_useMergedState, 2),
    value = _useMergedState2[0],
    setValue = _useMergedState2[1];
  var formatValue = value === undefined || value === null ? '' : String(value);
  var _React$useState = react.useState(false),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    focused = _React$useState2[0],
    setFocused = _React$useState2[1];
  var compositionRef = react.useRef(false);
  var _React$useState3 = react.useState(null),
    _React$useState4 = (0,slicedToArray/* default */.Z)(_React$useState3, 2),
    textareaResized = _React$useState4[0],
    setTextareaResized = _React$useState4[1];

  // =============================== Ref ================================
  var resizableTextAreaRef = (0,react.useRef)(null);
  var getTextArea = function getTextArea() {
    var _resizableTextAreaRef;
    return (_resizableTextAreaRef = resizableTextAreaRef.current) === null || _resizableTextAreaRef === void 0 ? void 0 : _resizableTextAreaRef.textArea;
  };
  var focus = function focus() {
    getTextArea().focus();
  };
  (0,react.useImperativeHandle)(ref, function () {
    return {
      resizableTextArea: resizableTextAreaRef.current,
      focus: focus,
      blur: function blur() {
        getTextArea().blur();
      }
    };
  });
  (0,react.useEffect)(function () {
    setFocused(function (prev) {
      return !disabled && prev;
    });
  }, [disabled]);

  // =========================== Select Range ===========================
  var _React$useState5 = react.useState(null),
    _React$useState6 = (0,slicedToArray/* default */.Z)(_React$useState5, 2),
    selection = _React$useState6[0],
    setSelection = _React$useState6[1];
  react.useEffect(function () {
    if (selection) {
      var _getTextArea;
      (_getTextArea = getTextArea()).setSelectionRange.apply(_getTextArea, (0,toConsumableArray/* default */.Z)(selection));
    }
  }, [selection]);

  // ============================== Count ===============================
  var countConfig = (0,useCount/* default */.Z)(count, showCount);
  var mergedMax = (_countConfig$max = countConfig.max) !== null && _countConfig$max !== void 0 ? _countConfig$max : maxLength;

  // Max length value
  var hasMaxLength = Number(mergedMax) > 0;
  var valueLength = countConfig.strategy(formatValue);
  var isOutOfRange = !!mergedMax && valueLength > mergedMax;

  // ============================== Change ==============================
  var triggerChange = function triggerChange(e, currentValue) {
    var cutValue = currentValue;
    if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
      cutValue = countConfig.exceedFormatter(currentValue, {
        max: countConfig.max
      });
      if (currentValue !== cutValue) {
        setSelection([getTextArea().selectionStart || 0, getTextArea().selectionEnd || 0]);
      }
    }
    setValue(cutValue);
    (0,commonUtils/* resolveOnChange */.rJ)(e.currentTarget, e, onChange, cutValue);
  };

  // =========================== Value Update ===========================
  var onInternalCompositionStart = function onInternalCompositionStart(e) {
    compositionRef.current = true;
    onCompositionStart === null || onCompositionStart === void 0 || onCompositionStart(e);
  };
  var onInternalCompositionEnd = function onInternalCompositionEnd(e) {
    compositionRef.current = false;
    triggerChange(e, e.currentTarget.value);
    onCompositionEnd === null || onCompositionEnd === void 0 || onCompositionEnd(e);
  };
  var onInternalChange = function onInternalChange(e) {
    triggerChange(e, e.target.value);
  };
  var handleKeyDown = function handleKeyDown(e) {
    var onPressEnter = rest.onPressEnter,
      onKeyDown = rest.onKeyDown;
    if (e.key === 'Enter' && onPressEnter) {
      onPressEnter(e);
    }
    onKeyDown === null || onKeyDown === void 0 || onKeyDown(e);
  };
  var handleFocus = function handleFocus(e) {
    setFocused(true);
    onFocus === null || onFocus === void 0 || onFocus(e);
  };
  var handleBlur = function handleBlur(e) {
    setFocused(false);
    onBlur === null || onBlur === void 0 || onBlur(e);
  };

  // ============================== Reset ===============================
  var handleReset = function handleReset(e) {
    setValue('');
    focus();
    (0,commonUtils/* resolveOnChange */.rJ)(getTextArea(), e, onChange);
  };
  var suffixNode = suffix;
  var dataCount;
  if (countConfig.show) {
    if (countConfig.showFormatter) {
      dataCount = countConfig.showFormatter({
        value: formatValue,
        count: valueLength,
        maxLength: mergedMax
      });
    } else {
      dataCount = "".concat(valueLength).concat(hasMaxLength ? " / ".concat(mergedMax) : '');
    }
    suffixNode = /*#__PURE__*/react.createElement(react.Fragment, null, suffixNode, /*#__PURE__*/react.createElement("span", {
      className: classnames_default()("".concat(prefixCls, "-data-count"), classNames === null || classNames === void 0 ? void 0 : classNames.count),
      style: styles === null || styles === void 0 ? void 0 : styles.count
    }, dataCount));
  }
  var handleResize = function handleResize(size) {
    var _getTextArea2;
    onResize === null || onResize === void 0 || onResize(size);
    if ((_getTextArea2 = getTextArea()) !== null && _getTextArea2 !== void 0 && _getTextArea2.style.height) {
      setTextareaResized(true);
    }
  };
  var isPureTextArea = !rest.autoSize && !showCount && !allowClear;
  return /*#__PURE__*/react.createElement(es/* BaseInput */.Q, {
    value: formatValue,
    allowClear: allowClear,
    handleReset: handleReset,
    suffix: suffixNode,
    prefixCls: prefixCls,
    classNames: (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, classNames), {}, {
      affixWrapper: classnames_default()(classNames === null || classNames === void 0 ? void 0 : classNames.affixWrapper, (_clsx = {}, (0,defineProperty/* default */.Z)(_clsx, "".concat(prefixCls, "-show-count"), showCount), (0,defineProperty/* default */.Z)(_clsx, "".concat(prefixCls, "-textarea-allow-clear"), allowClear), _clsx))
    }),
    disabled: disabled,
    focused: focused,
    className: classnames_default()(className, isOutOfRange && "".concat(prefixCls, "-out-of-range")),
    style: (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, style), textareaResized && !isPureTextArea ? {
      height: 'auto'
    } : {}),
    dataAttrs: {
      affixWrapper: {
        'data-count': typeof dataCount === 'string' ? dataCount : undefined
      }
    },
    hidden: hidden
  }, /*#__PURE__*/react.createElement(es_ResizableTextArea, (0,esm_extends/* default */.Z)({}, rest, {
    maxLength: maxLength,
    onKeyDown: handleKeyDown,
    onChange: onInternalChange,
    onFocus: handleFocus,
    onBlur: handleBlur,
    onCompositionStart: onInternalCompositionStart,
    onCompositionEnd: onInternalCompositionEnd,
    className: classnames_default()(classNames === null || classNames === void 0 ? void 0 : classNames.textarea),
    style: (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, styles === null || styles === void 0 ? void 0 : styles.textarea), {}, {
      resize: style === null || style === void 0 ? void 0 : style.resize
    }),
    disabled: disabled,
    prefixCls: prefixCls,
    onResize: handleResize,
    ref: resizableTextAreaRef
  })));
});
/* harmony default export */ var es_TextArea = (TextArea);
;// CONCATENATED MODULE: ./node_modules/rc-textarea/es/index.js


/* harmony default export */ var rc_textarea_es = (es_TextArea);
;// CONCATENATED MODULE: ./node_modules/antd/es/input/TextArea.js
"use client";

var TextArea_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};















const TextArea_TextArea = /*#__PURE__*/(0,react.forwardRef)((props, ref) => {
  var _a, _b;
  const {
      prefixCls: customizePrefixCls,
      bordered = true,
      size: customizeSize,
      disabled: customDisabled,
      status: customStatus,
      allowClear,
      classNames: classes,
      rootClassName,
      className,
      style,
      styles,
      variant: customVariant
    } = props,
    rest = TextArea_rest(props, ["prefixCls", "bordered", "size", "disabled", "status", "allowClear", "classNames", "rootClassName", "className", "style", "styles", "variant"]);
  if (false) {}
  const {
    getPrefixCls,
    direction,
    textArea
  } = react.useContext(context/* ConfigContext */.E_);
  // ===================== Size =====================
  const mergedSize = (0,useSize/* default */.Z)(customizeSize);
  // ===================== Disabled =====================
  const disabled = react.useContext(DisabledContext/* default */.Z);
  const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
  // ===================== Status =====================
  const {
    status: contextStatus,
    hasFeedback,
    feedbackIcon
  } = react.useContext(form_context/* FormItemInputContext */.aM);
  const mergedStatus = (0,statusUtils/* getMergedStatus */.F)(contextStatus, customStatus);
  // ===================== Ref =====================
  const innerRef = react.useRef(null);
  react.useImperativeHandle(ref, () => {
    var _a;
    return {
      resizableTextArea: (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.resizableTextArea,
      focus: option => {
        var _a, _b;
        triggerFocus((_b = (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.resizableTextArea) === null || _b === void 0 ? void 0 : _b.textArea, option);
      },
      blur: () => {
        var _a;
        return (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.blur();
      }
    };
  });
  const prefixCls = getPrefixCls('input', customizePrefixCls);
  // ===================== Style =====================
  const rootCls = (0,useCSSVarCls/* default */.Z)(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = (0,input_style/* default */.ZP)(prefixCls, rootCls);
  const [variant, enableVariantCls] = (0,useVariants/* default */.Z)(customVariant, bordered);
  const mergedAllowClear = _util_getAllowClear(allowClear !== null && allowClear !== void 0 ? allowClear : textArea === null || textArea === void 0 ? void 0 : textArea.allowClear);
  return wrapCSSVar( /*#__PURE__*/react.createElement(rc_textarea_es, Object.assign({
    autoComplete: textArea === null || textArea === void 0 ? void 0 : textArea.autoComplete
  }, rest, {
    style: Object.assign(Object.assign({}, textArea === null || textArea === void 0 ? void 0 : textArea.style), style),
    styles: Object.assign(Object.assign({}, textArea === null || textArea === void 0 ? void 0 : textArea.styles), styles),
    disabled: mergedDisabled,
    allowClear: mergedAllowClear,
    className: classnames_default()(cssVarCls, rootCls, className, rootClassName, textArea === null || textArea === void 0 ? void 0 : textArea.className),
    classNames: Object.assign(Object.assign(Object.assign({}, classes), textArea === null || textArea === void 0 ? void 0 : textArea.classNames), {
      textarea: classnames_default()({
        [`${prefixCls}-sm`]: mergedSize === 'small',
        [`${prefixCls}-lg`]: mergedSize === 'large'
      }, hashId, classes === null || classes === void 0 ? void 0 : classes.textarea, (_a = textArea === null || textArea === void 0 ? void 0 : textArea.classNames) === null || _a === void 0 ? void 0 : _a.textarea),
      variant: classnames_default()({
        [`${prefixCls}-${variant}`]: enableVariantCls
      }, (0,statusUtils/* getStatusClassNames */.Z)(prefixCls, mergedStatus)),
      affixWrapper: classnames_default()(`${prefixCls}-textarea-affix-wrapper`, {
        [`${prefixCls}-affix-wrapper-rtl`]: direction === 'rtl',
        [`${prefixCls}-affix-wrapper-sm`]: mergedSize === 'small',
        [`${prefixCls}-affix-wrapper-lg`]: mergedSize === 'large',
        [`${prefixCls}-textarea-show-count`]: props.showCount || ((_b = props.count) === null || _b === void 0 ? void 0 : _b.show)
      }, hashId)
    }),
    prefixCls: prefixCls,
    suffix: hasFeedback && /*#__PURE__*/react.createElement("span", {
      className: `${prefixCls}-textarea-suffix`
    }, feedbackIcon),
    ref: innerRef
  })));
});
/* harmony default export */ var input_TextArea = (TextArea_TextArea);
;// CONCATENATED MODULE: ./node_modules/antd/es/input/index.js
"use client";







const es_input_Input = input_Input;
es_input_Input.Group = input_Group;
es_input_Input.Search = input_Search;
es_input_Input.TextArea = input_TextArea;
es_input_Input.Password = input_Password;
es_input_Input.OTP = input_OTP;
/* harmony default export */ var input = (es_input_Input);

/***/ }),

/***/ 47673:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ik: function() { return /* binding */ genBasicInputStyle; },
/* harmony export */   nz: function() { return /* binding */ genPlaceholderStyle; },
/* harmony export */   s7: function() { return /* binding */ genInputGroupStyle; }
/* harmony export */ });
/* unused harmony exports genActiveStyle, genInputSmallStyle */
/* harmony import */ var _ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54548);
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14747);
/* harmony import */ var _style_compact_item__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(80110);
/* harmony import */ var _theme_internal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(92030);
/* harmony import */ var _theme_internal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(45503);
/* harmony import */ var _token__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(20353);
/* harmony import */ var _variants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(93900);







const genPlaceholderStyle = color => ({
  // Firefox
  '&::-moz-placeholder': {
    opacity: 1
  },
  '&::placeholder': {
    color,
    userSelect: 'none' // https://github.com/ant-design/ant-design/pull/32639
  },
  '&:placeholder-shown': {
    textOverflow: 'ellipsis'
  }
});
const genActiveStyle = token => ({
  borderColor: token.activeBorderColor,
  boxShadow: token.activeShadow,
  outline: 0,
  backgroundColor: token.activeBg
});
const genInputLargeStyle = token => {
  const {
    paddingBlockLG,
    lineHeightLG,
    borderRadiusLG,
    paddingInlineLG
  } = token;
  return {
    padding: `${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(paddingBlockLG)} ${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(paddingInlineLG)}`,
    fontSize: token.inputFontSizeLG,
    lineHeight: lineHeightLG,
    borderRadius: borderRadiusLG
  };
};
const genInputSmallStyle = token => ({
  padding: `${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.paddingBlockSM)} ${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.paddingInlineSM)}`,
  fontSize: token.inputFontSizeSM,
  borderRadius: token.borderRadiusSM
});
const genBasicInputStyle = token => Object.assign(Object.assign({
  position: 'relative',
  display: 'inline-block',
  width: '100%',
  minWidth: 0,
  padding: `${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.paddingBlock)} ${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.paddingInline)}`,
  color: token.colorText,
  fontSize: token.inputFontSize,
  lineHeight: token.lineHeight,
  borderRadius: token.borderRadius,
  transition: `all ${token.motionDurationMid}`
}, genPlaceholderStyle(token.colorTextPlaceholder)), {
  // Reset height for `textarea`s
  'textarea&': {
    maxWidth: '100%',
    // prevent textarea resize from coming out of its container
    height: 'auto',
    minHeight: token.controlHeight,
    lineHeight: token.lineHeight,
    verticalAlign: 'bottom',
    transition: `all ${token.motionDurationSlow}, height 0s`,
    resize: 'vertical'
  },
  // Size
  '&-lg': Object.assign({}, genInputLargeStyle(token)),
  '&-sm': Object.assign({}, genInputSmallStyle(token)),
  // RTL
  '&-rtl': {
    direction: 'rtl'
  },
  '&-textarea-rtl': {
    direction: 'rtl'
  }
});
const genInputGroupStyle = token => {
  const {
    componentCls,
    antCls
  } = token;
  return {
    position: 'relative',
    display: 'table',
    width: '100%',
    borderCollapse: 'separate',
    borderSpacing: 0,
    // Undo padding and float of grid classes
    [`&[class*='col-']`]: {
      paddingInlineEnd: token.paddingXS,
      '&:last-child': {
        paddingInlineEnd: 0
      }
    },
    // Sizing options
    [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: Object.assign({}, genInputLargeStyle(token)),
    [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: Object.assign({}, genInputSmallStyle(token)),
    // Fix https://github.com/ant-design/ant-design/issues/5754
    [`&-lg ${antCls}-select-single ${antCls}-select-selector`]: {
      height: token.controlHeightLG
    },
    [`&-sm ${antCls}-select-single ${antCls}-select-selector`]: {
      height: token.controlHeightSM
    },
    [`> ${componentCls}`]: {
      display: 'table-cell',
      '&:not(:first-child):not(:last-child)': {
        borderRadius: 0
      }
    },
    [`${componentCls}-group`]: {
      [`&-addon, &-wrap`]: {
        display: 'table-cell',
        width: 1,
        whiteSpace: 'nowrap',
        verticalAlign: 'middle',
        '&:not(:first-child):not(:last-child)': {
          borderRadius: 0
        }
      },
      '&-wrap > *': {
        display: 'block !important'
      },
      '&-addon': {
        position: 'relative',
        padding: `0 ${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.paddingInline)}`,
        color: token.colorText,
        fontWeight: 'normal',
        fontSize: token.inputFontSize,
        textAlign: 'center',
        borderRadius: token.borderRadius,
        transition: `all ${token.motionDurationSlow}`,
        lineHeight: 1,
        // Reset Select's style in addon
        [`${antCls}-select`]: {
          margin: `${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.calc(token.paddingBlock).add(1).mul(-1).equal())} ${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.calc(token.paddingInline).mul(-1).equal())}`,
          [`&${antCls}-select-single:not(${antCls}-select-customize-input):not(${antCls}-pagination-size-changer)`]: {
            [`${antCls}-select-selector`]: {
              backgroundColor: 'inherit',
              border: `${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.lineWidth)} ${token.lineType} transparent`,
              boxShadow: 'none'
            }
          },
          '&-open, &-focused': {
            [`${antCls}-select-selector`]: {
              color: token.colorPrimary
            }
          }
        },
        // https://github.com/ant-design/ant-design/issues/31333
        [`${antCls}-cascader-picker`]: {
          margin: `-9px ${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.calc(token.paddingInline).mul(-1).equal())}`,
          backgroundColor: 'transparent',
          [`${antCls}-cascader-input`]: {
            textAlign: 'start',
            border: 0,
            boxShadow: 'none'
          }
        }
      }
    },
    [`${componentCls}`]: {
      width: '100%',
      marginBottom: 0,
      textAlign: 'inherit',
      '&:focus': {
        zIndex: 1,
        // Fix https://gw.alipayobjects.com/zos/rmsportal/DHNpoqfMXSfrSnlZvhsJ.png
        borderInlineEndWidth: 1
      },
      '&:hover': {
        zIndex: 1,
        borderInlineEndWidth: 1,
        [`${componentCls}-search-with-button &`]: {
          zIndex: 0
        }
      }
    },
    // Reset rounded corners
    [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
      borderStartEndRadius: 0,
      borderEndEndRadius: 0,
      // Reset Select's style in addon
      [`${antCls}-select ${antCls}-select-selector`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${componentCls}-affix-wrapper`]: {
      [`&:not(:first-child) ${componentCls}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      },
      [`&:not(:last-child) ${componentCls}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      // Reset Select's style in addon
      [`${antCls}-select ${antCls}-select-selector`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`${componentCls}-affix-wrapper`]: {
      '&:not(:last-child)': {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${componentCls}-search &`]: {
          borderStartStartRadius: token.borderRadius,
          borderEndStartRadius: token.borderRadius
        }
      },
      [`&:not(:first-child), ${componentCls}-search &:not(:first-child)`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&${componentCls}-group-compact`]: Object.assign(Object.assign({
      display: 'block'
    }, (0,_style__WEBPACK_IMPORTED_MODULE_1__/* .clearFix */ .dF)()), {
      [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
        '&:not(:first-child):not(:last-child)': {
          borderInlineEndWidth: token.lineWidth,
          '&:hover': {
            zIndex: 1
          },
          '&:focus': {
            zIndex: 1
          }
        }
      },
      '& > *': {
        display: 'inline-block',
        float: 'none',
        verticalAlign: 'top',
        // https://github.com/ant-design/ant-design-pro/issues/139
        borderRadius: 0
      },
      [`
        & > ${componentCls}-affix-wrapper,
        & > ${componentCls}-number-affix-wrapper,
        & > ${antCls}-picker-range
      `]: {
        display: 'inline-flex'
      },
      '& > *:not(:last-child)': {
        marginInlineEnd: token.calc(token.lineWidth).mul(-1).equal(),
        borderInlineEndWidth: token.lineWidth
      },
      // Undo float for .ant-input-group .ant-input
      [`${componentCls}`]: {
        float: 'none'
      },
      // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
      [`& > ${antCls}-select > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
        borderInlineEndWidth: token.lineWidth,
        borderRadius: 0,
        '&:hover': {
          zIndex: 1
        },
        '&:focus': {
          zIndex: 1
        }
      },
      [`& > ${antCls}-select-focused`]: {
        zIndex: 1
      },
      // update z-index for arrow icon
      [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
        zIndex: 1 // https://github.com/ant-design/ant-design/issues/20371
      },
      [`& > *:first-child,
      & > ${antCls}-select:first-child > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
        borderStartStartRadius: token.borderRadius,
        borderEndStartRadius: token.borderRadius
      },
      [`& > *:last-child,
      & > ${antCls}-select:last-child > ${antCls}-select-selector,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
        borderInlineEndWidth: token.lineWidth,
        borderStartEndRadius: token.borderRadius,
        borderEndEndRadius: token.borderRadius
      },
      // https://github.com/ant-design/ant-design/issues/12493
      [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
        verticalAlign: 'top'
      },
      [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
        marginInlineStart: token.calc(token.lineWidth).mul(-1).equal(),
        [`${componentCls}-affix-wrapper`]: {
          borderRadius: 0
        }
      },
      [`${componentCls}-group-wrapper:not(:last-child)`]: {
        [`&${componentCls}-search > ${componentCls}-group`]: {
          [`& > ${componentCls}-group-addon > ${componentCls}-search-button`]: {
            borderRadius: 0
          },
          [`& > ${componentCls}`]: {
            borderStartStartRadius: token.borderRadius,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            borderEndStartRadius: token.borderRadius
          }
        }
      }
    })
  };
};
const genInputStyle = token => {
  const {
    componentCls,
    controlHeightSM,
    lineWidth,
    calc
  } = token;
  const FIXED_CHROME_COLOR_HEIGHT = 16;
  const colorSmallPadding = calc(controlHeightSM).sub(calc(lineWidth).mul(2)).sub(FIXED_CHROME_COLOR_HEIGHT).div(2).equal();
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (0,_style__WEBPACK_IMPORTED_MODULE_1__/* .resetComponent */ .Wf)(token)), genBasicInputStyle(token)), (0,_variants__WEBPACK_IMPORTED_MODULE_2__/* .genOutlinedStyle */ .qG)(token)), (0,_variants__WEBPACK_IMPORTED_MODULE_2__/* .genFilledStyle */ .H8)(token)), (0,_variants__WEBPACK_IMPORTED_MODULE_2__/* .genBorderlessStyle */ .Mu)(token)), {
      '&[type="color"]': {
        height: token.controlHeight,
        [`&${componentCls}-lg`]: {
          height: token.controlHeightLG
        },
        [`&${componentCls}-sm`]: {
          height: controlHeightSM,
          paddingTop: colorSmallPadding,
          paddingBottom: colorSmallPadding
        }
      },
      '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
        '-webkit-appearance': 'none'
      }
    })
  };
};
const genAllowClearStyle = token => {
  const {
    componentCls
  } = token;
  return {
    // ========================= Input =========================
    [`${componentCls}-clear-icon`]: {
      margin: 0,
      color: token.colorTextQuaternary,
      fontSize: token.fontSizeIcon,
      verticalAlign: -1,
      // https://github.com/ant-design/ant-design/pull/18151
      // https://codesandbox.io/s/wizardly-sun-u10br
      cursor: 'pointer',
      transition: `color ${token.motionDurationSlow}`,
      '&:hover': {
        color: token.colorTextTertiary
      },
      '&:active': {
        color: token.colorText
      },
      '&-hidden': {
        visibility: 'hidden'
      },
      '&-has-suffix': {
        margin: `0 ${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.inputAffixPadding)}`
      }
    }
  };
};
const genAffixStyle = token => {
  const {
    componentCls,
    inputAffixPadding,
    colorTextDescription,
    motionDurationSlow,
    colorIcon,
    colorIconHover,
    iconCls
  } = token;
  const affixCls = `${componentCls}-affix-wrapper`;
  return {
    [affixCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token)), {
      display: 'inline-flex',
      [`&:not(${componentCls}-disabled):hover`]: {
        zIndex: 1,
        [`${componentCls}-search-with-button &`]: {
          zIndex: 0
        }
      },
      '&-focused, &:focus': {
        zIndex: 1
      },
      [`> input${componentCls}`]: {
        padding: 0
      },
      [`> input${componentCls}, > textarea${componentCls}`]: {
        fontSize: 'inherit',
        border: 'none',
        borderRadius: 0,
        outline: 'none',
        background: 'transparent',
        color: 'inherit',
        '&::-ms-reveal': {
          display: 'none'
        },
        '&:focus': {
          boxShadow: 'none !important'
        }
      },
      '&::before': {
        display: 'inline-block',
        width: 0,
        visibility: 'hidden',
        content: '"\\a0"'
      },
      [`${componentCls}`]: {
        '&-prefix, &-suffix': {
          display: 'flex',
          flex: 'none',
          alignItems: 'center',
          '> *:not(:last-child)': {
            marginInlineEnd: token.paddingXS
          }
        },
        '&-show-count-suffix': {
          color: colorTextDescription
        },
        '&-show-count-has-suffix': {
          marginInlineEnd: token.paddingXXS
        },
        '&-prefix': {
          marginInlineEnd: inputAffixPadding
        },
        '&-suffix': {
          marginInlineStart: inputAffixPadding
        }
      }
    }), genAllowClearStyle(token)), {
      // password
      [`${iconCls}${componentCls}-password-icon`]: {
        color: colorIcon,
        cursor: 'pointer',
        transition: `all ${motionDurationSlow}`,
        '&:hover': {
          color: colorIconHover
        }
      }
    })
  };
};
const genGroupStyle = token => {
  const {
    componentCls,
    borderRadiusLG,
    borderRadiusSM
  } = token;
  return {
    [`${componentCls}-group`]: Object.assign(Object.assign(Object.assign({}, (0,_style__WEBPACK_IMPORTED_MODULE_1__/* .resetComponent */ .Wf)(token)), genInputGroupStyle(token)), {
      '&-rtl': {
        direction: 'rtl'
      },
      '&-wrapper': Object.assign(Object.assign(Object.assign({
        display: 'inline-block',
        width: '100%',
        textAlign: 'start',
        verticalAlign: 'top',
        '&-rtl': {
          direction: 'rtl'
        },
        // Size
        '&-lg': {
          [`${componentCls}-group-addon`]: {
            borderRadius: borderRadiusLG,
            fontSize: token.inputFontSizeLG
          }
        },
        '&-sm': {
          [`${componentCls}-group-addon`]: {
            borderRadius: borderRadiusSM
          }
        }
      }, (0,_variants__WEBPACK_IMPORTED_MODULE_2__/* .genOutlinedGroupStyle */ .ir)(token)), (0,_variants__WEBPACK_IMPORTED_MODULE_2__/* .genFilledGroupStyle */ .S5)(token)), {
        // '&-disabled': {
        //   [`${componentCls}-group-addon`]: {
        //     ...genDisabledStyle(token),
        //   },
        // },
        // Fix the issue of using icons in Space Compact mode
        // https://github.com/ant-design/ant-design/issues/42122
        [`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
          [`${componentCls}, ${componentCls}-group-addon`]: {
            borderRadius: 0
          }
        },
        [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: {
          [`${componentCls}, ${componentCls}-group-addon`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: {
          [`${componentCls}, ${componentCls}-group-addon`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        // Fix the issue of input use show-count param in space compact mode
        // https://github.com/ant-design/ant-design/issues/46872
        [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
          [`${componentCls}-affix-wrapper`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        }
      })
    })
  };
};
const genSearchInputStyle = token => {
  const {
    componentCls,
    antCls
  } = token;
  const searchPrefixCls = `${componentCls}-search`;
  return {
    [searchPrefixCls]: {
      [`${componentCls}`]: {
        '&:hover, &:focus': {
          borderColor: token.colorPrimaryHover,
          [`+ ${componentCls}-group-addon ${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
            borderInlineStartColor: token.colorPrimaryHover
          }
        }
      },
      [`${componentCls}-affix-wrapper`]: {
        borderRadius: 0
      },
      // fix slight height diff in Firefox:
      // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
      [`${componentCls}-lg`]: {
        lineHeight: token.calc(token.lineHeightLG).sub(0.0002).equal({
          unit: false
        })
      },
      [`> ${componentCls}-group`]: {
        [`> ${componentCls}-group-addon:last-child`]: {
          insetInlineStart: -1,
          padding: 0,
          border: 0,
          [`${searchPrefixCls}-button`]: {
            // Fix https://github.com/ant-design/ant-design/issues/47150
            marginInlineEnd: -1,
            paddingTop: 0,
            paddingBottom: 0,
            borderStartStartRadius: 0,
            borderStartEndRadius: token.borderRadius,
            borderEndEndRadius: token.borderRadius,
            borderEndStartRadius: 0,
            boxShadow: 'none'
          },
          [`${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
            color: token.colorTextDescription,
            '&:hover': {
              color: token.colorPrimaryHover
            },
            '&:active': {
              color: token.colorPrimaryActive
            },
            [`&${antCls}-btn-loading::before`]: {
              insetInlineStart: 0,
              insetInlineEnd: 0,
              insetBlockStart: 0,
              insetBlockEnd: 0
            }
          }
        }
      },
      [`${searchPrefixCls}-button`]: {
        height: token.controlHeight,
        '&:hover, &:focus': {
          zIndex: 1
        }
      },
      [`&-large ${searchPrefixCls}-button`]: {
        height: token.controlHeightLG
      },
      [`&-small ${searchPrefixCls}-button`]: {
        height: token.controlHeightSM
      },
      '&-rtl': {
        direction: 'rtl'
      },
      // ===================== Compact Item Customized Styles =====================
      [`&${componentCls}-compact-item`]: {
        [`&:not(${componentCls}-compact-last-item)`]: {
          [`${componentCls}-group-addon`]: {
            [`${componentCls}-search-button`]: {
              marginInlineEnd: token.calc(token.lineWidth).mul(-1).equal(),
              borderRadius: 0
            }
          }
        },
        [`&:not(${componentCls}-compact-first-item)`]: {
          [`${componentCls},${componentCls}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`> ${componentCls}-group-addon ${componentCls}-search-button,
        > ${componentCls},
        ${componentCls}-affix-wrapper`]: {
          '&:hover,&:focus,&:active': {
            zIndex: 2
          }
        },
        [`> ${componentCls}-affix-wrapper-focused`]: {
          zIndex: 2
        }
      }
    }
  };
};
const genTextAreaStyle = token => {
  const {
    componentCls,
    paddingLG
  } = token;
  const textareaPrefixCls = `${componentCls}-textarea`;
  return {
    [textareaPrefixCls]: {
      position: 'relative',
      '&-show-count': {
        // https://github.com/ant-design/ant-design/issues/33049
        [`> ${componentCls}`]: {
          height: '100%'
        },
        [`${componentCls}-data-count`]: {
          position: 'absolute',
          bottom: token.calc(token.fontSize).mul(token.lineHeight).mul(-1).equal(),
          insetInlineEnd: 0,
          color: token.colorTextDescription,
          whiteSpace: 'nowrap',
          pointerEvents: 'none'
        }
      },
      '&-allow-clear': {
        [`> ${componentCls}`]: {
          paddingInlineEnd: paddingLG
        }
      },
      [`&-affix-wrapper${textareaPrefixCls}-has-feedback`]: {
        [`${componentCls}`]: {
          paddingInlineEnd: paddingLG
        }
      },
      [`&-affix-wrapper${componentCls}-affix-wrapper`]: {
        padding: 0,
        [`> textarea${componentCls}`]: {
          fontSize: 'inherit',
          border: 'none',
          outline: 'none',
          background: 'transparent',
          '&:focus': {
            boxShadow: 'none !important'
          }
        },
        [`${componentCls}-suffix`]: {
          margin: 0,
          '> *:not(:last-child)': {
            marginInline: 0
          },
          // Clear Icon
          [`${componentCls}-clear-icon`]: {
            position: 'absolute',
            insetInlineEnd: token.paddingXS,
            insetBlockStart: token.paddingXS
          },
          // Feedback Icon
          [`${textareaPrefixCls}-suffix`]: {
            position: 'absolute',
            top: 0,
            insetInlineEnd: token.paddingInline,
            bottom: 0,
            zIndex: 1,
            display: 'inline-flex',
            alignItems: 'center',
            margin: 'auto',
            pointerEvents: 'none'
          }
        }
      }
    }
  };
};
// ============================== Range ===============================
const genRangeStyle = token => {
  const {
    componentCls
  } = token;
  return {
    [`${componentCls}-out-of-range`]: {
      [`&, & input, & textarea, ${componentCls}-show-count-suffix, ${componentCls}-data-count`]: {
        color: token.colorError
      }
    }
  };
};
// ============================== Export ==============================
/* harmony default export */ __webpack_exports__.ZP = ((0,_theme_internal__WEBPACK_IMPORTED_MODULE_3__/* .genStyleHooks */ .I$)('Input', token => {
  const inputToken = (0,_theme_internal__WEBPACK_IMPORTED_MODULE_4__/* .merge */ .TS)(token, (0,_token__WEBPACK_IMPORTED_MODULE_5__/* .initInputToken */ .e)(token));
  return [genInputStyle(inputToken), genTextAreaStyle(inputToken), genAffixStyle(inputToken), genGroupStyle(inputToken), genSearchInputStyle(inputToken), genRangeStyle(inputToken),
  // =====================================================
  // ==             Space Compact                       ==
  // =====================================================
  (0,_style_compact_item__WEBPACK_IMPORTED_MODULE_6__/* .genCompactItemStyle */ .c)(inputToken)];
}, _token__WEBPACK_IMPORTED_MODULE_5__/* .initComponentToken */ .T, {
  resetFont: false
}));

/***/ }),

/***/ 20353:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: function() { return /* binding */ initComponentToken; },
/* harmony export */   e: function() { return /* binding */ initInputToken; }
/* harmony export */ });
/* harmony import */ var _theme_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45503);

function initInputToken(token) {
  return (0,_theme_internal__WEBPACK_IMPORTED_MODULE_0__/* .merge */ .TS)(token, {
    inputAffixPadding: token.paddingXXS
  });
}
const initComponentToken = token => {
  const {
    controlHeight,
    fontSize,
    lineHeight,
    lineWidth,
    controlHeightSM,
    controlHeightLG,
    fontSizeLG,
    lineHeightLG,
    paddingSM,
    controlPaddingHorizontalSM,
    controlPaddingHorizontal,
    colorFillAlter,
    colorPrimaryHover,
    colorPrimary,
    controlOutlineWidth,
    controlOutline,
    colorErrorOutline,
    colorWarningOutline,
    colorBgContainer
  } = token;
  return {
    paddingBlock: Math.max(Math.round((controlHeight - fontSize * lineHeight) / 2 * 10) / 10 - lineWidth, 0),
    paddingBlockSM: Math.max(Math.round((controlHeightSM - fontSize * lineHeight) / 2 * 10) / 10 - lineWidth, 0),
    paddingBlockLG: Math.ceil((controlHeightLG - fontSizeLG * lineHeightLG) / 2 * 10) / 10 - lineWidth,
    paddingInline: paddingSM - lineWidth,
    paddingInlineSM: controlPaddingHorizontalSM - lineWidth,
    paddingInlineLG: controlPaddingHorizontal - lineWidth,
    addonBg: colorFillAlter,
    activeBorderColor: colorPrimary,
    hoverBorderColor: colorPrimaryHover,
    activeShadow: `0 0 0 ${controlOutlineWidth}px ${controlOutline}`,
    errorActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorErrorOutline}`,
    warningActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorWarningOutline}`,
    hoverBg: colorBgContainer,
    activeBg: colorBgContainer,
    inputFontSize: fontSize,
    inputFontSizeLG: fontSizeLG,
    inputFontSizeSM: fontSize
  };
};

/***/ }),

/***/ 93900:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H8: function() { return /* binding */ genFilledStyle; },
/* harmony export */   Mu: function() { return /* binding */ genBorderlessStyle; },
/* harmony export */   S5: function() { return /* binding */ genFilledGroupStyle; },
/* harmony export */   ir: function() { return /* binding */ genOutlinedGroupStyle; },
/* harmony export */   qG: function() { return /* binding */ genOutlinedStyle; }
/* harmony export */ });
/* unused harmony exports genHoverStyle, genDisabledStyle, genBaseOutlinedStyle */
/* harmony import */ var _ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54548);
/* harmony import */ var _theme_internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45503);


const genHoverStyle = token => ({
  borderColor: token.hoverBorderColor,
  backgroundColor: token.hoverBg
});
const genDisabledStyle = token => ({
  color: token.colorTextDisabled,
  backgroundColor: token.colorBgContainerDisabled,
  borderColor: token.colorBorder,
  boxShadow: 'none',
  cursor: 'not-allowed',
  opacity: 1,
  [`input[disabled], textarea[disabled]`]: {
    cursor: 'not-allowed'
  },
  '&:hover:not([disabled])': Object.assign({}, genHoverStyle((0,_theme_internal__WEBPACK_IMPORTED_MODULE_1__/* .merge */ .TS)(token, {
    hoverBorderColor: token.colorBorder,
    hoverBg: token.colorBgContainerDisabled
  })))
});
/* ============== Outlined ============== */
const genBaseOutlinedStyle = (token, options) => ({
  background: token.colorBgContainer,
  borderWidth: token.lineWidth,
  borderStyle: token.lineType,
  borderColor: options.borderColor,
  '&:hover': {
    borderColor: options.hoverBorderColor,
    backgroundColor: token.hoverBg
  },
  '&:focus, &:focus-within': {
    borderColor: options.activeBorderColor,
    boxShadow: options.activeShadow,
    outline: 0,
    backgroundColor: token.activeBg
  }
});
const genOutlinedStatusStyle = (token, options) => ({
  [`&${token.componentCls}-status-${options.status}:not(${token.componentCls}-disabled)`]: Object.assign(Object.assign({}, genBaseOutlinedStyle(token, options)), {
    [`${token.componentCls}-prefix, ${token.componentCls}-suffix`]: {
      color: options.affixColor
    }
  })
});
const genOutlinedStyle = (token, extraStyles) => ({
  '&-outlined': Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseOutlinedStyle(token, {
    borderColor: token.colorBorder,
    hoverBorderColor: token.hoverBorderColor,
    activeBorderColor: token.activeBorderColor,
    activeShadow: token.activeShadow
  })), {
    [`&${token.componentCls}-disabled, &[disabled]`]: Object.assign({}, genDisabledStyle(token))
  }), genOutlinedStatusStyle(token, {
    status: 'error',
    borderColor: token.colorError,
    hoverBorderColor: token.colorErrorBorderHover,
    activeBorderColor: token.colorError,
    activeShadow: token.errorActiveShadow,
    affixColor: token.colorError
  })), genOutlinedStatusStyle(token, {
    status: 'warning',
    borderColor: token.colorWarning,
    hoverBorderColor: token.colorWarningBorderHover,
    activeBorderColor: token.colorWarning,
    activeShadow: token.warningActiveShadow,
    affixColor: token.colorWarning
  })), extraStyles)
});
const genOutlinedGroupStatusStyle = (token, options) => ({
  [`&${token.componentCls}-group-wrapper-status-${options.status}`]: {
    [`${token.componentCls}-group-addon`]: {
      borderColor: options.addonBorderColor,
      color: options.addonColor
    }
  }
});
const genOutlinedGroupStyle = token => ({
  '&-outlined': Object.assign(Object.assign(Object.assign({
    [`${token.componentCls}-group`]: {
      '&-addon': {
        background: token.addonBg,
        border: `${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.lineWidth)} ${token.lineType} ${token.colorBorder}`
      },
      '&-addon:first-child': {
        borderInlineEnd: 0
      },
      '&-addon:last-child': {
        borderInlineStart: 0
      }
    }
  }, genOutlinedGroupStatusStyle(token, {
    status: 'error',
    addonBorderColor: token.colorError,
    addonColor: token.colorErrorText
  })), genOutlinedGroupStatusStyle(token, {
    status: 'warning',
    addonBorderColor: token.colorWarning,
    addonColor: token.colorWarningText
  })), {
    [`&${token.componentCls}-group-wrapper-disabled`]: {
      [`${token.componentCls}-group-addon`]: Object.assign({}, genDisabledStyle(token))
    }
  })
});
/* ============ Borderless ============ */
const genBorderlessStyle = (token, extraStyles) => ({
  '&-borderless': Object.assign({
    background: 'transparent',
    border: 'none',
    '&:focus, &:focus-within': {
      outline: 'none'
    },
    [`&${token.componentCls}-disabled, &[disabled]`]: {
      color: token.colorTextDisabled
    }
  }, extraStyles)
});
/* ============== Filled ============== */
const genBaseFilledStyle = (token, options) => ({
  background: options.bg,
  borderWidth: token.lineWidth,
  borderStyle: token.lineType,
  borderColor: 'transparent',
  [`input&, & input, textarea&, & textarea`]: {
    color: options === null || options === void 0 ? void 0 : options.inputColor
  },
  '&:hover': {
    background: options.hoverBg
  },
  '&:focus, &:focus-within': {
    outline: 0,
    borderColor: options.activeBorderColor,
    backgroundColor: token.activeBg
  }
});
const genFilledStatusStyle = (token, options) => ({
  [`&${token.componentCls}-status-${options.status}:not(${token.componentCls}-disabled)`]: Object.assign(Object.assign({}, genBaseFilledStyle(token, options)), {
    [`${token.componentCls}-prefix, ${token.componentCls}-suffix`]: {
      color: options.affixColor
    }
  })
});
const genFilledStyle = (token, extraStyles) => ({
  '&-filled': Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseFilledStyle(token, {
    bg: token.colorFillTertiary,
    hoverBg: token.colorFillSecondary,
    activeBorderColor: token.colorPrimary
  })), {
    [`&${token.componentCls}-disabled, &[disabled]`]: Object.assign({}, genDisabledStyle(token))
  }), genFilledStatusStyle(token, {
    status: 'error',
    bg: token.colorErrorBg,
    hoverBg: token.colorErrorBgHover,
    activeBorderColor: token.colorError,
    inputColor: token.colorErrorText,
    affixColor: token.colorError
  })), genFilledStatusStyle(token, {
    status: 'warning',
    bg: token.colorWarningBg,
    hoverBg: token.colorWarningBgHover,
    activeBorderColor: token.colorWarning,
    inputColor: token.colorWarningText,
    affixColor: token.colorWarning
  })), extraStyles)
});
const genFilledGroupStatusStyle = (token, options) => ({
  [`&${token.componentCls}-group-wrapper-status-${options.status}`]: {
    [`${token.componentCls}-group-addon`]: {
      background: options.addonBg,
      color: options.addonColor
    }
  }
});
const genFilledGroupStyle = token => ({
  '&-filled': Object.assign(Object.assign(Object.assign({
    [`${token.componentCls}-group`]: {
      '&-addon': {
        background: token.colorFillTertiary
      },
      [`${token.componentCls}-filled:not(:focus):not(:focus-within)`]: {
        '&:not(:first-child)': {
          borderInlineStart: `${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.lineWidth)} ${token.lineType} ${token.colorSplit}`
        },
        '&:not(:last-child)': {
          borderInlineEnd: `${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.lineWidth)} ${token.lineType} ${token.colorSplit}`
        }
      }
    }
  }, genFilledGroupStatusStyle(token, {
    status: 'error',
    addonBg: token.colorErrorBg,
    addonColor: token.colorErrorText
  })), genFilledGroupStatusStyle(token, {
    status: 'warning',
    addonBg: token.colorWarningBg,
    addonColor: token.colorWarningText
  })), {
    [`&${token.componentCls}-group-wrapper-disabled`]: {
      [`${token.componentCls}-group`]: {
        '&-addon': {
          background: token.colorFillTertiary,
          color: token.colorTextDisabled
        },
        '&-addon:first-child': {
          borderInlineStart: `${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.lineWidth)} ${token.lineType} ${token.colorBorder}`,
          borderTop: `${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.lineWidth)} ${token.lineType} ${token.colorBorder}`,
          borderBottom: `${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.lineWidth)} ${token.lineType} ${token.colorBorder}`
        },
        '&-addon:last-child': {
          borderInlineEnd: `${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.lineWidth)} ${token.lineType} ${token.colorBorder}`,
          borderTop: `${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.lineWidth)} ${token.lineType} ${token.colorBorder}`,
          borderBottom: `${(0,_ant_design_cssinjs__WEBPACK_IMPORTED_MODULE_0__/* .unit */ .bf)(token.lineWidth)} ${token.lineType} ${token.colorBorder}`
        }
      }
    }
  })
});

/***/ }),

/***/ 92783:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: function() { return /* binding */ segmented; }
});

// EXTERNAL MODULE: ./node_modules/@umijs/preset-umi/node_modules/react/index.js
var react = __webpack_require__(62435);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(93967);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(87462);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js + 1 modules
var slicedToArray = __webpack_require__(97685);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js + 1 modules
var objectWithoutProperties = __webpack_require__(91);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(4942);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__(1413);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__(71002);
// EXTERNAL MODULE: ./node_modules/rc-util/es/hooks/useMergedState.js
var useMergedState = __webpack_require__(21770);
// EXTERNAL MODULE: ./node_modules/rc-util/es/ref.js
var es_ref = __webpack_require__(42550);
// EXTERNAL MODULE: ./node_modules/rc-util/es/omit.js
var omit = __webpack_require__(98423);
// EXTERNAL MODULE: ./node_modules/rc-motion/es/index.js + 12 modules
var es = __webpack_require__(82225);
// EXTERNAL MODULE: ./node_modules/rc-util/es/hooks/useLayoutEffect.js
var useLayoutEffect = __webpack_require__(8410);
;// CONCATENATED MODULE: ./node_modules/rc-segmented/es/MotionThumb.js







var calcThumbStyle = function calcThumbStyle(targetElement) {
  return targetElement ? {
    left: targetElement.offsetLeft,
    right: targetElement.parentElement.clientWidth - targetElement.clientWidth - targetElement.offsetLeft,
    width: targetElement.clientWidth
  } : null;
};
var toPX = function toPX(value) {
  return value !== undefined ? "".concat(value, "px") : undefined;
};
function MotionThumb(props) {
  var prefixCls = props.prefixCls,
    containerRef = props.containerRef,
    value = props.value,
    getValueIndex = props.getValueIndex,
    motionName = props.motionName,
    onMotionStart = props.onMotionStart,
    onMotionEnd = props.onMotionEnd,
    direction = props.direction;
  var thumbRef = react.useRef(null);
  var _React$useState = react.useState(value),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    prevValue = _React$useState2[0],
    setPrevValue = _React$useState2[1];

  // =========================== Effect ===========================
  var findValueElement = function findValueElement(val) {
    var _containerRef$current;
    var index = getValueIndex(val);
    var ele = (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.querySelectorAll(".".concat(prefixCls, "-item"))[index];
    return (ele === null || ele === void 0 ? void 0 : ele.offsetParent) && ele;
  };
  var _React$useState3 = react.useState(null),
    _React$useState4 = (0,slicedToArray/* default */.Z)(_React$useState3, 2),
    prevStyle = _React$useState4[0],
    setPrevStyle = _React$useState4[1];
  var _React$useState5 = react.useState(null),
    _React$useState6 = (0,slicedToArray/* default */.Z)(_React$useState5, 2),
    nextStyle = _React$useState6[0],
    setNextStyle = _React$useState6[1];
  (0,useLayoutEffect/* default */.Z)(function () {
    if (prevValue !== value) {
      var prev = findValueElement(prevValue);
      var next = findValueElement(value);
      var calcPrevStyle = calcThumbStyle(prev);
      var calcNextStyle = calcThumbStyle(next);
      setPrevValue(value);
      setPrevStyle(calcPrevStyle);
      setNextStyle(calcNextStyle);
      if (prev && next) {
        onMotionStart();
      } else {
        onMotionEnd();
      }
    }
  }, [value]);
  var thumbStart = react.useMemo(function () {
    return direction === 'rtl' ? toPX(-(prevStyle === null || prevStyle === void 0 ? void 0 : prevStyle.right)) : toPX(prevStyle === null || prevStyle === void 0 ? void 0 : prevStyle.left);
  }, [direction, prevStyle]);
  var thumbActive = react.useMemo(function () {
    return direction === 'rtl' ? toPX(-(nextStyle === null || nextStyle === void 0 ? void 0 : nextStyle.right)) : toPX(nextStyle === null || nextStyle === void 0 ? void 0 : nextStyle.left);
  }, [direction, nextStyle]);

  // =========================== Motion ===========================
  var onAppearStart = function onAppearStart() {
    return {
      transform: "translateX(var(--thumb-start-left))",
      width: "var(--thumb-start-width)"
    };
  };
  var onAppearActive = function onAppearActive() {
    return {
      transform: "translateX(var(--thumb-active-left))",
      width: "var(--thumb-active-width)"
    };
  };
  var onVisibleChanged = function onVisibleChanged() {
    setPrevStyle(null);
    setNextStyle(null);
    onMotionEnd();
  };

  // =========================== Render ===========================
  // No need motion when nothing exist in queue
  if (!prevStyle || !nextStyle) {
    return null;
  }
  return /*#__PURE__*/react.createElement(es/* default */.ZP, {
    visible: true,
    motionName: motionName,
    motionAppear: true,
    onAppearStart: onAppearStart,
    onAppearActive: onAppearActive,
    onVisibleChanged: onVisibleChanged
  }, function (_ref, ref) {
    var motionClassName = _ref.className,
      motionStyle = _ref.style;
    var mergedStyle = (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, motionStyle), {}, {
      '--thumb-start-left': thumbStart,
      '--thumb-start-width': toPX(prevStyle === null || prevStyle === void 0 ? void 0 : prevStyle.width),
      '--thumb-active-left': thumbActive,
      '--thumb-active-width': toPX(nextStyle === null || nextStyle === void 0 ? void 0 : nextStyle.width)
    });

    // It's little ugly which should be refactor when @umi/test update to latest jsdom
    var motionProps = {
      ref: (0,es_ref/* composeRef */.sQ)(thumbRef, ref),
      style: mergedStyle,
      className: classnames_default()("".concat(prefixCls, "-thumb"), motionClassName)
    };
    if (false) {}
    return /*#__PURE__*/react.createElement("div", motionProps);
  });
}
;// CONCATENATED MODULE: ./node_modules/rc-segmented/es/index.js






var _excluded = ["prefixCls", "direction", "options", "disabled", "defaultValue", "value", "onChange", "className", "motionName"];






function getValidTitle(option) {
  if (typeof option.title !== 'undefined') {
    return option.title;
  }

  // read `label` when title is `undefined`
  if ((0,esm_typeof/* default */.Z)(option.label) !== 'object') {
    var _option$label;
    return (_option$label = option.label) === null || _option$label === void 0 ? void 0 : _option$label.toString();
  }
}
function normalizeOptions(options) {
  return options.map(function (option) {
    if ((0,esm_typeof/* default */.Z)(option) === 'object' && option !== null) {
      var validTitle = getValidTitle(option);
      return (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, option), {}, {
        title: validTitle
      });
    }
    return {
      label: option === null || option === void 0 ? void 0 : option.toString(),
      title: option === null || option === void 0 ? void 0 : option.toString(),
      value: option
    };
  });
}
var InternalSegmentedOption = function InternalSegmentedOption(_ref) {
  var prefixCls = _ref.prefixCls,
    className = _ref.className,
    disabled = _ref.disabled,
    checked = _ref.checked,
    label = _ref.label,
    title = _ref.title,
    value = _ref.value,
    onChange = _ref.onChange;
  var handleChange = function handleChange(event) {
    if (disabled) {
      return;
    }
    onChange(event, value);
  };
  return /*#__PURE__*/react.createElement("label", {
    className: classnames_default()(className, (0,defineProperty/* default */.Z)({}, "".concat(prefixCls, "-item-disabled"), disabled))
  }, /*#__PURE__*/react.createElement("input", {
    className: "".concat(prefixCls, "-item-input"),
    type: "radio",
    disabled: disabled,
    checked: checked,
    onChange: handleChange
  }), /*#__PURE__*/react.createElement("div", {
    className: "".concat(prefixCls, "-item-label"),
    title: title
  }, label));
};
var Segmented = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var _segmentedOptions$, _classNames2;
  var _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-segmented' : _props$prefixCls,
    direction = props.direction,
    _props$options = props.options,
    options = _props$options === void 0 ? [] : _props$options,
    disabled = props.disabled,
    defaultValue = props.defaultValue,
    value = props.value,
    onChange = props.onChange,
    _props$className = props.className,
    className = _props$className === void 0 ? '' : _props$className,
    _props$motionName = props.motionName,
    motionName = _props$motionName === void 0 ? 'thumb-motion' : _props$motionName,
    restProps = (0,objectWithoutProperties/* default */.Z)(props, _excluded);
  var containerRef = react.useRef(null);
  var mergedRef = react.useMemo(function () {
    return (0,es_ref/* composeRef */.sQ)(containerRef, ref);
  }, [containerRef, ref]);
  var segmentedOptions = react.useMemo(function () {
    return normalizeOptions(options);
  }, [options]);

  // Note: We should not auto switch value when value not exist in options
  // which may break single source of truth.
  var _useMergedState = (0,useMergedState/* default */.Z)((_segmentedOptions$ = segmentedOptions[0]) === null || _segmentedOptions$ === void 0 ? void 0 : _segmentedOptions$.value, {
      value: value,
      defaultValue: defaultValue
    }),
    _useMergedState2 = (0,slicedToArray/* default */.Z)(_useMergedState, 2),
    rawValue = _useMergedState2[0],
    setRawValue = _useMergedState2[1];

  // ======================= Change ========================
  var _React$useState = react.useState(false),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    thumbShow = _React$useState2[0],
    setThumbShow = _React$useState2[1];
  var handleChange = function handleChange(event, val) {
    if (disabled) {
      return;
    }
    setRawValue(val);
    onChange === null || onChange === void 0 || onChange(val);
  };
  var divProps = (0,omit/* default */.Z)(restProps, ['children']);
  return /*#__PURE__*/react.createElement("div", (0,esm_extends/* default */.Z)({}, divProps, {
    className: classnames_default()(prefixCls, (_classNames2 = {}, (0,defineProperty/* default */.Z)(_classNames2, "".concat(prefixCls, "-rtl"), direction === 'rtl'), (0,defineProperty/* default */.Z)(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _classNames2), className),
    ref: mergedRef
  }), /*#__PURE__*/react.createElement("div", {
    className: "".concat(prefixCls, "-group")
  }, /*#__PURE__*/react.createElement(MotionThumb, {
    prefixCls: prefixCls,
    value: rawValue,
    containerRef: containerRef,
    motionName: "".concat(prefixCls, "-").concat(motionName),
    direction: direction,
    getValueIndex: function getValueIndex(val) {
      return segmentedOptions.findIndex(function (n) {
        return n.value === val;
      });
    },
    onMotionStart: function onMotionStart() {
      setThumbShow(true);
    },
    onMotionEnd: function onMotionEnd() {
      setThumbShow(false);
    }
  }), segmentedOptions.map(function (segmentedOption) {
    return /*#__PURE__*/react.createElement(InternalSegmentedOption, (0,esm_extends/* default */.Z)({}, segmentedOption, {
      key: segmentedOption.value,
      prefixCls: prefixCls,
      className: classnames_default()(segmentedOption.className, "".concat(prefixCls, "-item"), (0,defineProperty/* default */.Z)({}, "".concat(prefixCls, "-item-selected"), segmentedOption.value === rawValue && !thumbShow)),
      checked: segmentedOption.value === rawValue,
      onChange: handleChange,
      disabled: !!disabled || !!segmentedOption.disabled
    }));
  })));
});
if (false) {}
var TypedSegmented = Segmented;
/* harmony default export */ var rc_segmented_es = (TypedSegmented);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/context.js
var context = __webpack_require__(53124);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/hooks/useSize.js
var useSize = __webpack_require__(98675);
// EXTERNAL MODULE: ./node_modules/@ant-design/cssinjs/es/index.js + 35 modules
var cssinjs_es = __webpack_require__(54548);
// EXTERNAL MODULE: ./node_modules/antd/es/style/index.js
var style = __webpack_require__(14747);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/genComponentStyleHook.js + 6 modules
var genComponentStyleHook = __webpack_require__(92030);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/statistic.js
var statistic = __webpack_require__(45503);
;// CONCATENATED MODULE: ./node_modules/antd/es/segmented/style/index.js



// ============================== Mixins ==============================
function getItemDisabledStyle(cls, token) {
  return {
    [`${cls}, ${cls}:hover, ${cls}:focus`]: {
      color: token.colorTextDisabled,
      cursor: 'not-allowed'
    }
  };
}
function getItemSelectedStyle(token) {
  return {
    backgroundColor: token.itemSelectedBg,
    boxShadow: token.boxShadowTertiary
  };
}
const segmentedTextEllipsisCss = Object.assign({
  overflow: 'hidden'
}, style/* textEllipsis */.vS);
// ============================== Styles ==============================
const genSegmentedStyle = token => {
  const {
    componentCls
  } = token;
  const labelHeight = token.calc(token.controlHeight).sub(token.calc(token.trackPadding).mul(2)).equal();
  const labelHeightLG = token.calc(token.controlHeightLG).sub(token.calc(token.trackPadding).mul(2)).equal();
  const labelHeightSM = token.calc(token.controlHeightSM).sub(token.calc(token.trackPadding).mul(2)).equal();
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (0,style/* resetComponent */.Wf)(token)), {
      display: 'inline-block',
      padding: token.trackPadding,
      color: token.itemColor,
      background: token.trackBg,
      borderRadius: token.borderRadius,
      transition: `all ${token.motionDurationMid} ${token.motionEaseInOut}`,
      [`${componentCls}-group`]: {
        position: 'relative',
        display: 'flex',
        alignItems: 'stretch',
        justifyItems: 'flex-start',
        width: '100%'
      },
      // RTL styles
      [`&${componentCls}-rtl`]: {
        direction: 'rtl'
      },
      // block styles
      [`&${componentCls}-block`]: {
        display: 'flex'
      },
      [`&${componentCls}-block ${componentCls}-item`]: {
        flex: 1,
        minWidth: 0
      },
      // item styles
      [`${componentCls}-item`]: {
        position: 'relative',
        textAlign: 'center',
        cursor: 'pointer',
        transition: `color ${token.motionDurationMid} ${token.motionEaseInOut}`,
        borderRadius: token.borderRadiusSM,
        // Fix Safari render bug
        // https://github.com/ant-design/ant-design/issues/45250
        transform: 'translateZ(0)',
        '&-selected': Object.assign(Object.assign({}, getItemSelectedStyle(token)), {
          color: token.itemSelectedColor
        }),
        '&::after': {
          content: '""',
          position: 'absolute',
          zIndex: -1,
          width: '100%',
          height: '100%',
          top: 0,
          insetInlineStart: 0,
          borderRadius: 'inherit',
          transition: `background-color ${token.motionDurationMid}`,
          // This is mandatory to make it not clickable or hoverable
          // Ref: https://github.com/ant-design/ant-design/issues/40888
          pointerEvents: 'none'
        },
        [`&:hover:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)`]: {
          color: token.itemHoverColor,
          '&::after': {
            backgroundColor: token.itemHoverBg
          }
        },
        [`&:active:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)`]: {
          color: token.itemHoverColor,
          '&::after': {
            backgroundColor: token.itemActiveBg
          }
        },
        '&-label': Object.assign({
          minHeight: labelHeight,
          lineHeight: (0,cssinjs_es/* unit */.bf)(labelHeight),
          padding: `0 ${(0,cssinjs_es/* unit */.bf)(token.segmentedPaddingHorizontal)}`
        }, segmentedTextEllipsisCss),
        // syntactic sugar to add `icon` for Segmented Item
        '&-icon + *': {
          marginInlineStart: token.calc(token.marginSM).div(2).equal()
        },
        '&-input': {
          position: 'absolute',
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: 0,
          height: 0,
          opacity: 0,
          pointerEvents: 'none'
        }
      },
      // thumb styles
      [`${componentCls}-thumb`]: Object.assign(Object.assign({}, getItemSelectedStyle(token)), {
        position: 'absolute',
        insetBlockStart: 0,
        insetInlineStart: 0,
        width: 0,
        height: '100%',
        padding: `${(0,cssinjs_es/* unit */.bf)(token.paddingXXS)} 0`,
        borderRadius: token.borderRadiusSM,
        [`& ~ ${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-item-disabled)::after`]: {
          backgroundColor: 'transparent'
        }
      }),
      // size styles
      [`&${componentCls}-lg`]: {
        borderRadius: token.borderRadiusLG,
        [`${componentCls}-item-label`]: {
          minHeight: labelHeightLG,
          lineHeight: (0,cssinjs_es/* unit */.bf)(labelHeightLG),
          padding: `0 ${(0,cssinjs_es/* unit */.bf)(token.segmentedPaddingHorizontal)}`,
          fontSize: token.fontSizeLG
        },
        [`${componentCls}-item, ${componentCls}-thumb`]: {
          borderRadius: token.borderRadius
        }
      },
      [`&${componentCls}-sm`]: {
        borderRadius: token.borderRadiusSM,
        [`${componentCls}-item-label`]: {
          minHeight: labelHeightSM,
          lineHeight: (0,cssinjs_es/* unit */.bf)(labelHeightSM),
          padding: `0 ${(0,cssinjs_es/* unit */.bf)(token.segmentedPaddingHorizontalSM)}`
        },
        [`${componentCls}-item, ${componentCls}-thumb`]: {
          borderRadius: token.borderRadiusXS
        }
      }
    }), getItemDisabledStyle(`&-disabled ${componentCls}-item`, token)), getItemDisabledStyle(`${componentCls}-item-disabled`, token)), {
      // transition effect when `appear-active`
      [`${componentCls}-thumb-motion-appear-active`]: {
        transition: `transform ${token.motionDurationSlow} ${token.motionEaseInOut}, width ${token.motionDurationSlow} ${token.motionEaseInOut}`,
        willChange: 'transform, width'
      }
    })
  };
};
// ============================== Export ==============================
const prepareComponentToken = token => {
  const {
    colorTextLabel,
    colorText,
    colorFillSecondary,
    colorBgElevated,
    colorFill,
    lineWidthBold,
    colorBgLayout
  } = token;
  return {
    trackPadding: lineWidthBold,
    trackBg: colorBgLayout,
    itemColor: colorTextLabel,
    itemHoverColor: colorText,
    itemHoverBg: colorFillSecondary,
    itemSelectedBg: colorBgElevated,
    itemActiveBg: colorFill,
    itemSelectedColor: colorText
  };
};
/* harmony default export */ var segmented_style = ((0,genComponentStyleHook/* genStyleHooks */.I$)('Segmented', token => {
  const {
    lineWidth,
    calc
  } = token;
  const segmentedToken = (0,statistic/* merge */.TS)(token, {
    segmentedPaddingHorizontal: calc(token.controlPaddingHorizontal).sub(lineWidth).equal(),
    segmentedPaddingHorizontalSM: calc(token.controlPaddingHorizontalSM).sub(lineWidth).equal()
  });
  return [genSegmentedStyle(segmentedToken)];
}, prepareComponentToken));
;// CONCATENATED MODULE: ./node_modules/antd/es/segmented/index.js
"use client";

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};






function isSegmentedLabeledOptionWithIcon(option) {
  return typeof option === 'object' && !!(option === null || option === void 0 ? void 0 : option.icon);
}
const InternalSegmented = /*#__PURE__*/react.forwardRef((props, ref) => {
  const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      block,
      options = [],
      size: customSize = 'middle',
      style
    } = props,
    restProps = __rest(props, ["prefixCls", "className", "rootClassName", "block", "options", "size", "style"]);
  const {
    getPrefixCls,
    direction,
    segmented
  } = react.useContext(context/* ConfigContext */.E_);
  const prefixCls = getPrefixCls('segmented', customizePrefixCls);
  // Style
  const [wrapCSSVar, hashId, cssVarCls] = segmented_style(prefixCls);
  // ===================== Size =====================
  const mergedSize = (0,useSize/* default */.Z)(customSize);
  // syntactic sugar to support `icon` for Segmented Item
  const extendedOptions = react.useMemo(() => options.map(option => {
    if (isSegmentedLabeledOptionWithIcon(option)) {
      const {
          icon,
          label
        } = option,
        restOption = __rest(option, ["icon", "label"]);
      return Object.assign(Object.assign({}, restOption), {
        label: ( /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("span", {
          className: `${prefixCls}-item-icon`
        }, icon), label && /*#__PURE__*/react.createElement("span", null, label)))
      });
    }
    return option;
  }), [options, prefixCls]);
  const cls = classnames_default()(className, rootClassName, segmented === null || segmented === void 0 ? void 0 : segmented.className, {
    [`${prefixCls}-block`]: block,
    [`${prefixCls}-sm`]: mergedSize === 'small',
    [`${prefixCls}-lg`]: mergedSize === 'large'
  }, hashId, cssVarCls);
  const mergedStyle = Object.assign(Object.assign({}, segmented === null || segmented === void 0 ? void 0 : segmented.style), style);
  return wrapCSSVar( /*#__PURE__*/react.createElement(rc_segmented_es, Object.assign({}, restProps, {
    className: cls,
    style: mergedStyle,
    options: extendedOptions,
    ref: ref,
    prefixCls: prefixCls,
    direction: direction
  })));
});
const segmented_Segmented = InternalSegmented;
if (false) {}
/* harmony default export */ var segmented = (segmented_Segmented);

/***/ }),

/***/ 21687:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: function() { return /* binding */ skeleton; }
});

// EXTERNAL MODULE: ./node_modules/@umijs/preset-umi/node_modules/react/index.js
var react = __webpack_require__(62435);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(93967);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/context.js
var context = __webpack_require__(53124);
// EXTERNAL MODULE: ./node_modules/rc-util/es/omit.js
var omit = __webpack_require__(98423);
;// CONCATENATED MODULE: ./node_modules/antd/es/skeleton/Element.js
"use client";



const Element = props => {
  const {
    prefixCls,
    className,
    style,
    size,
    shape
  } = props;
  const sizeCls = classnames_default()({
    [`${prefixCls}-lg`]: size === 'large',
    [`${prefixCls}-sm`]: size === 'small'
  });
  const shapeCls = classnames_default()({
    [`${prefixCls}-circle`]: shape === 'circle',
    [`${prefixCls}-square`]: shape === 'square',
    [`${prefixCls}-round`]: shape === 'round'
  });
  const sizeStyle = react.useMemo(() => typeof size === 'number' ? {
    width: size,
    height: size,
    lineHeight: `${size}px`
  } : {}, [size]);
  return /*#__PURE__*/react.createElement("span", {
    className: classnames_default()(prefixCls, sizeCls, shapeCls, className),
    style: Object.assign(Object.assign({}, sizeStyle), style)
  });
};
/* harmony default export */ var skeleton_Element = (Element);
// EXTERNAL MODULE: ./node_modules/@ant-design/cssinjs/es/index.js + 35 modules
var es = __webpack_require__(54548);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/genComponentStyleHook.js + 6 modules
var genComponentStyleHook = __webpack_require__(92030);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/statistic.js
var statistic = __webpack_require__(45503);
;// CONCATENATED MODULE: ./node_modules/antd/es/skeleton/style/index.js


const skeletonClsLoading = new es/* Keyframes */.E4(`ant-skeleton-loading`, {
  '0%': {
    backgroundPosition: '100% 50%'
  },
  '100%': {
    backgroundPosition: '0 50%'
  }
});
const genSkeletonElementCommonSize = size => ({
  height: size,
  lineHeight: (0,es/* unit */.bf)(size)
});
const genSkeletonElementAvatarSize = size => Object.assign({
  width: size
}, genSkeletonElementCommonSize(size));
const genSkeletonColor = token => ({
  background: token.skeletonLoadingBackground,
  backgroundSize: '400% 100%',
  animationName: skeletonClsLoading,
  animationDuration: token.skeletonLoadingMotionDuration,
  animationTimingFunction: 'ease',
  animationIterationCount: 'infinite'
});
const genSkeletonElementInputSize = (size, calc) => Object.assign({
  width: calc(size).mul(5).equal(),
  minWidth: calc(size).mul(5).equal()
}, genSkeletonElementCommonSize(size));
const genSkeletonElementAvatar = token => {
  const {
    skeletonAvatarCls,
    gradientFromColor,
    controlHeight,
    controlHeightLG,
    controlHeightSM
  } = token;
  return {
    [`${skeletonAvatarCls}`]: Object.assign({
      display: 'inline-block',
      verticalAlign: 'top',
      background: gradientFromColor
    }, genSkeletonElementAvatarSize(controlHeight)),
    [`${skeletonAvatarCls}${skeletonAvatarCls}-circle`]: {
      borderRadius: '50%'
    },
    [`${skeletonAvatarCls}${skeletonAvatarCls}-lg`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightLG)),
    [`${skeletonAvatarCls}${skeletonAvatarCls}-sm`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightSM))
  };
};
const genSkeletonElementInput = token => {
  const {
    controlHeight,
    borderRadiusSM,
    skeletonInputCls,
    controlHeightLG,
    controlHeightSM,
    gradientFromColor,
    calc
  } = token;
  return {
    [`${skeletonInputCls}`]: Object.assign({
      display: 'inline-block',
      verticalAlign: 'top',
      background: gradientFromColor,
      borderRadius: borderRadiusSM
    }, genSkeletonElementInputSize(controlHeight, calc)),
    [`${skeletonInputCls}-lg`]: Object.assign({}, genSkeletonElementInputSize(controlHeightLG, calc)),
    [`${skeletonInputCls}-sm`]: Object.assign({}, genSkeletonElementInputSize(controlHeightSM, calc))
  };
};
const genSkeletonElementImageSize = size => Object.assign({
  width: size
}, genSkeletonElementCommonSize(size));
const genSkeletonElementImage = token => {
  const {
    skeletonImageCls,
    imageSizeBase,
    gradientFromColor,
    borderRadiusSM,
    calc
  } = token;
  return {
    [`${skeletonImageCls}`]: Object.assign(Object.assign({
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      verticalAlign: 'top',
      background: gradientFromColor,
      borderRadius: borderRadiusSM
    }, genSkeletonElementImageSize(calc(imageSizeBase).mul(2).equal())), {
      [`${skeletonImageCls}-path`]: {
        fill: '#bfbfbf'
      },
      [`${skeletonImageCls}-svg`]: Object.assign(Object.assign({}, genSkeletonElementImageSize(imageSizeBase)), {
        maxWidth: calc(imageSizeBase).mul(4).equal(),
        maxHeight: calc(imageSizeBase).mul(4).equal()
      }),
      [`${skeletonImageCls}-svg${skeletonImageCls}-svg-circle`]: {
        borderRadius: '50%'
      }
    }),
    [`${skeletonImageCls}${skeletonImageCls}-circle`]: {
      borderRadius: '50%'
    }
  };
};
const genSkeletonElementButtonShape = (token, size, buttonCls) => {
  const {
    skeletonButtonCls
  } = token;
  return {
    [`${buttonCls}${skeletonButtonCls}-circle`]: {
      width: size,
      minWidth: size,
      borderRadius: '50%'
    },
    [`${buttonCls}${skeletonButtonCls}-round`]: {
      borderRadius: size
    }
  };
};
const genSkeletonElementButtonSize = (size, calc) => Object.assign({
  width: calc(size).mul(2).equal(),
  minWidth: calc(size).mul(2).equal()
}, genSkeletonElementCommonSize(size));
const genSkeletonElementButton = token => {
  const {
    borderRadiusSM,
    skeletonButtonCls,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    gradientFromColor,
    calc
  } = token;
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
    [`${skeletonButtonCls}`]: Object.assign({
      display: 'inline-block',
      verticalAlign: 'top',
      background: gradientFromColor,
      borderRadius: borderRadiusSM,
      width: calc(controlHeight).mul(2).equal(),
      minWidth: calc(controlHeight).mul(2).equal()
    }, genSkeletonElementButtonSize(controlHeight, calc))
  }, genSkeletonElementButtonShape(token, controlHeight, skeletonButtonCls)), {
    [`${skeletonButtonCls}-lg`]: Object.assign({}, genSkeletonElementButtonSize(controlHeightLG, calc))
  }), genSkeletonElementButtonShape(token, controlHeightLG, `${skeletonButtonCls}-lg`)), {
    [`${skeletonButtonCls}-sm`]: Object.assign({}, genSkeletonElementButtonSize(controlHeightSM, calc))
  }), genSkeletonElementButtonShape(token, controlHeightSM, `${skeletonButtonCls}-sm`));
};
// =============================== Base ===============================
const genBaseStyle = token => {
  const {
    componentCls,
    skeletonAvatarCls,
    skeletonTitleCls,
    skeletonParagraphCls,
    skeletonButtonCls,
    skeletonInputCls,
    skeletonImageCls,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    gradientFromColor,
    padding,
    marginSM,
    borderRadius,
    titleHeight,
    blockRadius,
    paragraphLiHeight,
    controlHeightXS,
    paragraphMarginTop
  } = token;
  return {
    [`${componentCls}`]: {
      display: 'table',
      width: '100%',
      [`${componentCls}-header`]: {
        display: 'table-cell',
        paddingInlineEnd: padding,
        verticalAlign: 'top',
        // Avatar
        [`${skeletonAvatarCls}`]: Object.assign({
          display: 'inline-block',
          verticalAlign: 'top',
          background: gradientFromColor
        }, genSkeletonElementAvatarSize(controlHeight)),
        [`${skeletonAvatarCls}-circle`]: {
          borderRadius: '50%'
        },
        [`${skeletonAvatarCls}-lg`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightLG)),
        [`${skeletonAvatarCls}-sm`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightSM))
      },
      [`${componentCls}-content`]: {
        display: 'table-cell',
        width: '100%',
        verticalAlign: 'top',
        // Title
        [`${skeletonTitleCls}`]: {
          width: '100%',
          height: titleHeight,
          background: gradientFromColor,
          borderRadius: blockRadius,
          [`+ ${skeletonParagraphCls}`]: {
            marginBlockStart: controlHeightSM
          }
        },
        // paragraph
        [`${skeletonParagraphCls}`]: {
          padding: 0,
          '> li': {
            width: '100%',
            height: paragraphLiHeight,
            listStyle: 'none',
            background: gradientFromColor,
            borderRadius: blockRadius,
            '+ li': {
              marginBlockStart: controlHeightXS
            }
          }
        },
        [`${skeletonParagraphCls}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
          width: '61%'
        }
      },
      [`&-round ${componentCls}-content`]: {
        [`${skeletonTitleCls}, ${skeletonParagraphCls} > li`]: {
          borderRadius
        }
      }
    },
    [`${componentCls}-with-avatar ${componentCls}-content`]: {
      // Title
      [`${skeletonTitleCls}`]: {
        marginBlockStart: marginSM,
        [`+ ${skeletonParagraphCls}`]: {
          marginBlockStart: paragraphMarginTop
        }
      }
    },
    // Skeleton element
    [`${componentCls}${componentCls}-element`]: Object.assign(Object.assign(Object.assign(Object.assign({
      display: 'inline-block',
      width: 'auto'
    }, genSkeletonElementButton(token)), genSkeletonElementAvatar(token)), genSkeletonElementInput(token)), genSkeletonElementImage(token)),
    // Skeleton Block Button, Input
    [`${componentCls}${componentCls}-block`]: {
      width: '100%',
      [`${skeletonButtonCls}`]: {
        width: '100%'
      },
      [`${skeletonInputCls}`]: {
        width: '100%'
      }
    },
    // With active animation
    [`${componentCls}${componentCls}-active`]: {
      [`
        ${skeletonTitleCls},
        ${skeletonParagraphCls} > li,
        ${skeletonAvatarCls},
        ${skeletonButtonCls},
        ${skeletonInputCls},
        ${skeletonImageCls}
      `]: Object.assign({}, genSkeletonColor(token))
    }
  };
};
// ============================== Export ==============================
const prepareComponentToken = token => {
  const {
    colorFillContent,
    colorFill
  } = token;
  const gradientFromColor = colorFillContent;
  const gradientToColor = colorFill;
  return {
    color: gradientFromColor,
    colorGradientEnd: gradientToColor,
    gradientFromColor,
    gradientToColor,
    titleHeight: token.controlHeight / 2,
    blockRadius: token.borderRadiusSM,
    paragraphMarginTop: token.marginLG + token.marginXXS,
    paragraphLiHeight: token.controlHeight / 2
  };
};
/* harmony default export */ var skeleton_style = ((0,genComponentStyleHook/* genStyleHooks */.I$)('Skeleton', token => {
  const {
    componentCls,
    calc
  } = token;
  const skeletonToken = (0,statistic/* merge */.TS)(token, {
    skeletonAvatarCls: `${componentCls}-avatar`,
    skeletonTitleCls: `${componentCls}-title`,
    skeletonParagraphCls: `${componentCls}-paragraph`,
    skeletonButtonCls: `${componentCls}-button`,
    skeletonInputCls: `${componentCls}-input`,
    skeletonImageCls: `${componentCls}-image`,
    imageSizeBase: calc(token.controlHeight).mul(1.5).equal(),
    borderRadius: 100,
    // Large number to make capsule shape
    skeletonLoadingBackground: `linear-gradient(90deg, ${token.gradientFromColor} 25%, ${token.gradientToColor} 37%, ${token.gradientFromColor} 63%)`,
    skeletonLoadingMotionDuration: '1.4s'
  });
  return [genBaseStyle(skeletonToken)];
}, prepareComponentToken, {
  deprecatedTokens: [['color', 'gradientFromColor'], ['colorGradientEnd', 'gradientToColor']]
}));
;// CONCATENATED MODULE: ./node_modules/antd/es/skeleton/Avatar.js
"use client";







const SkeletonAvatar = props => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    active,
    shape = 'circle',
    size = 'default'
  } = props;
  const {
    getPrefixCls
  } = react.useContext(context/* ConfigContext */.E_);
  const prefixCls = getPrefixCls('skeleton', customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = skeleton_style(prefixCls);
  const otherProps = (0,omit/* default */.Z)(props, ['prefixCls', 'className']);
  const cls = classnames_default()(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active
  }, className, rootClassName, hashId, cssVarCls);
  return wrapCSSVar( /*#__PURE__*/react.createElement("div", {
    className: cls
  }, /*#__PURE__*/react.createElement(skeleton_Element, Object.assign({
    prefixCls: `${prefixCls}-avatar`,
    shape: shape,
    size: size
  }, otherProps))));
};
/* harmony default export */ var Avatar = (SkeletonAvatar);
;// CONCATENATED MODULE: ./node_modules/antd/es/skeleton/Button.js
"use client";







const SkeletonButton = props => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    active,
    block = false,
    size = 'default'
  } = props;
  const {
    getPrefixCls
  } = react.useContext(context/* ConfigContext */.E_);
  const prefixCls = getPrefixCls('skeleton', customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = skeleton_style(prefixCls);
  const otherProps = (0,omit/* default */.Z)(props, ['prefixCls']);
  const cls = classnames_default()(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active,
    [`${prefixCls}-block`]: block
  }, className, rootClassName, hashId, cssVarCls);
  return wrapCSSVar( /*#__PURE__*/react.createElement("div", {
    className: cls
  }, /*#__PURE__*/react.createElement(skeleton_Element, Object.assign({
    prefixCls: `${prefixCls}-button`,
    size: size
  }, otherProps))));
};
/* harmony default export */ var Button = (SkeletonButton);
;// CONCATENATED MODULE: ./node_modules/antd/es/skeleton/Image.js
"use client";





const path = 'M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z';
const SkeletonImage = props => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style,
    active
  } = props;
  const {
    getPrefixCls
  } = react.useContext(context/* ConfigContext */.E_);
  const prefixCls = getPrefixCls('skeleton', customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = skeleton_style(prefixCls);
  const cls = classnames_default()(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active
  }, className, rootClassName, hashId, cssVarCls);
  return wrapCSSVar( /*#__PURE__*/react.createElement("div", {
    className: cls
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(`${prefixCls}-image`, className),
    style: style
  }, /*#__PURE__*/react.createElement("svg", {
    viewBox: "0 0 1098 1024",
    xmlns: "http://www.w3.org/2000/svg",
    className: `${prefixCls}-image-svg`
  }, /*#__PURE__*/react.createElement("path", {
    d: path,
    className: `${prefixCls}-image-path`
  })))));
};
/* harmony default export */ var Image = (SkeletonImage);
;// CONCATENATED MODULE: ./node_modules/antd/es/skeleton/Input.js
"use client";







const SkeletonInput = props => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    active,
    block,
    size = 'default'
  } = props;
  const {
    getPrefixCls
  } = react.useContext(context/* ConfigContext */.E_);
  const prefixCls = getPrefixCls('skeleton', customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = skeleton_style(prefixCls);
  const otherProps = (0,omit/* default */.Z)(props, ['prefixCls']);
  const cls = classnames_default()(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active,
    [`${prefixCls}-block`]: block
  }, className, rootClassName, hashId, cssVarCls);
  return wrapCSSVar( /*#__PURE__*/react.createElement("div", {
    className: cls
  }, /*#__PURE__*/react.createElement(skeleton_Element, Object.assign({
    prefixCls: `${prefixCls}-input`,
    size: size
  }, otherProps))));
};
/* harmony default export */ var Input = (SkeletonInput);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(87462);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons-svg/es/asn/DotChartOutlined.js
// This icon file is generated automatically.
var DotChartOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M888 792H200V168c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v688c0 4.4 3.6 8 8 8h752c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM288 604a64 64 0 10128 0 64 64 0 10-128 0zm118-224a48 48 0 1096 0 48 48 0 10-96 0zm158 228a96 96 0 10192 0 96 96 0 10-192 0zm148-314a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "dot-chart", "theme": "outlined" };
/* harmony default export */ var asn_DotChartOutlined = (DotChartOutlined);

// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/components/AntdIcon.js + 3 modules
var AntdIcon = __webpack_require__(42135);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons/es/icons/DotChartOutlined.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY




var DotChartOutlined_DotChartOutlined = function DotChartOutlined(props, ref) {
  return /*#__PURE__*/react.createElement(AntdIcon/* default */.Z, (0,esm_extends/* default */.Z)({}, props, {
    ref: ref,
    icon: asn_DotChartOutlined
  }));
};

/**![dot-chart](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTg4OCA3OTJIMjAwVjE2OGMwLTQuNC0zLjYtOC04LThoLTU2Yy00LjQgMC04IDMuNi04IDh2Njg4YzAgNC40IDMuNiA4IDggOGg3NTJjNC40IDAgOC0zLjYgOC04di01NmMwLTQuNC0zLjYtOC04LTh6TTI4OCA2MDRhNjQgNjQgMCAxMDEyOCAwIDY0IDY0IDAgMTAtMTI4IDB6bTExOC0yMjRhNDggNDggMCAxMDk2IDAgNDggNDggMCAxMC05NiAwem0xNTggMjI4YTk2IDk2IDAgMTAxOTIgMCA5NiA5NiAwIDEwLTE5MiAwem0xNDgtMzE0YTU2IDU2IDAgMTAxMTIgMCA1NiA1NiAwIDEwLTExMiAweiIgLz48L3N2Zz4=) */
var RefIcon = /*#__PURE__*/react.forwardRef(DotChartOutlined_DotChartOutlined);
if (false) {}
/* harmony default export */ var icons_DotChartOutlined = (RefIcon);
;// CONCATENATED MODULE: ./node_modules/antd/es/skeleton/Node.js
"use client";






const SkeletonNode = props => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style,
    active,
    children
  } = props;
  const {
    getPrefixCls
  } = react.useContext(context/* ConfigContext */.E_);
  const prefixCls = getPrefixCls('skeleton', customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = skeleton_style(prefixCls);
  const cls = classnames_default()(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active
  }, hashId, className, rootClassName, cssVarCls);
  const content = children !== null && children !== void 0 ? children : /*#__PURE__*/react.createElement(icons_DotChartOutlined, null);
  return wrapCSSVar( /*#__PURE__*/react.createElement("div", {
    className: cls
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(`${prefixCls}-image`, className),
    style: style
  }, content)));
};
/* harmony default export */ var Node = (SkeletonNode);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 2 modules
var toConsumableArray = __webpack_require__(74902);
;// CONCATENATED MODULE: ./node_modules/antd/es/skeleton/Paragraph.js
"use client";




const getWidth = (index, props) => {
  const {
    width,
    rows = 2
  } = props;
  if (Array.isArray(width)) {
    return width[index];
  }
  // last paragraph
  if (rows - 1 === index) {
    return width;
  }
  return undefined;
};
const Paragraph = props => {
  const {
    prefixCls,
    className,
    style,
    rows
  } = props;
  const rowList = (0,toConsumableArray/* default */.Z)(Array(rows)).map((_, index) => (
  /*#__PURE__*/
  // eslint-disable-next-line react/no-array-index-key
  react.createElement("li", {
    key: index,
    style: {
      width: getWidth(index, props)
    }
  })));
  return /*#__PURE__*/react.createElement("ul", {
    className: classnames_default()(prefixCls, className),
    style: style
  }, rowList);
};
/* harmony default export */ var skeleton_Paragraph = (Paragraph);
;// CONCATENATED MODULE: ./node_modules/antd/es/skeleton/Title.js
"use client";

/* eslint-disable jsx-a11y/heading-has-content */


const Title = _ref => {
  let {
    prefixCls,
    className,
    width,
    style
  } = _ref;
  return /*#__PURE__*/react.createElement("h3", {
    className: classnames_default()(prefixCls, className),
    style: Object.assign({
      width
    }, style)
  });
};
/* harmony default export */ var skeleton_Title = (Title);
;// CONCATENATED MODULE: ./node_modules/antd/es/skeleton/Skeleton.js
"use client";













function getComponentProps(prop) {
  if (prop && typeof prop === 'object') {
    return prop;
  }
  return {};
}
function getAvatarBasicProps(hasTitle, hasParagraph) {
  if (hasTitle && !hasParagraph) {
    // Square avatar
    return {
      size: 'large',
      shape: 'square'
    };
  }
  return {
    size: 'large',
    shape: 'circle'
  };
}
function getTitleBasicProps(hasAvatar, hasParagraph) {
  if (!hasAvatar && hasParagraph) {
    return {
      width: '38%'
    };
  }
  if (hasAvatar && hasParagraph) {
    return {
      width: '50%'
    };
  }
  return {};
}
function getParagraphBasicProps(hasAvatar, hasTitle) {
  const basicProps = {};
  // Width
  if (!hasAvatar || !hasTitle) {
    basicProps.width = '61%';
  }
  // Rows
  if (!hasAvatar && hasTitle) {
    basicProps.rows = 3;
  } else {
    basicProps.rows = 2;
  }
  return basicProps;
}
const Skeleton = props => {
  const {
    prefixCls: customizePrefixCls,
    loading,
    className,
    rootClassName,
    style,
    children,
    avatar = false,
    title = true,
    paragraph = true,
    active,
    round
  } = props;
  const {
    getPrefixCls,
    direction,
    skeleton
  } = react.useContext(context/* ConfigContext */.E_);
  const prefixCls = getPrefixCls('skeleton', customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = skeleton_style(prefixCls);
  if (loading || !('loading' in props)) {
    const hasAvatar = !!avatar;
    const hasTitle = !!title;
    const hasParagraph = !!paragraph;
    // Avatar
    let avatarNode;
    if (hasAvatar) {
      const avatarProps = Object.assign(Object.assign({
        prefixCls: `${prefixCls}-avatar`
      }, getAvatarBasicProps(hasTitle, hasParagraph)), getComponentProps(avatar));
      // We direct use SkeletonElement as avatar in skeleton internal.
      avatarNode = /*#__PURE__*/react.createElement("div", {
        className: `${prefixCls}-header`
      }, /*#__PURE__*/react.createElement(skeleton_Element, Object.assign({}, avatarProps)));
    }
    let contentNode;
    if (hasTitle || hasParagraph) {
      // Title
      let $title;
      if (hasTitle) {
        const titleProps = Object.assign(Object.assign({
          prefixCls: `${prefixCls}-title`
        }, getTitleBasicProps(hasAvatar, hasParagraph)), getComponentProps(title));
        $title = /*#__PURE__*/react.createElement(skeleton_Title, Object.assign({}, titleProps));
      }
      // Paragraph
      let paragraphNode;
      if (hasParagraph) {
        const paragraphProps = Object.assign(Object.assign({
          prefixCls: `${prefixCls}-paragraph`
        }, getParagraphBasicProps(hasAvatar, hasTitle)), getComponentProps(paragraph));
        paragraphNode = /*#__PURE__*/react.createElement(skeleton_Paragraph, Object.assign({}, paragraphProps));
      }
      contentNode = /*#__PURE__*/react.createElement("div", {
        className: `${prefixCls}-content`
      }, $title, paragraphNode);
    }
    const cls = classnames_default()(prefixCls, {
      [`${prefixCls}-with-avatar`]: hasAvatar,
      [`${prefixCls}-active`]: active,
      [`${prefixCls}-rtl`]: direction === 'rtl',
      [`${prefixCls}-round`]: round
    }, skeleton === null || skeleton === void 0 ? void 0 : skeleton.className, className, rootClassName, hashId, cssVarCls);
    return wrapCSSVar( /*#__PURE__*/react.createElement("div", {
      className: cls,
      style: Object.assign(Object.assign({}, skeleton === null || skeleton === void 0 ? void 0 : skeleton.style), style)
    }, avatarNode, contentNode));
  }
  return children !== null && children !== void 0 ? children : null;
};
Skeleton.Button = Button;
Skeleton.Avatar = Avatar;
Skeleton.Input = Input;
Skeleton.Image = Image;
Skeleton.Node = Node;
if (false) {}
/* harmony default export */ var skeleton_Skeleton = (Skeleton);
;// CONCATENATED MODULE: ./node_modules/antd/es/skeleton/index.js
"use client";


/* harmony default export */ var skeleton = (skeleton_Skeleton);

/***/ }),

/***/ 42075:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: function() { return /* binding */ space; }
});

// UNUSED EXPORTS: SpaceContext

// EXTERNAL MODULE: ./node_modules/@umijs/preset-umi/node_modules/react/index.js
var react = __webpack_require__(62435);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(93967);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/rc-util/es/Children/toArray.js
var toArray = __webpack_require__(50344);
// EXTERNAL MODULE: ./node_modules/antd/es/_util/gapSize.js
var gapSize = __webpack_require__(98065);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/context.js
var context = __webpack_require__(53124);
// EXTERNAL MODULE: ./node_modules/antd/es/space/Compact.js
var Compact = __webpack_require__(4173);
;// CONCATENATED MODULE: ./node_modules/antd/es/space/context.js

const SpaceContext = /*#__PURE__*/react.createContext({
  latestIndex: 0
});
const SpaceContextProvider = SpaceContext.Provider;
;// CONCATENATED MODULE: ./node_modules/antd/es/space/Item.js
"use client";



const Item = _ref => {
  let {
    className,
    index,
    children,
    split,
    style
  } = _ref;
  const {
    latestIndex
  } = react.useContext(SpaceContext);
  if (children === null || children === undefined) {
    return null;
  }
  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {
    className: className,
    style: style
  }, children), index < latestIndex && split && /*#__PURE__*/react.createElement("span", {
    className: `${className}-split`
  }, split));
};
/* harmony default export */ var space_Item = (Item);
// EXTERNAL MODULE: ./node_modules/antd/es/space/style/index.js + 1 modules
var space_style = __webpack_require__(51916);
;// CONCATENATED MODULE: ./node_modules/antd/es/space/index.js
"use client";

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};










const InternalSpace = /*#__PURE__*/react.forwardRef((props, ref) => {
  var _a, _b;
  const {
    getPrefixCls,
    space,
    direction: directionConfig
  } = react.useContext(context/* ConfigContext */.E_);
  const {
      size = (space === null || space === void 0 ? void 0 : space.size) || 'small',
      align,
      className,
      rootClassName,
      children,
      direction = 'horizontal',
      prefixCls: customizePrefixCls,
      split,
      style,
      wrap = false,
      classNames: customClassNames,
      styles
    } = props,
    otherProps = __rest(props, ["size", "align", "className", "rootClassName", "children", "direction", "prefixCls", "split", "style", "wrap", "classNames", "styles"]);
  const [horizontalSize, verticalSize] = Array.isArray(size) ? size : [size, size];
  const isPresetVerticalSize = (0,gapSize/* isPresetSize */.n)(verticalSize);
  const isPresetHorizontalSize = (0,gapSize/* isPresetSize */.n)(horizontalSize);
  const isValidVerticalSize = (0,gapSize/* isValidGapNumber */.T)(verticalSize);
  const isValidHorizontalSize = (0,gapSize/* isValidGapNumber */.T)(horizontalSize);
  const childNodes = (0,toArray/* default */.Z)(children, {
    keepEmpty: true
  });
  const mergedAlign = align === undefined && direction === 'horizontal' ? 'center' : align;
  const prefixCls = getPrefixCls('space', customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = (0,space_style/* default */.Z)(prefixCls);
  const cls = classnames_default()(prefixCls, space === null || space === void 0 ? void 0 : space.className, hashId, `${prefixCls}-${direction}`, {
    [`${prefixCls}-rtl`]: directionConfig === 'rtl',
    [`${prefixCls}-align-${mergedAlign}`]: mergedAlign,
    [`${prefixCls}-gap-row-${verticalSize}`]: isPresetVerticalSize,
    [`${prefixCls}-gap-col-${horizontalSize}`]: isPresetHorizontalSize
  }, className, rootClassName, cssVarCls);
  const itemClassName = classnames_default()(`${prefixCls}-item`, (_a = customClassNames === null || customClassNames === void 0 ? void 0 : customClassNames.item) !== null && _a !== void 0 ? _a : (_b = space === null || space === void 0 ? void 0 : space.classNames) === null || _b === void 0 ? void 0 : _b.item);
  // Calculate latest one
  let latestIndex = 0;
  const nodes = childNodes.map((child, i) => {
    var _a, _b;
    if (child !== null && child !== undefined) {
      latestIndex = i;
    }
    const key = child && child.key || `${itemClassName}-${i}`;
    return /*#__PURE__*/react.createElement(space_Item, {
      className: itemClassName,
      key: key,
      index: i,
      split: split,
      style: (_a = styles === null || styles === void 0 ? void 0 : styles.item) !== null && _a !== void 0 ? _a : (_b = space === null || space === void 0 ? void 0 : space.styles) === null || _b === void 0 ? void 0 : _b.item
    }, child);
  });
  const spaceContext = react.useMemo(() => ({
    latestIndex
  }), [latestIndex]);
  // =========================== Render ===========================
  if (childNodes.length === 0) {
    return null;
  }
  const gapStyle = {};
  if (wrap) {
    gapStyle.flexWrap = 'wrap';
  }
  if (!isPresetHorizontalSize && isValidHorizontalSize) {
    gapStyle.columnGap = horizontalSize;
  }
  if (!isPresetVerticalSize && isValidVerticalSize) {
    gapStyle.rowGap = verticalSize;
  }
  return wrapCSSVar( /*#__PURE__*/react.createElement("div", Object.assign({
    ref: ref,
    className: cls,
    style: Object.assign(Object.assign(Object.assign({}, gapStyle), space === null || space === void 0 ? void 0 : space.style), style)
  }, otherProps), /*#__PURE__*/react.createElement(SpaceContextProvider, {
    value: spaceContext
  }, nodes)));
});
const Space = InternalSpace;
Space.Compact = Compact/* default */.ZP;
if (false) {}
/* harmony default export */ var space = (Space);

/***/ }),

/***/ 75081:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: function() { return /* binding */ spin; }
});

// EXTERNAL MODULE: ./node_modules/@umijs/preset-umi/node_modules/react/index.js
var react = __webpack_require__(62435);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(93967);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/rc-util/es/omit.js
var omit = __webpack_require__(98423);
;// CONCATENATED MODULE: ./node_modules/throttle-debounce/esm/index.js
/* eslint-disable no-undefined,no-param-reassign,no-shadow */

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)
 *                                            are most useful.
 * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,
 *                                            as-is, to `callback` when the throttled-function is executed.
 * @param {object} [options] -              An object to configure options.
 * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds
 *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed
 *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for
 *                                            `delay` milliseconds, the internal counter is reset).
 * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback
 *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that
 *                                            callback will never executed if both noLeading = true and noTrailing = true.
 * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is
 *                                            false (at end), schedule `callback` to execute after `delay` ms.
 *
 * @returns {Function} A new, throttled, function.
 */
function throttle (delay, callback, options) {
  var _ref = options || {},
      _ref$noTrailing = _ref.noTrailing,
      noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing,
      _ref$noLeading = _ref.noLeading,
      noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading,
      _ref$debounceMode = _ref.debounceMode,
      debounceMode = _ref$debounceMode === void 0 ? undefined : _ref$debounceMode;
  /*
   * After wrapper has stopped being called, this timeout ensures that
   * `callback` is executed at the proper times in `throttle` and `end`
   * debounce modes.
   */


  var timeoutID;
  var cancelled = false; // Keep track of the last time `callback` was executed.

  var lastExec = 0; // Function to clear existing timeout

  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  } // Function to cancel next exec


  function cancel(options) {
    var _ref2 = options || {},
        _ref2$upcomingOnly = _ref2.upcomingOnly,
        upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;

    clearExistingTimeout();
    cancelled = !upcomingOnly;
  }
  /*
   * The `wrapper` function encapsulates all of the throttling / debouncing
   * functionality and when executed will limit the rate at which `callback`
   * is executed.
   */


  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }

    var self = this;
    var elapsed = Date.now() - lastExec;

    if (cancelled) {
      return;
    } // Execute `callback` and update the `lastExec` timestamp.


    function exec() {
      lastExec = Date.now();
      callback.apply(self, arguments_);
    }
    /*
     * If `debounceMode` is true (at begin) this is used to clear the flag
     * to allow future `callback` executions.
     */


    function clear() {
      timeoutID = undefined;
    }

    if (!noLeading && debounceMode && !timeoutID) {
      /*
       * Since `wrapper` is being called for the first time and
       * `debounceMode` is true (at begin), execute `callback`
       * and noLeading != true.
       */
      exec();
    }

    clearExistingTimeout();

    if (debounceMode === undefined && elapsed > delay) {
      if (noLeading) {
        /*
         * In throttle mode with noLeading, if `delay` time has
         * been exceeded, update `lastExec` and schedule `callback`
         * to execute after `delay` ms.
         */
        lastExec = Date.now();

        if (!noTrailing) {
          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
        }
      } else {
        /*
         * In throttle mode without noLeading, if `delay` time has been exceeded, execute
         * `callback`.
         */
        exec();
      }
    } else if (noTrailing !== true) {
      /*
       * In trailing throttle mode, since `delay` time has not been
       * exceeded, schedule `callback` to execute `delay` ms after most
       * recent execution.
       *
       * If `debounceMode` is true (at begin), schedule `clear` to execute
       * after `delay` ms.
       *
       * If `debounceMode` is false (at end), schedule `callback` to
       * execute after `delay` ms.
       */
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
    }
  }

  wrapper.cancel = cancel; // Return the wrapper function.

  return wrapper;
}

/* eslint-disable no-undefined */
/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                        to `callback` when the debounced-function is executed.
 * @param {object} [options] -           An object to configure options.
 * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
 *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
 *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
 *
 * @returns {Function} A new, debounced function.
 */

function debounce (delay, callback, options) {
  var _ref = options || {},
      _ref$atBegin = _ref.atBegin,
      atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;

  return throttle(delay, callback, {
    debounceMode: atBegin !== false
  });
}


//# sourceMappingURL=index.js.map

// EXTERNAL MODULE: ./node_modules/antd/es/_util/reactNode.js
var reactNode = __webpack_require__(96159);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/context.js
var context = __webpack_require__(53124);
// EXTERNAL MODULE: ./node_modules/@ant-design/cssinjs/es/index.js + 35 modules
var es = __webpack_require__(54548);
// EXTERNAL MODULE: ./node_modules/antd/es/style/index.js
var style = __webpack_require__(14747);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/genComponentStyleHook.js + 6 modules
var genComponentStyleHook = __webpack_require__(92030);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/statistic.js
var statistic = __webpack_require__(45503);
;// CONCATENATED MODULE: ./node_modules/antd/es/spin/style/index.js



const antSpinMove = new es/* Keyframes */.E4('antSpinMove', {
  to: {
    opacity: 1
  }
});
const antRotate = new es/* Keyframes */.E4('antRotate', {
  to: {
    transform: 'rotate(405deg)'
  }
});
const genSpinStyle = token => {
  const {
    componentCls,
    calc
  } = token;
  return {
    [`${componentCls}`]: Object.assign(Object.assign({}, (0,style/* resetComponent */.Wf)(token)), {
      position: 'absolute',
      display: 'none',
      color: token.colorPrimary,
      fontSize: 0,
      textAlign: 'center',
      verticalAlign: 'middle',
      opacity: 0,
      transition: `transform ${token.motionDurationSlow} ${token.motionEaseInOutCirc}`,
      '&-spinning': {
        position: 'static',
        display: 'inline-block',
        opacity: 1
      },
      [`${componentCls}-text`]: {
        fontSize: token.fontSize,
        paddingTop: calc(calc(token.dotSize).sub(token.fontSize)).div(2).add(2).equal()
      },
      '&-fullscreen': {
        position: 'fixed',
        width: '100vw',
        height: '100vh',
        backgroundColor: token.colorBgMask,
        zIndex: token.zIndexPopupBase,
        inset: 0,
        display: 'flex',
        alignItems: 'center',
        flexDirection: 'column',
        justifyContent: 'center',
        opacity: 0,
        visibility: 'hidden',
        transition: `all ${token.motionDurationMid}`,
        '&-show': {
          opacity: 1,
          visibility: 'visible'
        },
        [`${componentCls}-dot ${componentCls}-dot-item`]: {
          backgroundColor: token.colorWhite
        },
        [`${componentCls}-text`]: {
          color: token.colorTextLightSolid
        }
      },
      '&-nested-loading': {
        position: 'relative',
        [`> div > ${componentCls}`]: {
          position: 'absolute',
          top: 0,
          insetInlineStart: 0,
          zIndex: 4,
          display: 'block',
          width: '100%',
          height: '100%',
          maxHeight: token.contentHeight,
          [`${componentCls}-dot`]: {
            position: 'absolute',
            top: '50%',
            insetInlineStart: '50%',
            margin: calc(token.dotSize).mul(-1).div(2).equal()
          },
          [`${componentCls}-text`]: {
            position: 'absolute',
            top: '50%',
            width: '100%',
            textShadow: `0 1px 2px ${token.colorBgContainer}` // FIXME: shadow
          },
          [`&${componentCls}-show-text ${componentCls}-dot`]: {
            marginTop: calc(token.dotSize).div(2).mul(-1).sub(10).equal()
          },
          '&-sm': {
            [`${componentCls}-dot`]: {
              margin: calc(token.dotSizeSM).mul(-1).div(2).equal()
            },
            [`${componentCls}-text`]: {
              paddingTop: calc(calc(token.dotSizeSM).sub(token.fontSize)).div(2).add(2).equal()
            },
            [`&${componentCls}-show-text ${componentCls}-dot`]: {
              marginTop: calc(token.dotSizeSM).div(2).mul(-1).sub(10).equal()
            }
          },
          '&-lg': {
            [`${componentCls}-dot`]: {
              margin: calc(token.dotSizeLG).mul(-1).div(2).equal()
            },
            [`${componentCls}-text`]: {
              paddingTop: calc(calc(token.dotSizeLG).sub(token.fontSize)).div(2).add(2).equal()
            },
            [`&${componentCls}-show-text ${componentCls}-dot`]: {
              marginTop: calc(token.dotSizeLG).div(2).mul(-1).sub(10).equal()
            }
          }
        },
        [`${componentCls}-container`]: {
          position: 'relative',
          transition: `opacity ${token.motionDurationSlow}`,
          '&::after': {
            position: 'absolute',
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            zIndex: 10,
            width: '100%',
            height: '100%',
            background: token.colorBgContainer,
            opacity: 0,
            transition: `all ${token.motionDurationSlow}`,
            content: '""',
            pointerEvents: 'none'
          }
        },
        [`${componentCls}-blur`]: {
          clear: 'both',
          opacity: 0.5,
          userSelect: 'none',
          pointerEvents: 'none',
          [`&::after`]: {
            opacity: 0.4,
            pointerEvents: 'auto'
          }
        }
      },
      // tip
      // ------------------------------
      [`&-tip`]: {
        color: token.spinDotDefault
      },
      // dots
      // ------------------------------
      [`${componentCls}-dot`]: {
        position: 'relative',
        display: 'inline-block',
        fontSize: token.dotSize,
        width: '1em',
        height: '1em',
        '&-item': {
          position: 'absolute',
          display: 'block',
          width: calc(token.dotSize).sub(calc(token.marginXXS).div(2)).div(2).equal(),
          height: calc(token.dotSize).sub(calc(token.marginXXS).div(2)).div(2).equal(),
          backgroundColor: token.colorPrimary,
          borderRadius: '100%',
          transform: 'scale(0.75)',
          transformOrigin: '50% 50%',
          opacity: 0.3,
          animationName: antSpinMove,
          animationDuration: '1s',
          animationIterationCount: 'infinite',
          animationTimingFunction: 'linear',
          animationDirection: 'alternate',
          '&:nth-child(1)': {
            top: 0,
            insetInlineStart: 0,
            animationDelay: '0s'
          },
          '&:nth-child(2)': {
            top: 0,
            insetInlineEnd: 0,
            animationDelay: '0.4s'
          },
          '&:nth-child(3)': {
            insetInlineEnd: 0,
            bottom: 0,
            animationDelay: '0.8s'
          },
          '&:nth-child(4)': {
            bottom: 0,
            insetInlineStart: 0,
            animationDelay: '1.2s'
          }
        },
        '&-spin': {
          transform: 'rotate(45deg)',
          animationName: antRotate,
          animationDuration: '1.2s',
          animationIterationCount: 'infinite',
          animationTimingFunction: 'linear'
        }
      },
      // small
      [`&-sm ${componentCls}-dot`]: {
        fontSize: token.dotSizeSM,
        i: {
          width: calc(calc(token.dotSizeSM).sub(calc(token.marginXXS).div(2))).div(2).equal(),
          height: calc(calc(token.dotSizeSM).sub(calc(token.marginXXS).div(2))).div(2).equal()
        }
      },
      // large
      [`&-lg ${componentCls}-dot`]: {
        fontSize: token.dotSizeLG,
        i: {
          width: calc(calc(token.dotSizeLG).sub(token.marginXXS)).div(2).equal(),
          height: calc(calc(token.dotSizeLG).sub(token.marginXXS)).div(2).equal()
        }
      },
      [`&${componentCls}-show-text ${componentCls}-text`]: {
        display: 'block'
      }
    })
  };
};
const prepareComponentToken = token => {
  const {
    controlHeightLG,
    controlHeight
  } = token;
  return {
    contentHeight: 400,
    dotSize: controlHeightLG / 2,
    dotSizeSM: controlHeightLG * 0.35,
    dotSizeLG: controlHeight
  };
};
// ============================== Export ==============================
/* harmony default export */ var spin_style = ((0,genComponentStyleHook/* genStyleHooks */.I$)('Spin', token => {
  const spinToken = (0,statistic/* merge */.TS)(token, {
    spinDotDefault: token.colorTextDescription
  });
  return [genSpinStyle(spinToken)];
}, prepareComponentToken));
;// CONCATENATED MODULE: ./node_modules/antd/es/spin/index.js
"use client";

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};








const SpinSizes = (/* unused pure expression or super */ null && (['small', 'default', 'large']));
// Render indicator
let defaultIndicator = null;
function renderIndicator(prefixCls, props) {
  const {
    indicator
  } = props;
  const dotClassName = `${prefixCls}-dot`;
  // should not be render default indicator when indicator value is null
  if (indicator === null) {
    return null;
  }
  if ( /*#__PURE__*/react.isValidElement(indicator)) {
    return (0,reactNode/* cloneElement */.Tm)(indicator, {
      className: classnames_default()(indicator.props.className, dotClassName)
    });
  }
  if ( /*#__PURE__*/react.isValidElement(defaultIndicator)) {
    return (0,reactNode/* cloneElement */.Tm)(defaultIndicator, {
      className: classnames_default()(defaultIndicator.props.className, dotClassName)
    });
  }
  return /*#__PURE__*/react.createElement("span", {
    className: classnames_default()(dotClassName, `${prefixCls}-dot-spin`)
  }, /*#__PURE__*/react.createElement("i", {
    className: `${prefixCls}-dot-item`,
    key: 1
  }), /*#__PURE__*/react.createElement("i", {
    className: `${prefixCls}-dot-item`,
    key: 2
  }), /*#__PURE__*/react.createElement("i", {
    className: `${prefixCls}-dot-item`,
    key: 3
  }), /*#__PURE__*/react.createElement("i", {
    className: `${prefixCls}-dot-item`,
    key: 4
  }));
}
function shouldDelay(spinning, delay) {
  return !!spinning && !!delay && !isNaN(Number(delay));
}
const Spin = props => {
  const {
      prefixCls: customizePrefixCls,
      spinning: customSpinning = true,
      delay = 0,
      className,
      rootClassName,
      size = 'default',
      tip,
      wrapperClassName,
      style,
      children,
      fullscreen = false
    } = props,
    restProps = __rest(props, ["prefixCls", "spinning", "delay", "className", "rootClassName", "size", "tip", "wrapperClassName", "style", "children", "fullscreen"]);
  const {
    getPrefixCls
  } = react.useContext(context/* ConfigContext */.E_);
  const prefixCls = getPrefixCls('spin', customizePrefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = spin_style(prefixCls);
  const [spinning, setSpinning] = react.useState(() => customSpinning && !shouldDelay(customSpinning, delay));
  react.useEffect(() => {
    if (customSpinning) {
      const showSpinning = debounce(delay, () => {
        setSpinning(true);
      });
      showSpinning();
      return () => {
        var _a;
        (_a = showSpinning === null || showSpinning === void 0 ? void 0 : showSpinning.cancel) === null || _a === void 0 ? void 0 : _a.call(showSpinning);
      };
    }
    setSpinning(false);
  }, [delay, customSpinning]);
  const isNestedPattern = react.useMemo(() => typeof children !== 'undefined' && !fullscreen, [children, fullscreen]);
  if (false) {}
  const {
    direction,
    spin
  } = react.useContext(context/* ConfigContext */.E_);
  const spinClassName = classnames_default()(prefixCls, spin === null || spin === void 0 ? void 0 : spin.className, {
    [`${prefixCls}-sm`]: size === 'small',
    [`${prefixCls}-lg`]: size === 'large',
    [`${prefixCls}-spinning`]: spinning,
    [`${prefixCls}-show-text`]: !!tip,
    [`${prefixCls}-fullscreen`]: fullscreen,
    [`${prefixCls}-fullscreen-show`]: fullscreen && spinning,
    [`${prefixCls}-rtl`]: direction === 'rtl'
  }, className, rootClassName, hashId, cssVarCls);
  const containerClassName = classnames_default()(`${prefixCls}-container`, {
    [`${prefixCls}-blur`]: spinning
  });
  // fix https://fb.me/react-unknown-prop
  const divProps = (0,omit/* default */.Z)(restProps, ['indicator']);
  const mergedStyle = Object.assign(Object.assign({}, spin === null || spin === void 0 ? void 0 : spin.style), style);
  const spinElement = /*#__PURE__*/react.createElement("div", Object.assign({}, divProps, {
    style: mergedStyle,
    className: spinClassName,
    "aria-live": "polite",
    "aria-busy": spinning
  }), renderIndicator(prefixCls, props), tip && (isNestedPattern || fullscreen) ? ( /*#__PURE__*/react.createElement("div", {
    className: `${prefixCls}-text`
  }, tip)) : null);
  if (isNestedPattern) {
    return wrapCSSVar( /*#__PURE__*/react.createElement("div", Object.assign({}, divProps, {
      className: classnames_default()(`${prefixCls}-nested-loading`, wrapperClassName, hashId, cssVarCls)
    }), spinning && /*#__PURE__*/react.createElement("div", {
      key: "loading"
    }, spinElement), /*#__PURE__*/react.createElement("div", {
      className: containerClassName,
      key: "container"
    }, children)));
  }
  return wrapCSSVar(spinElement);
};
Spin.setDefaultIndicator = indicator => {
  defaultIndicator = indicator;
};
if (false) {}
/* harmony default export */ var spin = (Spin);

/***/ }),

/***/ 7168:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: function() { return /* binding */ tabs; }
});

// EXTERNAL MODULE: ./node_modules/@umijs/preset-umi/node_modules/react/index.js
var react = __webpack_require__(62435);
// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/icons/CloseOutlined.js + 1 modules
var CloseOutlined = __webpack_require__(97937);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(87462);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons-svg/es/asn/EllipsisOutlined.js
// This icon file is generated automatically.
var EllipsisOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "ellipsis", "theme": "outlined" };
/* harmony default export */ var asn_EllipsisOutlined = (EllipsisOutlined);

// EXTERNAL MODULE: ./node_modules/@ant-design/icons/es/components/AntdIcon.js + 3 modules
var AntdIcon = __webpack_require__(42135);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons/es/icons/EllipsisOutlined.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY




var EllipsisOutlined_EllipsisOutlined = function EllipsisOutlined(props, ref) {
  return /*#__PURE__*/react.createElement(AntdIcon/* default */.Z, (0,esm_extends/* default */.Z)({}, props, {
    ref: ref,
    icon: asn_EllipsisOutlined
  }));
};

/**![ellipsis](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE3NiA1MTFhNTYgNTYgMCAxMDExMiAwIDU2IDU2IDAgMTAtMTEyIDB6bTI4MCAwYTU2IDU2IDAgMTAxMTIgMCA1NiA1NiAwIDEwLTExMiAwem0yODAgMGE1NiA1NiAwIDEwMTEyIDAgNTYgNTYgMCAxMC0xMTIgMHoiIC8+PC9zdmc+) */
var RefIcon = /*#__PURE__*/react.forwardRef(EllipsisOutlined_EllipsisOutlined);
if (false) {}
/* harmony default export */ var icons_EllipsisOutlined = (RefIcon);
;// CONCATENATED MODULE: ./node_modules/@ant-design/icons-svg/es/asn/PlusOutlined.js
// This icon file is generated automatically.
var PlusOutlined = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { "tag": "path", "attrs": { "d": "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z" } }] }, "name": "plus", "theme": "outlined" };
/* harmony default export */ var asn_PlusOutlined = (PlusOutlined);

;// CONCATENATED MODULE: ./node_modules/@ant-design/icons/es/icons/PlusOutlined.js

// GENERATE BY ./scripts/generate.ts
// DON NOT EDIT IT MANUALLY




var PlusOutlined_PlusOutlined = function PlusOutlined(props, ref) {
  return /*#__PURE__*/react.createElement(AntdIcon/* default */.Z, (0,esm_extends/* default */.Z)({}, props, {
    ref: ref,
    icon: asn_PlusOutlined
  }));
};

/**![plus](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTQ4MiAxNTJoNjBxOCAwIDggOHY3MDRxMCA4LTggOGgtNjBxLTggMC04LThWMTYwcTAtOCA4LTh6IiAvPjxwYXRoIGQ9Ik0xOTIgNDc0aDY3MnE4IDAgOCA4djYwcTAgOC04IDhIMTYwcS04IDAtOC04di02MHEwLTggOC04eiIgLz48L3N2Zz4=) */
var PlusOutlined_RefIcon = /*#__PURE__*/react.forwardRef(PlusOutlined_PlusOutlined);
if (false) {}
/* harmony default export */ var icons_PlusOutlined = (PlusOutlined_RefIcon);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(93967);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(4942);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__(1413);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js + 1 modules
var slicedToArray = __webpack_require__(97685);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__(71002);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js + 1 modules
var objectWithoutProperties = __webpack_require__(91);
// EXTERNAL MODULE: ./node_modules/rc-util/es/hooks/useMergedState.js
var useMergedState = __webpack_require__(21770);
// EXTERNAL MODULE: ./node_modules/rc-util/es/isMobile.js
var isMobile = __webpack_require__(31131);
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/TabContext.js

/* harmony default export */ var TabContext = (/*#__PURE__*/(0,react.createContext)(null));
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 2 modules
var toConsumableArray = __webpack_require__(74902);
// EXTERNAL MODULE: ./node_modules/rc-resize-observer/es/index.js + 5 modules
var es = __webpack_require__(9220);
// EXTERNAL MODULE: ./node_modules/rc-util/es/hooks/useEvent.js
var useEvent = __webpack_require__(66680);
// EXTERNAL MODULE: ./node_modules/rc-util/es/ref.js
var es_ref = __webpack_require__(42550);
// EXTERNAL MODULE: ./node_modules/rc-util/es/raf.js
var raf = __webpack_require__(75164);
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/hooks/useIndicator.js



var useIndicator = function useIndicator(options) {
  var activeTabOffset = options.activeTabOffset,
    horizontal = options.horizontal,
    rtl = options.rtl,
    _options$indicator = options.indicator,
    indicator = _options$indicator === void 0 ? {} : _options$indicator;
  var size = indicator.size,
    _indicator$align = indicator.align,
    align = _indicator$align === void 0 ? 'center' : _indicator$align;
  var _useState = (0,react.useState)(),
    _useState2 = (0,slicedToArray/* default */.Z)(_useState, 2),
    inkStyle = _useState2[0],
    setInkStyle = _useState2[1];
  var inkBarRafRef = (0,react.useRef)();
  var getLength = react.useCallback(function (origin) {
    if (typeof size === 'function') {
      return size(origin);
    }
    if (typeof size === 'number') {
      return size;
    }
    return origin;
  }, [size]);

  // Delay set ink style to avoid remove tab blink
  function cleanInkBarRaf() {
    raf/* default */.Z.cancel(inkBarRafRef.current);
  }
  (0,react.useEffect)(function () {
    var newInkStyle = {};
    if (activeTabOffset) {
      if (horizontal) {
        newInkStyle.width = getLength(activeTabOffset.width);
        var key = rtl ? 'right' : 'left';
        if (align === 'start') {
          newInkStyle[key] = activeTabOffset[key];
        }
        if (align === 'center') {
          newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width / 2;
          newInkStyle.transform = rtl ? 'translateX(50%)' : 'translateX(-50%)';
        }
        if (align === 'end') {
          newInkStyle[key] = activeTabOffset[key] + activeTabOffset.width;
          newInkStyle.transform = 'translateX(-100%)';
        }
      } else {
        newInkStyle.height = getLength(activeTabOffset.height);
        if (align === 'start') {
          newInkStyle.top = activeTabOffset.top;
        }
        if (align === 'center') {
          newInkStyle.top = activeTabOffset.top + activeTabOffset.height / 2;
          newInkStyle.transform = 'translateY(-50%)';
        }
        if (align === 'end') {
          newInkStyle.top = activeTabOffset.top + activeTabOffset.height;
          newInkStyle.transform = 'translateY(-100%)';
        }
      }
    }
    cleanInkBarRaf();
    inkBarRafRef.current = (0,raf/* default */.Z)(function () {
      setInkStyle(newInkStyle);
    });
    return cleanInkBarRaf;
  }, [activeTabOffset, horizontal, rtl, align, getLength]);
  return {
    style: inkStyle
  };
};
/* harmony default export */ var hooks_useIndicator = (useIndicator);
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/hooks/useOffsets.js


var DEFAULT_SIZE = {
  width: 0,
  height: 0,
  left: 0,
  top: 0
};
function useOffsets(tabs, tabSizes, holderScrollWidth) {
  return (0,react.useMemo)(function () {
    var _tabs$;
    var map = new Map();
    var lastOffset = tabSizes.get((_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key) || DEFAULT_SIZE;
    var rightOffset = lastOffset.left + lastOffset.width;
    for (var i = 0; i < tabs.length; i += 1) {
      var key = tabs[i].key;
      var data = tabSizes.get(key);

      // Reuse last one when not exist yet
      if (!data) {
        var _tabs;
        data = tabSizes.get((_tabs = tabs[i - 1]) === null || _tabs === void 0 ? void 0 : _tabs.key) || DEFAULT_SIZE;
      }
      var entity = map.get(key) || (0,objectSpread2/* default */.Z)({}, data);

      // Right
      entity.right = rightOffset - entity.left - entity.width;

      // Update entity
      map.set(key, entity);
    }
    return map;
  }, [tabs.map(function (tab) {
    return tab.key;
  }).join('_'), tabSizes, holderScrollWidth]);
}
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/hooks/useSyncState.js


function useSyncState(defaultState, onChange) {
  var stateRef = react.useRef(defaultState);
  var _React$useState = react.useState({}),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    forceUpdate = _React$useState2[1];
  function setState(updater) {
    var newValue = typeof updater === 'function' ? updater(stateRef.current) : updater;
    if (newValue !== stateRef.current) {
      onChange(newValue, stateRef.current);
    }
    stateRef.current = newValue;
    forceUpdate({});
  }
  return [stateRef.current, setState];
}
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/hooks/useTouchMove.js



var MIN_SWIPE_DISTANCE = 0.1;
var STOP_SWIPE_DISTANCE = 0.01;
var REFRESH_INTERVAL = 20;
var SPEED_OFF_MULTIPLE = Math.pow(0.995, REFRESH_INTERVAL);

// ================================= Hook =================================
function useTouchMove(ref, onOffset) {
  var _useState = (0,react.useState)(),
    _useState2 = (0,slicedToArray/* default */.Z)(_useState, 2),
    touchPosition = _useState2[0],
    setTouchPosition = _useState2[1];
  var _useState3 = (0,react.useState)(0),
    _useState4 = (0,slicedToArray/* default */.Z)(_useState3, 2),
    lastTimestamp = _useState4[0],
    setLastTimestamp = _useState4[1];
  var _useState5 = (0,react.useState)(0),
    _useState6 = (0,slicedToArray/* default */.Z)(_useState5, 2),
    lastTimeDiff = _useState6[0],
    setLastTimeDiff = _useState6[1];
  var _useState7 = (0,react.useState)(),
    _useState8 = (0,slicedToArray/* default */.Z)(_useState7, 2),
    lastOffset = _useState8[0],
    setLastOffset = _useState8[1];
  var motionRef = (0,react.useRef)();

  // ========================= Events =========================
  // >>> Touch events
  function onTouchStart(e) {
    var _e$touches$ = e.touches[0],
      screenX = _e$touches$.screenX,
      screenY = _e$touches$.screenY;
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    window.clearInterval(motionRef.current);
  }
  function onTouchMove(e) {
    if (!touchPosition) return;
    e.preventDefault();
    var _e$touches$2 = e.touches[0],
      screenX = _e$touches$2.screenX,
      screenY = _e$touches$2.screenY;
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    var offsetX = screenX - touchPosition.x;
    var offsetY = screenY - touchPosition.y;
    onOffset(offsetX, offsetY);
    var now = Date.now();
    setLastTimestamp(now);
    setLastTimeDiff(now - lastTimestamp);
    setLastOffset({
      x: offsetX,
      y: offsetY
    });
  }
  function onTouchEnd() {
    if (!touchPosition) return;
    setTouchPosition(null);
    setLastOffset(null);

    // Swipe if needed
    if (lastOffset) {
      var distanceX = lastOffset.x / lastTimeDiff;
      var distanceY = lastOffset.y / lastTimeDiff;
      var absX = Math.abs(distanceX);
      var absY = Math.abs(distanceY);

      // Skip swipe if low distance
      if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE) return;
      var currentX = distanceX;
      var currentY = distanceY;
      motionRef.current = window.setInterval(function () {
        if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
          window.clearInterval(motionRef.current);
          return;
        }
        currentX *= SPEED_OFF_MULTIPLE;
        currentY *= SPEED_OFF_MULTIPLE;
        onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL);
      }, REFRESH_INTERVAL);
    }
  }

  // >>> Wheel event
  var lastWheelDirectionRef = (0,react.useRef)();
  function onWheel(e) {
    var deltaX = e.deltaX,
      deltaY = e.deltaY;

    // Convert both to x & y since wheel only happened on PC
    var mixed = 0;
    var absX = Math.abs(deltaX);
    var absY = Math.abs(deltaY);
    if (absX === absY) {
      mixed = lastWheelDirectionRef.current === 'x' ? deltaX : deltaY;
    } else if (absX > absY) {
      mixed = deltaX;
      lastWheelDirectionRef.current = 'x';
    } else {
      mixed = deltaY;
      lastWheelDirectionRef.current = 'y';
    }
    if (onOffset(-mixed, -mixed)) {
      e.preventDefault();
    }
  }

  // ========================= Effect =========================
  var touchEventsRef = (0,react.useRef)(null);
  touchEventsRef.current = {
    onTouchStart: onTouchStart,
    onTouchMove: onTouchMove,
    onTouchEnd: onTouchEnd,
    onWheel: onWheel
  };
  react.useEffect(function () {
    function onProxyTouchStart(e) {
      touchEventsRef.current.onTouchStart(e);
    }
    function onProxyTouchMove(e) {
      touchEventsRef.current.onTouchMove(e);
    }
    function onProxyTouchEnd(e) {
      touchEventsRef.current.onTouchEnd(e);
    }
    function onProxyWheel(e) {
      touchEventsRef.current.onWheel(e);
    }
    document.addEventListener('touchmove', onProxyTouchMove, {
      passive: false
    });
    document.addEventListener('touchend', onProxyTouchEnd, {
      passive: false
    });

    // No need to clean up since element removed
    ref.current.addEventListener('touchstart', onProxyTouchStart, {
      passive: false
    });
    ref.current.addEventListener('wheel', onProxyWheel);
    return function () {
      document.removeEventListener('touchmove', onProxyTouchMove);
      document.removeEventListener('touchend', onProxyTouchEnd);
    };
  }, []);
}
// EXTERNAL MODULE: ./node_modules/rc-util/es/hooks/useLayoutEffect.js
var useLayoutEffect = __webpack_require__(8410);
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/hooks/useUpdate.js




/**
 * Help to merge callback with `useLayoutEffect`.
 * One time will only trigger once.
 */
function useUpdate(callback) {
  var _useState = (0,react.useState)(0),
    _useState2 = (0,slicedToArray/* default */.Z)(_useState, 2),
    count = _useState2[0],
    setCount = _useState2[1];
  var effectRef = (0,react.useRef)(0);
  var callbackRef = (0,react.useRef)();
  callbackRef.current = callback;

  // Trigger on `useLayoutEffect`
  (0,useLayoutEffect/* useLayoutUpdateEffect */.o)(function () {
    var _callbackRef$current;
    (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 || _callbackRef$current.call(callbackRef);
  }, [count]);

  // Trigger to update count
  return function () {
    if (effectRef.current !== count) {
      return;
    }
    effectRef.current += 1;
    setCount(effectRef.current);
  };
}
function useUpdateState(defaultState) {
  var batchRef = (0,react.useRef)([]);
  var _useState3 = (0,react.useState)({}),
    _useState4 = (0,slicedToArray/* default */.Z)(_useState3, 2),
    forceUpdate = _useState4[1];
  var state = (0,react.useRef)(typeof defaultState === 'function' ? defaultState() : defaultState);
  var flushUpdate = useUpdate(function () {
    var current = state.current;
    batchRef.current.forEach(function (callback) {
      current = callback(current);
    });
    batchRef.current = [];
    state.current = current;
    forceUpdate({});
  });
  function updater(callback) {
    batchRef.current.push(callback);
    flushUpdate();
  }
  return [state.current, updater];
}
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/hooks/useVisibleRange.js

var useVisibleRange_DEFAULT_SIZE = {
  width: 0,
  height: 0,
  left: 0,
  top: 0,
  right: 0
};
function useVisibleRange(tabOffsets, visibleTabContentValue, transform, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, _ref) {
  var tabs = _ref.tabs,
    tabPosition = _ref.tabPosition,
    rtl = _ref.rtl;
  var charUnit;
  var position;
  var transformSize;
  if (['top', 'bottom'].includes(tabPosition)) {
    charUnit = 'width';
    position = rtl ? 'right' : 'left';
    transformSize = Math.abs(transform);
  } else {
    charUnit = 'height';
    position = 'top';
    transformSize = -transform;
  }
  return (0,react.useMemo)(function () {
    if (!tabs.length) {
      return [0, 0];
    }
    var len = tabs.length;
    var endIndex = len;
    for (var i = 0; i < len; i += 1) {
      var offset = tabOffsets.get(tabs[i].key) || useVisibleRange_DEFAULT_SIZE;
      if (offset[position] + offset[charUnit] > transformSize + visibleTabContentValue) {
        endIndex = i - 1;
        break;
      }
    }
    var startIndex = 0;
    for (var _i = len - 1; _i >= 0; _i -= 1) {
      var _offset = tabOffsets.get(tabs[_i].key) || useVisibleRange_DEFAULT_SIZE;
      if (_offset[position] < transformSize) {
        startIndex = _i + 1;
        break;
      }
    }
    return startIndex >= endIndex ? [0, 0] : [startIndex, endIndex];
  }, [tabOffsets, visibleTabContentValue, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, transformSize, tabPosition, tabs.map(function (tab) {
    return tab.key;
  }).join('_'), rtl]);
}
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/util.js
/**
 * We trade Map as deps which may change with same value but different ref object.
 * We should make it as hash for deps
 * */
function stringify(obj) {
  var tgt;
  if (obj instanceof Map) {
    tgt = {};
    obj.forEach(function (v, k) {
      tgt[k] = v;
    });
  } else {
    tgt = obj;
  }
  return JSON.stringify(tgt);
}
var RC_TABS_DOUBLE_QUOTE = 'TABS_DQ';
function genDataNodeKey(key) {
  return String(key).replace(/"/g, RC_TABS_DOUBLE_QUOTE);
}
function getRemovable(closable, closeIcon, editable, disabled) {
  if (
  // Only editable tabs can be removed
  !editable ||
  // Tabs cannot be removed when disabled
  disabled ||
  // closable is false
  closable === false ||
  // If closable is undefined, the remove button should be hidden when closeIcon is null or false
  closable === undefined && (closeIcon === false || closeIcon === null)) {
    return false;
  }
  return true;
}
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/TabNavList/AddButton.js

var AddButton = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var prefixCls = props.prefixCls,
    editable = props.editable,
    locale = props.locale,
    style = props.style;
  if (!editable || editable.showAdd === false) {
    return null;
  }
  return /*#__PURE__*/react.createElement("button", {
    ref: ref,
    type: "button",
    className: "".concat(prefixCls, "-nav-add"),
    style: style,
    "aria-label": (locale === null || locale === void 0 ? void 0 : locale.addAriaLabel) || 'Add tab',
    onClick: function onClick(event) {
      editable.onEdit('add', {
        event: event
      });
    }
  }, editable.addIcon || '+');
});
/* harmony default export */ var TabNavList_AddButton = (AddButton);
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/TabNavList/ExtraContent.js


var ExtraContent = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var position = props.position,
    prefixCls = props.prefixCls,
    extra = props.extra;
  if (!extra) {
    return null;
  }
  var content;

  // Parse extra
  var assertExtra = {};
  if ((0,esm_typeof/* default */.Z)(extra) === 'object' && ! /*#__PURE__*/react.isValidElement(extra)) {
    assertExtra = extra;
  } else {
    assertExtra.right = extra;
  }
  if (position === 'right') {
    content = assertExtra.right;
  }
  if (position === 'left') {
    content = assertExtra.left;
  }
  return content ? /*#__PURE__*/react.createElement("div", {
    className: "".concat(prefixCls, "-extra-content"),
    ref: ref
  }, content) : null;
});
if (false) {}
/* harmony default export */ var TabNavList_ExtraContent = (ExtraContent);
// EXTERNAL MODULE: ./node_modules/@rc-component/trigger/es/index.js + 11 modules
var trigger_es = __webpack_require__(40228);
// EXTERNAL MODULE: ./node_modules/rc-util/es/KeyCode.js
var KeyCode = __webpack_require__(15105);
;// CONCATENATED MODULE: ./node_modules/rc-dropdown/es/hooks/useAccessibility.js



var ESC = KeyCode/* default */.Z.ESC,
  TAB = KeyCode/* default */.Z.TAB;
function useAccessibility(_ref) {
  var visible = _ref.visible,
    triggerRef = _ref.triggerRef,
    onVisibleChange = _ref.onVisibleChange,
    autoFocus = _ref.autoFocus,
    overlayRef = _ref.overlayRef;
  var focusMenuRef = react.useRef(false);
  var handleCloseMenuAndReturnFocus = function handleCloseMenuAndReturnFocus() {
    if (visible) {
      var _triggerRef$current, _triggerRef$current$f;
      (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 || (_triggerRef$current$f = _triggerRef$current.focus) === null || _triggerRef$current$f === void 0 || _triggerRef$current$f.call(_triggerRef$current);
      onVisibleChange === null || onVisibleChange === void 0 || onVisibleChange(false);
    }
  };
  var focusMenu = function focusMenu() {
    var _overlayRef$current;
    if ((_overlayRef$current = overlayRef.current) !== null && _overlayRef$current !== void 0 && _overlayRef$current.focus) {
      overlayRef.current.focus();
      focusMenuRef.current = true;
      return true;
    }
    return false;
  };
  var handleKeyDown = function handleKeyDown(event) {
    switch (event.keyCode) {
      case ESC:
        handleCloseMenuAndReturnFocus();
        break;
      case TAB:
        {
          var focusResult = false;
          if (!focusMenuRef.current) {
            focusResult = focusMenu();
          }
          if (focusResult) {
            event.preventDefault();
          } else {
            handleCloseMenuAndReturnFocus();
          }
          break;
        }
    }
  };
  react.useEffect(function () {
    if (visible) {
      window.addEventListener("keydown", handleKeyDown);
      if (autoFocus) {
        // FIXME: hack with raf
        (0,raf/* default */.Z)(focusMenu, 3);
      }
      return function () {
        window.removeEventListener("keydown", handleKeyDown);
        focusMenuRef.current = false;
      };
    }
    return function () {
      focusMenuRef.current = false;
    };
  }, [visible]); // eslint-disable-line react-hooks/exhaustive-deps
}
;// CONCATENATED MODULE: ./node_modules/rc-dropdown/es/Overlay.js


var Overlay = /*#__PURE__*/(0,react.forwardRef)(function (props, ref) {
  var overlay = props.overlay,
    arrow = props.arrow,
    prefixCls = props.prefixCls;
  var overlayNode = (0,react.useMemo)(function () {
    var overlayElement;
    if (typeof overlay === 'function') {
      overlayElement = overlay();
    } else {
      overlayElement = overlay;
    }
    return overlayElement;
  }, [overlay]);
  var composedRef = (0,es_ref/* composeRef */.sQ)(ref, overlayNode === null || overlayNode === void 0 ? void 0 : overlayNode.ref);
  return /*#__PURE__*/react.createElement(react.Fragment, null, arrow && /*#__PURE__*/react.createElement("div", {
    className: "".concat(prefixCls, "-arrow")
  }), /*#__PURE__*/react.cloneElement(overlayNode, {
    ref: (0,es_ref/* supportRef */.Yr)(overlayNode) ? composedRef : undefined
  }));
});
/* harmony default export */ var es_Overlay = (Overlay);
;// CONCATENATED MODULE: ./node_modules/rc-dropdown/es/placements.js
var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset = [0, 0];
var placements = {
  topLeft: {
    points: ['bl', 'tl'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  top: {
    points: ['bc', 'tc'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  topRight: {
    points: ['br', 'tr'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  bottom: {
    points: ['tc', 'bc'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  bottomRight: {
    points: ['tr', 'br'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  }
};
/* harmony default export */ var es_placements = (placements);
;// CONCATENATED MODULE: ./node_modules/rc-dropdown/es/Dropdown.js




var _excluded = ["arrow", "prefixCls", "transitionName", "animation", "align", "placement", "placements", "getPopupContainer", "showAction", "hideAction", "overlayClassName", "overlayStyle", "visible", "trigger", "autoFocus", "overlay", "children", "onVisibleChange"];







function Dropdown(props, ref) {
  var _children$props;
  var _props$arrow = props.arrow,
    arrow = _props$arrow === void 0 ? false : _props$arrow,
    _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-dropdown' : _props$prefixCls,
    transitionName = props.transitionName,
    animation = props.animation,
    align = props.align,
    _props$placement = props.placement,
    placement = _props$placement === void 0 ? 'bottomLeft' : _props$placement,
    _props$placements = props.placements,
    placements = _props$placements === void 0 ? es_placements : _props$placements,
    getPopupContainer = props.getPopupContainer,
    showAction = props.showAction,
    hideAction = props.hideAction,
    overlayClassName = props.overlayClassName,
    overlayStyle = props.overlayStyle,
    visible = props.visible,
    _props$trigger = props.trigger,
    trigger = _props$trigger === void 0 ? ['hover'] : _props$trigger,
    autoFocus = props.autoFocus,
    overlay = props.overlay,
    children = props.children,
    onVisibleChange = props.onVisibleChange,
    otherProps = (0,objectWithoutProperties/* default */.Z)(props, _excluded);
  var _React$useState = react.useState(),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    triggerVisible = _React$useState2[0],
    setTriggerVisible = _React$useState2[1];
  var mergedVisible = 'visible' in props ? visible : triggerVisible;
  var triggerRef = react.useRef(null);
  var overlayRef = react.useRef(null);
  var childRef = react.useRef(null);
  react.useImperativeHandle(ref, function () {
    return triggerRef.current;
  });
  var handleVisibleChange = function handleVisibleChange(newVisible) {
    setTriggerVisible(newVisible);
    onVisibleChange === null || onVisibleChange === void 0 || onVisibleChange(newVisible);
  };
  useAccessibility({
    visible: mergedVisible,
    triggerRef: childRef,
    onVisibleChange: handleVisibleChange,
    autoFocus: autoFocus,
    overlayRef: overlayRef
  });
  var onClick = function onClick(e) {
    var onOverlayClick = props.onOverlayClick;
    setTriggerVisible(false);
    if (onOverlayClick) {
      onOverlayClick(e);
    }
  };
  var getMenuElement = function getMenuElement() {
    return /*#__PURE__*/react.createElement(es_Overlay, {
      ref: overlayRef,
      overlay: overlay,
      prefixCls: prefixCls,
      arrow: arrow
    });
  };
  var getMenuElementOrLambda = function getMenuElementOrLambda() {
    if (typeof overlay === 'function') {
      return getMenuElement;
    }
    return getMenuElement();
  };
  var getMinOverlayWidthMatchTrigger = function getMinOverlayWidthMatchTrigger() {
    var minOverlayWidthMatchTrigger = props.minOverlayWidthMatchTrigger,
      alignPoint = props.alignPoint;
    if ('minOverlayWidthMatchTrigger' in props) {
      return minOverlayWidthMatchTrigger;
    }
    return !alignPoint;
  };
  var getOpenClassName = function getOpenClassName() {
    var openClassName = props.openClassName;
    if (openClassName !== undefined) {
      return openClassName;
    }
    return "".concat(prefixCls, "-open");
  };
  var childrenNode = /*#__PURE__*/react.cloneElement(children, {
    className: classnames_default()((_children$props = children.props) === null || _children$props === void 0 ? void 0 : _children$props.className, mergedVisible && getOpenClassName()),
    ref: (0,es_ref/* supportRef */.Yr)(children) ? (0,es_ref/* composeRef */.sQ)(childRef, children.ref) : undefined
  });
  var triggerHideAction = hideAction;
  if (!triggerHideAction && trigger.indexOf('contextMenu') !== -1) {
    triggerHideAction = ['click'];
  }
  return /*#__PURE__*/react.createElement(trigger_es/* default */.Z, (0,esm_extends/* default */.Z)({
    builtinPlacements: placements
  }, otherProps, {
    prefixCls: prefixCls,
    ref: triggerRef,
    popupClassName: classnames_default()(overlayClassName, (0,defineProperty/* default */.Z)({}, "".concat(prefixCls, "-show-arrow"), arrow)),
    popupStyle: overlayStyle,
    action: trigger,
    showAction: showAction,
    hideAction: triggerHideAction,
    popupPlacement: placement,
    popupAlign: align,
    popupTransitionName: transitionName,
    popupAnimation: animation,
    popupVisible: mergedVisible,
    stretch: getMinOverlayWidthMatchTrigger() ? 'minWidth' : '',
    popup: getMenuElementOrLambda(),
    onPopupVisibleChange: handleVisibleChange,
    onPopupClick: onClick,
    getPopupContainer: getPopupContainer
  }), childrenNode);
}
/* harmony default export */ var es_Dropdown = (/*#__PURE__*/react.forwardRef(Dropdown));
;// CONCATENATED MODULE: ./node_modules/rc-dropdown/es/index.js

/* harmony default export */ var rc_dropdown_es = (es_Dropdown);
;// CONCATENATED MODULE: ./node_modules/rc-overflow/es/Item.js



var Item_excluded = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"];



// Use shared variable to save bundle size
var UNDEFINED = undefined;
function InternalItem(props, ref) {
  var prefixCls = props.prefixCls,
    invalidate = props.invalidate,
    item = props.item,
    renderItem = props.renderItem,
    responsive = props.responsive,
    responsiveDisabled = props.responsiveDisabled,
    registerSize = props.registerSize,
    itemKey = props.itemKey,
    className = props.className,
    style = props.style,
    children = props.children,
    display = props.display,
    order = props.order,
    _props$component = props.component,
    Component = _props$component === void 0 ? 'div' : _props$component,
    restProps = (0,objectWithoutProperties/* default */.Z)(props, Item_excluded);
  var mergedHidden = responsive && !display;
  // ================================ Effect ================================
  function internalRegisterSize(width) {
    registerSize(itemKey, width);
  }
  react.useEffect(function () {
    return function () {
      internalRegisterSize(null);
    };
  }, []);
  // ================================ Render ================================
  var childNode = renderItem && item !== UNDEFINED ? renderItem(item) : children;
  var overflowStyle;
  if (!invalidate) {
    overflowStyle = {
      opacity: mergedHidden ? 0 : 1,
      height: mergedHidden ? 0 : UNDEFINED,
      overflowY: mergedHidden ? 'hidden' : UNDEFINED,
      order: responsive ? order : UNDEFINED,
      pointerEvents: mergedHidden ? 'none' : UNDEFINED,
      position: mergedHidden ? 'absolute' : UNDEFINED
    };
  }
  var overflowProps = {};
  if (mergedHidden) {
    overflowProps['aria-hidden'] = true;
  }
  var itemNode = /*#__PURE__*/react.createElement(Component, (0,esm_extends/* default */.Z)({
    className: classnames_default()(!invalidate && prefixCls, className),
    style: (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, overflowStyle), style)
  }, overflowProps, restProps, {
    ref: ref
  }), childNode);
  if (responsive) {
    itemNode = /*#__PURE__*/react.createElement(es/* default */.Z, {
      onResize: function onResize(_ref) {
        var offsetWidth = _ref.offsetWidth;
        internalRegisterSize(offsetWidth);
      },
      disabled: responsiveDisabled
    }, itemNode);
  }
  return itemNode;
}
var Item = /*#__PURE__*/react.forwardRef(InternalItem);
Item.displayName = 'Item';
/* harmony default export */ var es_Item = (Item);
// EXTERNAL MODULE: ./node_modules/@umijs/preset-umi/node_modules/react-dom/index.js
var react_dom = __webpack_require__(61254);
;// CONCATENATED MODULE: ./node_modules/rc-overflow/es/hooks/channelUpdate.js

function channelUpdate(callback) {
  if (typeof MessageChannel === 'undefined') {
    (0,raf/* default */.Z)(callback);
  } else {
    var channel = new MessageChannel();
    channel.port1.onmessage = function () {
      return callback();
    };
    channel.port2.postMessage(undefined);
  }
}
;// CONCATENATED MODULE: ./node_modules/rc-overflow/es/hooks/useEffectState.js





/**
 * Batcher for record any `useEffectState` need update.
 */
function useBatcher() {
  // Updater Trigger
  var updateFuncRef = react.useRef(null);
  // Notify update
  var notifyEffectUpdate = function notifyEffectUpdate(callback) {
    if (!updateFuncRef.current) {
      updateFuncRef.current = [];
      channelUpdate(function () {
        (0,react_dom.unstable_batchedUpdates)(function () {
          updateFuncRef.current.forEach(function (fn) {
            fn();
          });
          updateFuncRef.current = null;
        });
      });
    }
    updateFuncRef.current.push(callback);
  };
  return notifyEffectUpdate;
}
/**
 * Trigger state update by `useLayoutEffect` to save perf.
 */
function useEffectState(notifyEffectUpdate, defaultValue) {
  // Value
  var _React$useState = react.useState(defaultValue),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    stateValue = _React$useState2[0],
    setStateValue = _React$useState2[1];
  // Set State
  var setEffectVal = (0,useEvent/* default */.Z)(function (nextValue) {
    notifyEffectUpdate(function () {
      setStateValue(nextValue);
    });
  });
  return [stateValue, setEffectVal];
}
;// CONCATENATED MODULE: ./node_modules/rc-overflow/es/context.js

var OverflowContext = /*#__PURE__*/react.createContext(null);
;// CONCATENATED MODULE: ./node_modules/rc-overflow/es/RawItem.js


var RawItem_excluded = ["component"],
  _excluded2 = ["className"],
  _excluded3 = ["className"];




var InternalRawItem = function InternalRawItem(props, ref) {
  var context = react.useContext(OverflowContext);
  // Render directly when context not provided
  if (!context) {
    var _props$component = props.component,
      Component = _props$component === void 0 ? 'div' : _props$component,
      _restProps = (0,objectWithoutProperties/* default */.Z)(props, RawItem_excluded);
    return /*#__PURE__*/react.createElement(Component, (0,esm_extends/* default */.Z)({}, _restProps, {
      ref: ref
    }));
  }
  var contextClassName = context.className,
    restContext = (0,objectWithoutProperties/* default */.Z)(context, _excluded2);
  var className = props.className,
    restProps = (0,objectWithoutProperties/* default */.Z)(props, _excluded3);
  // Do not pass context to sub item to avoid multiple measure
  return /*#__PURE__*/react.createElement(OverflowContext.Provider, {
    value: null
  }, /*#__PURE__*/react.createElement(es_Item, (0,esm_extends/* default */.Z)({
    ref: ref,
    className: classnames_default()(contextClassName, className)
  }, restContext, restProps)));
};
var RawItem = /*#__PURE__*/react.forwardRef(InternalRawItem);
RawItem.displayName = 'RawItem';
/* harmony default export */ var es_RawItem = (RawItem);
;// CONCATENATED MODULE: ./node_modules/rc-overflow/es/Overflow.js




var Overflow_excluded = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"];









var RESPONSIVE = 'responsive';
var INVALIDATE = 'invalidate';

function defaultRenderRest(omittedItems) {
  return "+ ".concat(omittedItems.length, " ...");
}
function Overflow(props, ref) {
  var _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-overflow' : _props$prefixCls,
    _props$data = props.data,
    data = _props$data === void 0 ? [] : _props$data,
    renderItem = props.renderItem,
    renderRawItem = props.renderRawItem,
    itemKey = props.itemKey,
    _props$itemWidth = props.itemWidth,
    itemWidth = _props$itemWidth === void 0 ? 10 : _props$itemWidth,
    ssr = props.ssr,
    style = props.style,
    className = props.className,
    maxCount = props.maxCount,
    renderRest = props.renderRest,
    renderRawRest = props.renderRawRest,
    suffix = props.suffix,
    _props$component = props.component,
    Component = _props$component === void 0 ? 'div' : _props$component,
    itemComponent = props.itemComponent,
    onVisibleChange = props.onVisibleChange,
    restProps = (0,objectWithoutProperties/* default */.Z)(props, Overflow_excluded);
  var fullySSR = ssr === 'full';
  var notifyEffectUpdate = useBatcher();
  var _useEffectState = useEffectState(notifyEffectUpdate, null),
    _useEffectState2 = (0,slicedToArray/* default */.Z)(_useEffectState, 2),
    containerWidth = _useEffectState2[0],
    setContainerWidth = _useEffectState2[1];
  var mergedContainerWidth = containerWidth || 0;
  var _useEffectState3 = useEffectState(notifyEffectUpdate, new Map()),
    _useEffectState4 = (0,slicedToArray/* default */.Z)(_useEffectState3, 2),
    itemWidths = _useEffectState4[0],
    setItemWidths = _useEffectState4[1];
  var _useEffectState5 = useEffectState(notifyEffectUpdate, 0),
    _useEffectState6 = (0,slicedToArray/* default */.Z)(_useEffectState5, 2),
    prevRestWidth = _useEffectState6[0],
    setPrevRestWidth = _useEffectState6[1];
  var _useEffectState7 = useEffectState(notifyEffectUpdate, 0),
    _useEffectState8 = (0,slicedToArray/* default */.Z)(_useEffectState7, 2),
    restWidth = _useEffectState8[0],
    setRestWidth = _useEffectState8[1];
  var _useEffectState9 = useEffectState(notifyEffectUpdate, 0),
    _useEffectState10 = (0,slicedToArray/* default */.Z)(_useEffectState9, 2),
    suffixWidth = _useEffectState10[0],
    setSuffixWidth = _useEffectState10[1];
  var _useState = (0,react.useState)(null),
    _useState2 = (0,slicedToArray/* default */.Z)(_useState, 2),
    suffixFixedStart = _useState2[0],
    setSuffixFixedStart = _useState2[1];
  var _useState3 = (0,react.useState)(null),
    _useState4 = (0,slicedToArray/* default */.Z)(_useState3, 2),
    displayCount = _useState4[0],
    setDisplayCount = _useState4[1];
  var mergedDisplayCount = react.useMemo(function () {
    if (displayCount === null && fullySSR) {
      return Number.MAX_SAFE_INTEGER;
    }
    return displayCount || 0;
  }, [displayCount, containerWidth]);
  var _useState5 = (0,react.useState)(false),
    _useState6 = (0,slicedToArray/* default */.Z)(_useState5, 2),
    restReady = _useState6[0],
    setRestReady = _useState6[1];
  var itemPrefixCls = "".concat(prefixCls, "-item");
  // Always use the max width to avoid blink
  var mergedRestWidth = Math.max(prevRestWidth, restWidth);
  // ================================= Data =================================
  var isResponsive = maxCount === RESPONSIVE;
  var shouldResponsive = data.length && isResponsive;
  var invalidate = maxCount === INVALIDATE;
  /**
   * When is `responsive`, we will always render rest node to get the real width of it for calculation
   */
  var showRest = shouldResponsive || typeof maxCount === 'number' && data.length > maxCount;
  var mergedData = (0,react.useMemo)(function () {
    var items = data;
    if (shouldResponsive) {
      if (containerWidth === null && fullySSR) {
        items = data;
      } else {
        items = data.slice(0, Math.min(data.length, mergedContainerWidth / itemWidth));
      }
    } else if (typeof maxCount === 'number') {
      items = data.slice(0, maxCount);
    }
    return items;
  }, [data, itemWidth, containerWidth, maxCount, shouldResponsive]);
  var omittedItems = (0,react.useMemo)(function () {
    if (shouldResponsive) {
      return data.slice(mergedDisplayCount + 1);
    }
    return data.slice(mergedData.length);
  }, [data, mergedData, shouldResponsive, mergedDisplayCount]);
  // ================================= Item =================================
  var getKey = (0,react.useCallback)(function (item, index) {
    var _ref;
    if (typeof itemKey === 'function') {
      return itemKey(item);
    }
    return (_ref = itemKey && (item === null || item === void 0 ? void 0 : item[itemKey])) !== null && _ref !== void 0 ? _ref : index;
  }, [itemKey]);
  var mergedRenderItem = (0,react.useCallback)(renderItem || function (item) {
    return item;
  }, [renderItem]);
  function updateDisplayCount(count, suffixFixedStartVal, notReady) {
    // React 18 will sync render even when the value is same in some case.
    // We take `mergedData` as deps which may cause dead loop if it's dynamic generate.
    // ref: https://github.com/ant-design/ant-design/issues/36559
    if (displayCount === count && (suffixFixedStartVal === undefined || suffixFixedStartVal === suffixFixedStart)) {
      return;
    }
    setDisplayCount(count);
    if (!notReady) {
      setRestReady(count < data.length - 1);
      onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(count);
    }
    if (suffixFixedStartVal !== undefined) {
      setSuffixFixedStart(suffixFixedStartVal);
    }
  }
  // ================================= Size =================================
  function onOverflowResize(_, element) {
    setContainerWidth(element.clientWidth);
  }
  function registerSize(key, width) {
    setItemWidths(function (origin) {
      var clone = new Map(origin);
      if (width === null) {
        clone.delete(key);
      } else {
        clone.set(key, width);
      }
      return clone;
    });
  }
  function registerOverflowSize(_, width) {
    setRestWidth(width);
    setPrevRestWidth(restWidth);
  }
  function registerSuffixSize(_, width) {
    setSuffixWidth(width);
  }
  // ================================ Effect ================================
  function getItemWidth(index) {
    return itemWidths.get(getKey(mergedData[index], index));
  }
  (0,useLayoutEffect/* default */.Z)(function () {
    if (mergedContainerWidth && typeof mergedRestWidth === 'number' && mergedData) {
      var totalWidth = suffixWidth;
      var len = mergedData.length;
      var lastIndex = len - 1;
      // When data count change to 0, reset this since not loop will reach
      if (!len) {
        updateDisplayCount(0, null);
        return;
      }
      for (var i = 0; i < len; i += 1) {
        var currentItemWidth = getItemWidth(i);
        // Fully will always render
        if (fullySSR) {
          currentItemWidth = currentItemWidth || 0;
        }
        // Break since data not ready
        if (currentItemWidth === undefined) {
          updateDisplayCount(i - 1, undefined, true);
          break;
        }
        // Find best match
        totalWidth += currentItemWidth;
        if (
        // Only one means `totalWidth` is the final width
        lastIndex === 0 && totalWidth <= mergedContainerWidth ||
        // Last two width will be the final width
        i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth) {
          // Additional check if match the end
          updateDisplayCount(lastIndex, null);
          break;
        } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
          // Can not hold all the content to show rest
          updateDisplayCount(i - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
          break;
        }
      }
      if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
        setSuffixFixedStart(null);
      }
    }
  }, [mergedContainerWidth, itemWidths, restWidth, suffixWidth, getKey, mergedData]);
  // ================================ Render ================================
  var displayRest = restReady && !!omittedItems.length;
  var suffixStyle = {};
  if (suffixFixedStart !== null && shouldResponsive) {
    suffixStyle = {
      position: 'absolute',
      left: suffixFixedStart,
      top: 0
    };
  }
  var itemSharedProps = {
    prefixCls: itemPrefixCls,
    responsive: shouldResponsive,
    component: itemComponent,
    invalidate: invalidate
  };
  // >>>>> Choice render fun by `renderRawItem`
  var internalRenderItemNode = renderRawItem ? function (item, index) {
    var key = getKey(item, index);
    return /*#__PURE__*/react.createElement(OverflowContext.Provider, {
      key: key,
      value: (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, itemSharedProps), {}, {
        order: index,
        item: item,
        itemKey: key,
        registerSize: registerSize,
        display: index <= mergedDisplayCount
      })
    }, renderRawItem(item, index));
  } : function (item, index) {
    var key = getKey(item, index);
    return /*#__PURE__*/react.createElement(es_Item, (0,esm_extends/* default */.Z)({}, itemSharedProps, {
      order: index,
      key: key,
      item: item,
      renderItem: mergedRenderItem,
      itemKey: key,
      registerSize: registerSize,
      display: index <= mergedDisplayCount
    }));
  };
  // >>>>> Rest node
  var restNode;
  var restContextProps = {
    order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
    className: "".concat(itemPrefixCls, "-rest"),
    registerSize: registerOverflowSize,
    display: displayRest
  };
  if (!renderRawRest) {
    var mergedRenderRest = renderRest || defaultRenderRest;
    restNode = /*#__PURE__*/react.createElement(es_Item, (0,esm_extends/* default */.Z)({}, itemSharedProps, restContextProps), typeof mergedRenderRest === 'function' ? mergedRenderRest(omittedItems) : mergedRenderRest);
  } else if (renderRawRest) {
    restNode = /*#__PURE__*/react.createElement(OverflowContext.Provider, {
      value: (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, itemSharedProps), restContextProps)
    }, renderRawRest(omittedItems));
  }
  var overflowNode = /*#__PURE__*/react.createElement(Component, (0,esm_extends/* default */.Z)({
    className: classnames_default()(!invalidate && prefixCls, className),
    style: style,
    ref: ref
  }, restProps), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && /*#__PURE__*/react.createElement(es_Item, (0,esm_extends/* default */.Z)({}, itemSharedProps, {
    responsive: isResponsive,
    responsiveDisabled: !shouldResponsive,
    order: mergedDisplayCount,
    className: "".concat(itemPrefixCls, "-suffix"),
    registerSize: registerSuffixSize,
    display: true,
    style: suffixStyle
  }), suffix));
  if (isResponsive) {
    overflowNode = /*#__PURE__*/react.createElement(es/* default */.Z, {
      onResize: onOverflowResize,
      disabled: !shouldResponsive
    }, overflowNode);
  }
  return overflowNode;
}
var ForwardOverflow = /*#__PURE__*/react.forwardRef(Overflow);
ForwardOverflow.displayName = 'Overflow';
ForwardOverflow.Item = es_RawItem;
ForwardOverflow.RESPONSIVE = RESPONSIVE;
ForwardOverflow.INVALIDATE = INVALIDATE;
// Convert to generic type
/* harmony default export */ var es_Overflow = (ForwardOverflow);
;// CONCATENATED MODULE: ./node_modules/rc-overflow/es/index.js

/* harmony default export */ var rc_overflow_es = (es_Overflow);
// EXTERNAL MODULE: ./node_modules/rc-util/es/isEqual.js
var isEqual = __webpack_require__(91881);
// EXTERNAL MODULE: ./node_modules/rc-util/es/warning.js
var warning = __webpack_require__(80334);
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/context/IdContext.js

var IdContext = /*#__PURE__*/react.createContext(null);
function getMenuId(uuid, eventKey) {
  if (uuid === undefined) {
    return null;
  }
  return "".concat(uuid, "-").concat(eventKey);
}

/**
 * Get `data-menu-id`
 */
function useMenuId(eventKey) {
  var id = react.useContext(IdContext);
  return getMenuId(id, eventKey);
}
// EXTERNAL MODULE: ./node_modules/rc-util/es/hooks/useMemo.js
var useMemo = __webpack_require__(56982);
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/context/MenuContext.js


var MenuContext_excluded = ["children", "locked"];



var MenuContext = /*#__PURE__*/react.createContext(null);
function mergeProps(origin, target) {
  var clone = (0,objectSpread2/* default */.Z)({}, origin);
  Object.keys(target).forEach(function (key) {
    var value = target[key];
    if (value !== undefined) {
      clone[key] = value;
    }
  });
  return clone;
}
function InheritableContextProvider(_ref) {
  var children = _ref.children,
    locked = _ref.locked,
    restProps = (0,objectWithoutProperties/* default */.Z)(_ref, MenuContext_excluded);
  var context = react.useContext(MenuContext);
  var inheritableContext = (0,useMemo/* default */.Z)(function () {
    return mergeProps(context, restProps);
  }, [context, restProps], function (prev, next) {
    return !locked && (prev[0] !== next[0] || !(0,isEqual/* default */.Z)(prev[1], next[1], true));
  });
  return /*#__PURE__*/react.createElement(MenuContext.Provider, {
    value: inheritableContext
  }, children);
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/context/PathContext.js


var EmptyList = [];

// ========================= Path Register =========================

var PathRegisterContext = /*#__PURE__*/react.createContext(null);
function useMeasure() {
  return react.useContext(PathRegisterContext);
}

// ========================= Path Tracker ==========================
var PathTrackerContext = /*#__PURE__*/react.createContext(EmptyList);
function useFullPath(eventKey) {
  var parentKeyPath = react.useContext(PathTrackerContext);
  return react.useMemo(function () {
    return eventKey !== undefined ? [].concat((0,toConsumableArray/* default */.Z)(parentKeyPath), [eventKey]) : parentKeyPath;
  }, [parentKeyPath, eventKey]);
}

// =========================== Path User ===========================

var PathUserContext = /*#__PURE__*/react.createContext(null);
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/context/PrivateContext.js

var PrivateContext = /*#__PURE__*/react.createContext({});
/* harmony default export */ var context_PrivateContext = (PrivateContext);
// EXTERNAL MODULE: ./node_modules/rc-util/es/Dom/isVisible.js
var isVisible = __webpack_require__(5110);
;// CONCATENATED MODULE: ./node_modules/rc-util/es/Dom/focus.js


function focusable(node) {
  var includePositive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if ((0,isVisible/* default */.Z)(node)) {
    var nodeName = node.nodeName.toLowerCase();
    var isFocusableElement =
    // Focusable element
    ['input', 'select', 'textarea', 'button'].includes(nodeName) ||
    // Editable element
    node.isContentEditable ||
    // Anchor with href element
    nodeName === 'a' && !!node.getAttribute('href');

    // Get tabIndex
    var tabIndexAttr = node.getAttribute('tabindex');
    var tabIndexNum = Number(tabIndexAttr);

    // Parse as number if validate
    var tabIndex = null;
    if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {
      tabIndex = tabIndexNum;
    } else if (isFocusableElement && tabIndex === null) {
      tabIndex = 0;
    }

    // Block focusable if disabled
    if (isFocusableElement && node.disabled) {
      tabIndex = null;
    }
    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
  }
  return false;
}
function getFocusNodeList(node) {
  var includePositive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var res = (0,toConsumableArray/* default */.Z)(node.querySelectorAll('*')).filter(function (child) {
    return focusable(child, includePositive);
  });
  if (focusable(node, includePositive)) {
    res.unshift(node);
  }
  return res;
}
var lastFocusElement = null;

/** @deprecated Do not use since this may failed when used in async */
function saveLastFocusNode() {
  lastFocusElement = document.activeElement;
}

/** @deprecated Do not use since this may failed when used in async */
function clearLastFocusNode() {
  lastFocusElement = null;
}

/** @deprecated Do not use since this may failed when used in async */
function backLastFocusNode() {
  if (lastFocusElement) {
    try {
      // 元素可能已经被移动了
      lastFocusElement.focus();

      /* eslint-disable no-empty */
    } catch (e) {
      // empty
    }
    /* eslint-enable no-empty */
  }
}
function limitTabRange(node, e) {
  if (e.keyCode === 9) {
    var tabNodeList = getFocusNodeList(node);
    var lastTabNode = tabNodeList[e.shiftKey ? 0 : tabNodeList.length - 1];
    var leavingTab = lastTabNode === document.activeElement || node === document.activeElement;
    if (leavingTab) {
      var target = tabNodeList[e.shiftKey ? tabNodeList.length - 1 : 0];
      target.focus();
      e.preventDefault();
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/hooks/useAccessibility.js






// destruct to reduce minify size
var LEFT = KeyCode/* default */.Z.LEFT,
  RIGHT = KeyCode/* default */.Z.RIGHT,
  UP = KeyCode/* default */.Z.UP,
  DOWN = KeyCode/* default */.Z.DOWN,
  ENTER = KeyCode/* default */.Z.ENTER,
  useAccessibility_ESC = KeyCode/* default */.Z.ESC,
  HOME = KeyCode/* default */.Z.HOME,
  END = KeyCode/* default */.Z.END;
var ArrowKeys = [UP, DOWN, LEFT, RIGHT];
function getOffset(mode, isRootLevel, isRtl, which) {
  var _offsets;
  var prev = 'prev';
  var next = 'next';
  var children = 'children';
  var parent = 'parent';

  // Inline enter is special that we use unique operation
  if (mode === 'inline' && which === ENTER) {
    return {
      inlineTrigger: true
    };
  }
  var inline = (0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)({}, UP, prev), DOWN, next);
  var horizontal = (0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)({}, LEFT, isRtl ? next : prev), RIGHT, isRtl ? prev : next), DOWN, children), ENTER, children);
  var vertical = (0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)({}, UP, prev), DOWN, next), ENTER, children), useAccessibility_ESC, parent), LEFT, isRtl ? children : parent), RIGHT, isRtl ? parent : children);
  var offsets = {
    inline: inline,
    horizontal: horizontal,
    vertical: vertical,
    inlineSub: inline,
    horizontalSub: vertical,
    verticalSub: vertical
  };
  var type = (_offsets = offsets["".concat(mode).concat(isRootLevel ? '' : 'Sub')]) === null || _offsets === void 0 ? void 0 : _offsets[which];
  switch (type) {
    case prev:
      return {
        offset: -1,
        sibling: true
      };
    case next:
      return {
        offset: 1,
        sibling: true
      };
    case parent:
      return {
        offset: -1,
        sibling: false
      };
    case children:
      return {
        offset: 1,
        sibling: false
      };
    default:
      return null;
  }
}
function findContainerUL(element) {
  var current = element;
  while (current) {
    if (current.getAttribute('data-menu-list')) {
      return current;
    }
    current = current.parentElement;
  }

  // Normally should not reach this line
  /* istanbul ignore next */
  return null;
}

/**
 * Find focused element within element set provided
 */
function getFocusElement(activeElement, elements) {
  var current = activeElement || document.activeElement;
  while (current) {
    if (elements.has(current)) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}

/**
 * Get focusable elements from the element set under provided container
 */
function getFocusableElements(container, elements) {
  var list = getFocusNodeList(container, true);
  return list.filter(function (ele) {
    return elements.has(ele);
  });
}
function getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {
  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  // Key on the menu item will not get validate parent container
  if (!parentQueryContainer) {
    return null;
  }

  // List current level menu item elements
  var sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);

  // Find next focus index
  var count = sameLevelFocusableMenuElementList.length;
  var focusIndex = sameLevelFocusableMenuElementList.findIndex(function (ele) {
    return focusMenuElement === ele;
  });
  if (offset < 0) {
    if (focusIndex === -1) {
      focusIndex = count - 1;
    } else {
      focusIndex -= 1;
    }
  } else if (offset > 0) {
    focusIndex += 1;
  }
  focusIndex = (focusIndex + count) % count;

  // Focus menu item
  return sameLevelFocusableMenuElementList[focusIndex];
}
var refreshElements = function refreshElements(keys, id) {
  var elements = new Set();
  var key2element = new Map();
  var element2key = new Map();
  keys.forEach(function (key) {
    var element = document.querySelector("[data-menu-id='".concat(getMenuId(id, key), "']"));
    if (element) {
      elements.add(element);
      element2key.set(element, key);
      key2element.set(key, element);
    }
  });
  return {
    elements: elements,
    key2element: key2element,
    element2key: element2key
  };
};
function useAccessibility_useAccessibility(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
  var rafRef = react.useRef();
  var activeRef = react.useRef();
  activeRef.current = activeKey;
  var cleanRaf = function cleanRaf() {
    raf/* default */.Z.cancel(rafRef.current);
  };
  react.useEffect(function () {
    return function () {
      cleanRaf();
    };
  }, []);
  return function (e) {
    var which = e.which;
    if ([].concat(ArrowKeys, [ENTER, useAccessibility_ESC, HOME, END]).includes(which)) {
      var keys = getKeys();
      var refreshedElements = refreshElements(keys, id);
      var _refreshedElements = refreshedElements,
        elements = _refreshedElements.elements,
        key2element = _refreshedElements.key2element,
        element2key = _refreshedElements.element2key;

      // First we should find current focused MenuItem/SubMenu element
      var activeElement = key2element.get(activeKey);
      var focusMenuElement = getFocusElement(activeElement, elements);
      var focusMenuKey = element2key.get(focusMenuElement);
      var offsetObj = getOffset(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);

      // Some mode do not have fully arrow operation like inline
      if (!offsetObj && which !== HOME && which !== END) {
        return;
      }

      // Arrow prevent default to avoid page scroll
      if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {
        e.preventDefault();
      }
      var tryFocus = function tryFocus(menuElement) {
        if (menuElement) {
          var focusTargetElement = menuElement;

          // Focus to link instead of menu item if possible
          var link = menuElement.querySelector('a');
          if (link !== null && link !== void 0 && link.getAttribute('href')) {
            focusTargetElement = link;
          }
          var targetKey = element2key.get(menuElement);
          triggerActiveKey(targetKey);

          /**
           * Do not `useEffect` here since `tryFocus` may trigger async
           * which makes React sync update the `activeKey`
           * that force render before `useRef` set the next activeKey
           */
          cleanRaf();
          rafRef.current = (0,raf/* default */.Z)(function () {
            if (activeRef.current === targetKey) {
              focusTargetElement.focus();
            }
          });
        }
      };
      if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
        // ========================== Sibling ==========================
        // Find walkable focus menu element container
        var parentQueryContainer;
        if (!focusMenuElement || mode === 'inline') {
          parentQueryContainer = containerRef.current;
        } else {
          parentQueryContainer = findContainerUL(focusMenuElement);
        }

        // Get next focus element
        var targetElement;
        var focusableElements = getFocusableElements(parentQueryContainer, elements);
        if (which === HOME) {
          targetElement = focusableElements[0];
        } else if (which === END) {
          targetElement = focusableElements[focusableElements.length - 1];
        } else {
          targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);
        }
        // Focus menu item
        tryFocus(targetElement);

        // ======================= InlineTrigger =======================
      } else if (offsetObj.inlineTrigger) {
        // Inline trigger no need switch to sub menu item
        triggerAccessibilityOpen(focusMenuKey);
        // =========================== Level ===========================
      } else if (offsetObj.offset > 0) {
        triggerAccessibilityOpen(focusMenuKey, true);
        cleanRaf();
        rafRef.current = (0,raf/* default */.Z)(function () {
          // Async should resync elements
          refreshedElements = refreshElements(keys, id);
          var controlId = focusMenuElement.getAttribute('aria-controls');
          var subQueryContainer = document.getElementById(controlId);

          // Get sub focusable menu item
          var targetElement = getNextFocusElement(subQueryContainer, refreshedElements.elements);

          // Focus menu item
          tryFocus(targetElement);
        }, 5);
      } else if (offsetObj.offset < 0) {
        var keyPath = getKeyPath(focusMenuKey, true);
        var parentKey = keyPath[keyPath.length - 2];
        var parentMenuElement = key2element.get(parentKey);

        // Focus menu item
        triggerAccessibilityOpen(parentKey, false);
        tryFocus(parentMenuElement);
      }
    }

    // Pass origin key down event
    originOnKeyDown === null || originOnKeyDown === void 0 || originOnKeyDown(e);
  };
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/utils/timeUtil.js
function nextSlice(callback) {
  /* istanbul ignore next */
  Promise.resolve().then(callback);
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/hooks/useKeyRecords.js






var PATH_SPLIT = '__RC_UTIL_PATH_SPLIT__';
var getPathStr = function getPathStr(keyPath) {
  return keyPath.join(PATH_SPLIT);
};
var getPathKeys = function getPathKeys(keyPathStr) {
  return keyPathStr.split(PATH_SPLIT);
};
var OVERFLOW_KEY = 'rc-menu-more';
function useKeyRecords() {
  var _React$useState = react.useState({}),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    internalForceUpdate = _React$useState2[1];
  var key2pathRef = (0,react.useRef)(new Map());
  var path2keyRef = (0,react.useRef)(new Map());
  var _React$useState3 = react.useState([]),
    _React$useState4 = (0,slicedToArray/* default */.Z)(_React$useState3, 2),
    overflowKeys = _React$useState4[0],
    setOverflowKeys = _React$useState4[1];
  var updateRef = (0,react.useRef)(0);
  var destroyRef = (0,react.useRef)(false);
  var forceUpdate = function forceUpdate() {
    if (!destroyRef.current) {
      internalForceUpdate({});
    }
  };
  var registerPath = (0,react.useCallback)(function (key, keyPath) {
    // Warning for invalidate or duplicated `key`
    if (false) {}

    // Fill map
    var connectedPath = getPathStr(keyPath);
    path2keyRef.current.set(connectedPath, key);
    key2pathRef.current.set(key, connectedPath);
    updateRef.current += 1;
    var id = updateRef.current;
    nextSlice(function () {
      if (id === updateRef.current) {
        forceUpdate();
      }
    });
  }, []);
  var unregisterPath = (0,react.useCallback)(function (key, keyPath) {
    var connectedPath = getPathStr(keyPath);
    path2keyRef.current.delete(connectedPath);
    key2pathRef.current.delete(key);
  }, []);
  var refreshOverflowKeys = (0,react.useCallback)(function (keys) {
    setOverflowKeys(keys);
  }, []);
  var getKeyPath = (0,react.useCallback)(function (eventKey, includeOverflow) {
    var fullPath = key2pathRef.current.get(eventKey) || '';
    var keys = getPathKeys(fullPath);
    if (includeOverflow && overflowKeys.includes(keys[0])) {
      keys.unshift(OVERFLOW_KEY);
    }
    return keys;
  }, [overflowKeys]);
  var isSubPathKey = (0,react.useCallback)(function (pathKeys, eventKey) {
    return pathKeys.some(function (pathKey) {
      var pathKeyList = getKeyPath(pathKey, true);
      return pathKeyList.includes(eventKey);
    });
  }, [getKeyPath]);
  var getKeys = function getKeys() {
    var keys = (0,toConsumableArray/* default */.Z)(key2pathRef.current.keys());
    if (overflowKeys.length) {
      keys.push(OVERFLOW_KEY);
    }
    return keys;
  };

  /**
   * Find current key related child path keys
   */
  var getSubPathKeys = (0,react.useCallback)(function (key) {
    var connectedPath = "".concat(key2pathRef.current.get(key)).concat(PATH_SPLIT);
    var pathKeys = new Set();
    (0,toConsumableArray/* default */.Z)(path2keyRef.current.keys()).forEach(function (pathKey) {
      if (pathKey.startsWith(connectedPath)) {
        pathKeys.add(path2keyRef.current.get(pathKey));
      }
    });
    return pathKeys;
  }, []);
  react.useEffect(function () {
    return function () {
      destroyRef.current = true;
    };
  }, []);
  return {
    // Register
    registerPath: registerPath,
    unregisterPath: unregisterPath,
    refreshOverflowKeys: refreshOverflowKeys,
    // Util
    isSubPathKey: isSubPathKey,
    getKeyPath: getKeyPath,
    getKeys: getKeys,
    getSubPathKeys: getSubPathKeys
  };
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/hooks/useMemoCallback.js


/**
 * Cache callback function that always return same ref instead.
 * This is used for context optimization.
 */
function useMemoCallback(func) {
  var funRef = react.useRef(func);
  funRef.current = func;
  var callback = react.useCallback(function () {
    var _funRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_funRef$current = funRef.current) === null || _funRef$current === void 0 ? void 0 : _funRef$current.call.apply(_funRef$current, [funRef].concat(args));
  }, []);
  return func ? callback : undefined;
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/hooks/useUUID.js



var uniquePrefix = Math.random().toFixed(5).toString().slice(2);
var internalId = 0;
function useUUID(id) {
  var _useMergedState = (0,useMergedState/* default */.Z)(id, {
      value: id
    }),
    _useMergedState2 = (0,slicedToArray/* default */.Z)(_useMergedState, 2),
    uuid = _useMergedState2[0],
    setUUID = _useMergedState2[1];
  react.useEffect(function () {
    internalId += 1;
    var newId =  false ? 0 : "".concat(uniquePrefix, "-").concat(internalId);
    setUUID("rc-menu-uuid-".concat(newId));
  }, []);
  return uuid;
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
var classCallCheck = __webpack_require__(15671);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
var createClass = __webpack_require__(43144);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js + 1 modules
var inherits = __webpack_require__(32531);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createSuper.js
var createSuper = __webpack_require__(29388);
// EXTERNAL MODULE: ./node_modules/rc-util/es/omit.js
var omit = __webpack_require__(98423);
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/hooks/useActive.js


function useActive(eventKey, disabled, onMouseEnter, onMouseLeave) {
  var _React$useContext = react.useContext(MenuContext),
    activeKey = _React$useContext.activeKey,
    onActive = _React$useContext.onActive,
    onInactive = _React$useContext.onInactive;
  var ret = {
    active: activeKey === eventKey
  };

  // Skip when disabled
  if (!disabled) {
    ret.onMouseEnter = function (domEvent) {
      onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({
        key: eventKey,
        domEvent: domEvent
      });
      onActive(eventKey);
    };
    ret.onMouseLeave = function (domEvent) {
      onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave({
        key: eventKey,
        domEvent: domEvent
      });
      onInactive(eventKey);
    };
  }
  return ret;
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/hooks/useDirectionStyle.js


function useDirectionStyle(level) {
  var _React$useContext = react.useContext(MenuContext),
    mode = _React$useContext.mode,
    rtl = _React$useContext.rtl,
    inlineIndent = _React$useContext.inlineIndent;
  if (mode !== 'inline') {
    return null;
  }
  var len = level;
  return rtl ? {
    paddingRight: len * inlineIndent
  } : {
    paddingLeft: len * inlineIndent
  };
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/Icon.js


function Icon(_ref) {
  var icon = _ref.icon,
    props = _ref.props,
    children = _ref.children;
  var iconNode;
  if (icon === null || icon === false) {
    return null;
  }
  if (typeof icon === 'function') {
    iconNode = /*#__PURE__*/react.createElement(icon, (0,objectSpread2/* default */.Z)({}, props));
  } else if (typeof icon !== "boolean") {
    // Compatible for origin definition
    iconNode = icon;
  }
  return iconNode || children || null;
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/utils/warnUtil.js

var warnUtil_excluded = ["item"];


/**
 * `onClick` event return `info.item` which point to react node directly.
 * We should warning this since it will not work on FC.
 */
function warnItemProp(_ref) {
  var item = _ref.item,
    restInfo = (0,objectWithoutProperties/* default */.Z)(_ref, warnUtil_excluded);
  Object.defineProperty(restInfo, 'item', {
    get: function get() {
      (0,warning/* default */.ZP)(false, '`info.item` is deprecated since we will move to function component that not provides React Node instance in future.');
      return item;
    }
  });
  return restInfo;
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/MenuItem.js









var MenuItem_excluded = ["title", "attribute", "elementRef"],
  MenuItem_excluded2 = ["style", "className", "eventKey", "warnKey", "disabled", "itemIcon", "children", "role", "onMouseEnter", "onMouseLeave", "onClick", "onKeyDown", "onFocus"],
  MenuItem_excluded3 = ["active"];















// Since Menu event provide the `info.item` which point to the MenuItem node instance.
// We have to use class component here.
// This should be removed from doc & api in future.
var LegacyMenuItem = /*#__PURE__*/function (_React$Component) {
  (0,inherits/* default */.Z)(LegacyMenuItem, _React$Component);
  var _super = (0,createSuper/* default */.Z)(LegacyMenuItem);
  function LegacyMenuItem() {
    (0,classCallCheck/* default */.Z)(this, LegacyMenuItem);
    return _super.apply(this, arguments);
  }
  (0,createClass/* default */.Z)(LegacyMenuItem, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
        title = _this$props.title,
        attribute = _this$props.attribute,
        elementRef = _this$props.elementRef,
        restProps = (0,objectWithoutProperties/* default */.Z)(_this$props, MenuItem_excluded);

      // Here the props are eventually passed to the DOM element.
      // React does not recognize non-standard attributes.
      // Therefore, remove the props that is not used here.
      // ref: https://github.com/ant-design/ant-design/issues/41395
      var passedProps = (0,omit/* default */.Z)(restProps, ['eventKey', 'popupClassName', 'popupOffset', 'onTitleClick']);
      (0,warning/* default */.ZP)(!attribute, '`attribute` of Menu.Item is deprecated. Please pass attribute directly.');
      return /*#__PURE__*/react.createElement(rc_overflow_es.Item, (0,esm_extends/* default */.Z)({}, attribute, {
        title: typeof title === 'string' ? title : undefined
      }, passedProps, {
        ref: elementRef
      }));
    }
  }]);
  return LegacyMenuItem;
}(react.Component);
/**
 * Real Menu Item component
 */
var InternalMenuItem = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var style = props.style,
    className = props.className,
    eventKey = props.eventKey,
    warnKey = props.warnKey,
    disabled = props.disabled,
    itemIcon = props.itemIcon,
    children = props.children,
    role = props.role,
    onMouseEnter = props.onMouseEnter,
    onMouseLeave = props.onMouseLeave,
    onClick = props.onClick,
    onKeyDown = props.onKeyDown,
    onFocus = props.onFocus,
    restProps = (0,objectWithoutProperties/* default */.Z)(props, MenuItem_excluded2);
  var domDataId = useMenuId(eventKey);
  var _React$useContext = react.useContext(MenuContext),
    prefixCls = _React$useContext.prefixCls,
    onItemClick = _React$useContext.onItemClick,
    contextDisabled = _React$useContext.disabled,
    overflowDisabled = _React$useContext.overflowDisabled,
    contextItemIcon = _React$useContext.itemIcon,
    selectedKeys = _React$useContext.selectedKeys,
    onActive = _React$useContext.onActive;
  var _React$useContext2 = react.useContext(context_PrivateContext),
    _internalRenderMenuItem = _React$useContext2._internalRenderMenuItem;
  var itemCls = "".concat(prefixCls, "-item");
  var legacyMenuItemRef = react.useRef();
  var elementRef = react.useRef();
  var mergedDisabled = contextDisabled || disabled;
  var mergedEleRef = (0,es_ref/* useComposeRef */.x1)(ref, elementRef);
  var connectedKeys = useFullPath(eventKey);

  // ================================ Warn ================================
  if (false) {}

  // ============================= Info =============================
  var getEventInfo = function getEventInfo(e) {
    return {
      key: eventKey,
      // Note: For legacy code is reversed which not like other antd component
      keyPath: (0,toConsumableArray/* default */.Z)(connectedKeys).reverse(),
      item: legacyMenuItemRef.current,
      domEvent: e
    };
  };

  // ============================= Icon =============================
  var mergedItemIcon = itemIcon || contextItemIcon;

  // ============================ Active ============================
  var _useActive = useActive(eventKey, mergedDisabled, onMouseEnter, onMouseLeave),
    active = _useActive.active,
    activeProps = (0,objectWithoutProperties/* default */.Z)(_useActive, MenuItem_excluded3);

  // ============================ Select ============================
  var selected = selectedKeys.includes(eventKey);

  // ======================== DirectionStyle ========================
  var directionStyle = useDirectionStyle(connectedKeys.length);

  // ============================ Events ============================
  var onInternalClick = function onInternalClick(e) {
    if (mergedDisabled) {
      return;
    }
    var info = getEventInfo(e);
    onClick === null || onClick === void 0 || onClick(warnItemProp(info));
    onItemClick(info);
  };
  var onInternalKeyDown = function onInternalKeyDown(e) {
    onKeyDown === null || onKeyDown === void 0 || onKeyDown(e);
    if (e.which === KeyCode/* default */.Z.ENTER) {
      var info = getEventInfo(e);

      // Legacy. Key will also trigger click event
      onClick === null || onClick === void 0 || onClick(warnItemProp(info));
      onItemClick(info);
    }
  };

  /**
   * Used for accessibility. Helper will focus element without key board.
   * We should manually trigger an active
   */
  var onInternalFocus = function onInternalFocus(e) {
    onActive(eventKey);
    onFocus === null || onFocus === void 0 || onFocus(e);
  };

  // ============================ Render ============================
  var optionRoleProps = {};
  if (props.role === 'option') {
    optionRoleProps['aria-selected'] = selected;
  }
  var renderNode = /*#__PURE__*/react.createElement(LegacyMenuItem, (0,esm_extends/* default */.Z)({
    ref: legacyMenuItemRef,
    elementRef: mergedEleRef,
    role: role === null ? 'none' : role || 'menuitem',
    tabIndex: disabled ? null : -1,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId
  }, restProps, activeProps, optionRoleProps, {
    component: "li",
    "aria-disabled": disabled,
    style: (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, directionStyle), style),
    className: classnames_default()(itemCls, (0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)({}, "".concat(itemCls, "-active"), active), "".concat(itemCls, "-selected"), selected), "".concat(itemCls, "-disabled"), mergedDisabled), className),
    onClick: onInternalClick,
    onKeyDown: onInternalKeyDown,
    onFocus: onInternalFocus
  }), children, /*#__PURE__*/react.createElement(Icon, {
    props: (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, props), {}, {
      isSelected: selected
    }),
    icon: mergedItemIcon
  }));
  if (_internalRenderMenuItem) {
    renderNode = _internalRenderMenuItem(renderNode, props, {
      selected: selected
    });
  }
  return renderNode;
});
function MenuItem(props, ref) {
  var eventKey = props.eventKey;

  // ==================== Record KeyPath ====================
  var measure = useMeasure();
  var connectedKeyPath = useFullPath(eventKey);

  // eslint-disable-next-line consistent-return
  react.useEffect(function () {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return function () {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  if (measure) {
    return null;
  }

  // ======================== Render ========================
  return /*#__PURE__*/react.createElement(InternalMenuItem, (0,esm_extends/* default */.Z)({}, props, {
    ref: ref
  }));
}
/* harmony default export */ var es_MenuItem = (/*#__PURE__*/react.forwardRef(MenuItem));
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/SubMenu/SubMenuList.js


var SubMenuList_excluded = ["className", "children"];



var InternalSubMenuList = function InternalSubMenuList(_ref, ref) {
  var className = _ref.className,
    children = _ref.children,
    restProps = (0,objectWithoutProperties/* default */.Z)(_ref, SubMenuList_excluded);
  var _React$useContext = react.useContext(MenuContext),
    prefixCls = _React$useContext.prefixCls,
    mode = _React$useContext.mode,
    rtl = _React$useContext.rtl;
  return /*#__PURE__*/react.createElement("ul", (0,esm_extends/* default */.Z)({
    className: classnames_default()(prefixCls, rtl && "".concat(prefixCls, "-rtl"), "".concat(prefixCls, "-sub"), "".concat(prefixCls, "-").concat(mode === 'inline' ? 'inline' : 'vertical'), className),
    role: "menu"
  }, restProps, {
    "data-menu-list": true,
    ref: ref
  }), children);
};
var SubMenuList = /*#__PURE__*/react.forwardRef(InternalSubMenuList);
SubMenuList.displayName = 'SubMenuList';
/* harmony default export */ var SubMenu_SubMenuList = (SubMenuList);
// EXTERNAL MODULE: ./node_modules/rc-util/es/Children/toArray.js
var toArray = __webpack_require__(50344);
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/utils/commonUtil.js



function parseChildren(children, keyPath) {
  return (0,toArray/* default */.Z)(children).map(function (child, index) {
    if ( /*#__PURE__*/react.isValidElement(child)) {
      var _eventKey, _child$props;
      var key = child.key;
      var eventKey = (_eventKey = (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.eventKey) !== null && _eventKey !== void 0 ? _eventKey : key;
      var emptyKey = eventKey === null || eventKey === undefined;
      if (emptyKey) {
        eventKey = "tmp_key-".concat([].concat((0,toConsumableArray/* default */.Z)(keyPath), [index]).join('-'));
      }
      var cloneProps = {
        key: eventKey,
        eventKey: eventKey
      };
      if (false) {}
      return /*#__PURE__*/react.cloneElement(child, cloneProps);
    }
    return child;
  });
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/placements.js
var placements_autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var placements_placements = {
  topLeft: {
    points: ['bl', 'tl'],
    overflow: placements_autoAdjustOverflow
  },
  topRight: {
    points: ['br', 'tr'],
    overflow: placements_autoAdjustOverflow
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: placements_autoAdjustOverflow
  },
  bottomRight: {
    points: ['tr', 'br'],
    overflow: placements_autoAdjustOverflow
  },
  leftTop: {
    points: ['tr', 'tl'],
    overflow: placements_autoAdjustOverflow
  },
  leftBottom: {
    points: ['br', 'bl'],
    overflow: placements_autoAdjustOverflow
  },
  rightTop: {
    points: ['tl', 'tr'],
    overflow: placements_autoAdjustOverflow
  },
  rightBottom: {
    points: ['bl', 'br'],
    overflow: placements_autoAdjustOverflow
  }
};
var placementsRtl = {
  topLeft: {
    points: ['bl', 'tl'],
    overflow: placements_autoAdjustOverflow
  },
  topRight: {
    points: ['br', 'tr'],
    overflow: placements_autoAdjustOverflow
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: placements_autoAdjustOverflow
  },
  bottomRight: {
    points: ['tr', 'br'],
    overflow: placements_autoAdjustOverflow
  },
  rightTop: {
    points: ['tr', 'tl'],
    overflow: placements_autoAdjustOverflow
  },
  rightBottom: {
    points: ['br', 'bl'],
    overflow: placements_autoAdjustOverflow
  },
  leftTop: {
    points: ['tl', 'tr'],
    overflow: placements_autoAdjustOverflow
  },
  leftBottom: {
    points: ['bl', 'br'],
    overflow: placements_autoAdjustOverflow
  }
};
/* harmony default export */ var rc_menu_es_placements = ((/* unused pure expression or super */ null && (placements_placements)));
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/utils/motionUtil.js
function getMotion(mode, motion, defaultMotions) {
  if (motion) {
    return motion;
  }
  if (defaultMotions) {
    return defaultMotions[mode] || defaultMotions.other;
  }
  return undefined;
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/SubMenu/PopupTrigger.js










var popupPlacementMap = {
  horizontal: 'bottomLeft',
  vertical: 'rightTop',
  'vertical-left': 'rightTop',
  'vertical-right': 'leftTop'
};
function PopupTrigger(_ref) {
  var prefixCls = _ref.prefixCls,
    visible = _ref.visible,
    children = _ref.children,
    popup = _ref.popup,
    popupStyle = _ref.popupStyle,
    popupClassName = _ref.popupClassName,
    popupOffset = _ref.popupOffset,
    disabled = _ref.disabled,
    mode = _ref.mode,
    onVisibleChange = _ref.onVisibleChange;
  var _React$useContext = react.useContext(MenuContext),
    getPopupContainer = _React$useContext.getPopupContainer,
    rtl = _React$useContext.rtl,
    subMenuOpenDelay = _React$useContext.subMenuOpenDelay,
    subMenuCloseDelay = _React$useContext.subMenuCloseDelay,
    builtinPlacements = _React$useContext.builtinPlacements,
    triggerSubMenuAction = _React$useContext.triggerSubMenuAction,
    forceSubMenuRender = _React$useContext.forceSubMenuRender,
    rootClassName = _React$useContext.rootClassName,
    motion = _React$useContext.motion,
    defaultMotions = _React$useContext.defaultMotions;
  var _React$useState = react.useState(false),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    innerVisible = _React$useState2[0],
    setInnerVisible = _React$useState2[1];
  var placement = rtl ? (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, placementsRtl), builtinPlacements) : (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, placements_placements), builtinPlacements);
  var popupPlacement = popupPlacementMap[mode];
  var targetMotion = getMotion(mode, motion, defaultMotions);
  var targetMotionRef = react.useRef(targetMotion);
  if (mode !== 'inline') {
    /**
     * PopupTrigger is only used for vertical and horizontal types.
     * When collapsed is unfolded, the inline animation will destroy the vertical animation.
     */
    targetMotionRef.current = targetMotion;
  }
  var mergedMotion = (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, targetMotionRef.current), {}, {
    leavedClassName: "".concat(prefixCls, "-hidden"),
    removeOnLeave: false,
    motionAppear: true
  });

  // Delay to change visible
  var visibleRef = react.useRef();
  react.useEffect(function () {
    visibleRef.current = (0,raf/* default */.Z)(function () {
      setInnerVisible(visible);
    });
    return function () {
      raf/* default */.Z.cancel(visibleRef.current);
    };
  }, [visible]);
  return /*#__PURE__*/react.createElement(trigger_es/* default */.Z, {
    prefixCls: prefixCls,
    popupClassName: classnames_default()("".concat(prefixCls, "-popup"), (0,defineProperty/* default */.Z)({}, "".concat(prefixCls, "-rtl"), rtl), popupClassName, rootClassName),
    stretch: mode === 'horizontal' ? 'minWidth' : null,
    getPopupContainer: getPopupContainer,
    builtinPlacements: placement,
    popupPlacement: popupPlacement,
    popupVisible: innerVisible,
    popup: popup,
    popupStyle: popupStyle,
    popupAlign: popupOffset && {
      offset: popupOffset
    },
    action: disabled ? [] : [triggerSubMenuAction],
    mouseEnterDelay: subMenuOpenDelay,
    mouseLeaveDelay: subMenuCloseDelay,
    onPopupVisibleChange: onVisibleChange,
    forceRender: forceSubMenuRender,
    popupMotion: mergedMotion,
    fresh: true
  }, children);
}
// EXTERNAL MODULE: ./node_modules/rc-motion/es/index.js + 12 modules
var rc_motion_es = __webpack_require__(82225);
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/SubMenu/InlineSubMenuList.js








function InlineSubMenuList(_ref) {
  var id = _ref.id,
    open = _ref.open,
    keyPath = _ref.keyPath,
    children = _ref.children;
  var fixedMode = 'inline';
  var _React$useContext = react.useContext(MenuContext),
    prefixCls = _React$useContext.prefixCls,
    forceSubMenuRender = _React$useContext.forceSubMenuRender,
    motion = _React$useContext.motion,
    defaultMotions = _React$useContext.defaultMotions,
    mode = _React$useContext.mode;

  // Always use latest mode check
  var sameModeRef = react.useRef(false);
  sameModeRef.current = mode === fixedMode;

  // We record `destroy` mark here since when mode change from `inline` to others.
  // The inline list should remove when motion end.
  var _React$useState = react.useState(!sameModeRef.current),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    destroy = _React$useState2[0],
    setDestroy = _React$useState2[1];
  var mergedOpen = sameModeRef.current ? open : false;

  // ================================= Effect =================================
  // Reset destroy state when mode change back
  react.useEffect(function () {
    if (sameModeRef.current) {
      setDestroy(false);
    }
  }, [mode]);

  // ================================= Render =================================
  var mergedMotion = (0,objectSpread2/* default */.Z)({}, getMotion(fixedMode, motion, defaultMotions));

  // No need appear since nest inlineCollapse changed
  if (keyPath.length > 1) {
    mergedMotion.motionAppear = false;
  }

  // Hide inline list when mode changed and motion end
  var originOnVisibleChanged = mergedMotion.onVisibleChanged;
  mergedMotion.onVisibleChanged = function (newVisible) {
    if (!sameModeRef.current && !newVisible) {
      setDestroy(true);
    }
    return originOnVisibleChanged === null || originOnVisibleChanged === void 0 ? void 0 : originOnVisibleChanged(newVisible);
  };
  if (destroy) {
    return null;
  }
  return /*#__PURE__*/react.createElement(InheritableContextProvider, {
    mode: fixedMode,
    locked: !sameModeRef.current
  }, /*#__PURE__*/react.createElement(rc_motion_es/* default */.ZP, (0,esm_extends/* default */.Z)({
    visible: mergedOpen
  }, mergedMotion, {
    forceRender: forceSubMenuRender,
    removeOnLeave: false,
    leavedClassName: "".concat(prefixCls, "-hidden")
  }), function (_ref2) {
    var motionClassName = _ref2.className,
      motionStyle = _ref2.style;
    return /*#__PURE__*/react.createElement(SubMenu_SubMenuList, {
      id: id,
      className: motionClassName,
      style: motionStyle
    }, children);
  }));
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/SubMenu/index.js





var SubMenu_excluded = ["style", "className", "title", "eventKey", "warnKey", "disabled", "internalPopupClose", "children", "itemIcon", "expandIcon", "popupClassName", "popupOffset", "popupStyle", "onClick", "onMouseEnter", "onMouseLeave", "onTitleClick", "onTitleMouseEnter", "onTitleMouseLeave"],
  SubMenu_excluded2 = ["active"];

















var InternalSubMenu = function InternalSubMenu(props) {
  var style = props.style,
    className = props.className,
    title = props.title,
    eventKey = props.eventKey,
    warnKey = props.warnKey,
    disabled = props.disabled,
    internalPopupClose = props.internalPopupClose,
    children = props.children,
    itemIcon = props.itemIcon,
    expandIcon = props.expandIcon,
    popupClassName = props.popupClassName,
    popupOffset = props.popupOffset,
    popupStyle = props.popupStyle,
    onClick = props.onClick,
    onMouseEnter = props.onMouseEnter,
    onMouseLeave = props.onMouseLeave,
    onTitleClick = props.onTitleClick,
    onTitleMouseEnter = props.onTitleMouseEnter,
    onTitleMouseLeave = props.onTitleMouseLeave,
    restProps = (0,objectWithoutProperties/* default */.Z)(props, SubMenu_excluded);
  var domDataId = useMenuId(eventKey);
  var _React$useContext = react.useContext(MenuContext),
    prefixCls = _React$useContext.prefixCls,
    mode = _React$useContext.mode,
    openKeys = _React$useContext.openKeys,
    contextDisabled = _React$useContext.disabled,
    overflowDisabled = _React$useContext.overflowDisabled,
    activeKey = _React$useContext.activeKey,
    selectedKeys = _React$useContext.selectedKeys,
    contextItemIcon = _React$useContext.itemIcon,
    contextExpandIcon = _React$useContext.expandIcon,
    onItemClick = _React$useContext.onItemClick,
    onOpenChange = _React$useContext.onOpenChange,
    onActive = _React$useContext.onActive;
  var _React$useContext2 = react.useContext(context_PrivateContext),
    _internalRenderSubMenuItem = _React$useContext2._internalRenderSubMenuItem;
  var _React$useContext3 = react.useContext(PathUserContext),
    isSubPathKey = _React$useContext3.isSubPathKey;
  var connectedPath = useFullPath();
  var subMenuPrefixCls = "".concat(prefixCls, "-submenu");
  var mergedDisabled = contextDisabled || disabled;
  var elementRef = react.useRef();
  var popupRef = react.useRef();

  // ================================ Warn ================================
  if (false) {}

  // ================================ Icon ================================
  var mergedItemIcon = itemIcon !== null && itemIcon !== void 0 ? itemIcon : contextItemIcon;
  var mergedExpandIcon = expandIcon !== null && expandIcon !== void 0 ? expandIcon : contextExpandIcon;

  // ================================ Open ================================
  var originOpen = openKeys.includes(eventKey);
  var open = !overflowDisabled && originOpen;

  // =============================== Select ===============================
  var childrenSelected = isSubPathKey(selectedKeys, eventKey);

  // =============================== Active ===============================
  var _useActive = useActive(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave),
    active = _useActive.active,
    activeProps = (0,objectWithoutProperties/* default */.Z)(_useActive, SubMenu_excluded2);

  // Fallback of active check to avoid hover on menu title or disabled item
  var _React$useState = react.useState(false),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    childrenActive = _React$useState2[0],
    setChildrenActive = _React$useState2[1];
  var triggerChildrenActive = function triggerChildrenActive(newActive) {
    if (!mergedDisabled) {
      setChildrenActive(newActive);
    }
  };
  var onInternalMouseEnter = function onInternalMouseEnter(domEvent) {
    triggerChildrenActive(true);
    onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({
      key: eventKey,
      domEvent: domEvent
    });
  };
  var onInternalMouseLeave = function onInternalMouseLeave(domEvent) {
    triggerChildrenActive(false);
    onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave({
      key: eventKey,
      domEvent: domEvent
    });
  };
  var mergedActive = react.useMemo(function () {
    if (active) {
      return active;
    }
    if (mode !== 'inline') {
      return childrenActive || isSubPathKey([activeKey], eventKey);
    }
    return false;
  }, [mode, active, activeKey, childrenActive, eventKey, isSubPathKey]);

  // ========================== DirectionStyle ==========================
  var directionStyle = useDirectionStyle(connectedPath.length);

  // =============================== Events ===============================
  // >>>> Title click
  var onInternalTitleClick = function onInternalTitleClick(e) {
    // Skip if disabled
    if (mergedDisabled) {
      return;
    }
    onTitleClick === null || onTitleClick === void 0 || onTitleClick({
      key: eventKey,
      domEvent: e
    });

    // Trigger open by click when mode is `inline`
    if (mode === 'inline') {
      onOpenChange(eventKey, !originOpen);
    }
  };

  // >>>> Context for children click
  var onMergedItemClick = useMemoCallback(function (info) {
    onClick === null || onClick === void 0 || onClick(warnItemProp(info));
    onItemClick(info);
  });

  // >>>>> Visible change
  var onPopupVisibleChange = function onPopupVisibleChange(newVisible) {
    if (mode !== 'inline') {
      onOpenChange(eventKey, newVisible);
    }
  };

  /**
   * Used for accessibility. Helper will focus element without key board.
   * We should manually trigger an active
   */
  var onInternalFocus = function onInternalFocus() {
    onActive(eventKey);
  };

  // =============================== Render ===============================
  var popupId = domDataId && "".concat(domDataId, "-popup");

  // >>>>> Title
  var titleNode = /*#__PURE__*/react.createElement("div", (0,esm_extends/* default */.Z)({
    role: "menuitem",
    style: directionStyle,
    className: "".concat(subMenuPrefixCls, "-title"),
    tabIndex: mergedDisabled ? null : -1,
    ref: elementRef,
    title: typeof title === 'string' ? title : null,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
    "aria-expanded": open,
    "aria-haspopup": true,
    "aria-controls": popupId,
    "aria-disabled": mergedDisabled,
    onClick: onInternalTitleClick,
    onFocus: onInternalFocus
  }, activeProps), title, /*#__PURE__*/react.createElement(Icon, {
    icon: mode !== 'horizontal' ? mergedExpandIcon : undefined,
    props: (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, props), {}, {
      isOpen: open,
      // [Legacy] Not sure why need this mark
      isSubMenu: true
    })
  }, /*#__PURE__*/react.createElement("i", {
    className: "".concat(subMenuPrefixCls, "-arrow")
  })));

  // Cache mode if it change to `inline` which do not have popup motion
  var triggerModeRef = react.useRef(mode);
  if (mode !== 'inline' && connectedPath.length > 1) {
    triggerModeRef.current = 'vertical';
  } else {
    triggerModeRef.current = mode;
  }
  if (!overflowDisabled) {
    var triggerMode = triggerModeRef.current;

    // Still wrap with Trigger here since we need avoid react re-mount dom node
    // Which makes motion failed
    titleNode = /*#__PURE__*/react.createElement(PopupTrigger, {
      mode: triggerMode,
      prefixCls: subMenuPrefixCls,
      visible: !internalPopupClose && open && mode !== 'inline',
      popupClassName: popupClassName,
      popupOffset: popupOffset,
      popupStyle: popupStyle,
      popup: /*#__PURE__*/react.createElement(InheritableContextProvider
      // Special handle of horizontal mode
      , {
        mode: triggerMode === 'horizontal' ? 'vertical' : triggerMode
      }, /*#__PURE__*/react.createElement(SubMenu_SubMenuList, {
        id: popupId,
        ref: popupRef
      }, children)),
      disabled: mergedDisabled,
      onVisibleChange: onPopupVisibleChange
    }, titleNode);
  }

  // >>>>> List node
  var listNode = /*#__PURE__*/react.createElement(rc_overflow_es.Item, (0,esm_extends/* default */.Z)({
    role: "none"
  }, restProps, {
    component: "li",
    style: style,
    className: classnames_default()(subMenuPrefixCls, "".concat(subMenuPrefixCls, "-").concat(mode), className, (0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)({}, "".concat(subMenuPrefixCls, "-open"), open), "".concat(subMenuPrefixCls, "-active"), mergedActive), "".concat(subMenuPrefixCls, "-selected"), childrenSelected), "".concat(subMenuPrefixCls, "-disabled"), mergedDisabled)),
    onMouseEnter: onInternalMouseEnter,
    onMouseLeave: onInternalMouseLeave
  }), titleNode, !overflowDisabled && /*#__PURE__*/react.createElement(InlineSubMenuList, {
    id: popupId,
    open: open,
    keyPath: connectedPath
  }, children));
  if (_internalRenderSubMenuItem) {
    listNode = _internalRenderSubMenuItem(listNode, props, {
      selected: childrenSelected,
      active: mergedActive,
      open: open,
      disabled: mergedDisabled
    });
  }

  // >>>>> Render
  return /*#__PURE__*/react.createElement(InheritableContextProvider, {
    onItemClick: onMergedItemClick,
    mode: mode === 'horizontal' ? 'vertical' : mode,
    itemIcon: mergedItemIcon,
    expandIcon: mergedExpandIcon
  }, listNode);
};
function SubMenu(props) {
  var eventKey = props.eventKey,
    children = props.children;
  var connectedKeyPath = useFullPath(eventKey);
  var childList = parseChildren(children, connectedKeyPath);

  // ==================== Record KeyPath ====================
  var measure = useMeasure();

  // eslint-disable-next-line consistent-return
  react.useEffect(function () {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return function () {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  var renderNode;

  // ======================== Render ========================
  if (measure) {
    renderNode = childList;
  } else {
    renderNode = /*#__PURE__*/react.createElement(InternalSubMenu, props, childList);
  }
  return /*#__PURE__*/react.createElement(PathTrackerContext.Provider, {
    value: connectedKeyPath
  }, renderNode);
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/MenuItemGroup.js


var MenuItemGroup_excluded = ["className", "title", "eventKey", "children"],
  MenuItemGroup_excluded2 = ["children"];






var InternalMenuItemGroup = function InternalMenuItemGroup(_ref) {
  var className = _ref.className,
    title = _ref.title,
    eventKey = _ref.eventKey,
    children = _ref.children,
    restProps = (0,objectWithoutProperties/* default */.Z)(_ref, MenuItemGroup_excluded);
  var _React$useContext = react.useContext(MenuContext),
    prefixCls = _React$useContext.prefixCls;
  var groupPrefixCls = "".concat(prefixCls, "-item-group");
  return /*#__PURE__*/react.createElement("li", (0,esm_extends/* default */.Z)({
    role: "presentation"
  }, restProps, {
    onClick: function onClick(e) {
      return e.stopPropagation();
    },
    className: classnames_default()(groupPrefixCls, className)
  }), /*#__PURE__*/react.createElement("div", {
    role: "presentation",
    className: "".concat(groupPrefixCls, "-title"),
    title: typeof title === 'string' ? title : undefined
  }, title), /*#__PURE__*/react.createElement("ul", {
    role: "group",
    className: "".concat(groupPrefixCls, "-list")
  }, children));
};
function MenuItemGroup(_ref2) {
  var children = _ref2.children,
    props = (0,objectWithoutProperties/* default */.Z)(_ref2, MenuItemGroup_excluded2);
  var connectedKeyPath = useFullPath(props.eventKey);
  var childList = parseChildren(children, connectedKeyPath);
  var measure = useMeasure();
  if (measure) {
    return childList;
  }
  return /*#__PURE__*/react.createElement(InternalMenuItemGroup, (0,omit/* default */.Z)(props, ['warnKey']), childList);
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/Divider.js




function Divider(_ref) {
  var className = _ref.className,
    style = _ref.style;
  var _React$useContext = react.useContext(MenuContext),
    prefixCls = _React$useContext.prefixCls;
  var measure = useMeasure();
  if (measure) {
    return null;
  }
  return /*#__PURE__*/react.createElement("li", {
    role: "separator",
    className: classnames_default()("".concat(prefixCls, "-item-divider"), className),
    style: style
  });
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/utils/nodeUtil.js



var nodeUtil_excluded = ["label", "children", "key", "type"];






function convertItemsToNodes(list) {
  return (list || []).map(function (opt, index) {
    if (opt && (0,esm_typeof/* default */.Z)(opt) === 'object') {
      var _ref = opt,
        label = _ref.label,
        children = _ref.children,
        key = _ref.key,
        type = _ref.type,
        restProps = (0,objectWithoutProperties/* default */.Z)(_ref, nodeUtil_excluded);
      var mergedKey = key !== null && key !== void 0 ? key : "tmp-".concat(index);

      // MenuItemGroup & SubMenuItem
      if (children || type === 'group') {
        if (type === 'group') {
          // Group
          return /*#__PURE__*/react.createElement(MenuItemGroup, (0,esm_extends/* default */.Z)({
            key: mergedKey
          }, restProps, {
            title: label
          }), convertItemsToNodes(children));
        }

        // Sub Menu
        return /*#__PURE__*/react.createElement(SubMenu, (0,esm_extends/* default */.Z)({
          key: mergedKey
        }, restProps, {
          title: label
        }), convertItemsToNodes(children));
      }

      // MenuItem & Divider
      if (type === 'divider') {
        return /*#__PURE__*/react.createElement(Divider, (0,esm_extends/* default */.Z)({
          key: mergedKey
        }, restProps));
      }
      return /*#__PURE__*/react.createElement(es_MenuItem, (0,esm_extends/* default */.Z)({
        key: mergedKey
      }, restProps), label);
    }
    return null;
  }).filter(function (opt) {
    return opt;
  });
}
function parseItems(children, items, keyPath) {
  var childNodes = children;
  if (items) {
    childNodes = convertItemsToNodes(items);
  }
  return parseChildren(childNodes, keyPath);
}
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/Menu.js






var Menu_excluded = ["prefixCls", "rootClassName", "style", "className", "tabIndex", "items", "children", "direction", "id", "mode", "inlineCollapsed", "disabled", "disabledOverflow", "subMenuOpenDelay", "subMenuCloseDelay", "forceSubMenuRender", "defaultOpenKeys", "openKeys", "activeKey", "defaultActiveFirst", "selectable", "multiple", "defaultSelectedKeys", "selectedKeys", "onSelect", "onDeselect", "inlineIndent", "motion", "defaultMotions", "triggerSubMenuAction", "builtinPlacements", "itemIcon", "expandIcon", "overflowedIndicator", "overflowedIndicatorPopupClassName", "getPopupContainer", "onClick", "onOpenChange", "onKeyDown", "openAnimation", "openTransitionName", "_internalRenderMenuItem", "_internalRenderSubMenuItem"];





















/**
 * Menu modify after refactor:
 * ## Add
 * - disabled
 *
 * ## Remove
 * - openTransitionName
 * - openAnimation
 * - onDestroy
 * - siderCollapsed: Seems antd do not use this prop (Need test in antd)
 * - collapsedWidth: Seems this logic should be handle by antd Layout.Sider
 */

// optimize for render
var EMPTY_LIST = [];
var Menu = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var _childList$;
  var _ref = props,
    _ref$prefixCls = _ref.prefixCls,
    prefixCls = _ref$prefixCls === void 0 ? 'rc-menu' : _ref$prefixCls,
    rootClassName = _ref.rootClassName,
    style = _ref.style,
    className = _ref.className,
    _ref$tabIndex = _ref.tabIndex,
    tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex,
    items = _ref.items,
    children = _ref.children,
    direction = _ref.direction,
    id = _ref.id,
    _ref$mode = _ref.mode,
    mode = _ref$mode === void 0 ? 'vertical' : _ref$mode,
    inlineCollapsed = _ref.inlineCollapsed,
    disabled = _ref.disabled,
    disabledOverflow = _ref.disabledOverflow,
    _ref$subMenuOpenDelay = _ref.subMenuOpenDelay,
    subMenuOpenDelay = _ref$subMenuOpenDelay === void 0 ? 0.1 : _ref$subMenuOpenDelay,
    _ref$subMenuCloseDela = _ref.subMenuCloseDelay,
    subMenuCloseDelay = _ref$subMenuCloseDela === void 0 ? 0.1 : _ref$subMenuCloseDela,
    forceSubMenuRender = _ref.forceSubMenuRender,
    defaultOpenKeys = _ref.defaultOpenKeys,
    openKeys = _ref.openKeys,
    activeKey = _ref.activeKey,
    defaultActiveFirst = _ref.defaultActiveFirst,
    _ref$selectable = _ref.selectable,
    selectable = _ref$selectable === void 0 ? true : _ref$selectable,
    _ref$multiple = _ref.multiple,
    multiple = _ref$multiple === void 0 ? false : _ref$multiple,
    defaultSelectedKeys = _ref.defaultSelectedKeys,
    selectedKeys = _ref.selectedKeys,
    onSelect = _ref.onSelect,
    onDeselect = _ref.onDeselect,
    _ref$inlineIndent = _ref.inlineIndent,
    inlineIndent = _ref$inlineIndent === void 0 ? 24 : _ref$inlineIndent,
    motion = _ref.motion,
    defaultMotions = _ref.defaultMotions,
    _ref$triggerSubMenuAc = _ref.triggerSubMenuAction,
    triggerSubMenuAction = _ref$triggerSubMenuAc === void 0 ? 'hover' : _ref$triggerSubMenuAc,
    builtinPlacements = _ref.builtinPlacements,
    itemIcon = _ref.itemIcon,
    expandIcon = _ref.expandIcon,
    _ref$overflowedIndica = _ref.overflowedIndicator,
    overflowedIndicator = _ref$overflowedIndica === void 0 ? '...' : _ref$overflowedIndica,
    overflowedIndicatorPopupClassName = _ref.overflowedIndicatorPopupClassName,
    getPopupContainer = _ref.getPopupContainer,
    onClick = _ref.onClick,
    onOpenChange = _ref.onOpenChange,
    onKeyDown = _ref.onKeyDown,
    openAnimation = _ref.openAnimation,
    openTransitionName = _ref.openTransitionName,
    _internalRenderMenuItem = _ref._internalRenderMenuItem,
    _internalRenderSubMenuItem = _ref._internalRenderSubMenuItem,
    restProps = (0,objectWithoutProperties/* default */.Z)(_ref, Menu_excluded);
  var childList = react.useMemo(function () {
    return parseItems(children, items, EMPTY_LIST);
  }, [children, items]);
  var _React$useState = react.useState(false),
    _React$useState2 = (0,slicedToArray/* default */.Z)(_React$useState, 2),
    mounted = _React$useState2[0],
    setMounted = _React$useState2[1];
  var containerRef = react.useRef();
  var uuid = useUUID(id);
  var isRtl = direction === 'rtl';

  // ========================= Warn =========================
  if (false) {}

  // ========================= Open =========================
  var _useMergedState = (0,useMergedState/* default */.Z)(defaultOpenKeys, {
      value: openKeys,
      postState: function postState(keys) {
        return keys || EMPTY_LIST;
      }
    }),
    _useMergedState2 = (0,slicedToArray/* default */.Z)(_useMergedState, 2),
    mergedOpenKeys = _useMergedState2[0],
    setMergedOpenKeys = _useMergedState2[1];

  // React 18 will merge mouse event which means we open key will not sync
  // ref: https://github.com/ant-design/ant-design/issues/38818
  var triggerOpenKeys = function triggerOpenKeys(keys) {
    var forceFlush = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    function doUpdate() {
      setMergedOpenKeys(keys);
      onOpenChange === null || onOpenChange === void 0 || onOpenChange(keys);
    }
    if (forceFlush) {
      (0,react_dom.flushSync)(doUpdate);
    } else {
      doUpdate();
    }
  };

  // >>>>> Cache & Reset open keys when inlineCollapsed changed
  var _React$useState3 = react.useState(mergedOpenKeys),
    _React$useState4 = (0,slicedToArray/* default */.Z)(_React$useState3, 2),
    inlineCacheOpenKeys = _React$useState4[0],
    setInlineCacheOpenKeys = _React$useState4[1];
  var mountRef = react.useRef(false);

  // ========================= Mode =========================
  var _React$useMemo = react.useMemo(function () {
      if ((mode === 'inline' || mode === 'vertical') && inlineCollapsed) {
        return ['vertical', inlineCollapsed];
      }
      return [mode, false];
    }, [mode, inlineCollapsed]),
    _React$useMemo2 = (0,slicedToArray/* default */.Z)(_React$useMemo, 2),
    mergedMode = _React$useMemo2[0],
    mergedInlineCollapsed = _React$useMemo2[1];
  var isInlineMode = mergedMode === 'inline';
  var _React$useState5 = react.useState(mergedMode),
    _React$useState6 = (0,slicedToArray/* default */.Z)(_React$useState5, 2),
    internalMode = _React$useState6[0],
    setInternalMode = _React$useState6[1];
  var _React$useState7 = react.useState(mergedInlineCollapsed),
    _React$useState8 = (0,slicedToArray/* default */.Z)(_React$useState7, 2),
    internalInlineCollapsed = _React$useState8[0],
    setInternalInlineCollapsed = _React$useState8[1];
  react.useEffect(function () {
    setInternalMode(mergedMode);
    setInternalInlineCollapsed(mergedInlineCollapsed);
    if (!mountRef.current) {
      return;
    }
    // Synchronously update MergedOpenKeys
    if (isInlineMode) {
      setMergedOpenKeys(inlineCacheOpenKeys);
    } else {
      // Trigger open event in case its in control
      triggerOpenKeys(EMPTY_LIST);
    }
  }, [mergedMode, mergedInlineCollapsed]);

  // ====================== Responsive ======================
  var _React$useState9 = react.useState(0),
    _React$useState10 = (0,slicedToArray/* default */.Z)(_React$useState9, 2),
    lastVisibleIndex = _React$useState10[0],
    setLastVisibleIndex = _React$useState10[1];
  var allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== 'horizontal' || disabledOverflow;

  // Cache
  react.useEffect(function () {
    if (isInlineMode) {
      setInlineCacheOpenKeys(mergedOpenKeys);
    }
  }, [mergedOpenKeys]);
  react.useEffect(function () {
    mountRef.current = true;
    return function () {
      mountRef.current = false;
    };
  }, []);

  // ========================= Path =========================
  var _useKeyRecords = useKeyRecords(),
    registerPath = _useKeyRecords.registerPath,
    unregisterPath = _useKeyRecords.unregisterPath,
    refreshOverflowKeys = _useKeyRecords.refreshOverflowKeys,
    isSubPathKey = _useKeyRecords.isSubPathKey,
    getKeyPath = _useKeyRecords.getKeyPath,
    getKeys = _useKeyRecords.getKeys,
    getSubPathKeys = _useKeyRecords.getSubPathKeys;
  var registerPathContext = react.useMemo(function () {
    return {
      registerPath: registerPath,
      unregisterPath: unregisterPath
    };
  }, [registerPath, unregisterPath]);
  var pathUserContext = react.useMemo(function () {
    return {
      isSubPathKey: isSubPathKey
    };
  }, [isSubPathKey]);
  react.useEffect(function () {
    refreshOverflowKeys(allVisible ? EMPTY_LIST : childList.slice(lastVisibleIndex + 1).map(function (child) {
      return child.key;
    }));
  }, [lastVisibleIndex, allVisible]);

  // ======================== Active ========================
  var _useMergedState3 = (0,useMergedState/* default */.Z)(activeKey || defaultActiveFirst && ((_childList$ = childList[0]) === null || _childList$ === void 0 ? void 0 : _childList$.key), {
      value: activeKey
    }),
    _useMergedState4 = (0,slicedToArray/* default */.Z)(_useMergedState3, 2),
    mergedActiveKey = _useMergedState4[0],
    setMergedActiveKey = _useMergedState4[1];
  var onActive = useMemoCallback(function (key) {
    setMergedActiveKey(key);
  });
  var onInactive = useMemoCallback(function () {
    setMergedActiveKey(undefined);
  });
  (0,react.useImperativeHandle)(ref, function () {
    return {
      list: containerRef.current,
      focus: function focus(options) {
        var _childList$find;
        var keys = getKeys();
        var _refreshElements = refreshElements(keys, uuid),
          elements = _refreshElements.elements,
          key2element = _refreshElements.key2element,
          element2key = _refreshElements.element2key;
        var focusableElements = getFocusableElements(containerRef.current, elements);
        var shouldFocusKey = mergedActiveKey !== null && mergedActiveKey !== void 0 ? mergedActiveKey : focusableElements[0] ? element2key.get(focusableElements[0]) : (_childList$find = childList.find(function (node) {
          return !node.props.disabled;
        })) === null || _childList$find === void 0 ? void 0 : _childList$find.key;
        var elementToFocus = key2element.get(shouldFocusKey);
        if (shouldFocusKey && elementToFocus) {
          var _elementToFocus$focus;
          elementToFocus === null || elementToFocus === void 0 || (_elementToFocus$focus = elementToFocus.focus) === null || _elementToFocus$focus === void 0 || _elementToFocus$focus.call(elementToFocus, options);
        }
      }
    };
  });

  // ======================== Select ========================
  // >>>>> Select keys
  var _useMergedState5 = (0,useMergedState/* default */.Z)(defaultSelectedKeys || [], {
      value: selectedKeys,
      // Legacy convert key to array
      postState: function postState(keys) {
        if (Array.isArray(keys)) {
          return keys;
        }
        if (keys === null || keys === undefined) {
          return EMPTY_LIST;
        }
        return [keys];
      }
    }),
    _useMergedState6 = (0,slicedToArray/* default */.Z)(_useMergedState5, 2),
    mergedSelectKeys = _useMergedState6[0],
    setMergedSelectKeys = _useMergedState6[1];

  // >>>>> Trigger select
  var triggerSelection = function triggerSelection(info) {
    if (selectable) {
      // Insert or Remove
      var targetKey = info.key;
      var exist = mergedSelectKeys.includes(targetKey);
      var newSelectKeys;
      if (multiple) {
        if (exist) {
          newSelectKeys = mergedSelectKeys.filter(function (key) {
            return key !== targetKey;
          });
        } else {
          newSelectKeys = [].concat((0,toConsumableArray/* default */.Z)(mergedSelectKeys), [targetKey]);
        }
      } else {
        newSelectKeys = [targetKey];
      }
      setMergedSelectKeys(newSelectKeys);

      // Trigger event
      var selectInfo = (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, info), {}, {
        selectedKeys: newSelectKeys
      });
      if (exist) {
        onDeselect === null || onDeselect === void 0 || onDeselect(selectInfo);
      } else {
        onSelect === null || onSelect === void 0 || onSelect(selectInfo);
      }
    }

    // Whatever selectable, always close it
    if (!multiple && mergedOpenKeys.length && internalMode !== 'inline') {
      triggerOpenKeys(EMPTY_LIST);
    }
  };

  // ========================= Open =========================
  /**
   * Click for item. SubMenu do not have selection status
   */
  var onInternalClick = useMemoCallback(function (info) {
    onClick === null || onClick === void 0 || onClick(warnItemProp(info));
    triggerSelection(info);
  });
  var onInternalOpenChange = useMemoCallback(function (key, open) {
    var newOpenKeys = mergedOpenKeys.filter(function (k) {
      return k !== key;
    });
    if (open) {
      newOpenKeys.push(key);
    } else if (internalMode !== 'inline') {
      // We need find all related popup to close
      var subPathKeys = getSubPathKeys(key);
      newOpenKeys = newOpenKeys.filter(function (k) {
        return !subPathKeys.has(k);
      });
    }
    if (!(0,isEqual/* default */.Z)(mergedOpenKeys, newOpenKeys, true)) {
      triggerOpenKeys(newOpenKeys, true);
    }
  });

  // ==================== Accessibility =====================
  var triggerAccessibilityOpen = function triggerAccessibilityOpen(key, open) {
    var nextOpen = open !== null && open !== void 0 ? open : !mergedOpenKeys.includes(key);
    onInternalOpenChange(key, nextOpen);
  };
  var onInternalKeyDown = useAccessibility_useAccessibility(internalMode, mergedActiveKey, isRtl, uuid, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown);

  // ======================== Effect ========================
  react.useEffect(function () {
    setMounted(true);
  }, []);

  // ======================= Context ========================
  var privateContext = react.useMemo(function () {
    return {
      _internalRenderMenuItem: _internalRenderMenuItem,
      _internalRenderSubMenuItem: _internalRenderSubMenuItem
    };
  }, [_internalRenderMenuItem, _internalRenderSubMenuItem]);

  // ======================== Render ========================

  // >>>>> Children
  var wrappedChildList = internalMode !== 'horizontal' || disabledOverflow ? childList :
  // Need wrap for overflow dropdown that do not response for open
  childList.map(function (child, index) {
    return (
      /*#__PURE__*/
      // Always wrap provider to avoid sub node re-mount
      react.createElement(InheritableContextProvider, {
        key: child.key,
        overflowDisabled: index > lastVisibleIndex
      }, child)
    );
  });

  // >>>>> Container
  var container = /*#__PURE__*/react.createElement(rc_overflow_es, (0,esm_extends/* default */.Z)({
    id: id,
    ref: containerRef,
    prefixCls: "".concat(prefixCls, "-overflow"),
    component: "ul",
    itemComponent: es_MenuItem,
    className: classnames_default()(prefixCls, "".concat(prefixCls, "-root"), "".concat(prefixCls, "-").concat(internalMode), className, (0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)({}, "".concat(prefixCls, "-inline-collapsed"), internalInlineCollapsed), "".concat(prefixCls, "-rtl"), isRtl), rootClassName),
    dir: direction,
    style: style,
    role: "menu",
    tabIndex: tabIndex,
    data: wrappedChildList,
    renderRawItem: function renderRawItem(node) {
      return node;
    },
    renderRawRest: function renderRawRest(omitItems) {
      // We use origin list since wrapped list use context to prevent open
      var len = omitItems.length;
      var originOmitItems = len ? childList.slice(-len) : null;
      return /*#__PURE__*/react.createElement(SubMenu, {
        eventKey: OVERFLOW_KEY,
        title: overflowedIndicator,
        disabled: allVisible,
        internalPopupClose: len === 0,
        popupClassName: overflowedIndicatorPopupClassName
      }, originOmitItems);
    },
    maxCount: internalMode !== 'horizontal' || disabledOverflow ? rc_overflow_es.INVALIDATE : rc_overflow_es.RESPONSIVE,
    ssr: "full",
    "data-menu-list": true,
    onVisibleChange: function onVisibleChange(newLastIndex) {
      setLastVisibleIndex(newLastIndex);
    },
    onKeyDown: onInternalKeyDown
  }, restProps));

  // >>>>> Render
  return /*#__PURE__*/react.createElement(context_PrivateContext.Provider, {
    value: privateContext
  }, /*#__PURE__*/react.createElement(IdContext.Provider, {
    value: uuid
  }, /*#__PURE__*/react.createElement(InheritableContextProvider, {
    prefixCls: prefixCls,
    rootClassName: rootClassName,
    mode: internalMode,
    openKeys: mergedOpenKeys,
    rtl: isRtl
    // Disabled
    ,
    disabled: disabled
    // Motion
    ,
    motion: mounted ? motion : null,
    defaultMotions: mounted ? defaultMotions : null
    // Active
    ,
    activeKey: mergedActiveKey,
    onActive: onActive,
    onInactive: onInactive
    // Selection
    ,
    selectedKeys: mergedSelectKeys
    // Level
    ,
    inlineIndent: inlineIndent
    // Popup
    ,
    subMenuOpenDelay: subMenuOpenDelay,
    subMenuCloseDelay: subMenuCloseDelay,
    forceSubMenuRender: forceSubMenuRender,
    builtinPlacements: builtinPlacements,
    triggerSubMenuAction: triggerSubMenuAction,
    getPopupContainer: getPopupContainer
    // Icon
    ,
    itemIcon: itemIcon,
    expandIcon: expandIcon
    // Events
    ,
    onItemClick: onInternalClick,
    onOpenChange: onInternalOpenChange
  }, /*#__PURE__*/react.createElement(PathUserContext.Provider, {
    value: pathUserContext
  }, container), /*#__PURE__*/react.createElement("div", {
    style: {
      display: 'none'
    },
    "aria-hidden": true
  }, /*#__PURE__*/react.createElement(PathRegisterContext.Provider, {
    value: registerPathContext
  }, childList)))));
});
/* harmony default export */ var es_Menu = (Menu);
;// CONCATENATED MODULE: ./node_modules/rc-menu/es/index.js







var ExportMenu = es_Menu;
ExportMenu.Item = es_MenuItem;
ExportMenu.SubMenu = SubMenu;
ExportMenu.ItemGroup = MenuItemGroup;
ExportMenu.Divider = Divider;
/* harmony default export */ var rc_menu_es = (ExportMenu);
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/TabNavList/OperationNode.js










var OperationNode = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var prefixCls = props.prefixCls,
    id = props.id,
    tabs = props.tabs,
    locale = props.locale,
    mobile = props.mobile,
    _props$moreIcon = props.moreIcon,
    moreIcon = _props$moreIcon === void 0 ? 'More' : _props$moreIcon,
    moreTransitionName = props.moreTransitionName,
    style = props.style,
    className = props.className,
    editable = props.editable,
    tabBarGutter = props.tabBarGutter,
    rtl = props.rtl,
    removeAriaLabel = props.removeAriaLabel,
    onTabClick = props.onTabClick,
    getPopupContainer = props.getPopupContainer,
    popupClassName = props.popupClassName;
  // ======================== Dropdown ========================
  var _useState = (0,react.useState)(false),
    _useState2 = (0,slicedToArray/* default */.Z)(_useState, 2),
    open = _useState2[0],
    setOpen = _useState2[1];
  var _useState3 = (0,react.useState)(null),
    _useState4 = (0,slicedToArray/* default */.Z)(_useState3, 2),
    selectedKey = _useState4[0],
    setSelectedKey = _useState4[1];
  var popupId = "".concat(id, "-more-popup");
  var dropdownPrefix = "".concat(prefixCls, "-dropdown");
  var selectedItemId = selectedKey !== null ? "".concat(popupId, "-").concat(selectedKey) : null;
  var dropdownAriaLabel = locale === null || locale === void 0 ? void 0 : locale.dropdownAriaLabel;
  function onRemoveTab(event, key) {
    event.preventDefault();
    event.stopPropagation();
    editable.onEdit('remove', {
      key: key,
      event: event
    });
  }
  var menu = /*#__PURE__*/react.createElement(rc_menu_es, {
    onClick: function onClick(_ref) {
      var key = _ref.key,
        domEvent = _ref.domEvent;
      onTabClick(key, domEvent);
      setOpen(false);
    },
    prefixCls: "".concat(dropdownPrefix, "-menu"),
    id: popupId,
    tabIndex: -1,
    role: "listbox",
    "aria-activedescendant": selectedItemId,
    selectedKeys: [selectedKey],
    "aria-label": dropdownAriaLabel !== undefined ? dropdownAriaLabel : 'expanded dropdown'
  }, tabs.map(function (tab) {
    var closable = tab.closable,
      disabled = tab.disabled,
      closeIcon = tab.closeIcon,
      key = tab.key,
      label = tab.label;
    var removable = getRemovable(closable, closeIcon, editable, disabled);
    return /*#__PURE__*/react.createElement(es_MenuItem, {
      key: key,
      id: "".concat(popupId, "-").concat(key),
      role: "option",
      "aria-controls": id && "".concat(id, "-panel-").concat(key),
      disabled: disabled
    }, /*#__PURE__*/react.createElement("span", null, label), removable && /*#__PURE__*/react.createElement("button", {
      type: "button",
      "aria-label": removeAriaLabel || 'remove',
      tabIndex: 0,
      className: "".concat(dropdownPrefix, "-menu-item-remove"),
      onClick: function onClick(e) {
        e.stopPropagation();
        onRemoveTab(e, key);
      }
    }, closeIcon || editable.removeIcon || '×'));
  }));
  function selectOffset(offset) {
    var enabledTabs = tabs.filter(function (tab) {
      return !tab.disabled;
    });
    var selectedIndex = enabledTabs.findIndex(function (tab) {
      return tab.key === selectedKey;
    }) || 0;
    var len = enabledTabs.length;
    for (var i = 0; i < len; i += 1) {
      selectedIndex = (selectedIndex + offset + len) % len;
      var tab = enabledTabs[selectedIndex];
      if (!tab.disabled) {
        setSelectedKey(tab.key);
        return;
      }
    }
  }
  function onKeyDown(e) {
    var which = e.which;
    if (!open) {
      if ([KeyCode/* default */.Z.DOWN, KeyCode/* default */.Z.SPACE, KeyCode/* default */.Z.ENTER].includes(which)) {
        setOpen(true);
        e.preventDefault();
      }
      return;
    }
    switch (which) {
      case KeyCode/* default */.Z.UP:
        selectOffset(-1);
        e.preventDefault();
        break;
      case KeyCode/* default */.Z.DOWN:
        selectOffset(1);
        e.preventDefault();
        break;
      case KeyCode/* default */.Z.ESC:
        setOpen(false);
        break;
      case KeyCode/* default */.Z.SPACE:
      case KeyCode/* default */.Z.ENTER:
        if (selectedKey !== null) {
          onTabClick(selectedKey, e);
        }
        break;
    }
  }

  // ========================= Effect =========================
  (0,react.useEffect)(function () {
    // We use query element here to avoid React strict warning
    var ele = document.getElementById(selectedItemId);
    if (ele && ele.scrollIntoView) {
      ele.scrollIntoView(false);
    }
  }, [selectedKey]);
  (0,react.useEffect)(function () {
    if (!open) {
      setSelectedKey(null);
    }
  }, [open]);

  // ========================= Render =========================
  var moreStyle = (0,defineProperty/* default */.Z)({}, rtl ? 'marginRight' : 'marginLeft', tabBarGutter);
  if (!tabs.length) {
    moreStyle.visibility = 'hidden';
    moreStyle.order = 1;
  }
  var overlayClassName = classnames_default()((0,defineProperty/* default */.Z)({}, "".concat(dropdownPrefix, "-rtl"), rtl));
  var moreNode = mobile ? null : /*#__PURE__*/react.createElement(rc_dropdown_es, {
    prefixCls: dropdownPrefix,
    overlay: menu,
    trigger: ['hover'],
    visible: tabs.length ? open : false,
    transitionName: moreTransitionName,
    onVisibleChange: setOpen,
    overlayClassName: classnames_default()(overlayClassName, popupClassName),
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    getPopupContainer: getPopupContainer
  }, /*#__PURE__*/react.createElement("button", {
    type: "button",
    className: "".concat(prefixCls, "-nav-more"),
    style: moreStyle,
    tabIndex: -1,
    "aria-hidden": "true",
    "aria-haspopup": "listbox",
    "aria-controls": popupId,
    id: "".concat(id, "-more"),
    "aria-expanded": open,
    onKeyDown: onKeyDown
  }, moreIcon));
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()("".concat(prefixCls, "-nav-operations"), className),
    style: style,
    ref: ref
  }, moreNode, /*#__PURE__*/react.createElement(TabNavList_AddButton, {
    prefixCls: prefixCls,
    locale: locale,
    editable: editable
  }));
});
/* harmony default export */ var TabNavList_OperationNode = (/*#__PURE__*/react.memo(OperationNode, function (_, next) {
  return (
    // https://github.com/ant-design/ant-design/issues/32544
    // We'd better remove syntactic sugar in `rc-menu` since this has perf issue
    next.tabMoving
  );
}));
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/TabNavList/TabNode.js





var TabNode = function TabNode(props) {
  var prefixCls = props.prefixCls,
    id = props.id,
    active = props.active,
    _props$tab = props.tab,
    key = _props$tab.key,
    label = _props$tab.label,
    disabled = _props$tab.disabled,
    closeIcon = _props$tab.closeIcon,
    icon = _props$tab.icon,
    closable = props.closable,
    renderWrapper = props.renderWrapper,
    removeAriaLabel = props.removeAriaLabel,
    editable = props.editable,
    onClick = props.onClick,
    onFocus = props.onFocus,
    style = props.style;
  var tabPrefix = "".concat(prefixCls, "-tab");
  var removable = getRemovable(closable, closeIcon, editable, disabled);
  function onInternalClick(e) {
    if (disabled) {
      return;
    }
    onClick(e);
  }
  function onRemoveTab(event) {
    event.preventDefault();
    event.stopPropagation();
    editable.onEdit('remove', {
      key: key,
      event: event
    });
  }
  var labelNode = react.useMemo(function () {
    return icon && typeof label === 'string' ? /*#__PURE__*/react.createElement("span", null, label) : label;
  }, [label, icon]);
  var node = /*#__PURE__*/react.createElement("div", {
    key: key
    // ref={ref}
    ,
    "data-node-key": genDataNodeKey(key),
    className: classnames_default()(tabPrefix, (0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)({}, "".concat(tabPrefix, "-with-remove"), removable), "".concat(tabPrefix, "-active"), active), "".concat(tabPrefix, "-disabled"), disabled)),
    style: style,
    onClick: onInternalClick
  }, /*#__PURE__*/react.createElement("div", {
    role: "tab",
    "aria-selected": active,
    id: id && "".concat(id, "-tab-").concat(key),
    className: "".concat(tabPrefix, "-btn"),
    "aria-controls": id && "".concat(id, "-panel-").concat(key),
    "aria-disabled": disabled,
    tabIndex: disabled ? null : 0,
    onClick: function onClick(e) {
      e.stopPropagation();
      onInternalClick(e);
    },
    onKeyDown: function onKeyDown(e) {
      if ([KeyCode/* default */.Z.SPACE, KeyCode/* default */.Z.ENTER].includes(e.which)) {
        e.preventDefault();
        onInternalClick(e);
      }
    },
    onFocus: onFocus
  }, icon && /*#__PURE__*/react.createElement("span", {
    className: "".concat(tabPrefix, "-icon")
  }, icon), label && labelNode), removable && /*#__PURE__*/react.createElement("button", {
    type: "button",
    "aria-label": removeAriaLabel || 'remove',
    tabIndex: 0,
    className: "".concat(tabPrefix, "-remove"),
    onClick: function onClick(e) {
      e.stopPropagation();
      onRemoveTab(e);
    }
  }, closeIcon || editable.removeIcon || '×'));
  return renderWrapper ? renderWrapper(node) : node;
};
/* harmony default export */ var TabNavList_TabNode = (TabNode);
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/TabNavList/index.js





/* eslint-disable react-hooks/exhaustive-deps */


















var getTabSize = function getTabSize(tab, containerRect) {
  // tabListRef
  var offsetWidth = tab.offsetWidth,
    offsetHeight = tab.offsetHeight,
    offsetTop = tab.offsetTop,
    offsetLeft = tab.offsetLeft;
  var _tab$getBoundingClien = tab.getBoundingClientRect(),
    width = _tab$getBoundingClien.width,
    height = _tab$getBoundingClien.height,
    x = _tab$getBoundingClien.x,
    y = _tab$getBoundingClien.y;

  // Use getBoundingClientRect to avoid decimal inaccuracy
  if (Math.abs(width - offsetWidth) < 1) {
    return [width, height, x - containerRect.x, y - containerRect.y];
  }
  return [offsetWidth, offsetHeight, offsetLeft, offsetTop];
};
var getSize = function getSize(refObj) {
  var _ref = refObj.current || {},
    _ref$offsetWidth = _ref.offsetWidth,
    offsetWidth = _ref$offsetWidth === void 0 ? 0 : _ref$offsetWidth,
    _ref$offsetHeight = _ref.offsetHeight,
    offsetHeight = _ref$offsetHeight === void 0 ? 0 : _ref$offsetHeight;

  // Use getBoundingClientRect to avoid decimal inaccuracy
  if (refObj.current) {
    var _refObj$current$getBo = refObj.current.getBoundingClientRect(),
      width = _refObj$current$getBo.width,
      height = _refObj$current$getBo.height;
    if (Math.abs(width - offsetWidth) < 1) {
      return [width, height];
    }
  }
  return [offsetWidth, offsetHeight];
};

/**
 * Convert `SizeInfo` to unit value. Such as [123, 456] with `top` position get `123`
 */
var getUnitValue = function getUnitValue(size, tabPositionTopOrBottom) {
  return size[tabPositionTopOrBottom ? 0 : 1];
};
var TabNavList = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var className = props.className,
    style = props.style,
    id = props.id,
    animated = props.animated,
    activeKey = props.activeKey,
    rtl = props.rtl,
    extra = props.extra,
    editable = props.editable,
    locale = props.locale,
    tabPosition = props.tabPosition,
    tabBarGutter = props.tabBarGutter,
    children = props.children,
    onTabClick = props.onTabClick,
    onTabScroll = props.onTabScroll,
    indicator = props.indicator;
  var _React$useContext = react.useContext(TabContext),
    prefixCls = _React$useContext.prefixCls,
    tabs = _React$useContext.tabs;
  var containerRef = (0,react.useRef)(null);
  var extraLeftRef = (0,react.useRef)(null);
  var extraRightRef = (0,react.useRef)(null);
  var tabsWrapperRef = (0,react.useRef)(null);
  var tabListRef = (0,react.useRef)(null);
  var operationsRef = (0,react.useRef)(null);
  var innerAddButtonRef = (0,react.useRef)(null);
  var tabPositionTopOrBottom = tabPosition === 'top' || tabPosition === 'bottom';
  var _useSyncState = useSyncState(0, function (next, prev) {
      if (tabPositionTopOrBottom && onTabScroll) {
        onTabScroll({
          direction: next > prev ? 'left' : 'right'
        });
      }
    }),
    _useSyncState2 = (0,slicedToArray/* default */.Z)(_useSyncState, 2),
    transformLeft = _useSyncState2[0],
    setTransformLeft = _useSyncState2[1];
  var _useSyncState3 = useSyncState(0, function (next, prev) {
      if (!tabPositionTopOrBottom && onTabScroll) {
        onTabScroll({
          direction: next > prev ? 'top' : 'bottom'
        });
      }
    }),
    _useSyncState4 = (0,slicedToArray/* default */.Z)(_useSyncState3, 2),
    transformTop = _useSyncState4[0],
    setTransformTop = _useSyncState4[1];
  var _useState = (0,react.useState)([0, 0]),
    _useState2 = (0,slicedToArray/* default */.Z)(_useState, 2),
    containerExcludeExtraSize = _useState2[0],
    setContainerExcludeExtraSize = _useState2[1];
  var _useState3 = (0,react.useState)([0, 0]),
    _useState4 = (0,slicedToArray/* default */.Z)(_useState3, 2),
    tabContentSize = _useState4[0],
    setTabContentSize = _useState4[1];
  var _useState5 = (0,react.useState)([0, 0]),
    _useState6 = (0,slicedToArray/* default */.Z)(_useState5, 2),
    addSize = _useState6[0],
    setAddSize = _useState6[1];
  var _useState7 = (0,react.useState)([0, 0]),
    _useState8 = (0,slicedToArray/* default */.Z)(_useState7, 2),
    operationSize = _useState8[0],
    setOperationSize = _useState8[1];
  var _useUpdateState = useUpdateState(new Map()),
    _useUpdateState2 = (0,slicedToArray/* default */.Z)(_useUpdateState, 2),
    tabSizes = _useUpdateState2[0],
    setTabSizes = _useUpdateState2[1];
  var tabOffsets = useOffsets(tabs, tabSizes, tabContentSize[0]);

  // ========================== Unit =========================
  var containerExcludeExtraSizeValue = getUnitValue(containerExcludeExtraSize, tabPositionTopOrBottom);
  var tabContentSizeValue = getUnitValue(tabContentSize, tabPositionTopOrBottom);
  var addSizeValue = getUnitValue(addSize, tabPositionTopOrBottom);
  var operationSizeValue = getUnitValue(operationSize, tabPositionTopOrBottom);
  var needScroll = containerExcludeExtraSizeValue < tabContentSizeValue + addSizeValue;
  var visibleTabContentValue = needScroll ? containerExcludeExtraSizeValue - operationSizeValue : containerExcludeExtraSizeValue - addSizeValue;

  // ========================== Util =========================
  var operationsHiddenClassName = "".concat(prefixCls, "-nav-operations-hidden");
  var transformMin = 0;
  var transformMax = 0;
  if (!tabPositionTopOrBottom) {
    transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
    transformMax = 0;
  } else if (rtl) {
    transformMin = 0;
    transformMax = Math.max(0, tabContentSizeValue - visibleTabContentValue);
  } else {
    transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
    transformMax = 0;
  }
  function alignInRange(value) {
    if (value < transformMin) {
      return transformMin;
    }
    if (value > transformMax) {
      return transformMax;
    }
    return value;
  }

  // ========================= Mobile ========================
  var touchMovingRef = (0,react.useRef)(null);
  var _useState9 = (0,react.useState)(),
    _useState10 = (0,slicedToArray/* default */.Z)(_useState9, 2),
    lockAnimation = _useState10[0],
    setLockAnimation = _useState10[1];
  function doLockAnimation() {
    setLockAnimation(Date.now());
  }
  function clearTouchMoving() {
    if (touchMovingRef.current) {
      clearTimeout(touchMovingRef.current);
    }
  }
  useTouchMove(tabsWrapperRef, function (offsetX, offsetY) {
    function doMove(setState, offset) {
      setState(function (value) {
        var newValue = alignInRange(value + offset);
        return newValue;
      });
    }

    // Skip scroll if place is enough
    if (!needScroll) {
      return false;
    }
    if (tabPositionTopOrBottom) {
      doMove(setTransformLeft, offsetX);
    } else {
      doMove(setTransformTop, offsetY);
    }
    clearTouchMoving();
    doLockAnimation();
    return true;
  });
  (0,react.useEffect)(function () {
    clearTouchMoving();
    if (lockAnimation) {
      touchMovingRef.current = setTimeout(function () {
        setLockAnimation(0);
      }, 100);
    }
    return clearTouchMoving;
  }, [lockAnimation]);

  // ===================== Visible Range =====================
  // Render tab node & collect tab offset
  var _useVisibleRange = useVisibleRange(tabOffsets,
    // Container
    visibleTabContentValue,
    // Transform
    tabPositionTopOrBottom ? transformLeft : transformTop,
    // Tabs
    tabContentSizeValue,
    // Add
    addSizeValue,
    // Operation
    operationSizeValue, (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, props), {}, {
      tabs: tabs
    })),
    _useVisibleRange2 = (0,slicedToArray/* default */.Z)(_useVisibleRange, 2),
    visibleStart = _useVisibleRange2[0],
    visibleEnd = _useVisibleRange2[1];

  // ========================= Scroll ========================
  var scrollToTab = (0,useEvent/* default */.Z)(function () {
    var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : activeKey;
    var tabOffset = tabOffsets.get(key) || {
      width: 0,
      height: 0,
      left: 0,
      right: 0,
      top: 0
    };
    if (tabPositionTopOrBottom) {
      // ============ Align with top & bottom ============
      var newTransform = transformLeft;

      // RTL
      if (rtl) {
        if (tabOffset.right < transformLeft) {
          newTransform = tabOffset.right;
        } else if (tabOffset.right + tabOffset.width > transformLeft + visibleTabContentValue) {
          newTransform = tabOffset.right + tabOffset.width - visibleTabContentValue;
        }
      }
      // LTR
      else if (tabOffset.left < -transformLeft) {
        newTransform = -tabOffset.left;
      } else if (tabOffset.left + tabOffset.width > -transformLeft + visibleTabContentValue) {
        newTransform = -(tabOffset.left + tabOffset.width - visibleTabContentValue);
      }
      setTransformTop(0);
      setTransformLeft(alignInRange(newTransform));
    } else {
      // ============ Align with left & right ============
      var _newTransform = transformTop;
      if (tabOffset.top < -transformTop) {
        _newTransform = -tabOffset.top;
      } else if (tabOffset.top + tabOffset.height > -transformTop + visibleTabContentValue) {
        _newTransform = -(tabOffset.top + tabOffset.height - visibleTabContentValue);
      }
      setTransformLeft(0);
      setTransformTop(alignInRange(_newTransform));
    }
  });

  // ========================== Tab ==========================
  var tabNodeStyle = {};
  if (tabPosition === 'top' || tabPosition === 'bottom') {
    tabNodeStyle[rtl ? 'marginRight' : 'marginLeft'] = tabBarGutter;
  } else {
    tabNodeStyle.marginTop = tabBarGutter;
  }
  var tabNodes = tabs.map(function (tab, i) {
    var key = tab.key;
    return /*#__PURE__*/react.createElement(TabNavList_TabNode, {
      id: id,
      prefixCls: prefixCls,
      key: key,
      tab: tab
      /* first node should not have margin left */,
      style: i === 0 ? undefined : tabNodeStyle,
      closable: tab.closable,
      editable: editable,
      active: key === activeKey,
      renderWrapper: children,
      removeAriaLabel: locale === null || locale === void 0 ? void 0 : locale.removeAriaLabel,
      onClick: function onClick(e) {
        onTabClick(key, e);
      },
      onFocus: function onFocus() {
        scrollToTab(key);
        doLockAnimation();
        if (!tabsWrapperRef.current) {
          return;
        }
        // Focus element will make scrollLeft change which we should reset back
        if (!rtl) {
          tabsWrapperRef.current.scrollLeft = 0;
        }
        tabsWrapperRef.current.scrollTop = 0;
      }
    });
  });

  // Update buttons records
  var updateTabSizes = function updateTabSizes() {
    return setTabSizes(function () {
      var _tabListRef$current;
      var newSizes = new Map();
      var listRect = (_tabListRef$current = tabListRef.current) === null || _tabListRef$current === void 0 ? void 0 : _tabListRef$current.getBoundingClientRect();
      tabs.forEach(function (_ref2) {
        var _tabListRef$current2;
        var key = _ref2.key;
        var btnNode = (_tabListRef$current2 = tabListRef.current) === null || _tabListRef$current2 === void 0 ? void 0 : _tabListRef$current2.querySelector("[data-node-key=\"".concat(genDataNodeKey(key), "\"]"));
        if (btnNode) {
          var _getTabSize = getTabSize(btnNode, listRect),
            _getTabSize2 = (0,slicedToArray/* default */.Z)(_getTabSize, 4),
            width = _getTabSize2[0],
            height = _getTabSize2[1],
            left = _getTabSize2[2],
            top = _getTabSize2[3];
          newSizes.set(key, {
            width: width,
            height: height,
            left: left,
            top: top
          });
        }
      });
      return newSizes;
    });
  };
  (0,react.useEffect)(function () {
    updateTabSizes();
  }, [tabs.map(function (tab) {
    return tab.key;
  }).join('_')]);
  var onListHolderResize = useUpdate(function () {
    // Update wrapper records
    var containerSize = getSize(containerRef);
    var extraLeftSize = getSize(extraLeftRef);
    var extraRightSize = getSize(extraRightRef);
    setContainerExcludeExtraSize([containerSize[0] - extraLeftSize[0] - extraRightSize[0], containerSize[1] - extraLeftSize[1] - extraRightSize[1]]);
    var newAddSize = getSize(innerAddButtonRef);
    setAddSize(newAddSize);
    var newOperationSize = getSize(operationsRef);
    setOperationSize(newOperationSize);

    // Which includes add button size
    var tabContentFullSize = getSize(tabListRef);
    setTabContentSize([tabContentFullSize[0] - newAddSize[0], tabContentFullSize[1] - newAddSize[1]]);

    // Update buttons records
    updateTabSizes();
  });

  // ======================== Dropdown =======================
  var startHiddenTabs = tabs.slice(0, visibleStart);
  var endHiddenTabs = tabs.slice(visibleEnd + 1);
  var hiddenTabs = [].concat((0,toConsumableArray/* default */.Z)(startHiddenTabs), (0,toConsumableArray/* default */.Z)(endHiddenTabs));

  // =================== Link & Operations ===================
  var activeTabOffset = tabOffsets.get(activeKey);
  var _useIndicator = hooks_useIndicator({
      activeTabOffset: activeTabOffset,
      horizontal: tabPositionTopOrBottom,
      indicator: indicator,
      rtl: rtl
    }),
    indicatorStyle = _useIndicator.style;

  // ========================= Effect ========================
  (0,react.useEffect)(function () {
    scrollToTab();
  }, [activeKey, transformMin, transformMax, stringify(activeTabOffset), stringify(tabOffsets), tabPositionTopOrBottom]);

  // Should recalculate when rtl changed
  (0,react.useEffect)(function () {
    onListHolderResize();
    // eslint-disable-next-line
  }, [rtl]);

  // ========================= Render ========================
  var hasDropdown = !!hiddenTabs.length;
  var wrapPrefix = "".concat(prefixCls, "-nav-wrap");
  var pingLeft;
  var pingRight;
  var pingTop;
  var pingBottom;
  if (tabPositionTopOrBottom) {
    if (rtl) {
      pingRight = transformLeft > 0;
      pingLeft = transformLeft !== transformMax;
    } else {
      pingLeft = transformLeft < 0;
      pingRight = transformLeft !== transformMin;
    }
  } else {
    pingTop = transformTop < 0;
    pingBottom = transformTop !== transformMin;
  }
  return /*#__PURE__*/react.createElement(es/* default */.Z, {
    onResize: onListHolderResize
  }, /*#__PURE__*/react.createElement("div", {
    ref: (0,es_ref/* useComposeRef */.x1)(ref, containerRef),
    role: "tablist",
    className: classnames_default()("".concat(prefixCls, "-nav"), className),
    style: style,
    onKeyDown: function onKeyDown() {
      // No need animation when use keyboard
      doLockAnimation();
    }
  }, /*#__PURE__*/react.createElement(TabNavList_ExtraContent, {
    ref: extraLeftRef,
    position: "left",
    extra: extra,
    prefixCls: prefixCls
  }), /*#__PURE__*/react.createElement(es/* default */.Z, {
    onResize: onListHolderResize
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()(wrapPrefix, (0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)({}, "".concat(wrapPrefix, "-ping-left"), pingLeft), "".concat(wrapPrefix, "-ping-right"), pingRight), "".concat(wrapPrefix, "-ping-top"), pingTop), "".concat(wrapPrefix, "-ping-bottom"), pingBottom)),
    ref: tabsWrapperRef
  }, /*#__PURE__*/react.createElement(es/* default */.Z, {
    onResize: onListHolderResize
  }, /*#__PURE__*/react.createElement("div", {
    ref: tabListRef,
    className: "".concat(prefixCls, "-nav-list"),
    style: {
      transform: "translate(".concat(transformLeft, "px, ").concat(transformTop, "px)"),
      transition: lockAnimation ? 'none' : undefined
    }
  }, tabNodes, /*#__PURE__*/react.createElement(TabNavList_AddButton, {
    ref: innerAddButtonRef,
    prefixCls: prefixCls,
    locale: locale,
    editable: editable,
    style: (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, tabNodes.length === 0 ? undefined : tabNodeStyle), {}, {
      visibility: hasDropdown ? 'hidden' : null
    })
  }), /*#__PURE__*/react.createElement("div", {
    className: classnames_default()("".concat(prefixCls, "-ink-bar"), (0,defineProperty/* default */.Z)({}, "".concat(prefixCls, "-ink-bar-animated"), animated.inkBar)),
    style: indicatorStyle
  }))))), /*#__PURE__*/react.createElement(TabNavList_OperationNode, (0,esm_extends/* default */.Z)({}, props, {
    removeAriaLabel: locale === null || locale === void 0 ? void 0 : locale.removeAriaLabel,
    ref: operationsRef,
    prefixCls: prefixCls,
    tabs: hiddenTabs,
    className: !hasDropdown && operationsHiddenClassName,
    tabMoving: !!lockAnimation
  })), /*#__PURE__*/react.createElement(TabNavList_ExtraContent, {
    ref: extraRightRef,
    position: "right",
    extra: extra,
    prefixCls: prefixCls
  })));
  /* eslint-enable */
});
/* harmony default export */ var es_TabNavList = (TabNavList);
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/TabPanelList/TabPane.js


var TabPane = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var prefixCls = props.prefixCls,
    className = props.className,
    style = props.style,
    id = props.id,
    active = props.active,
    tabKey = props.tabKey,
    children = props.children;
  return /*#__PURE__*/react.createElement("div", {
    id: id && "".concat(id, "-panel-").concat(tabKey),
    role: "tabpanel",
    tabIndex: active ? 0 : -1,
    "aria-labelledby": id && "".concat(id, "-tab-").concat(tabKey),
    "aria-hidden": !active,
    style: style,
    className: classnames_default()(prefixCls, active && "".concat(prefixCls, "-active"), className),
    ref: ref
  }, children);
});
if (false) {}
/* harmony default export */ var TabPanelList_TabPane = (TabPane);
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/TabNavList/Wrapper.js



var Wrapper_excluded = ["renderTabBar"],
  Wrapper_excluded2 = ["label", "key"];
// zombieJ: To compatible with `renderTabBar` usage.





// We have to create a TabNavList components.
var TabNavListWrapper = function TabNavListWrapper(_ref) {
  var renderTabBar = _ref.renderTabBar,
    restProps = (0,objectWithoutProperties/* default */.Z)(_ref, Wrapper_excluded);
  var _React$useContext = react.useContext(TabContext),
    tabs = _React$useContext.tabs;
  if (renderTabBar) {
    var tabNavBarProps = (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, restProps), {}, {
      // Legacy support. We do not use this actually
      panes: tabs.map(function (_ref2) {
        var label = _ref2.label,
          key = _ref2.key,
          restTabProps = (0,objectWithoutProperties/* default */.Z)(_ref2, Wrapper_excluded2);
        return /*#__PURE__*/react.createElement(TabPanelList_TabPane, (0,esm_extends/* default */.Z)({
          tab: label,
          key: key,
          tabKey: key
        }, restTabProps));
      })
    });
    return renderTabBar(tabNavBarProps, es_TabNavList);
  }
  return /*#__PURE__*/react.createElement(es_TabNavList, restProps);
};
if (false) {}
/* harmony default export */ var Wrapper = (TabNavListWrapper);
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/TabPanelList/index.js




var TabPanelList_excluded = ["key", "forceRender", "style", "className", "destroyInactiveTabPane"];





var TabPanelList = function TabPanelList(props) {
  var id = props.id,
    activeKey = props.activeKey,
    animated = props.animated,
    tabPosition = props.tabPosition,
    destroyInactiveTabPane = props.destroyInactiveTabPane;
  var _React$useContext = react.useContext(TabContext),
    prefixCls = _React$useContext.prefixCls,
    tabs = _React$useContext.tabs;
  var tabPaneAnimated = animated.tabPane;
  var tabPanePrefixCls = "".concat(prefixCls, "-tabpane");
  return /*#__PURE__*/react.createElement("div", {
    className: classnames_default()("".concat(prefixCls, "-content-holder"))
  }, /*#__PURE__*/react.createElement("div", {
    className: classnames_default()("".concat(prefixCls, "-content"), "".concat(prefixCls, "-content-").concat(tabPosition), (0,defineProperty/* default */.Z)({}, "".concat(prefixCls, "-content-animated"), tabPaneAnimated))
  }, tabs.map(function (item) {
    var key = item.key,
      forceRender = item.forceRender,
      paneStyle = item.style,
      paneClassName = item.className,
      itemDestroyInactiveTabPane = item.destroyInactiveTabPane,
      restTabProps = (0,objectWithoutProperties/* default */.Z)(item, TabPanelList_excluded);
    var active = key === activeKey;
    return /*#__PURE__*/react.createElement(rc_motion_es/* default */.ZP, (0,esm_extends/* default */.Z)({
      key: key,
      visible: active,
      forceRender: forceRender,
      removeOnLeave: !!(destroyInactiveTabPane || itemDestroyInactiveTabPane),
      leavedClassName: "".concat(tabPanePrefixCls, "-hidden")
    }, animated.tabPaneMotion), function (_ref, ref) {
      var motionStyle = _ref.style,
        motionClassName = _ref.className;
      return /*#__PURE__*/react.createElement(TabPanelList_TabPane, (0,esm_extends/* default */.Z)({}, restTabProps, {
        prefixCls: tabPanePrefixCls,
        id: id,
        tabKey: key,
        animated: tabPaneAnimated,
        active: active,
        style: (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, paneStyle), motionStyle),
        className: classnames_default()(paneClassName, motionClassName),
        ref: ref
      }));
    });
  })));
};
/* harmony default export */ var es_TabPanelList = (TabPanelList);
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/hooks/useAnimateConfig.js



function useAnimateConfig() {
  var animated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    inkBar: true,
    tabPane: false
  };
  var mergedAnimated;
  if (animated === false) {
    mergedAnimated = {
      inkBar: false,
      tabPane: false
    };
  } else if (animated === true) {
    mergedAnimated = {
      inkBar: true,
      tabPane: false
    };
  } else {
    mergedAnimated = (0,objectSpread2/* default */.Z)({
      inkBar: true
    }, (0,esm_typeof/* default */.Z)(animated) === 'object' ? animated : {});
  }

  // Enable tabPane animation if provide motion
  if (mergedAnimated.tabPaneMotion && mergedAnimated.tabPane === undefined) {
    mergedAnimated.tabPane = true;
  }
  if (!mergedAnimated.tabPaneMotion && mergedAnimated.tabPane) {
    if (false) {}
    mergedAnimated.tabPane = false;
  }
  return mergedAnimated;
}
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/Tabs.js






var Tabs_excluded = ["id", "prefixCls", "className", "items", "direction", "activeKey", "defaultActiveKey", "editable", "animated", "tabPosition", "tabBarGutter", "tabBarStyle", "tabBarExtraContent", "locale", "moreIcon", "moreTransitionName", "destroyInactiveTabPane", "renderTabBar", "onChange", "onTabClick", "onTabScroll", "getPopupContainer", "popupClassName", "indicator"];
// Accessibility https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/Tab_Role









/**
 * Should added antd:
 * - type
 *
 * Removed:
 * - onNextClick
 * - onPrevClick
 * - keyboard
 */

// Used for accessibility
var uuid = 0;
var Tabs = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var id = props.id,
    _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-tabs' : _props$prefixCls,
    className = props.className,
    items = props.items,
    direction = props.direction,
    activeKey = props.activeKey,
    defaultActiveKey = props.defaultActiveKey,
    editable = props.editable,
    animated = props.animated,
    _props$tabPosition = props.tabPosition,
    tabPosition = _props$tabPosition === void 0 ? 'top' : _props$tabPosition,
    tabBarGutter = props.tabBarGutter,
    tabBarStyle = props.tabBarStyle,
    tabBarExtraContent = props.tabBarExtraContent,
    locale = props.locale,
    moreIcon = props.moreIcon,
    moreTransitionName = props.moreTransitionName,
    destroyInactiveTabPane = props.destroyInactiveTabPane,
    renderTabBar = props.renderTabBar,
    onChange = props.onChange,
    onTabClick = props.onTabClick,
    onTabScroll = props.onTabScroll,
    getPopupContainer = props.getPopupContainer,
    popupClassName = props.popupClassName,
    indicator = props.indicator,
    restProps = (0,objectWithoutProperties/* default */.Z)(props, Tabs_excluded);
  var tabs = react.useMemo(function () {
    return (items || []).filter(function (item) {
      return item && (0,esm_typeof/* default */.Z)(item) === 'object' && 'key' in item;
    });
  }, [items]);
  var rtl = direction === 'rtl';
  var mergedAnimated = useAnimateConfig(animated);

  // ======================== Mobile ========================
  var _useState = (0,react.useState)(false),
    _useState2 = (0,slicedToArray/* default */.Z)(_useState, 2),
    mobile = _useState2[0],
    setMobile = _useState2[1];
  (0,react.useEffect)(function () {
    // Only update on the client side
    setMobile((0,isMobile/* default */.Z)());
  }, []);

  // ====================== Active Key ======================
  var _useMergedState = (0,useMergedState/* default */.Z)(function () {
      var _tabs$;
      return (_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key;
    }, {
      value: activeKey,
      defaultValue: defaultActiveKey
    }),
    _useMergedState2 = (0,slicedToArray/* default */.Z)(_useMergedState, 2),
    mergedActiveKey = _useMergedState2[0],
    setMergedActiveKey = _useMergedState2[1];
  var _useState3 = (0,react.useState)(function () {
      return tabs.findIndex(function (tab) {
        return tab.key === mergedActiveKey;
      });
    }),
    _useState4 = (0,slicedToArray/* default */.Z)(_useState3, 2),
    activeIndex = _useState4[0],
    setActiveIndex = _useState4[1];

  // Reset active key if not exist anymore
  (0,react.useEffect)(function () {
    var newActiveIndex = tabs.findIndex(function (tab) {
      return tab.key === mergedActiveKey;
    });
    if (newActiveIndex === -1) {
      var _tabs$newActiveIndex;
      newActiveIndex = Math.max(0, Math.min(activeIndex, tabs.length - 1));
      setMergedActiveKey((_tabs$newActiveIndex = tabs[newActiveIndex]) === null || _tabs$newActiveIndex === void 0 ? void 0 : _tabs$newActiveIndex.key);
    }
    setActiveIndex(newActiveIndex);
  }, [tabs.map(function (tab) {
    return tab.key;
  }).join('_'), mergedActiveKey, activeIndex]);

  // ===================== Accessibility ====================
  var _useMergedState3 = (0,useMergedState/* default */.Z)(null, {
      value: id
    }),
    _useMergedState4 = (0,slicedToArray/* default */.Z)(_useMergedState3, 2),
    mergedId = _useMergedState4[0],
    setMergedId = _useMergedState4[1];

  // Async generate id to avoid ssr mapping failed
  (0,react.useEffect)(function () {
    if (!id) {
      setMergedId("rc-tabs-".concat( false ? 0 : uuid));
      uuid += 1;
    }
  }, []);

  // ======================== Events ========================
  function onInternalTabClick(key, e) {
    onTabClick === null || onTabClick === void 0 || onTabClick(key, e);
    var isActiveChanged = key !== mergedActiveKey;
    setMergedActiveKey(key);
    if (isActiveChanged) {
      onChange === null || onChange === void 0 || onChange(key);
    }
  }

  // ======================== Render ========================
  var sharedProps = {
    id: mergedId,
    activeKey: mergedActiveKey,
    animated: mergedAnimated,
    tabPosition: tabPosition,
    rtl: rtl,
    mobile: mobile
  };
  var tabNavBarProps = (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, sharedProps), {}, {
    editable: editable,
    locale: locale,
    moreIcon: moreIcon,
    moreTransitionName: moreTransitionName,
    tabBarGutter: tabBarGutter,
    onTabClick: onInternalTabClick,
    onTabScroll: onTabScroll,
    extra: tabBarExtraContent,
    style: tabBarStyle,
    panes: null,
    getPopupContainer: getPopupContainer,
    popupClassName: popupClassName,
    indicator: indicator
  });
  return /*#__PURE__*/react.createElement(TabContext.Provider, {
    value: {
      tabs: tabs,
      prefixCls: prefixCls
    }
  }, /*#__PURE__*/react.createElement("div", (0,esm_extends/* default */.Z)({
    ref: ref,
    id: id,
    className: classnames_default()(prefixCls, "".concat(prefixCls, "-").concat(tabPosition), (0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)((0,defineProperty/* default */.Z)({}, "".concat(prefixCls, "-mobile"), mobile), "".concat(prefixCls, "-editable"), editable), "".concat(prefixCls, "-rtl"), rtl), className)
  }, restProps), /*#__PURE__*/react.createElement(Wrapper, (0,esm_extends/* default */.Z)({}, tabNavBarProps, {
    renderTabBar: renderTabBar
  })), /*#__PURE__*/react.createElement(es_TabPanelList, (0,esm_extends/* default */.Z)({
    destroyInactiveTabPane: destroyInactiveTabPane
  }, sharedProps, {
    animated: mergedAnimated
  }))));
});
if (false) {}
/* harmony default export */ var es_Tabs = (Tabs);
;// CONCATENATED MODULE: ./node_modules/rc-tabs/es/index.js

/* harmony default export */ var rc_tabs_es = (es_Tabs);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/context.js
var context = __webpack_require__(53124);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/hooks/useCSSVarCls.js
var useCSSVarCls = __webpack_require__(35792);
// EXTERNAL MODULE: ./node_modules/antd/es/config-provider/hooks/useSize.js
var useSize = __webpack_require__(98675);
// EXTERNAL MODULE: ./node_modules/antd/es/_util/motion.js
var motion = __webpack_require__(33603);
;// CONCATENATED MODULE: ./node_modules/antd/es/tabs/hooks/useAnimateConfig.js

const useAnimateConfig_motion = {
  motionAppear: false,
  motionEnter: true,
  motionLeave: true
};
function useAnimateConfig_useAnimateConfig(prefixCls) {
  let animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    inkBar: true,
    tabPane: false
  };
  let mergedAnimated;
  if (animated === false) {
    mergedAnimated = {
      inkBar: false,
      tabPane: false
    };
  } else if (animated === true) {
    mergedAnimated = {
      inkBar: true,
      tabPane: true
    };
  } else {
    mergedAnimated = Object.assign({
      inkBar: true
    }, typeof animated === 'object' ? animated : {});
  }
  if (mergedAnimated.tabPane) {
    mergedAnimated.tabPaneMotion = Object.assign(Object.assign({}, useAnimateConfig_motion), {
      motionName: (0,motion/* getTransitionName */.m)(prefixCls, 'switch')
    });
  }
  return mergedAnimated;
}
;// CONCATENATED MODULE: ./node_modules/antd/es/tabs/hooks/useLegacyItems.js
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



function filter(items) {
  return items.filter(item => item);
}
function useLegacyItems(items, children) {
  if (false) {}
  if (items) {
    return items;
  }
  const childrenItems = (0,toArray/* default */.Z)(children).map(node => {
    if ( /*#__PURE__*/react.isValidElement(node)) {
      const {
        key,
        props
      } = node;
      const _a = props || {},
        {
          tab
        } = _a,
        restProps = __rest(_a, ["tab"]);
      const item = Object.assign(Object.assign({
        key: String(key)
      }, restProps), {
        label: tab
      });
      return item;
    }
    return null;
  });
  return filter(childrenItems);
}
// EXTERNAL MODULE: ./node_modules/@ant-design/cssinjs/es/index.js + 35 modules
var cssinjs_es = __webpack_require__(54548);
// EXTERNAL MODULE: ./node_modules/antd/es/style/index.js
var style = __webpack_require__(14747);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/genComponentStyleHook.js + 6 modules
var genComponentStyleHook = __webpack_require__(92030);
// EXTERNAL MODULE: ./node_modules/antd/es/theme/util/statistic.js
var statistic = __webpack_require__(45503);
// EXTERNAL MODULE: ./node_modules/antd/es/style/motion/motion.js
var motion_motion = __webpack_require__(93590);
;// CONCATENATED MODULE: ./node_modules/antd/es/style/motion/slide.js


const slideUpIn = new cssinjs_es/* Keyframes */.E4('antSlideUpIn', {
  '0%': {
    transform: 'scaleY(0.8)',
    transformOrigin: '0% 0%',
    opacity: 0
  },
  '100%': {
    transform: 'scaleY(1)',
    transformOrigin: '0% 0%',
    opacity: 1
  }
});
const slideUpOut = new cssinjs_es/* Keyframes */.E4('antSlideUpOut', {
  '0%': {
    transform: 'scaleY(1)',
    transformOrigin: '0% 0%',
    opacity: 1
  },
  '100%': {
    transform: 'scaleY(0.8)',
    transformOrigin: '0% 0%',
    opacity: 0
  }
});
const slideDownIn = new cssinjs_es/* Keyframes */.E4('antSlideDownIn', {
  '0%': {
    transform: 'scaleY(0.8)',
    transformOrigin: '100% 100%',
    opacity: 0
  },
  '100%': {
    transform: 'scaleY(1)',
    transformOrigin: '100% 100%',
    opacity: 1
  }
});
const slideDownOut = new cssinjs_es/* Keyframes */.E4('antSlideDownOut', {
  '0%': {
    transform: 'scaleY(1)',
    transformOrigin: '100% 100%',
    opacity: 1
  },
  '100%': {
    transform: 'scaleY(0.8)',
    transformOrigin: '100% 100%',
    opacity: 0
  }
});
const slideLeftIn = new cssinjs_es/* Keyframes */.E4('antSlideLeftIn', {
  '0%': {
    transform: 'scaleX(0.8)',
    transformOrigin: '0% 0%',
    opacity: 0
  },
  '100%': {
    transform: 'scaleX(1)',
    transformOrigin: '0% 0%',
    opacity: 1
  }
});
const slideLeftOut = new cssinjs_es/* Keyframes */.E4('antSlideLeftOut', {
  '0%': {
    transform: 'scaleX(1)',
    transformOrigin: '0% 0%',
    opacity: 1
  },
  '100%': {
    transform: 'scaleX(0.8)',
    transformOrigin: '0% 0%',
    opacity: 0
  }
});
const slideRightIn = new cssinjs_es/* Keyframes */.E4('antSlideRightIn', {
  '0%': {
    transform: 'scaleX(0.8)',
    transformOrigin: '100% 0%',
    opacity: 0
  },
  '100%': {
    transform: 'scaleX(1)',
    transformOrigin: '100% 0%',
    opacity: 1
  }
});
const slideRightOut = new cssinjs_es/* Keyframes */.E4('antSlideRightOut', {
  '0%': {
    transform: 'scaleX(1)',
    transformOrigin: '100% 0%',
    opacity: 1
  },
  '100%': {
    transform: 'scaleX(0.8)',
    transformOrigin: '100% 0%',
    opacity: 0
  }
});
const slideMotion = {
  'slide-up': {
    inKeyframes: slideUpIn,
    outKeyframes: slideUpOut
  },
  'slide-down': {
    inKeyframes: slideDownIn,
    outKeyframes: slideDownOut
  },
  'slide-left': {
    inKeyframes: slideLeftIn,
    outKeyframes: slideLeftOut
  },
  'slide-right': {
    inKeyframes: slideRightIn,
    outKeyframes: slideRightOut
  }
};
const initSlideMotion = (token, motionName) => {
  const {
    antCls
  } = token;
  const motionCls = `${antCls}-${motionName}`;
  const {
    inKeyframes,
    outKeyframes
  } = slideMotion[motionName];
  return [(0,motion_motion/* initMotion */.R)(motionCls, inKeyframes, outKeyframes, token.motionDurationMid), {
    [`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
      transform: 'scale(0)',
      transformOrigin: '0% 0%',
      opacity: 0,
      animationTimingFunction: token.motionEaseOutQuint,
      [`&-prepare`]: {
        transform: 'scale(1)'
      }
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token.motionEaseInQuint
    }
  }];
};
;// CONCATENATED MODULE: ./node_modules/antd/es/tabs/style/motion.js

const genMotionStyle = token => {
  const {
    componentCls,
    motionDurationSlow
  } = token;
  return [{
    [componentCls]: {
      [`${componentCls}-switch`]: {
        '&-appear, &-enter': {
          transition: 'none',
          '&-start': {
            opacity: 0
          },
          '&-active': {
            opacity: 1,
            transition: `opacity ${motionDurationSlow}`
          }
        },
        '&-leave': {
          position: 'absolute',
          transition: 'none',
          inset: 0,
          '&-start': {
            opacity: 1
          },
          '&-active': {
            opacity: 0,
            transition: `opacity ${motionDurationSlow}`
          }
        }
      }
    }
  },
  // Follow code may reuse in other components
  [initSlideMotion(token, 'slide-up'), initSlideMotion(token, 'slide-down')]];
};
/* harmony default export */ var style_motion = (genMotionStyle);
;// CONCATENATED MODULE: ./node_modules/antd/es/tabs/style/index.js




const genCardStyle = token => {
  const {
    componentCls,
    tabsCardPadding,
    cardBg,
    cardGutter,
    colorBorderSecondary,
    itemSelectedColor
  } = token;
  return {
    [`${componentCls}-card`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-tab`]: {
          margin: 0,
          padding: tabsCardPadding,
          background: cardBg,
          border: `${(0,cssinjs_es/* unit */.bf)(token.lineWidth)} ${token.lineType} ${colorBorderSecondary}`,
          transition: `all ${token.motionDurationSlow} ${token.motionEaseInOut}`
        },
        [`${componentCls}-tab-active`]: {
          color: itemSelectedColor,
          background: token.colorBgContainer
        },
        [`${componentCls}-ink-bar`]: {
          visibility: 'hidden'
        }
      },
      // ========================== Top & Bottom ==========================
      [`&${componentCls}-top, &${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginLeft: {
              _skip_check_: true,
              value: (0,cssinjs_es/* unit */.bf)(cardGutter)
            }
          }
        }
      },
      [`&${componentCls}-top`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: `${(0,cssinjs_es/* unit */.bf)(token.borderRadiusLG)} ${(0,cssinjs_es/* unit */.bf)(token.borderRadiusLG)} 0 0`
          },
          [`${componentCls}-tab-active`]: {
            borderBottomColor: token.colorBgContainer
          }
        }
      },
      [`&${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: `0 0 ${(0,cssinjs_es/* unit */.bf)(token.borderRadiusLG)} ${(0,cssinjs_es/* unit */.bf)(token.borderRadiusLG)}`
          },
          [`${componentCls}-tab-active`]: {
            borderTopColor: token.colorBgContainer
          }
        }
      },
      // ========================== Left & Right ==========================
      [`&${componentCls}-left, &${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginTop: (0,cssinjs_es/* unit */.bf)(cardGutter)
          }
        }
      },
      [`&${componentCls}-left`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `${(0,cssinjs_es/* unit */.bf)(token.borderRadiusLG)} 0 0 ${(0,cssinjs_es/* unit */.bf)(token.borderRadiusLG)}`
            }
          },
          [`${componentCls}-tab-active`]: {
            borderRightColor: {
              _skip_check_: true,
              value: token.colorBgContainer
            }
          }
        }
      },
      [`&${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `0 ${(0,cssinjs_es/* unit */.bf)(token.borderRadiusLG)} ${(0,cssinjs_es/* unit */.bf)(token.borderRadiusLG)} 0`
            }
          },
          [`${componentCls}-tab-active`]: {
            borderLeftColor: {
              _skip_check_: true,
              value: token.colorBgContainer
            }
          }
        }
      }
    }
  };
};
const genDropdownStyle = token => {
  const {
    componentCls,
    itemHoverColor,
    dropdownEdgeChildVerticalPadding
  } = token;
  return {
    [`${componentCls}-dropdown`]: Object.assign(Object.assign({}, (0,style/* resetComponent */.Wf)(token)), {
      position: 'absolute',
      top: -9999,
      left: {
        _skip_check_: true,
        value: -9999
      },
      zIndex: token.zIndexPopup,
      display: 'block',
      '&-hidden': {
        display: 'none'
      },
      [`${componentCls}-dropdown-menu`]: {
        maxHeight: token.tabsDropdownHeight,
        margin: 0,
        padding: `${(0,cssinjs_es/* unit */.bf)(dropdownEdgeChildVerticalPadding)} 0`,
        overflowX: 'hidden',
        overflowY: 'auto',
        textAlign: {
          _skip_check_: true,
          value: 'left'
        },
        listStyleType: 'none',
        backgroundColor: token.colorBgContainer,
        backgroundClip: 'padding-box',
        borderRadius: token.borderRadiusLG,
        outline: 'none',
        boxShadow: token.boxShadowSecondary,
        '&-item': Object.assign(Object.assign({}, style/* textEllipsis */.vS), {
          display: 'flex',
          alignItems: 'center',
          minWidth: token.tabsDropdownWidth,
          margin: 0,
          padding: `${(0,cssinjs_es/* unit */.bf)(token.paddingXXS)} ${(0,cssinjs_es/* unit */.bf)(token.paddingSM)}`,
          color: token.colorText,
          fontWeight: 'normal',
          fontSize: token.fontSize,
          lineHeight: token.lineHeight,
          cursor: 'pointer',
          transition: `all ${token.motionDurationSlow}`,
          '> span': {
            flex: 1,
            whiteSpace: 'nowrap'
          },
          '&-remove': {
            flex: 'none',
            marginLeft: {
              _skip_check_: true,
              value: token.marginSM
            },
            color: token.colorTextDescription,
            fontSize: token.fontSizeSM,
            background: 'transparent',
            border: 0,
            cursor: 'pointer',
            '&:hover': {
              color: itemHoverColor
            }
          },
          '&:hover': {
            background: token.controlItemBgHover
          },
          '&-disabled': {
            '&, &:hover': {
              color: token.colorTextDisabled,
              background: 'transparent',
              cursor: 'not-allowed'
            }
          }
        })
      }
    })
  };
};
const genPositionStyle = token => {
  const {
    componentCls,
    margin,
    colorBorderSecondary,
    horizontalMargin,
    verticalItemPadding,
    verticalItemMargin,
    calc
  } = token;
  return {
    // ========================== Top & Bottom ==========================
    [`${componentCls}-top, ${componentCls}-bottom`]: {
      flexDirection: 'column',
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        margin: horizontalMargin,
        '&::before': {
          position: 'absolute',
          right: {
            _skip_check_: true,
            value: 0
          },
          left: {
            _skip_check_: true,
            value: 0
          },
          borderBottom: `${(0,cssinjs_es/* unit */.bf)(token.lineWidth)} ${token.lineType} ${colorBorderSecondary}`,
          content: "''"
        },
        [`${componentCls}-ink-bar`]: {
          height: token.lineWidthBold,
          '&-animated': {
            transition: `width ${token.motionDurationSlow}, left ${token.motionDurationSlow},
            right ${token.motionDurationSlow}`
          }
        },
        [`${componentCls}-nav-wrap`]: {
          '&::before, &::after': {
            top: 0,
            bottom: 0,
            width: token.controlHeight
          },
          '&::before': {
            left: {
              _skip_check_: true,
              value: 0
            },
            boxShadow: token.boxShadowTabsOverflowLeft
          },
          '&::after': {
            right: {
              _skip_check_: true,
              value: 0
            },
            boxShadow: token.boxShadowTabsOverflowRight
          },
          [`&${componentCls}-nav-wrap-ping-left::before`]: {
            opacity: 1
          },
          [`&${componentCls}-nav-wrap-ping-right::after`]: {
            opacity: 1
          }
        }
      }
    },
    [`${componentCls}-top`]: {
      [`> ${componentCls}-nav,
        > div > ${componentCls}-nav`]: {
        '&::before': {
          bottom: 0
        },
        [`${componentCls}-ink-bar`]: {
          bottom: 0
        }
      }
    },
    [`${componentCls}-bottom`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        order: 1,
        marginTop: margin,
        marginBottom: 0,
        '&::before': {
          top: 0
        },
        [`${componentCls}-ink-bar`]: {
          top: 0
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        order: 0
      }
    },
    // ========================== Left & Right ==========================
    [`${componentCls}-left, ${componentCls}-right`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        flexDirection: 'column',
        minWidth: calc(token.controlHeight).mul(1.25).equal(),
        // >>>>>>>>>>> Tab
        [`${componentCls}-tab`]: {
          padding: verticalItemPadding,
          textAlign: 'center'
        },
        [`${componentCls}-tab + ${componentCls}-tab`]: {
          margin: verticalItemMargin
        },
        // >>>>>>>>>>> Nav
        [`${componentCls}-nav-wrap`]: {
          flexDirection: 'column',
          '&::before, &::after': {
            right: {
              _skip_check_: true,
              value: 0
            },
            left: {
              _skip_check_: true,
              value: 0
            },
            height: token.controlHeight
          },
          '&::before': {
            top: 0,
            boxShadow: token.boxShadowTabsOverflowTop
          },
          '&::after': {
            bottom: 0,
            boxShadow: token.boxShadowTabsOverflowBottom
          },
          [`&${componentCls}-nav-wrap-ping-top::before`]: {
            opacity: 1
          },
          [`&${componentCls}-nav-wrap-ping-bottom::after`]: {
            opacity: 1
          }
        },
        // >>>>>>>>>>> Ink Bar
        [`${componentCls}-ink-bar`]: {
          width: token.lineWidthBold,
          '&-animated': {
            transition: `height ${token.motionDurationSlow}, top ${token.motionDurationSlow}`
          }
        },
        [`${componentCls}-nav-list, ${componentCls}-nav-operations`]: {
          flex: '1 0 auto',
          // fix safari scroll problem
          flexDirection: 'column'
        }
      }
    },
    [`${componentCls}-left`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-ink-bar`]: {
          right: {
            _skip_check_: true,
            value: 0
          }
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        marginLeft: {
          _skip_check_: true,
          value: (0,cssinjs_es/* unit */.bf)(calc(token.lineWidth).mul(-1).equal())
        },
        borderLeft: {
          _skip_check_: true,
          value: `${(0,cssinjs_es/* unit */.bf)(token.lineWidth)} ${token.lineType} ${token.colorBorder}`
        },
        [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
          paddingLeft: {
            _skip_check_: true,
            value: token.paddingLG
          }
        }
      }
    },
    [`${componentCls}-right`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        order: 1,
        [`${componentCls}-ink-bar`]: {
          left: {
            _skip_check_: true,
            value: 0
          }
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        order: 0,
        marginRight: {
          _skip_check_: true,
          value: calc(token.lineWidth).mul(-1).equal()
        },
        borderRight: {
          _skip_check_: true,
          value: `${(0,cssinjs_es/* unit */.bf)(token.lineWidth)} ${token.lineType} ${token.colorBorder}`
        },
        [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
          paddingRight: {
            _skip_check_: true,
            value: token.paddingLG
          }
        }
      }
    }
  };
};
const genSizeStyle = token => {
  const {
    componentCls,
    cardPaddingSM,
    cardPaddingLG,
    horizontalItemPaddingSM,
    horizontalItemPaddingLG
  } = token;
  return {
    [componentCls]: {
      '&-small': {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: horizontalItemPaddingSM,
            fontSize: token.titleFontSizeSM
          }
        }
      },
      '&-large': {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: horizontalItemPaddingLG,
            fontSize: token.titleFontSizeLG
          }
        }
      }
    },
    [`${componentCls}-card`]: {
      [`&${componentCls}-small`]: {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: cardPaddingSM
          }
        },
        [`&${componentCls}-bottom`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: `0 0 ${(0,cssinjs_es/* unit */.bf)(token.borderRadius)} ${(0,cssinjs_es/* unit */.bf)(token.borderRadius)}`
          }
        },
        [`&${componentCls}-top`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: `${(0,cssinjs_es/* unit */.bf)(token.borderRadius)} ${(0,cssinjs_es/* unit */.bf)(token.borderRadius)} 0 0`
          }
        },
        [`&${componentCls}-right`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `0 ${(0,cssinjs_es/* unit */.bf)(token.borderRadius)} ${(0,cssinjs_es/* unit */.bf)(token.borderRadius)} 0`
            }
          }
        },
        [`&${componentCls}-left`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `${(0,cssinjs_es/* unit */.bf)(token.borderRadius)} 0 0 ${(0,cssinjs_es/* unit */.bf)(token.borderRadius)}`
            }
          }
        }
      },
      [`&${componentCls}-large`]: {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: cardPaddingLG
          }
        }
      }
    }
  };
};
const genTabStyle = token => {
  const {
    componentCls,
    itemActiveColor,
    itemHoverColor,
    iconCls,
    tabsHorizontalItemMargin,
    horizontalItemPadding,
    itemSelectedColor,
    itemColor
  } = token;
  const tabCls = `${componentCls}-tab`;
  return {
    [tabCls]: {
      position: 'relative',
      WebkitTouchCallout: 'none',
      WebkitTapHighlightColor: 'transparent',
      display: 'inline-flex',
      alignItems: 'center',
      padding: horizontalItemPadding,
      fontSize: token.titleFontSize,
      background: 'transparent',
      border: 0,
      outline: 'none',
      cursor: 'pointer',
      color: itemColor,
      '&-btn, &-remove': Object.assign({
        '&:focus:not(:focus-visible), &:active': {
          color: itemActiveColor
        }
      }, (0,style/* genFocusStyle */.Qy)(token)),
      '&-btn': {
        outline: 'none',
        transition: `all ${token.motionDurationSlow}`,
        [`${tabCls}-icon:not(:last-child)`]: {
          marginInlineEnd: token.marginSM
        }
      },
      '&-remove': {
        flex: 'none',
        marginRight: {
          _skip_check_: true,
          value: token.calc(token.marginXXS).mul(-1).equal()
        },
        marginLeft: {
          _skip_check_: true,
          value: token.marginXS
        },
        color: token.colorTextDescription,
        fontSize: token.fontSizeSM,
        background: 'transparent',
        border: 'none',
        outline: 'none',
        cursor: 'pointer',
        transition: `all ${token.motionDurationSlow}`,
        '&:hover': {
          color: token.colorTextHeading
        }
      },
      '&:hover': {
        color: itemHoverColor
      },
      [`&${tabCls}-active ${tabCls}-btn`]: {
        color: itemSelectedColor,
        textShadow: token.tabsActiveTextShadow
      },
      [`&${tabCls}-disabled`]: {
        color: token.colorTextDisabled,
        cursor: 'not-allowed'
      },
      [`&${tabCls}-disabled ${tabCls}-btn, &${tabCls}-disabled ${componentCls}-remove`]: {
        '&:focus, &:active': {
          color: token.colorTextDisabled
        }
      },
      [`& ${tabCls}-remove ${iconCls}`]: {
        margin: 0
      },
      [`${iconCls}:not(:last-child)`]: {
        marginRight: {
          _skip_check_: true,
          value: token.marginSM
        }
      }
    },
    [`${tabCls} + ${tabCls}`]: {
      margin: {
        _skip_check_: true,
        value: tabsHorizontalItemMargin
      }
    }
  };
};
const genRtlStyle = token => {
  const {
    componentCls,
    tabsHorizontalItemMarginRTL,
    iconCls,
    cardGutter,
    calc
  } = token;
  const rtlCls = `${componentCls}-rtl`;
  return {
    [rtlCls]: {
      direction: 'rtl',
      [`${componentCls}-nav`]: {
        [`${componentCls}-tab`]: {
          margin: {
            _skip_check_: true,
            value: tabsHorizontalItemMarginRTL
          },
          [`${componentCls}-tab:last-of-type`]: {
            marginLeft: {
              _skip_check_: true,
              value: 0
            }
          },
          [iconCls]: {
            marginRight: {
              _skip_check_: true,
              value: 0
            },
            marginLeft: {
              _skip_check_: true,
              value: (0,cssinjs_es/* unit */.bf)(token.marginSM)
            }
          },
          [`${componentCls}-tab-remove`]: {
            marginRight: {
              _skip_check_: true,
              value: (0,cssinjs_es/* unit */.bf)(token.marginXS)
            },
            marginLeft: {
              _skip_check_: true,
              value: (0,cssinjs_es/* unit */.bf)(calc(token.marginXXS).mul(-1).equal())
            },
            [iconCls]: {
              margin: 0
            }
          }
        }
      },
      [`&${componentCls}-left`]: {
        [`> ${componentCls}-nav`]: {
          order: 1
        },
        [`> ${componentCls}-content-holder`]: {
          order: 0
        }
      },
      [`&${componentCls}-right`]: {
        [`> ${componentCls}-nav`]: {
          order: 0
        },
        [`> ${componentCls}-content-holder`]: {
          order: 1
        }
      },
      // ====================== Card ======================
      [`&${componentCls}-card${componentCls}-top, &${componentCls}-card${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginRight: {
              _skip_check_: true,
              value: cardGutter
            },
            marginLeft: {
              _skip_check_: true,
              value: 0
            }
          }
        }
      }
    },
    [`${componentCls}-dropdown-rtl`]: {
      direction: 'rtl'
    },
    [`${componentCls}-menu-item`]: {
      [`${componentCls}-dropdown-rtl`]: {
        textAlign: {
          _skip_check_: true,
          value: 'right'
        }
      }
    }
  };
};
const genTabsStyle = token => {
  const {
    componentCls,
    tabsCardPadding,
    cardHeight,
    cardGutter,
    itemHoverColor,
    itemActiveColor,
    colorBorderSecondary
  } = token;
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, (0,style/* resetComponent */.Wf)(token)), {
      display: 'flex',
      // ========================== Navigation ==========================
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        position: 'relative',
        display: 'flex',
        flex: 'none',
        alignItems: 'center',
        [`${componentCls}-nav-wrap`]: {
          position: 'relative',
          display: 'flex',
          flex: 'auto',
          alignSelf: 'stretch',
          overflow: 'hidden',
          whiteSpace: 'nowrap',
          transform: 'translate(0)',
          // Fix chrome render bug
          // >>>>> Ping shadow
          '&::before, &::after': {
            position: 'absolute',
            zIndex: 1,
            opacity: 0,
            transition: `opacity ${token.motionDurationSlow}`,
            content: "''",
            pointerEvents: 'none'
          }
        },
        [`${componentCls}-nav-list`]: {
          position: 'relative',
          display: 'flex',
          transition: `opacity ${token.motionDurationSlow}`
        },
        // >>>>>>>> Operations
        [`${componentCls}-nav-operations`]: {
          display: 'flex',
          alignSelf: 'stretch'
        },
        [`${componentCls}-nav-operations-hidden`]: {
          position: 'absolute',
          visibility: 'hidden',
          pointerEvents: 'none'
        },
        [`${componentCls}-nav-more`]: {
          position: 'relative',
          padding: tabsCardPadding,
          background: 'transparent',
          border: 0,
          color: token.colorText,
          '&::after': {
            position: 'absolute',
            right: {
              _skip_check_: true,
              value: 0
            },
            bottom: 0,
            left: {
              _skip_check_: true,
              value: 0
            },
            height: token.calc(token.controlHeightLG).div(8).equal(),
            transform: 'translateY(100%)',
            content: "''"
          }
        },
        [`${componentCls}-nav-add`]: Object.assign({
          minWidth: cardHeight,
          minHeight: cardHeight,
          marginLeft: {
            _skip_check_: true,
            value: cardGutter
          },
          padding: `0 ${(0,cssinjs_es/* unit */.bf)(token.paddingXS)}`,
          background: 'transparent',
          border: `${(0,cssinjs_es/* unit */.bf)(token.lineWidth)} ${token.lineType} ${colorBorderSecondary}`,
          borderRadius: `${(0,cssinjs_es/* unit */.bf)(token.borderRadiusLG)} ${(0,cssinjs_es/* unit */.bf)(token.borderRadiusLG)} 0 0`,
          outline: 'none',
          cursor: 'pointer',
          color: token.colorText,
          transition: `all ${token.motionDurationSlow} ${token.motionEaseInOut}`,
          '&:hover': {
            color: itemHoverColor
          },
          '&:active, &:focus:not(:focus-visible)': {
            color: itemActiveColor
          }
        }, (0,style/* genFocusStyle */.Qy)(token))
      },
      [`${componentCls}-extra-content`]: {
        flex: 'none'
      },
      // ============================ InkBar ============================
      [`${componentCls}-ink-bar`]: {
        position: 'absolute',
        background: token.inkBarColor,
        pointerEvents: 'none'
      }
    }), genTabStyle(token)), {
      // =========================== TabPanes ===========================
      [`${componentCls}-content`]: {
        position: 'relative',
        width: '100%'
      },
      [`${componentCls}-content-holder`]: {
        flex: 'auto',
        minWidth: 0,
        minHeight: 0
      },
      [`${componentCls}-tabpane`]: {
        outline: 'none',
        '&-hidden': {
          display: 'none'
        }
      }
    }),
    [`${componentCls}-centered`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-nav-wrap`]: {
          [`&:not([class*='${componentCls}-nav-wrap-ping'])`]: {
            justifyContent: 'center'
          }
        }
      }
    }
  };
};
const prepareComponentToken = token => {
  const cardHeight = token.controlHeightLG;
  return {
    zIndexPopup: token.zIndexPopupBase + 50,
    cardBg: token.colorFillAlter,
    cardHeight,
    // Initialize with empty string, because cardPadding will be calculated with cardHeight by default.
    cardPadding: `${(cardHeight - Math.round(token.fontSize * token.lineHeight)) / 2 - token.lineWidth}px ${token.padding}px`,
    cardPaddingSM: `${token.paddingXXS * 1.5}px ${token.padding}px`,
    cardPaddingLG: `${token.paddingXS}px ${token.padding}px ${token.paddingXXS * 1.5}px`,
    titleFontSize: token.fontSize,
    titleFontSizeLG: token.fontSizeLG,
    titleFontSizeSM: token.fontSize,
    inkBarColor: token.colorPrimary,
    horizontalMargin: `0 0 ${token.margin}px 0`,
    horizontalItemGutter: 32,
    // Fixed Value
    // Initialize with empty string, because horizontalItemMargin will be calculated with horizontalItemGutter by default.
    horizontalItemMargin: ``,
    horizontalItemMarginRTL: ``,
    horizontalItemPadding: `${token.paddingSM}px 0`,
    horizontalItemPaddingSM: `${token.paddingXS}px 0`,
    horizontalItemPaddingLG: `${token.padding}px 0`,
    verticalItemPadding: `${token.paddingXS}px ${token.paddingLG}px`,
    verticalItemMargin: `${token.margin}px 0 0 0`,
    itemColor: token.colorText,
    itemSelectedColor: token.colorPrimary,
    itemHoverColor: token.colorPrimaryHover,
    itemActiveColor: token.colorPrimaryActive,
    cardGutter: token.marginXXS / 2
  };
};
// ============================== Export ==============================
/* harmony default export */ var tabs_style = ((0,genComponentStyleHook/* genStyleHooks */.I$)('Tabs', token => {
  const tabsToken = (0,statistic/* merge */.TS)(token, {
    // `cardPadding` is empty by default, so we could calculate with dynamic `cardHeight`
    tabsCardPadding: token.cardPadding,
    dropdownEdgeChildVerticalPadding: token.paddingXXS,
    tabsActiveTextShadow: '0 0 0.25px currentcolor',
    tabsDropdownHeight: 200,
    tabsDropdownWidth: 120,
    tabsHorizontalItemMargin: `0 0 0 ${(0,cssinjs_es/* unit */.bf)(token.horizontalItemGutter)}`,
    tabsHorizontalItemMarginRTL: `0 0 0 ${(0,cssinjs_es/* unit */.bf)(token.horizontalItemGutter)}`
  });
  return [genSizeStyle(tabsToken), genRtlStyle(tabsToken), genPositionStyle(tabsToken), genDropdownStyle(tabsToken), genCardStyle(tabsToken), genTabsStyle(tabsToken), style_motion(tabsToken)];
}, prepareComponentToken));
;// CONCATENATED MODULE: ./node_modules/antd/es/tabs/TabPane.js
const TabPane_TabPane = () => null;
if (false) {}
/* harmony default export */ var tabs_TabPane = (TabPane_TabPane);
;// CONCATENATED MODULE: ./node_modules/antd/es/tabs/index.js
"use client";

var tabs_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};














const tabs_Tabs = props => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const {
      type,
      className,
      rootClassName,
      size: customSize,
      onEdit,
      hideAdd,
      centered,
      addIcon,
      removeIcon,
      moreIcon,
      popupClassName,
      children,
      items,
      animated,
      style,
      indicatorSize,
      indicator
    } = props,
    otherProps = tabs_rest(props, ["type", "className", "rootClassName", "size", "onEdit", "hideAdd", "centered", "addIcon", "removeIcon", "moreIcon", "popupClassName", "children", "items", "animated", "style", "indicatorSize", "indicator"]);
  const {
    prefixCls: customizePrefixCls
  } = otherProps;
  const {
    direction,
    tabs,
    getPrefixCls,
    getPopupContainer
  } = react.useContext(context/* ConfigContext */.E_);
  const prefixCls = getPrefixCls('tabs', customizePrefixCls);
  const rootCls = (0,useCSSVarCls/* default */.Z)(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = tabs_style(prefixCls, rootCls);
  let editable;
  if (type === 'editable-card') {
    editable = {
      onEdit: (editType, _ref) => {
        let {
          key,
          event
        } = _ref;
        onEdit === null || onEdit === void 0 ? void 0 : onEdit(editType === 'add' ? event : key, editType);
      },
      removeIcon: (_a = removeIcon !== null && removeIcon !== void 0 ? removeIcon : tabs === null || tabs === void 0 ? void 0 : tabs.removeIcon) !== null && _a !== void 0 ? _a : /*#__PURE__*/react.createElement(CloseOutlined/* default */.Z, null),
      addIcon: (addIcon !== null && addIcon !== void 0 ? addIcon : tabs === null || tabs === void 0 ? void 0 : tabs.addIcon) || /*#__PURE__*/react.createElement(icons_PlusOutlined, null),
      showAdd: hideAdd !== true
    };
  }
  const rootPrefixCls = getPrefixCls();
  if (false) {}
  const size = (0,useSize/* default */.Z)(customSize);
  const mergedItems = useLegacyItems(items, children);
  const mergedAnimated = useAnimateConfig_useAnimateConfig(prefixCls, animated);
  const mergedStyle = Object.assign(Object.assign({}, tabs === null || tabs === void 0 ? void 0 : tabs.style), style);
  const mergedIndicator = {
    align: (_b = indicator === null || indicator === void 0 ? void 0 : indicator.align) !== null && _b !== void 0 ? _b : (_c = tabs === null || tabs === void 0 ? void 0 : tabs.indicator) === null || _c === void 0 ? void 0 : _c.align,
    size: (_g = (_e = (_d = indicator === null || indicator === void 0 ? void 0 : indicator.size) !== null && _d !== void 0 ? _d : indicatorSize) !== null && _e !== void 0 ? _e : (_f = tabs === null || tabs === void 0 ? void 0 : tabs.indicator) === null || _f === void 0 ? void 0 : _f.size) !== null && _g !== void 0 ? _g : tabs === null || tabs === void 0 ? void 0 : tabs.indicatorSize
  };
  return wrapCSSVar( /*#__PURE__*/react.createElement(rc_tabs_es, Object.assign({
    direction: direction,
    getPopupContainer: getPopupContainer,
    moreTransitionName: `${rootPrefixCls}-slide-up`
  }, otherProps, {
    items: mergedItems,
    className: classnames_default()({
      [`${prefixCls}-${size}`]: size,
      [`${prefixCls}-card`]: ['card', 'editable-card'].includes(type),
      [`${prefixCls}-editable-card`]: type === 'editable-card',
      [`${prefixCls}-centered`]: centered
    }, tabs === null || tabs === void 0 ? void 0 : tabs.className, className, rootClassName, hashId, cssVarCls, rootCls),
    popupClassName: classnames_default()(popupClassName, hashId, cssVarCls, rootCls),
    style: mergedStyle,
    editable: editable,
    moreIcon: (_h = moreIcon !== null && moreIcon !== void 0 ? moreIcon : tabs === null || tabs === void 0 ? void 0 : tabs.moreIcon) !== null && _h !== void 0 ? _h : /*#__PURE__*/react.createElement(icons_EllipsisOutlined, null),
    prefixCls: prefixCls,
    animated: mergedAnimated,
    indicator: mergedIndicator
  })));
};
tabs_Tabs.TabPane = tabs_TabPane;
if (false) {}
/* harmony default export */ var tabs = (tabs_Tabs);

/***/ }),

/***/ 58162:
/***/ (function(module) {

"use strict";

// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
function base (ALPHABET) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256)
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i)
    var xc = x.charCodeAt(0)
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i
  }
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)
  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
  function encode (source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source)
    }
    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0
    var length = 0
    var pbegin = 0
    var pend = source.length
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++
      zeroes++
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0
    var b58 = new Uint8Array(size)
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin]
            // Apply "b58 = b58 * 256 + ch".
      var i = 0
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0
        b58[it1] = (carry % BASE) >>> 0
        carry = (carry / BASE) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      pbegin++
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length
    while (it2 !== size && b58[it2] === 0) {
      it2++
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes)
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return new Uint8Array() }
    var psz = 0
        // Skip and count leading '1's.
    var zeroes = 0
    var length = 0
    while (source[psz] === LEADER) {
      zeroes++
      psz++
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size)
        // Process the characters.
    while (source[psz]) {
            // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)]
            // Invalid character
      if (carry === 255) { return }
      var i = 0
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0
        b256[it3] = (carry % 256) >>> 0
        carry = (carry / 256) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      psz++
    }
        // Skip leading zeroes in b256.
    var it4 = size - length
    while (it4 !== size && b256[it4] === 0) {
      it4++
    }
    var vch = new Uint8Array(zeroes + (size - it4))
    var j = zeroes
    while (it4 !== size) {
      vch[j++] = b256[it4++]
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string)
    if (buffer) { return buffer }
    throw new Error('Non-base' + BASE + ' character')
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
module.exports = base


/***/ }),

/***/ 27715:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bech32m = exports.bech32 = void 0;
const ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
const ALPHABET_MAP = {};
for (let z = 0; z < ALPHABET.length; z++) {
    const x = ALPHABET.charAt(z);
    ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
    const b = pre >> 25;
    return (((pre & 0x1ffffff) << 5) ^
        (-((b >> 0) & 1) & 0x3b6a57b2) ^
        (-((b >> 1) & 1) & 0x26508e6d) ^
        (-((b >> 2) & 1) & 0x1ea119fa) ^
        (-((b >> 3) & 1) & 0x3d4233dd) ^
        (-((b >> 4) & 1) & 0x2a1462b3));
}
function prefixChk(prefix) {
    let chk = 1;
    for (let i = 0; i < prefix.length; ++i) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
            return 'Invalid prefix (' + prefix + ')';
        chk = polymodStep(chk) ^ (c >> 5);
    }
    chk = polymodStep(chk);
    for (let i = 0; i < prefix.length; ++i) {
        const v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ (v & 0x1f);
    }
    return chk;
}
function convert(data, inBits, outBits, pad) {
    let value = 0;
    let bits = 0;
    const maxV = (1 << outBits) - 1;
    const result = [];
    for (let i = 0; i < data.length; ++i) {
        value = (value << inBits) | data[i];
        bits += inBits;
        while (bits >= outBits) {
            bits -= outBits;
            result.push((value >> bits) & maxV);
        }
    }
    if (pad) {
        if (bits > 0) {
            result.push((value << (outBits - bits)) & maxV);
        }
    }
    else {
        if (bits >= inBits)
            return 'Excess padding';
        if ((value << (outBits - bits)) & maxV)
            return 'Non-zero padding';
    }
    return result;
}
function toWords(bytes) {
    return convert(bytes, 8, 5, true);
}
function fromWordsUnsafe(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
        return res;
}
function fromWords(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res))
        return res;
    throw new Error(res);
}
function getLibraryFromEncoding(encoding) {
    let ENCODING_CONST;
    if (encoding === 'bech32') {
        ENCODING_CONST = 1;
    }
    else {
        ENCODING_CONST = 0x2bc830a3;
    }
    function encode(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
            throw new TypeError('Exceeds length limit');
        prefix = prefix.toLowerCase();
        // determine chk mod
        let chk = prefixChk(prefix);
        if (typeof chk === 'string')
            throw new Error(chk);
        let result = prefix + '1';
        for (let i = 0; i < words.length; ++i) {
            const x = words[i];
            if (x >> 5 !== 0)
                throw new Error('Non 5-bit word');
            chk = polymodStep(chk) ^ x;
            result += ALPHABET.charAt(x);
        }
        for (let i = 0; i < 6; ++i) {
            chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i = 0; i < 6; ++i) {
            const v = (chk >> ((5 - i) * 5)) & 0x1f;
            result += ALPHABET.charAt(v);
        }
        return result;
    }
    function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
            return str + ' too short';
        if (str.length > LIMIT)
            return 'Exceeds length limit';
        // don't allow mixed case
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
            return 'Mixed-case string ' + str;
        str = lowered;
        const split = str.lastIndexOf('1');
        if (split === -1)
            return 'No separator character for ' + str;
        if (split === 0)
            return 'Missing prefix for ' + str;
        const prefix = str.slice(0, split);
        const wordChars = str.slice(split + 1);
        if (wordChars.length < 6)
            return 'Data too short';
        let chk = prefixChk(prefix);
        if (typeof chk === 'string')
            return chk;
        const words = [];
        for (let i = 0; i < wordChars.length; ++i) {
            const c = wordChars.charAt(i);
            const v = ALPHABET_MAP[c];
            if (v === undefined)
                return 'Unknown character ' + c;
            chk = polymodStep(chk) ^ v;
            // not in the checksum?
            if (i + 6 >= wordChars.length)
                continue;
            words.push(v);
        }
        if (chk !== ENCODING_CONST)
            return 'Invalid checksum for ' + str;
        return { prefix, words };
    }
    function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object')
            return res;
    }
    function decode(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object')
            return res;
        throw new Error(res);
    }
    return {
        decodeUnsafe,
        decode,
        encode,
        toWords,
        fromWordsUnsafe,
        fromWords,
    };
}
exports.bech32 = getLibraryFromEncoding('bech32');
exports.bech32m = getLibraryFromEncoding('bech32m');


/***/ }),

/***/ 82190:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const parser_1 = __webpack_require__(36574);
function combine(psbts) {
  const self = psbts[0];
  const selfKeyVals = parser_1.psbtToKeyVals(self);
  const others = psbts.slice(1);
  if (others.length === 0) throw new Error('Combine: Nothing to combine');
  const selfTx = getTx(self);
  if (selfTx === undefined) {
    throw new Error('Combine: Self missing transaction');
  }
  const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);
  const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);
  const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);
  for (const other of others) {
    const otherTx = getTx(other);
    if (
      otherTx === undefined ||
      !otherTx.toBuffer().equals(selfTx.toBuffer())
    ) {
      throw new Error(
        'Combine: One of the Psbts does not have the same transaction.',
      );
    }
    const otherKeyVals = parser_1.psbtToKeyVals(other);
    const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);
    otherGlobalSet.forEach(
      keyPusher(
        selfGlobalSet,
        selfKeyVals.globalKeyVals,
        otherKeyVals.globalKeyVals,
      ),
    );
    const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);
    otherInputSets.forEach((inputSet, idx) =>
      inputSet.forEach(
        keyPusher(
          selfInputSets[idx],
          selfKeyVals.inputKeyVals[idx],
          otherKeyVals.inputKeyVals[idx],
        ),
      ),
    );
    const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);
    otherOutputSets.forEach((outputSet, idx) =>
      outputSet.forEach(
        keyPusher(
          selfOutputSets[idx],
          selfKeyVals.outputKeyVals[idx],
          otherKeyVals.outputKeyVals[idx],
        ),
      ),
    );
  }
  return parser_1.psbtFromKeyVals(selfTx, {
    globalMapKeyVals: selfKeyVals.globalKeyVals,
    inputKeyVals: selfKeyVals.inputKeyVals,
    outputKeyVals: selfKeyVals.outputKeyVals,
  });
}
exports.combine = combine;
function keyPusher(selfSet, selfKeyVals, otherKeyVals) {
  return key => {
    if (selfSet.has(key)) return;
    const newKv = otherKeyVals.filter(kv => kv.key.toString('hex') === key)[0];
    selfKeyVals.push(newKv);
    selfSet.add(key);
  };
}
function getTx(psbt) {
  return psbt.globalMap.unsignedTx;
}
function getKeySet(keyVals) {
  const set = new Set();
  keyVals.forEach(keyVal => {
    const hex = keyVal.key.toString('hex');
    if (set.has(hex))
      throw new Error('Combine: KeyValue Map keys should be unique');
    set.add(hex);
  });
  return set;
}


/***/ }),

/***/ 44041:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(1847);
const range = n => [...Array(n).keys()];
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {
    throw new Error(
      'Decode Error: could not decode globalXpub with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {
    throw new Error(
      'Decode Error: globalXpub has invalid extended pubkey in key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if ((keyVal.value.length / 4) % 1 !== 0) {
    throw new Error(
      'Decode Error: Global GLOBAL_XPUB value length should be multiple of 4',
    );
  }
  const extendedPubkey = keyVal.key.slice(1);
  const data = {
    masterFingerprint: keyVal.value.slice(0, 4),
    extendedPubkey,
    path: 'm',
  };
  for (const i of range(keyVal.value.length / 4 - 1)) {
    const val = keyVal.value.readUInt32LE(i * 4 + 4);
    const isHard = !!(val & 0x80000000);
    const idx = val & 0x7fffffff;
    data.path += '/' + idx.toString(10) + (isHard ? "'" : '');
  }
  return data;
}
exports.decode = decode;
function encode(data) {
  const head = Buffer.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);
  const key = Buffer.concat([head, data.extendedPubkey]);
  const splitPath = data.path.split('/');
  const value = Buffer.allocUnsafe(splitPath.length * 4);
  data.masterFingerprint.copy(value, 0);
  let offset = 4;
  splitPath.slice(1).forEach(level => {
    const isHard = level.slice(-1) === "'";
    let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);
    if (isHard) num += 0x80000000;
    value.writeUInt32LE(num, offset);
    offset += 4;
  });
  return {
    key,
    value,
  };
}
exports.encode = encode;
exports.expected =
  '{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }';
function check(data) {
  const epk = data.extendedPubkey;
  const mfp = data.masterFingerprint;
  const p = data.path;
  return (
    Buffer.isBuffer(epk) &&
    epk.length === 78 &&
    [2, 3].indexOf(epk[45]) > -1 &&
    Buffer.isBuffer(mfp) &&
    mfp.length === 4 &&
    typeof p === 'string' &&
    !!p.match(/^m(\/\d+'?)*$/)
  );
}
exports.check = check;
function canAddToArray(array, item, dupeSet) {
  const dupeString = item.extendedPubkey.toString('hex');
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return (
    array.filter(v => v.extendedPubkey.equals(item.extendedPubkey)).length === 0
  );
}
exports.canAddToArray = canAddToArray;


/***/ }),

/***/ 74480:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(1847);
function encode(data) {
  return {
    key: Buffer.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),
    value: data.toBuffer(),
  };
}
exports.encode = encode;


/***/ }),

/***/ 71528:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(1847);
const globalXpub = __webpack_require__(44041);
const unsignedTx = __webpack_require__(74480);
const finalScriptSig = __webpack_require__(20859);
const finalScriptWitness = __webpack_require__(8248);
const nonWitnessUtxo = __webpack_require__(70537);
const partialSig = __webpack_require__(61511);
const porCommitment = __webpack_require__(65896);
const sighashType = __webpack_require__(91243);
const tapKeySig = __webpack_require__(3530);
const tapLeafScript = __webpack_require__(49265);
const tapMerkleRoot = __webpack_require__(23934);
const tapScriptSig = __webpack_require__(50602);
const witnessUtxo = __webpack_require__(82954);
const tapTree = __webpack_require__(6036);
const bip32Derivation = __webpack_require__(44799);
const checkPubkey = __webpack_require__(99595);
const redeemScript = __webpack_require__(9705);
const tapBip32Derivation = __webpack_require__(17196);
const tapInternalKey = __webpack_require__(29375);
const witnessScript = __webpack_require__(66327);
const globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: checkPubkey.makeChecker([]),
};
exports.globals = globals;
const inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1.InputTypes.BIP32_DERIVATION,
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1.InputTypes.REDEEM_SCRIPT,
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1.InputTypes.WITNESS_SCRIPT,
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1.InputTypes.PARTIAL_SIG,
    typeFields_1.InputTypes.BIP32_DERIVATION,
  ]),
  tapKeySig,
  tapScriptSig,
  tapLeafScript,
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1.InputTypes.TAP_BIP32_DERIVATION,
  ),
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1.InputTypes.TAP_INTERNAL_KEY,
  ),
  tapMerkleRoot,
};
exports.inputs = inputs;
const outputs = {
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1.OutputTypes.BIP32_DERIVATION,
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1.OutputTypes.REDEEM_SCRIPT,
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1.OutputTypes.WITNESS_SCRIPT,
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1.OutputTypes.BIP32_DERIVATION,
  ]),
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1.OutputTypes.TAP_BIP32_DERIVATION,
  ),
  tapTree,
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1.OutputTypes.TAP_INTERNAL_KEY,
  ),
};
exports.outputs = outputs;


/***/ }),

/***/ 20859:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(1847);
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {
    throw new Error(
      'Decode Error: could not decode finalScriptSig with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(data) {
  const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);
  return {
    key,
    value: data,
  };
}
exports.encode = encode;
exports.expected = 'Buffer';
function check(data) {
  return Buffer.isBuffer(data);
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.finalScriptSig === undefined;
}
exports.canAdd = canAdd;


/***/ }),

/***/ 8248:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(1847);
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {
    throw new Error(
      'Decode Error: could not decode finalScriptWitness with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(data) {
  const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);
  return {
    key,
    value: data,
  };
}
exports.encode = encode;
exports.expected = 'Buffer';
function check(data) {
  return Buffer.isBuffer(data);
}
exports.check = check;
function canAdd(currentData, newData) {
  return (
    !!currentData && !!newData && currentData.finalScriptWitness === undefined
  );
}
exports.canAdd = canAdd;


/***/ }),

/***/ 70537:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(1847);
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {
    throw new Error(
      'Decode Error: could not decode nonWitnessUtxo with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(data) {
  return {
    key: Buffer.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),
    value: data,
  };
}
exports.encode = encode;
exports.expected = 'Buffer';
function check(data) {
  return Buffer.isBuffer(data);
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.nonWitnessUtxo === undefined;
}
exports.canAdd = canAdd;


/***/ }),

/***/ 61511:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(1847);
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {
    throw new Error(
      'Decode Error: could not decode partialSig with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (
    !(keyVal.key.length === 34 || keyVal.key.length === 66) ||
    ![2, 3, 4].includes(keyVal.key[1])
  ) {
    throw new Error(
      'Decode Error: partialSig has invalid pubkey in key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  const pubkey = keyVal.key.slice(1);
  return {
    pubkey,
    signature: keyVal.value,
  };
}
exports.decode = decode;
function encode(pSig) {
  const head = Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);
  return {
    key: Buffer.concat([head, pSig.pubkey]),
    value: pSig.signature,
  };
}
exports.encode = encode;
exports.expected = '{ pubkey: Buffer; signature: Buffer; }';
function check(data) {
  return (
    Buffer.isBuffer(data.pubkey) &&
    Buffer.isBuffer(data.signature) &&
    [33, 65].includes(data.pubkey.length) &&
    [2, 3, 4].includes(data.pubkey[0]) &&
    isDerSigWithSighash(data.signature)
  );
}
exports.check = check;
function isDerSigWithSighash(buf) {
  if (!Buffer.isBuffer(buf) || buf.length < 9) return false;
  if (buf[0] !== 0x30) return false;
  if (buf.length !== buf[1] + 3) return false;
  if (buf[2] !== 0x02) return false;
  const rLen = buf[3];
  if (rLen > 33 || rLen < 1) return false;
  if (buf[3 + rLen + 1] !== 0x02) return false;
  const sLen = buf[3 + rLen + 2];
  if (sLen > 33 || sLen < 1) return false;
  if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;
  return true;
}
function canAddToArray(array, item, dupeSet) {
  const dupeString = item.pubkey.toString('hex');
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;
}
exports.canAddToArray = canAddToArray;


/***/ }),

/***/ 65896:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(1847);
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {
    throw new Error(
      'Decode Error: could not decode porCommitment with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value.toString('utf8');
}
exports.decode = decode;
function encode(data) {
  const key = Buffer.from([typeFields_1.InputTypes.POR_COMMITMENT]);
  return {
    key,
    value: Buffer.from(data, 'utf8'),
  };
}
exports.encode = encode;
exports.expected = 'string';
function check(data) {
  return typeof data === 'string';
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.porCommitment === undefined;
}
exports.canAdd = canAdd;


/***/ }),

/***/ 91243:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(1847);
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {
    throw new Error(
      'Decode Error: could not decode sighashType with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  return keyVal.value.readUInt32LE(0);
}
exports.decode = decode;
function encode(data) {
  const key = Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);
  const value = Buffer.allocUnsafe(4);
  value.writeUInt32LE(data, 0);
  return {
    key,
    value,
  };
}
exports.encode = encode;
exports.expected = 'number';
function check(data) {
  return typeof data === 'number';
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.sighashType === undefined;
}
exports.canAdd = canAdd;


/***/ }),

/***/ 3530:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(1847);
function decode(keyVal) {
  if (
    keyVal.key[0] !== typeFields_1.InputTypes.TAP_KEY_SIG ||
    keyVal.key.length !== 1
  ) {
    throw new Error(
      'Decode Error: could not decode tapKeySig with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (!check(keyVal.value)) {
    throw new Error(
      'Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature',
    );
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(value) {
  const key = Buffer.from([typeFields_1.InputTypes.TAP_KEY_SIG]);
  return { key, value };
}
exports.encode = encode;
exports.expected = 'Buffer';
function check(data) {
  return Buffer.isBuffer(data) && (data.length === 64 || data.length === 65);
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.tapKeySig === undefined;
}
exports.canAdd = canAdd;


/***/ }),

/***/ 49265:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(1847);
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_LEAF_SCRIPT) {
    throw new Error(
      'Decode Error: could not decode tapLeafScript with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if ((keyVal.key.length - 2) % 32 !== 0) {
    throw new Error(
      'Decode Error: tapLeafScript has invalid control block in key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  const leafVersion = keyVal.value[keyVal.value.length - 1];
  if ((keyVal.key[1] & 0xfe) !== leafVersion) {
    throw new Error(
      'Decode Error: tapLeafScript bad leaf version in key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  const script = keyVal.value.slice(0, -1);
  const controlBlock = keyVal.key.slice(1);
  return { controlBlock, script, leafVersion };
}
exports.decode = decode;
function encode(tScript) {
  const head = Buffer.from([typeFields_1.InputTypes.TAP_LEAF_SCRIPT]);
  const verBuf = Buffer.from([tScript.leafVersion]);
  return {
    key: Buffer.concat([head, tScript.controlBlock]),
    value: Buffer.concat([tScript.script, verBuf]),
  };
}
exports.encode = encode;
exports.expected =
  '{ controlBlock: Buffer; leafVersion: number, script: Buffer; }';
function check(data) {
  return (
    Buffer.isBuffer(data.controlBlock) &&
    (data.controlBlock.length - 1) % 32 === 0 &&
    (data.controlBlock[0] & 0xfe) === data.leafVersion &&
    Buffer.isBuffer(data.script)
  );
}
exports.check = check;
function canAddToArray(array, item, dupeSet) {
  const dupeString = item.controlBlock.toString('hex');
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return (
    array.filter(v => v.controlBlock.equals(item.controlBlock)).length === 0
  );
}
exports.canAddToArray = canAddToArray;


/***/ }),

/***/ 23934:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(1847);
function decode(keyVal) {
  if (
    keyVal.key[0] !== typeFields_1.InputTypes.TAP_MERKLE_ROOT ||
    keyVal.key.length !== 1
  ) {
    throw new Error(
      'Decode Error: could not decode tapMerkleRoot with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (!check(keyVal.value)) {
    throw new Error('Decode Error: tapMerkleRoot not a 32-byte hash');
  }
  return keyVal.value;
}
exports.decode = decode;
function encode(value) {
  const key = Buffer.from([typeFields_1.InputTypes.TAP_MERKLE_ROOT]);
  return { key, value };
}
exports.encode = encode;
exports.expected = 'Buffer';
function check(data) {
  return Buffer.isBuffer(data) && data.length === 32;
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.tapMerkleRoot === undefined;
}
exports.canAdd = canAdd;


/***/ }),

/***/ 50602:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(1847);
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_SCRIPT_SIG) {
    throw new Error(
      'Decode Error: could not decode tapScriptSig with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (keyVal.key.length !== 65) {
    throw new Error(
      'Decode Error: tapScriptSig has invalid key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {
    throw new Error(
      'Decode Error: tapScriptSig has invalid signature in key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  const pubkey = keyVal.key.slice(1, 33);
  const leafHash = keyVal.key.slice(33);
  return {
    pubkey,
    leafHash,
    signature: keyVal.value,
  };
}
exports.decode = decode;
function encode(tSig) {
  const head = Buffer.from([typeFields_1.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: Buffer.concat([head, tSig.pubkey, tSig.leafHash]),
    value: tSig.signature,
  };
}
exports.encode = encode;
exports.expected = '{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }';
function check(data) {
  return (
    Buffer.isBuffer(data.pubkey) &&
    Buffer.isBuffer(data.leafHash) &&
    Buffer.isBuffer(data.signature) &&
    data.pubkey.length === 32 &&
    data.leafHash.length === 32 &&
    (data.signature.length === 64 || data.signature.length === 65)
  );
}
exports.check = check;
function canAddToArray(array, item, dupeSet) {
  const dupeString =
    item.pubkey.toString('hex') + item.leafHash.toString('hex');
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return (
    array.filter(
      v => v.pubkey.equals(item.pubkey) && v.leafHash.equals(item.leafHash),
    ).length === 0
  );
}
exports.canAddToArray = canAddToArray;


/***/ }),

/***/ 82954:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(1847);
const tools_1 = __webpack_require__(19254);
const varuint = __webpack_require__(3493);
function decode(keyVal) {
  if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {
    throw new Error(
      'Decode Error: could not decode witnessUtxo with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  const value = tools_1.readUInt64LE(keyVal.value, 0);
  let _offset = 8;
  const scriptLen = varuint.decode(keyVal.value, _offset);
  _offset += varuint.encodingLength(scriptLen);
  const script = keyVal.value.slice(_offset);
  if (script.length !== scriptLen) {
    throw new Error('Decode Error: WITNESS_UTXO script is not proper length');
  }
  return {
    script,
    value,
  };
}
exports.decode = decode;
function encode(data) {
  const { script, value } = data;
  const varintLen = varuint.encodingLength(script.length);
  const result = Buffer.allocUnsafe(8 + varintLen + script.length);
  tools_1.writeUInt64LE(result, value, 0);
  varuint.encode(script.length, result, 8);
  script.copy(result, 8 + varintLen);
  return {
    key: Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),
    value: result,
  };
}
exports.encode = encode;
exports.expected = '{ script: Buffer; value: number; }';
function check(data) {
  return Buffer.isBuffer(data.script) && typeof data.value === 'number';
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.witnessUtxo === undefined;
}
exports.canAdd = canAdd;


/***/ }),

/***/ 6036:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const typeFields_1 = __webpack_require__(1847);
const varuint = __webpack_require__(3493);
function decode(keyVal) {
  if (
    keyVal.key[0] !== typeFields_1.OutputTypes.TAP_TREE ||
    keyVal.key.length !== 1
  ) {
    throw new Error(
      'Decode Error: could not decode tapTree with key 0x' +
        keyVal.key.toString('hex'),
    );
  }
  let _offset = 0;
  const data = [];
  while (_offset < keyVal.value.length) {
    const depth = keyVal.value[_offset++];
    const leafVersion = keyVal.value[_offset++];
    const scriptLen = varuint.decode(keyVal.value, _offset);
    _offset += varuint.encodingLength(scriptLen);
    data.push({
      depth,
      leafVersion,
      script: keyVal.value.slice(_offset, _offset + scriptLen),
    });
    _offset += scriptLen;
  }
  return { leaves: data };
}
exports.decode = decode;
function encode(tree) {
  const key = Buffer.from([typeFields_1.OutputTypes.TAP_TREE]);
  const bufs = [].concat(
    ...tree.leaves.map(tapLeaf => [
      Buffer.of(tapLeaf.depth, tapLeaf.leafVersion),
      varuint.encode(tapLeaf.script.length),
      tapLeaf.script,
    ]),
  );
  return {
    key,
    value: Buffer.concat(bufs),
  };
}
exports.encode = encode;
exports.expected =
  '{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }';
function check(data) {
  return (
    Array.isArray(data.leaves) &&
    data.leaves.every(
      tapLeaf =>
        tapLeaf.depth >= 0 &&
        tapLeaf.depth <= 128 &&
        (tapLeaf.leafVersion & 0xfe) === tapLeaf.leafVersion &&
        Buffer.isBuffer(tapLeaf.script),
    )
  );
}
exports.check = check;
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.tapTree === undefined;
}
exports.canAdd = canAdd;


/***/ }),

/***/ 44799:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const range = n => [...Array(n).keys()];
const isValidDERKey = pubkey =>
  (pubkey.length === 33 && [2, 3].includes(pubkey[0])) ||
  (pubkey.length === 65 && 4 === pubkey[0]);
function makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        'Decode Error: could not decode bip32Derivation with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    const pubkey = keyVal.key.slice(1);
    if (!isValidPubkey(pubkey)) {
      throw new Error(
        'Decode Error: bip32Derivation has invalid pubkey in key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    if ((keyVal.value.length / 4) % 1 !== 0) {
      throw new Error(
        'Decode Error: Input BIP32_DERIVATION value length should be multiple of 4',
      );
    }
    const data = {
      masterFingerprint: keyVal.value.slice(0, 4),
      pubkey,
      path: 'm',
    };
    for (const i of range(keyVal.value.length / 4 - 1)) {
      const val = keyVal.value.readUInt32LE(i * 4 + 4);
      const isHard = !!(val & 0x80000000);
      const idx = val & 0x7fffffff;
      data.path += '/' + idx.toString(10) + (isHard ? "'" : '');
    }
    return data;
  }
  function encode(data) {
    const head = Buffer.from([TYPE_BYTE]);
    const key = Buffer.concat([head, data.pubkey]);
    const splitPath = data.path.split('/');
    const value = Buffer.allocUnsafe(splitPath.length * 4);
    data.masterFingerprint.copy(value, 0);
    let offset = 4;
    splitPath.slice(1).forEach(level => {
      const isHard = level.slice(-1) === "'";
      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);
      if (isHard) num += 0x80000000;
      value.writeUInt32LE(num, offset);
      offset += 4;
    });
    return {
      key,
      value,
    };
  }
  const expected =
    '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }';
  function check(data) {
    return (
      Buffer.isBuffer(data.pubkey) &&
      Buffer.isBuffer(data.masterFingerprint) &&
      typeof data.path === 'string' &&
      isValidPubkey(data.pubkey) &&
      data.masterFingerprint.length === 4
    );
  }
  function canAddToArray(array, item, dupeSet) {
    const dupeString = item.pubkey.toString('hex');
    if (dupeSet.has(dupeString)) return false;
    dupeSet.add(dupeString);
    return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAddToArray,
  };
}
exports.makeConverter = makeConverter;


/***/ }),

/***/ 99595:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function makeChecker(pubkeyTypes) {
  return checkPubkey;
  function checkPubkey(keyVal) {
    let pubkey;
    if (pubkeyTypes.includes(keyVal.key[0])) {
      pubkey = keyVal.key.slice(1);
      if (
        !(pubkey.length === 33 || pubkey.length === 65) ||
        ![2, 3, 4].includes(pubkey[0])
      ) {
        throw new Error(
          'Format Error: invalid pubkey in key 0x' + keyVal.key.toString('hex'),
        );
      }
    }
    return pubkey;
  }
}
exports.makeChecker = makeChecker;


/***/ }),

/***/ 9705:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
function makeConverter(TYPE_BYTE) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        'Decode Error: could not decode redeemScript with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    return keyVal.value;
  }
  function encode(data) {
    const key = Buffer.from([TYPE_BYTE]);
    return {
      key,
      value: data,
    };
  }
  const expected = 'Buffer';
  function check(data) {
    return Buffer.isBuffer(data);
  }
  function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.redeemScript === undefined;
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAdd,
  };
}
exports.makeConverter = makeConverter;


/***/ }),

/***/ 17196:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const varuint = __webpack_require__(3493);
const bip32Derivation = __webpack_require__(44799);
const isValidBIP340Key = pubkey => pubkey.length === 32;
function makeConverter(TYPE_BYTE) {
  const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);
  function decode(keyVal) {
    const nHashes = varuint.decode(keyVal.value);
    const nHashesLen = varuint.encodingLength(nHashes);
    const base = parent.decode({
      key: keyVal.key,
      value: keyVal.value.slice(nHashesLen + nHashes * 32),
    });
    const leafHashes = new Array(nHashes);
    for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {
      leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);
    }
    return Object.assign({}, base, { leafHashes });
  }
  function encode(data) {
    const base = parent.encode(data);
    const nHashesLen = varuint.encodingLength(data.leafHashes.length);
    const nHashesBuf = Buffer.allocUnsafe(nHashesLen);
    varuint.encode(data.leafHashes.length, nHashesBuf);
    const value = Buffer.concat([nHashesBuf, ...data.leafHashes, base.value]);
    return Object.assign({}, base, { value });
  }
  const expected =
    '{ ' +
    'masterFingerprint: Buffer; ' +
    'pubkey: Buffer; ' +
    'path: string; ' +
    'leafHashes: Buffer[]; ' +
    '}';
  function check(data) {
    return (
      Array.isArray(data.leafHashes) &&
      data.leafHashes.every(
        leafHash => Buffer.isBuffer(leafHash) && leafHash.length === 32,
      ) &&
      parent.check(data)
    );
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAddToArray: parent.canAddToArray,
  };
}
exports.makeConverter = makeConverter;


/***/ }),

/***/ 29375:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
function makeConverter(TYPE_BYTE) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {
      throw new Error(
        'Decode Error: could not decode tapInternalKey with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    if (keyVal.value.length !== 32) {
      throw new Error(
        'Decode Error: tapInternalKey not a 32-byte x-only pubkey',
      );
    }
    return keyVal.value;
  }
  function encode(value) {
    const key = Buffer.from([TYPE_BYTE]);
    return { key, value };
  }
  const expected = 'Buffer';
  function check(data) {
    return Buffer.isBuffer(data) && data.length === 32;
  }
  function canAdd(currentData, newData) {
    return (
      !!currentData && !!newData && currentData.tapInternalKey === undefined
    );
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAdd,
  };
}
exports.makeConverter = makeConverter;


/***/ }),

/***/ 66327:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
function makeConverter(TYPE_BYTE) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        'Decode Error: could not decode witnessScript with key 0x' +
          keyVal.key.toString('hex'),
      );
    }
    return keyVal.value;
  }
  function encode(data) {
    const key = Buffer.from([TYPE_BYTE]);
    return {
      key,
      value: data,
    };
  }
  const expected = 'Buffer';
  function check(data) {
    return Buffer.isBuffer(data);
  }
  function canAdd(currentData, newData) {
    return (
      !!currentData && !!newData && currentData.witnessScript === undefined
    );
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAdd,
  };
}
exports.makeConverter = makeConverter;


/***/ }),

/***/ 19254:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const varuint = __webpack_require__(3493);
exports.range = n => [...Array(n).keys()];
function reverseBuffer(buffer) {
  if (buffer.length < 1) return buffer;
  let j = buffer.length - 1;
  let tmp = 0;
  for (let i = 0; i < buffer.length / 2; i++) {
    tmp = buffer[i];
    buffer[i] = buffer[j];
    buffer[j] = tmp;
    j--;
  }
  return buffer;
}
exports.reverseBuffer = reverseBuffer;
function keyValsToBuffer(keyVals) {
  const buffers = keyVals.map(keyValToBuffer);
  buffers.push(Buffer.from([0]));
  return Buffer.concat(buffers);
}
exports.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(keyVal) {
  const keyLen = keyVal.key.length;
  const valLen = keyVal.value.length;
  const keyVarIntLen = varuint.encodingLength(keyLen);
  const valVarIntLen = varuint.encodingLength(valLen);
  const buffer = Buffer.allocUnsafe(
    keyVarIntLen + keyLen + valVarIntLen + valLen,
  );
  varuint.encode(keyLen, buffer, 0);
  keyVal.key.copy(buffer, keyVarIntLen);
  varuint.encode(valLen, buffer, keyVarIntLen + keyLen);
  keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);
  return buffer;
}
exports.keyValToBuffer = keyValToBuffer;
// https://github.com/feross/buffer/blob/master/index.js#L1127
function verifuint(value, max) {
  if (typeof value !== 'number')
    throw new Error('cannot write a non-number as a number');
  if (value < 0)
    throw new Error('specified a negative value for writing an unsigned value');
  if (value > max) throw new Error('RangeError: value out of range');
  if (Math.floor(value) !== value)
    throw new Error('value has a fractional component');
}
function readUInt64LE(buffer, offset) {
  const a = buffer.readUInt32LE(offset);
  let b = buffer.readUInt32LE(offset + 4);
  b *= 0x100000000;
  verifuint(b + a, 0x001fffffffffffff);
  return b + a;
}
exports.readUInt64LE = readUInt64LE;
function writeUInt64LE(buffer, value, offset) {
  verifuint(value, 0x001fffffffffffff);
  buffer.writeInt32LE(value & -1, offset);
  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);
  return offset + 8;
}
exports.writeUInt64LE = writeUInt64LE;


/***/ }),

/***/ 3493:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Number.MAX_SAFE_INTEGER
const MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(n) {
  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)
    throw new RangeError('value out of range');
}
function encode(_number, buffer, offset) {
  checkUInt53(_number);
  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(_number));
  if (!Buffer.isBuffer(buffer))
    throw new TypeError('buffer must be a Buffer instance');
  if (!offset) offset = 0;
  // 8 bit
  if (_number < 0xfd) {
    buffer.writeUInt8(_number, offset);
    Object.assign(encode, { bytes: 1 });
    // 16 bit
  } else if (_number <= 0xffff) {
    buffer.writeUInt8(0xfd, offset);
    buffer.writeUInt16LE(_number, offset + 1);
    Object.assign(encode, { bytes: 3 });
    // 32 bit
  } else if (_number <= 0xffffffff) {
    buffer.writeUInt8(0xfe, offset);
    buffer.writeUInt32LE(_number, offset + 1);
    Object.assign(encode, { bytes: 5 });
    // 64 bit
  } else {
    buffer.writeUInt8(0xff, offset);
    buffer.writeUInt32LE(_number >>> 0, offset + 1);
    buffer.writeUInt32LE((_number / 0x100000000) | 0, offset + 5);
    Object.assign(encode, { bytes: 9 });
  }
  return buffer;
}
exports.encode = encode;
function decode(buffer, offset) {
  if (!Buffer.isBuffer(buffer))
    throw new TypeError('buffer must be a Buffer instance');
  if (!offset) offset = 0;
  const first = buffer.readUInt8(offset);
  // 8 bit
  if (first < 0xfd) {
    Object.assign(decode, { bytes: 1 });
    return first;
    // 16 bit
  } else if (first === 0xfd) {
    Object.assign(decode, { bytes: 3 });
    return buffer.readUInt16LE(offset + 1);
    // 32 bit
  } else if (first === 0xfe) {
    Object.assign(decode, { bytes: 5 });
    return buffer.readUInt32LE(offset + 1);
    // 64 bit
  } else {
    Object.assign(decode, { bytes: 9 });
    const lo = buffer.readUInt32LE(offset + 1);
    const hi = buffer.readUInt32LE(offset + 5);
    const _number = hi * 0x0100000000 + lo;
    checkUInt53(_number);
    return _number;
  }
}
exports.decode = decode;
function encodingLength(_number) {
  checkUInt53(_number);
  return _number < 0xfd
    ? 1
    : _number <= 0xffff
    ? 3
    : _number <= 0xffffffff
    ? 5
    : 9;
}
exports.encodingLength = encodingLength;


/***/ }),

/***/ 12974:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const convert = __webpack_require__(71528);
const tools_1 = __webpack_require__(19254);
const varuint = __webpack_require__(3493);
const typeFields_1 = __webpack_require__(1847);
function psbtFromBuffer(buffer, txGetter) {
  let offset = 0;
  function varSlice() {
    const keyLen = varuint.decode(buffer, offset);
    offset += varuint.encodingLength(keyLen);
    const key = buffer.slice(offset, offset + keyLen);
    offset += keyLen;
    return key;
  }
  function readUInt32BE() {
    const num = buffer.readUInt32BE(offset);
    offset += 4;
    return num;
  }
  function readUInt8() {
    const num = buffer.readUInt8(offset);
    offset += 1;
    return num;
  }
  function getKeyValue() {
    const key = varSlice();
    const value = varSlice();
    return {
      key,
      value,
    };
  }
  function checkEndOfKeyValPairs() {
    if (offset >= buffer.length) {
      throw new Error('Format Error: Unexpected End of PSBT');
    }
    const isEnd = buffer.readUInt8(offset) === 0;
    if (isEnd) {
      offset++;
    }
    return isEnd;
  }
  if (readUInt32BE() !== 0x70736274) {
    throw new Error('Format Error: Invalid Magic Number');
  }
  if (readUInt8() !== 0xff) {
    throw new Error(
      'Format Error: Magic Number must be followed by 0xff separator',
    );
  }
  const globalMapKeyVals = [];
  const globalKeyIndex = {};
  while (!checkEndOfKeyValPairs()) {
    const keyVal = getKeyValue();
    const hexKey = keyVal.key.toString('hex');
    if (globalKeyIndex[hexKey]) {
      throw new Error(
        'Format Error: Keys must be unique for global keymap: key ' + hexKey,
      );
    }
    globalKeyIndex[hexKey] = 1;
    globalMapKeyVals.push(keyVal);
  }
  const unsignedTxMaps = globalMapKeyVals.filter(
    keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX,
  );
  if (unsignedTxMaps.length !== 1) {
    throw new Error('Format Error: Only one UNSIGNED_TX allowed');
  }
  const unsignedTx = txGetter(unsignedTxMaps[0].value);
  // Get input and output counts to loop the respective fields
  const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();
  const inputKeyVals = [];
  const outputKeyVals = [];
  // Get input fields
  for (const index of tools_1.range(inputCount)) {
    const inputKeyIndex = {};
    const input = [];
    while (!checkEndOfKeyValPairs()) {
      const keyVal = getKeyValue();
      const hexKey = keyVal.key.toString('hex');
      if (inputKeyIndex[hexKey]) {
        throw new Error(
          'Format Error: Keys must be unique for each input: ' +
            'input index ' +
            index +
            ' key ' +
            hexKey,
        );
      }
      inputKeyIndex[hexKey] = 1;
      input.push(keyVal);
    }
    inputKeyVals.push(input);
  }
  for (const index of tools_1.range(outputCount)) {
    const outputKeyIndex = {};
    const output = [];
    while (!checkEndOfKeyValPairs()) {
      const keyVal = getKeyValue();
      const hexKey = keyVal.key.toString('hex');
      if (outputKeyIndex[hexKey]) {
        throw new Error(
          'Format Error: Keys must be unique for each output: ' +
            'output index ' +
            index +
            ' key ' +
            hexKey,
        );
      }
      outputKeyIndex[hexKey] = 1;
      output.push(keyVal);
    }
    outputKeyVals.push(output);
  }
  return psbtFromKeyVals(unsignedTx, {
    globalMapKeyVals,
    inputKeyVals,
    outputKeyVals,
  });
}
exports.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(type, keyBuf, keyNum) {
  if (!keyBuf.equals(Buffer.from([keyNum]))) {
    throw new Error(
      `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
    );
  }
}
exports.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(
  unsignedTx,
  { globalMapKeyVals, inputKeyVals, outputKeyVals },
) {
  // That was easy :-)
  const globalMap = {
    unsignedTx,
  };
  let txCount = 0;
  for (const keyVal of globalMapKeyVals) {
    // If a globalMap item needs pubkey, uncomment
    // const pubkey = convert.globals.checkPubkey(keyVal);
    switch (keyVal.key[0]) {
      case typeFields_1.GlobalTypes.UNSIGNED_TX:
        checkKeyBuffer(
          'global',
          keyVal.key,
          typeFields_1.GlobalTypes.UNSIGNED_TX,
        );
        if (txCount > 0) {
          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');
        }
        txCount++;
        break;
      case typeFields_1.GlobalTypes.GLOBAL_XPUB:
        if (globalMap.globalXpub === undefined) {
          globalMap.globalXpub = [];
        }
        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));
        break;
      default:
        // This will allow inclusion during serialization.
        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];
        globalMap.unknownKeyVals.push(keyVal);
    }
  }
  // Get input and output counts to loop the respective fields
  const inputCount = inputKeyVals.length;
  const outputCount = outputKeyVals.length;
  const inputs = [];
  const outputs = [];
  // Get input fields
  for (const index of tools_1.range(inputCount)) {
    const input = {};
    for (const keyVal of inputKeyVals[index]) {
      convert.inputs.checkPubkey(keyVal);
      switch (keyVal.key[0]) {
        case typeFields_1.InputTypes.NON_WITNESS_UTXO:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.NON_WITNESS_UTXO,
          );
          if (input.nonWitnessUtxo !== undefined) {
            throw new Error(
              'Format Error: Input has multiple NON_WITNESS_UTXO',
            );
          }
          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);
          break;
        case typeFields_1.InputTypes.WITNESS_UTXO:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.WITNESS_UTXO,
          );
          if (input.witnessUtxo !== undefined) {
            throw new Error('Format Error: Input has multiple WITNESS_UTXO');
          }
          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);
          break;
        case typeFields_1.InputTypes.PARTIAL_SIG:
          if (input.partialSig === undefined) {
            input.partialSig = [];
          }
          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));
          break;
        case typeFields_1.InputTypes.SIGHASH_TYPE:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.SIGHASH_TYPE,
          );
          if (input.sighashType !== undefined) {
            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');
          }
          input.sighashType = convert.inputs.sighashType.decode(keyVal);
          break;
        case typeFields_1.InputTypes.REDEEM_SCRIPT:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.REDEEM_SCRIPT,
          );
          if (input.redeemScript !== undefined) {
            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');
          }
          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);
          break;
        case typeFields_1.InputTypes.WITNESS_SCRIPT:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.WITNESS_SCRIPT,
          );
          if (input.witnessScript !== undefined) {
            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');
          }
          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);
          break;
        case typeFields_1.InputTypes.BIP32_DERIVATION:
          if (input.bip32Derivation === undefined) {
            input.bip32Derivation = [];
          }
          input.bip32Derivation.push(
            convert.inputs.bip32Derivation.decode(keyVal),
          );
          break;
        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.FINAL_SCRIPTSIG,
          );
          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);
          break;
        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.FINAL_SCRIPTWITNESS,
          );
          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(
            keyVal,
          );
          break;
        case typeFields_1.InputTypes.POR_COMMITMENT:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.POR_COMMITMENT,
          );
          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);
          break;
        case typeFields_1.InputTypes.TAP_KEY_SIG:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.TAP_KEY_SIG,
          );
          input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);
          break;
        case typeFields_1.InputTypes.TAP_SCRIPT_SIG:
          if (input.tapScriptSig === undefined) {
            input.tapScriptSig = [];
          }
          input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));
          break;
        case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:
          if (input.tapLeafScript === undefined) {
            input.tapLeafScript = [];
          }
          input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));
          break;
        case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:
          if (input.tapBip32Derivation === undefined) {
            input.tapBip32Derivation = [];
          }
          input.tapBip32Derivation.push(
            convert.inputs.tapBip32Derivation.decode(keyVal),
          );
          break;
        case typeFields_1.InputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.TAP_INTERNAL_KEY,
          );
          input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);
          break;
        case typeFields_1.InputTypes.TAP_MERKLE_ROOT:
          checkKeyBuffer(
            'input',
            keyVal.key,
            typeFields_1.InputTypes.TAP_MERKLE_ROOT,
          );
          input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);
          break;
        default:
          // This will allow inclusion during serialization.
          if (!input.unknownKeyVals) input.unknownKeyVals = [];
          input.unknownKeyVals.push(keyVal);
      }
    }
    inputs.push(input);
  }
  for (const index of tools_1.range(outputCount)) {
    const output = {};
    for (const keyVal of outputKeyVals[index]) {
      convert.outputs.checkPubkey(keyVal);
      switch (keyVal.key[0]) {
        case typeFields_1.OutputTypes.REDEEM_SCRIPT:
          checkKeyBuffer(
            'output',
            keyVal.key,
            typeFields_1.OutputTypes.REDEEM_SCRIPT,
          );
          if (output.redeemScript !== undefined) {
            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');
          }
          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);
          break;
        case typeFields_1.OutputTypes.WITNESS_SCRIPT:
          checkKeyBuffer(
            'output',
            keyVal.key,
            typeFields_1.OutputTypes.WITNESS_SCRIPT,
          );
          if (output.witnessScript !== undefined) {
            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');
          }
          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);
          break;
        case typeFields_1.OutputTypes.BIP32_DERIVATION:
          if (output.bip32Derivation === undefined) {
            output.bip32Derivation = [];
          }
          output.bip32Derivation.push(
            convert.outputs.bip32Derivation.decode(keyVal),
          );
          break;
        case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            'output',
            keyVal.key,
            typeFields_1.OutputTypes.TAP_INTERNAL_KEY,
          );
          output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);
          break;
        case typeFields_1.OutputTypes.TAP_TREE:
          checkKeyBuffer(
            'output',
            keyVal.key,
            typeFields_1.OutputTypes.TAP_TREE,
          );
          output.tapTree = convert.outputs.tapTree.decode(keyVal);
          break;
        case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:
          if (output.tapBip32Derivation === undefined) {
            output.tapBip32Derivation = [];
          }
          output.tapBip32Derivation.push(
            convert.outputs.tapBip32Derivation.decode(keyVal),
          );
          break;
        default:
          if (!output.unknownKeyVals) output.unknownKeyVals = [];
          output.unknownKeyVals.push(keyVal);
      }
    }
    outputs.push(output);
  }
  return { globalMap, inputs, outputs };
}
exports.psbtFromKeyVals = psbtFromKeyVals;


/***/ }),

/***/ 36574:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(12974));
__export(__webpack_require__(15312));


/***/ }),

/***/ 15312:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const convert = __webpack_require__(71528);
const tools_1 = __webpack_require__(19254);
function psbtToBuffer({ globalMap, inputs, outputs }) {
  const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({
    globalMap,
    inputs,
    outputs,
  });
  const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);
  const keyValsOrEmptyToBuffer = keyVals =>
    keyVals.length === 0
      ? [Buffer.from([0])]
      : keyVals.map(tools_1.keyValsToBuffer);
  const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);
  const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);
  const header = Buffer.allocUnsafe(5);
  header.writeUIntBE(0x70736274ff, 0, 5);
  return Buffer.concat(
    [header, globalBuffer].concat(inputBuffers, outputBuffers),
  );
}
exports.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (a, b) => {
  return a.key.compare(b.key);
};
function keyValsFromMap(keyValMap, converterFactory) {
  const keyHexSet = new Set();
  const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {
    if (key === 'unknownKeyVals') return result;
    // We are checking for undefined anyways. So ignore TS error
    // @ts-ignore
    const converter = converterFactory[key];
    if (converter === undefined) return result;
    const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(
      converter.encode,
    );
    const keyHexes = encodedKeyVals.map(kv => kv.key.toString('hex'));
    keyHexes.forEach(hex => {
      if (keyHexSet.has(hex))
        throw new Error('Serialize Error: Duplicate key: ' + hex);
      keyHexSet.add(hex);
    });
    return result.concat(encodedKeyVals);
  }, []);
  // Get other keyVals that have not yet been gotten
  const otherKeyVals = keyValMap.unknownKeyVals
    ? keyValMap.unknownKeyVals.filter(keyVal => {
        return !keyHexSet.has(keyVal.key.toString('hex'));
      })
    : [];
  return keyVals.concat(otherKeyVals).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap, inputs, outputs }) {
  // First parse the global keyVals
  // Get any extra keyvals to pass along
  return {
    globalKeyVals: keyValsFromMap(globalMap, convert.globals),
    inputKeyVals: inputs.map(i => keyValsFromMap(i, convert.inputs)),
    outputKeyVals: outputs.map(o => keyValsFromMap(o, convert.outputs)),
  };
}
exports.psbtToKeyVals = psbtToKeyVals;


/***/ }),

/***/ 95011:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const combiner_1 = __webpack_require__(82190);
const parser_1 = __webpack_require__(36574);
const typeFields_1 = __webpack_require__(1847);
const utils_1 = __webpack_require__(96403);
class Psbt {
  constructor(tx) {
    this.inputs = [];
    this.outputs = [];
    this.globalMap = {
      unsignedTx: tx,
    };
  }
  static fromBase64(data, txFromBuffer) {
    const buffer = Buffer.from(data, 'base64');
    return this.fromBuffer(buffer, txFromBuffer);
  }
  static fromHex(data, txFromBuffer) {
    const buffer = Buffer.from(data, 'hex');
    return this.fromBuffer(buffer, txFromBuffer);
  }
  static fromBuffer(buffer, txFromBuffer) {
    const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);
    const psbt = new this(results.globalMap.unsignedTx);
    Object.assign(psbt, results);
    return psbt;
  }
  toBase64() {
    const buffer = this.toBuffer();
    return buffer.toString('base64');
  }
  toHex() {
    const buffer = this.toBuffer();
    return buffer.toString('hex');
  }
  toBuffer() {
    return parser_1.psbtToBuffer(this);
  }
  updateGlobal(updateData) {
    utils_1.updateGlobal(updateData, this.globalMap);
    return this;
  }
  updateInput(inputIndex, updateData) {
    const input = utils_1.checkForInput(this.inputs, inputIndex);
    utils_1.updateInput(updateData, input);
    return this;
  }
  updateOutput(outputIndex, updateData) {
    const output = utils_1.checkForOutput(this.outputs, outputIndex);
    utils_1.updateOutput(updateData, output);
    return this;
  }
  addUnknownKeyValToGlobal(keyVal) {
    utils_1.checkHasKey(
      keyVal,
      this.globalMap.unknownKeyVals,
      utils_1.getEnumLength(typeFields_1.GlobalTypes),
    );
    if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];
    this.globalMap.unknownKeyVals.push(keyVal);
    return this;
  }
  addUnknownKeyValToInput(inputIndex, keyVal) {
    const input = utils_1.checkForInput(this.inputs, inputIndex);
    utils_1.checkHasKey(
      keyVal,
      input.unknownKeyVals,
      utils_1.getEnumLength(typeFields_1.InputTypes),
    );
    if (!input.unknownKeyVals) input.unknownKeyVals = [];
    input.unknownKeyVals.push(keyVal);
    return this;
  }
  addUnknownKeyValToOutput(outputIndex, keyVal) {
    const output = utils_1.checkForOutput(this.outputs, outputIndex);
    utils_1.checkHasKey(
      keyVal,
      output.unknownKeyVals,
      utils_1.getEnumLength(typeFields_1.OutputTypes),
    );
    if (!output.unknownKeyVals) output.unknownKeyVals = [];
    output.unknownKeyVals.push(keyVal);
    return this;
  }
  addInput(inputData) {
    this.globalMap.unsignedTx.addInput(inputData);
    this.inputs.push({
      unknownKeyVals: [],
    });
    const addKeyVals = inputData.unknownKeyVals || [];
    const inputIndex = this.inputs.length - 1;
    if (!Array.isArray(addKeyVals)) {
      throw new Error('unknownKeyVals must be an Array');
    }
    addKeyVals.forEach(keyVal =>
      this.addUnknownKeyValToInput(inputIndex, keyVal),
    );
    utils_1.addInputAttributes(this.inputs, inputData);
    return this;
  }
  addOutput(outputData) {
    this.globalMap.unsignedTx.addOutput(outputData);
    this.outputs.push({
      unknownKeyVals: [],
    });
    const addKeyVals = outputData.unknownKeyVals || [];
    const outputIndex = this.outputs.length - 1;
    if (!Array.isArray(addKeyVals)) {
      throw new Error('unknownKeyVals must be an Array');
    }
    addKeyVals.forEach(keyVal =>
      this.addUnknownKeyValToOutput(outputIndex, keyVal),
    );
    utils_1.addOutputAttributes(this.outputs, outputData);
    return this;
  }
  clearFinalizedInput(inputIndex) {
    const input = utils_1.checkForInput(this.inputs, inputIndex);
    utils_1.inputCheckUncleanFinalized(inputIndex, input);
    for (const key of Object.keys(input)) {
      if (
        ![
          'witnessUtxo',
          'nonWitnessUtxo',
          'finalScriptSig',
          'finalScriptWitness',
          'unknownKeyVals',
        ].includes(key)
      ) {
        // @ts-ignore
        delete input[key];
      }
    }
    return this;
  }
  combine(...those) {
    // Combine this with those.
    // Return self for chaining.
    const result = combiner_1.combine([this].concat(those));
    Object.assign(this, result);
    return this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
}
exports.Psbt = Psbt;


/***/ }),

/***/ 1847:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var GlobalTypes;
(function(GlobalTypes) {
  GlobalTypes[(GlobalTypes['UNSIGNED_TX'] = 0)] = 'UNSIGNED_TX';
  GlobalTypes[(GlobalTypes['GLOBAL_XPUB'] = 1)] = 'GLOBAL_XPUB';
})((GlobalTypes = exports.GlobalTypes || (exports.GlobalTypes = {})));
exports.GLOBAL_TYPE_NAMES = ['unsignedTx', 'globalXpub'];
var InputTypes;
(function(InputTypes) {
  InputTypes[(InputTypes['NON_WITNESS_UTXO'] = 0)] = 'NON_WITNESS_UTXO';
  InputTypes[(InputTypes['WITNESS_UTXO'] = 1)] = 'WITNESS_UTXO';
  InputTypes[(InputTypes['PARTIAL_SIG'] = 2)] = 'PARTIAL_SIG';
  InputTypes[(InputTypes['SIGHASH_TYPE'] = 3)] = 'SIGHASH_TYPE';
  InputTypes[(InputTypes['REDEEM_SCRIPT'] = 4)] = 'REDEEM_SCRIPT';
  InputTypes[(InputTypes['WITNESS_SCRIPT'] = 5)] = 'WITNESS_SCRIPT';
  InputTypes[(InputTypes['BIP32_DERIVATION'] = 6)] = 'BIP32_DERIVATION';
  InputTypes[(InputTypes['FINAL_SCRIPTSIG'] = 7)] = 'FINAL_SCRIPTSIG';
  InputTypes[(InputTypes['FINAL_SCRIPTWITNESS'] = 8)] = 'FINAL_SCRIPTWITNESS';
  InputTypes[(InputTypes['POR_COMMITMENT'] = 9)] = 'POR_COMMITMENT';
  InputTypes[(InputTypes['TAP_KEY_SIG'] = 19)] = 'TAP_KEY_SIG';
  InputTypes[(InputTypes['TAP_SCRIPT_SIG'] = 20)] = 'TAP_SCRIPT_SIG';
  InputTypes[(InputTypes['TAP_LEAF_SCRIPT'] = 21)] = 'TAP_LEAF_SCRIPT';
  InputTypes[(InputTypes['TAP_BIP32_DERIVATION'] = 22)] =
    'TAP_BIP32_DERIVATION';
  InputTypes[(InputTypes['TAP_INTERNAL_KEY'] = 23)] = 'TAP_INTERNAL_KEY';
  InputTypes[(InputTypes['TAP_MERKLE_ROOT'] = 24)] = 'TAP_MERKLE_ROOT';
})((InputTypes = exports.InputTypes || (exports.InputTypes = {})));
exports.INPUT_TYPE_NAMES = [
  'nonWitnessUtxo',
  'witnessUtxo',
  'partialSig',
  'sighashType',
  'redeemScript',
  'witnessScript',
  'bip32Derivation',
  'finalScriptSig',
  'finalScriptWitness',
  'porCommitment',
  'tapKeySig',
  'tapScriptSig',
  'tapLeafScript',
  'tapBip32Derivation',
  'tapInternalKey',
  'tapMerkleRoot',
];
var OutputTypes;
(function(OutputTypes) {
  OutputTypes[(OutputTypes['REDEEM_SCRIPT'] = 0)] = 'REDEEM_SCRIPT';
  OutputTypes[(OutputTypes['WITNESS_SCRIPT'] = 1)] = 'WITNESS_SCRIPT';
  OutputTypes[(OutputTypes['BIP32_DERIVATION'] = 2)] = 'BIP32_DERIVATION';
  OutputTypes[(OutputTypes['TAP_INTERNAL_KEY'] = 5)] = 'TAP_INTERNAL_KEY';
  OutputTypes[(OutputTypes['TAP_TREE'] = 6)] = 'TAP_TREE';
  OutputTypes[(OutputTypes['TAP_BIP32_DERIVATION'] = 7)] =
    'TAP_BIP32_DERIVATION';
})((OutputTypes = exports.OutputTypes || (exports.OutputTypes = {})));
exports.OUTPUT_TYPE_NAMES = [
  'redeemScript',
  'witnessScript',
  'bip32Derivation',
  'tapInternalKey',
  'tapTree',
  'tapBip32Derivation',
];


/***/ }),

/***/ 96403:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const converter = __webpack_require__(71528);
function checkForInput(inputs, inputIndex) {
  const input = inputs[inputIndex];
  if (input === undefined) throw new Error(`No input #${inputIndex}`);
  return input;
}
exports.checkForInput = checkForInput;
function checkForOutput(outputs, outputIndex) {
  const output = outputs[outputIndex];
  if (output === undefined) throw new Error(`No output #${outputIndex}`);
  return output;
}
exports.checkForOutput = checkForOutput;
function checkHasKey(checkKeyVal, keyVals, enumLength) {
  if (checkKeyVal.key[0] < enumLength) {
    throw new Error(
      `Use the method for your specific key instead of addUnknownKeyVal*`,
    );
  }
  if (
    keyVals &&
    keyVals.filter(kv => kv.key.equals(checkKeyVal.key)).length !== 0
  ) {
    throw new Error(`Duplicate Key: ${checkKeyVal.key.toString('hex')}`);
  }
}
exports.checkHasKey = checkHasKey;
function getEnumLength(myenum) {
  let count = 0;
  Object.keys(myenum).forEach(val => {
    if (Number(isNaN(Number(val)))) {
      count++;
    }
  });
  return count;
}
exports.getEnumLength = getEnumLength;
function inputCheckUncleanFinalized(inputIndex, input) {
  let result = false;
  if (input.nonWitnessUtxo || input.witnessUtxo) {
    const needScriptSig = !!input.redeemScript;
    const needWitnessScript = !!input.witnessScript;
    const scriptSigOK = !needScriptSig || !!input.finalScriptSig;
    const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;
    const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;
    result = scriptSigOK && witnessScriptOK && hasOneFinal;
  }
  if (result === false) {
    throw new Error(
      `Input #${inputIndex} has too much or too little data to clean`,
    );
  }
}
exports.inputCheckUncleanFinalized = inputCheckUncleanFinalized;
function throwForUpdateMaker(typeName, name, expected, data) {
  throw new Error(
    `Data for ${typeName} key ${name} is incorrect: Expected ` +
      `${expected} and got ${JSON.stringify(data)}`,
  );
}
function updateMaker(typeName) {
  return (updateData, mainData) => {
    for (const name of Object.keys(updateData)) {
      // @ts-ignore
      const data = updateData[name];
      // @ts-ignore
      const { canAdd, canAddToArray, check, expected } =
        // @ts-ignore
        converter[typeName + 's'][name] || {};
      const isArray = !!canAddToArray;
      // If unknown data. ignore and do not add
      if (check) {
        if (isArray) {
          if (
            !Array.isArray(data) ||
            // @ts-ignore
            (mainData[name] && !Array.isArray(mainData[name]))
          ) {
            throw new Error(`Key type ${name} must be an array`);
          }
          if (!data.every(check)) {
            throwForUpdateMaker(typeName, name, expected, data);
          }
          // @ts-ignore
          const arr = mainData[name] || [];
          const dupeCheckSet = new Set();
          if (!data.every(v => canAddToArray(arr, v, dupeCheckSet))) {
            throw new Error('Can not add duplicate data to array');
          }
          // @ts-ignore
          mainData[name] = arr.concat(data);
        } else {
          if (!check(data)) {
            throwForUpdateMaker(typeName, name, expected, data);
          }
          if (!canAdd(mainData, data)) {
            throw new Error(`Can not add duplicate data to ${typeName}`);
          }
          // @ts-ignore
          mainData[name] = data;
        }
      }
    }
  };
}
exports.updateGlobal = updateMaker('global');
exports.updateInput = updateMaker('input');
exports.updateOutput = updateMaker('output');
function addInputAttributes(inputs, data) {
  const index = inputs.length - 1;
  const input = checkForInput(inputs, index);
  exports.updateInput(data, input);
}
exports.addInputAttributes = addInputAttributes;
function addOutputAttributes(outputs, data) {
  const index = outputs.length - 1;
  const output = checkForOutput(outputs, index);
  exports.updateOutput(data, output);
}
exports.addOutputAttributes = addOutputAttributes;
function defaultVersionSetter(version, txBuf) {
  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
    throw new Error('Set Version: Invalid Transaction');
  }
  txBuf.writeUInt32LE(version, 0);
  return txBuf;
}
exports.defaultVersionSetter = defaultVersionSetter;
function defaultLocktimeSetter(locktime, txBuf) {
  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
    throw new Error('Set Locktime: Invalid Transaction');
  }
  txBuf.writeUInt32LE(locktime, txBuf.length - 4);
  return txBuf;
}
exports.defaultLocktimeSetter = defaultLocktimeSetter;


/***/ }),

/***/ 95488:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toOutputScript =
  exports.fromOutputScript =
  exports.toBech32 =
  exports.toBase58Check =
  exports.fromBech32 =
  exports.fromBase58Check =
    void 0;
const networks = __webpack_require__(74378);
const payments = __webpack_require__(84972);
const bscript = __webpack_require__(73357);
const types_1 = __webpack_require__(41838);
const bech32_1 = __webpack_require__(27715);
const bs58check = __webpack_require__(58334);
const FUTURE_SEGWIT_MAX_SIZE = 40;
const FUTURE_SEGWIT_MIN_SIZE = 2;
const FUTURE_SEGWIT_MAX_VERSION = 16;
const FUTURE_SEGWIT_MIN_VERSION = 2;
const FUTURE_SEGWIT_VERSION_DIFF = 0x50;
const FUTURE_SEGWIT_VERSION_WARNING =
  'WARNING: Sending to a future segwit version address can lead to loss of funds. ' +
  'End users MUST be warned carefully in the GUI and asked if they wish to proceed ' +
  'with caution. Wallets should verify the segwit version from the output of fromBech32, ' +
  'then decide when it is safe to use which version of segwit.';
function _toFutureSegwitAddress(output, network) {
  const data = output.slice(2);
  if (
    data.length < FUTURE_SEGWIT_MIN_SIZE ||
    data.length > FUTURE_SEGWIT_MAX_SIZE
  )
    throw new TypeError('Invalid program length for segwit address');
  const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;
  if (
    version < FUTURE_SEGWIT_MIN_VERSION ||
    version > FUTURE_SEGWIT_MAX_VERSION
  )
    throw new TypeError('Invalid version for segwit address');
  if (output[1] !== data.length)
    throw new TypeError('Invalid script for segwit address');
  console.warn(FUTURE_SEGWIT_VERSION_WARNING);
  return toBech32(data, version, network.bech32);
}
function fromBase58Check(address) {
  const payload = Buffer.from(bs58check.decode(address));
  // TODO: 4.0.0, move to "toOutputScript"
  if (payload.length < 21) throw new TypeError(address + ' is too short');
  if (payload.length > 21) throw new TypeError(address + ' is too long');
  const version = payload.readUInt8(0);
  const hash = payload.slice(1);
  return { version, hash };
}
exports.fromBase58Check = fromBase58Check;
function fromBech32(address) {
  let result;
  let version;
  try {
    result = bech32_1.bech32.decode(address);
  } catch (e) {}
  if (result) {
    version = result.words[0];
    if (version !== 0) throw new TypeError(address + ' uses wrong encoding');
  } else {
    result = bech32_1.bech32m.decode(address);
    version = result.words[0];
    if (version === 0) throw new TypeError(address + ' uses wrong encoding');
  }
  const data = bech32_1.bech32.fromWords(result.words.slice(1));
  return {
    version,
    prefix: result.prefix,
    data: Buffer.from(data),
  };
}
exports.fromBech32 = fromBech32;
function toBase58Check(hash, version) {
  (0, types_1.typeforce)(
    (0, types_1.tuple)(types_1.Hash160bit, types_1.UInt8),
    arguments,
  );
  const payload = Buffer.allocUnsafe(21);
  payload.writeUInt8(version, 0);
  hash.copy(payload, 1);
  return bs58check.encode(payload);
}
exports.toBase58Check = toBase58Check;
function toBech32(data, version, prefix) {
  const words = bech32_1.bech32.toWords(data);
  words.unshift(version);
  return version === 0
    ? bech32_1.bech32.encode(prefix, words)
    : bech32_1.bech32m.encode(prefix, words);
}
exports.toBech32 = toBech32;
function fromOutputScript(output, network) {
  // TODO: Network
  network = network || networks.bitcoin;
  try {
    return payments.p2pkh({ output, network }).address;
  } catch (e) {}
  try {
    return payments.p2sh({ output, network }).address;
  } catch (e) {}
  try {
    return payments.p2wpkh({ output, network }).address;
  } catch (e) {}
  try {
    return payments.p2wsh({ output, network }).address;
  } catch (e) {}
  try {
    return payments.p2tr({ output, network }).address;
  } catch (e) {}
  try {
    return _toFutureSegwitAddress(output, network);
  } catch (e) {}
  throw new Error(bscript.toASM(output) + ' has no matching Address');
}
exports.fromOutputScript = fromOutputScript;
function toOutputScript(address, network) {
  network = network || networks.bitcoin;
  let decodeBase58;
  let decodeBech32;
  try {
    decodeBase58 = fromBase58Check(address);
  } catch (e) {}
  if (decodeBase58) {
    if (decodeBase58.version === network.pubKeyHash)
      return payments.p2pkh({ hash: decodeBase58.hash }).output;
    if (decodeBase58.version === network.scriptHash)
      return payments.p2sh({ hash: decodeBase58.hash }).output;
  } else {
    try {
      decodeBech32 = fromBech32(address);
    } catch (e) {}
    if (decodeBech32) {
      if (decodeBech32.prefix !== network.bech32)
        throw new Error(address + ' has an invalid prefix');
      if (decodeBech32.version === 0) {
        if (decodeBech32.data.length === 20)
          return payments.p2wpkh({ hash: decodeBech32.data }).output;
        if (decodeBech32.data.length === 32)
          return payments.p2wsh({ hash: decodeBech32.data }).output;
      } else if (decodeBech32.version === 1) {
        if (decodeBech32.data.length === 32)
          return payments.p2tr({ pubkey: decodeBech32.data }).output;
      } else if (
        decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION &&
        decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION &&
        decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE &&
        decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE
      ) {
        console.warn(FUTURE_SEGWIT_VERSION_WARNING);
        return bscript.compile([
          decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,
          decodeBech32.data,
        ]);
      }
    }
  }
  throw new Error(address + ' has no matching Script');
}
exports.toOutputScript = toOutputScript;


/***/ }),

/***/ 77617:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
// NOTE: SIGHASH byte ignored AND restricted, truncate before use
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encode = exports.decode = exports.check = void 0;
function check(buffer) {
  if (buffer.length < 8) return false;
  if (buffer.length > 72) return false;
  if (buffer[0] !== 0x30) return false;
  if (buffer[1] !== buffer.length - 2) return false;
  if (buffer[2] !== 0x02) return false;
  const lenR = buffer[3];
  if (lenR === 0) return false;
  if (5 + lenR >= buffer.length) return false;
  if (buffer[4 + lenR] !== 0x02) return false;
  const lenS = buffer[5 + lenR];
  if (lenS === 0) return false;
  if (6 + lenR + lenS !== buffer.length) return false;
  if (buffer[4] & 0x80) return false;
  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) return false;
  if (buffer[lenR + 6] & 0x80) return false;
  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))
    return false;
  return true;
}
exports.check = check;
function decode(buffer) {
  if (buffer.length < 8) throw new Error('DER sequence length is too short');
  if (buffer.length > 72) throw new Error('DER sequence length is too long');
  if (buffer[0] !== 0x30) throw new Error('Expected DER sequence');
  if (buffer[1] !== buffer.length - 2)
    throw new Error('DER sequence length is invalid');
  if (buffer[2] !== 0x02) throw new Error('Expected DER integer');
  const lenR = buffer[3];
  if (lenR === 0) throw new Error('R length is zero');
  if (5 + lenR >= buffer.length) throw new Error('R length is too long');
  if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)');
  const lenS = buffer[5 + lenR];
  if (lenS === 0) throw new Error('S length is zero');
  if (6 + lenR + lenS !== buffer.length) throw new Error('S length is invalid');
  if (buffer[4] & 0x80) throw new Error('R value is negative');
  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))
    throw new Error('R value excessively padded');
  if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative');
  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))
    throw new Error('S value excessively padded');
  // non-BIP66 - extract R, S values
  return {
    r: buffer.slice(4, 4 + lenR),
    s: buffer.slice(6 + lenR),
  };
}
exports.decode = decode;
/*
 * Expects r and s to be positive DER integers.
 *
 * The DER format uses the most significant bit as a sign bit (& 0x80).
 * If the significant bit is set AND the integer is positive, a 0x00 is prepended.
 *
 * Examples:
 *
 *      0 =>     0x00
 *      1 =>     0x01
 *     -1 =>     0xff
 *    127 =>     0x7f
 *   -127 =>     0x81
 *    128 =>   0x0080
 *   -128 =>     0x80
 *    255 =>   0x00ff
 *   -255 =>   0xff01
 *  16300 =>   0x3fac
 * -16300 =>   0xc054
 *  62300 => 0x00f35c
 * -62300 => 0xff0ca4
 */
function encode(r, s) {
  const lenR = r.length;
  const lenS = s.length;
  if (lenR === 0) throw new Error('R length is zero');
  if (lenS === 0) throw new Error('S length is zero');
  if (lenR > 33) throw new Error('R length is too long');
  if (lenS > 33) throw new Error('S length is too long');
  if (r[0] & 0x80) throw new Error('R value is negative');
  if (s[0] & 0x80) throw new Error('S value is negative');
  if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80))
    throw new Error('R value excessively padded');
  if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80))
    throw new Error('S value excessively padded');
  const signature = Buffer.allocUnsafe(6 + lenR + lenS);
  // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
  signature[0] = 0x30;
  signature[1] = signature.length - 2;
  signature[2] = 0x02;
  signature[3] = r.length;
  r.copy(signature, 4);
  signature[4 + lenR] = 0x02;
  signature[5 + lenR] = s.length;
  s.copy(signature, 6 + lenR);
  return signature;
}
exports.encode = encode;


/***/ }),

/***/ 87949:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Block = void 0;
const bufferutils_1 = __webpack_require__(9357);
const bcrypto = __webpack_require__(5525);
const merkle_1 = __webpack_require__(298);
const transaction_1 = __webpack_require__(82737);
const types = __webpack_require__(41838);
const { typeforce } = types;
const errorMerkleNoTxes = new TypeError(
  'Cannot compute merkle root for zero transactions',
);
const errorWitnessNotSegwit = new TypeError(
  'Cannot compute witness commit for non-segwit block',
);
class Block {
  constructor() {
    this.version = 1;
    this.prevHash = undefined;
    this.merkleRoot = undefined;
    this.timestamp = 0;
    this.witnessCommit = undefined;
    this.bits = 0;
    this.nonce = 0;
    this.transactions = undefined;
  }
  static fromBuffer(buffer) {
    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');
    const bufferReader = new bufferutils_1.BufferReader(buffer);
    const block = new Block();
    block.version = bufferReader.readInt32();
    block.prevHash = bufferReader.readSlice(32);
    block.merkleRoot = bufferReader.readSlice(32);
    block.timestamp = bufferReader.readUInt32();
    block.bits = bufferReader.readUInt32();
    block.nonce = bufferReader.readUInt32();
    if (buffer.length === 80) return block;
    const readTransaction = () => {
      const tx = transaction_1.Transaction.fromBuffer(
        bufferReader.buffer.slice(bufferReader.offset),
        true,
      );
      bufferReader.offset += tx.byteLength();
      return tx;
    };
    const nTransactions = bufferReader.readVarInt();
    block.transactions = [];
    for (let i = 0; i < nTransactions; ++i) {
      const tx = readTransaction();
      block.transactions.push(tx);
    }
    const witnessCommit = block.getWitnessCommit();
    // This Block contains a witness commit
    if (witnessCommit) block.witnessCommit = witnessCommit;
    return block;
  }
  static fromHex(hex) {
    return Block.fromBuffer(Buffer.from(hex, 'hex'));
  }
  static calculateTarget(bits) {
    const exponent = ((bits & 0xff000000) >> 24) - 3;
    const mantissa = bits & 0x007fffff;
    const target = Buffer.alloc(32, 0);
    target.writeUIntBE(mantissa, 29 - exponent, 3);
    return target;
  }
  static calculateMerkleRoot(transactions, forWitness) {
    typeforce([{ getHash: types.Function }], transactions);
    if (transactions.length === 0) throw errorMerkleNoTxes;
    if (forWitness && !txesHaveWitnessCommit(transactions))
      throw errorWitnessNotSegwit;
    const hashes = transactions.map(transaction =>
      transaction.getHash(forWitness),
    );
    const rootHash = (0, merkle_1.fastMerkleRoot)(hashes, bcrypto.hash256);
    return forWitness
      ? bcrypto.hash256(
          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]]),
        )
      : rootHash;
  }
  getWitnessCommit() {
    if (!txesHaveWitnessCommit(this.transactions)) return null;
    // The merkle root for the witness data is in an OP_RETURN output.
    // There is no rule for the index of the output, so use filter to find it.
    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed
    // If multiple commits are found, the output with highest index is assumed.
    const witnessCommits = this.transactions[0].outs
      .filter(out =>
        out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex')),
      )
      .map(out => out.script.slice(6, 38));
    if (witnessCommits.length === 0) return null;
    // Use the commit with the highest output (should only be one though)
    const result = witnessCommits[witnessCommits.length - 1];
    if (!(result instanceof Buffer && result.length === 32)) return null;
    return result;
  }
  hasWitnessCommit() {
    if (
      this.witnessCommit instanceof Buffer &&
      this.witnessCommit.length === 32
    )
      return true;
    if (this.getWitnessCommit() !== null) return true;
    return false;
  }
  hasWitness() {
    return anyTxHasWitness(this.transactions);
  }
  weight() {
    const base = this.byteLength(false, false);
    const total = this.byteLength(false, true);
    return base * 3 + total;
  }
  byteLength(headersOnly, allowWitness = true) {
    if (headersOnly || !this.transactions) return 80;
    return (
      80 +
      bufferutils_1.varuint.encodingLength(this.transactions.length) +
      this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)
    );
  }
  getHash() {
    return bcrypto.hash256(this.toBuffer(true));
  }
  getId() {
    return (0, bufferutils_1.reverseBuffer)(this.getHash()).toString('hex');
  }
  getUTCDate() {
    const date = new Date(0); // epoch
    date.setUTCSeconds(this.timestamp);
    return date;
  }
  // TODO: buffer, offset compatibility
  toBuffer(headersOnly) {
    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));
    const bufferWriter = new bufferutils_1.BufferWriter(buffer);
    bufferWriter.writeInt32(this.version);
    bufferWriter.writeSlice(this.prevHash);
    bufferWriter.writeSlice(this.merkleRoot);
    bufferWriter.writeUInt32(this.timestamp);
    bufferWriter.writeUInt32(this.bits);
    bufferWriter.writeUInt32(this.nonce);
    if (headersOnly || !this.transactions) return buffer;
    bufferutils_1.varuint.encode(
      this.transactions.length,
      buffer,
      bufferWriter.offset,
    );
    bufferWriter.offset += bufferutils_1.varuint.encode.bytes;
    this.transactions.forEach(tx => {
      const txSize = tx.byteLength(); // TODO: extract from toBuffer?
      tx.toBuffer(buffer, bufferWriter.offset);
      bufferWriter.offset += txSize;
    });
    return buffer;
  }
  toHex(headersOnly) {
    return this.toBuffer(headersOnly).toString('hex');
  }
  checkTxRoots() {
    // If the Block has segwit transactions but no witness commit,
    // there's no way it can be valid, so fail the check.
    const hasWitnessCommit = this.hasWitnessCommit();
    if (!hasWitnessCommit && this.hasWitness()) return false;
    return (
      this.__checkMerkleRoot() &&
      (hasWitnessCommit ? this.__checkWitnessCommit() : true)
    );
  }
  checkProofOfWork() {
    const hash = (0, bufferutils_1.reverseBuffer)(this.getHash());
    const target = Block.calculateTarget(this.bits);
    return hash.compare(target) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions) throw errorMerkleNoTxes;
    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(actualMerkleRoot) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions) throw errorMerkleNoTxes;
    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
    const actualWitnessCommit = Block.calculateMerkleRoot(
      this.transactions,
      true,
    );
    return this.witnessCommit.compare(actualWitnessCommit) === 0;
  }
}
exports.Block = Block;
function txesHaveWitnessCommit(transactions) {
  return (
    transactions instanceof Array &&
    transactions[0] &&
    transactions[0].ins &&
    transactions[0].ins instanceof Array &&
    transactions[0].ins[0] &&
    transactions[0].ins[0].witness &&
    transactions[0].ins[0].witness instanceof Array &&
    transactions[0].ins[0].witness.length > 0
  );
}
function anyTxHasWitness(transactions) {
  return (
    transactions instanceof Array &&
    transactions.some(
      tx =>
        typeof tx === 'object' &&
        tx.ins instanceof Array &&
        tx.ins.some(
          input =>
            typeof input === 'object' &&
            input.witness instanceof Array &&
            input.witness.length > 0,
        ),
    )
  );
}


/***/ }),

/***/ 9357:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BufferReader =
  exports.BufferWriter =
  exports.cloneBuffer =
  exports.reverseBuffer =
  exports.writeUInt64LE =
  exports.readUInt64LE =
  exports.varuint =
    void 0;
const types = __webpack_require__(41838);
const { typeforce } = types;
const varuint = __webpack_require__(57795);
exports.varuint = varuint;
// https://github.com/feross/buffer/blob/master/index.js#L1127
function verifuint(value, max) {
  if (typeof value !== 'number')
    throw new Error('cannot write a non-number as a number');
  if (value < 0)
    throw new Error('specified a negative value for writing an unsigned value');
  if (value > max) throw new Error('RangeError: value out of range');
  if (Math.floor(value) !== value)
    throw new Error('value has a fractional component');
}
function readUInt64LE(buffer, offset) {
  const a = buffer.readUInt32LE(offset);
  let b = buffer.readUInt32LE(offset + 4);
  b *= 0x100000000;
  verifuint(b + a, 0x001fffffffffffff);
  return b + a;
}
exports.readUInt64LE = readUInt64LE;
function writeUInt64LE(buffer, value, offset) {
  verifuint(value, 0x001fffffffffffff);
  buffer.writeInt32LE(value & -1, offset);
  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);
  return offset + 8;
}
exports.writeUInt64LE = writeUInt64LE;
function reverseBuffer(buffer) {
  if (buffer.length < 1) return buffer;
  let j = buffer.length - 1;
  let tmp = 0;
  for (let i = 0; i < buffer.length / 2; i++) {
    tmp = buffer[i];
    buffer[i] = buffer[j];
    buffer[j] = tmp;
    j--;
  }
  return buffer;
}
exports.reverseBuffer = reverseBuffer;
function cloneBuffer(buffer) {
  const clone = Buffer.allocUnsafe(buffer.length);
  buffer.copy(clone);
  return clone;
}
exports.cloneBuffer = cloneBuffer;
/**
 * Helper class for serialization of bitcoin data types into a pre-allocated buffer.
 */
class BufferWriter {
  static withCapacity(size) {
    return new BufferWriter(Buffer.alloc(size));
  }
  constructor(buffer, offset = 0) {
    this.buffer = buffer;
    this.offset = offset;
    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);
  }
  writeUInt8(i) {
    this.offset = this.buffer.writeUInt8(i, this.offset);
  }
  writeInt32(i) {
    this.offset = this.buffer.writeInt32LE(i, this.offset);
  }
  writeUInt32(i) {
    this.offset = this.buffer.writeUInt32LE(i, this.offset);
  }
  writeUInt64(i) {
    this.offset = writeUInt64LE(this.buffer, i, this.offset);
  }
  writeVarInt(i) {
    varuint.encode(i, this.buffer, this.offset);
    this.offset += varuint.encode.bytes;
  }
  writeSlice(slice) {
    if (this.buffer.length < this.offset + slice.length) {
      throw new Error('Cannot write slice out of bounds');
    }
    this.offset += slice.copy(this.buffer, this.offset);
  }
  writeVarSlice(slice) {
    this.writeVarInt(slice.length);
    this.writeSlice(slice);
  }
  writeVector(vector) {
    this.writeVarInt(vector.length);
    vector.forEach(buf => this.writeVarSlice(buf));
  }
  end() {
    if (this.buffer.length === this.offset) {
      return this.buffer;
    }
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
exports.BufferWriter = BufferWriter;
/**
 * Helper class for reading of bitcoin data types from a buffer.
 */
class BufferReader {
  constructor(buffer, offset = 0) {
    this.buffer = buffer;
    this.offset = offset;
    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);
  }
  readUInt8() {
    const result = this.buffer.readUInt8(this.offset);
    this.offset++;
    return result;
  }
  readInt32() {
    const result = this.buffer.readInt32LE(this.offset);
    this.offset += 4;
    return result;
  }
  readUInt32() {
    const result = this.buffer.readUInt32LE(this.offset);
    this.offset += 4;
    return result;
  }
  readUInt64() {
    const result = readUInt64LE(this.buffer, this.offset);
    this.offset += 8;
    return result;
  }
  readVarInt() {
    const vi = varuint.decode(this.buffer, this.offset);
    this.offset += varuint.decode.bytes;
    return vi;
  }
  readSlice(n) {
    if (this.buffer.length < this.offset + n) {
      throw new Error('Cannot read slice out of bounds');
    }
    const result = this.buffer.slice(this.offset, this.offset + n);
    this.offset += n;
    return result;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const count = this.readVarInt();
    const vector = [];
    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());
    return vector;
  }
}
exports.BufferReader = BufferReader;


/***/ }),

/***/ 5525:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.taggedHash =
  exports.TAGGED_HASH_PREFIXES =
  exports.TAGS =
  exports.hash256 =
  exports.hash160 =
  exports.sha256 =
  exports.sha1 =
  exports.ripemd160 =
    void 0;
const ripemd160_1 = __webpack_require__(70830);
const sha1_1 = __webpack_require__(73963);
const sha256_1 = __webpack_require__(23061);
function ripemd160(buffer) {
  return Buffer.from((0, ripemd160_1.ripemd160)(Uint8Array.from(buffer)));
}
exports.ripemd160 = ripemd160;
function sha1(buffer) {
  return Buffer.from((0, sha1_1.sha1)(Uint8Array.from(buffer)));
}
exports.sha1 = sha1;
function sha256(buffer) {
  return Buffer.from((0, sha256_1.sha256)(Uint8Array.from(buffer)));
}
exports.sha256 = sha256;
function hash160(buffer) {
  return Buffer.from(
    (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(Uint8Array.from(buffer))),
  );
}
exports.hash160 = hash160;
function hash256(buffer) {
  return Buffer.from(
    (0, sha256_1.sha256)((0, sha256_1.sha256)(Uint8Array.from(buffer))),
  );
}
exports.hash256 = hash256;
exports.TAGS = [
  'BIP0340/challenge',
  'BIP0340/aux',
  'BIP0340/nonce',
  'TapLeaf',
  'TapBranch',
  'TapSighash',
  'TapTweak',
  'KeyAgg list',
  'KeyAgg coefficient',
];
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
exports.TAGGED_HASH_PREFIXES = {
  'BIP0340/challenge': Buffer.from([
    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,
    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,
    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,
    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,
  ]),
  'BIP0340/aux': Buffer.from([
    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,
    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,
    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,
    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,
  ]),
  'BIP0340/nonce': Buffer.from([
    7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244,
    52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47, 7, 73,
    119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215,
    62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47,
  ]),
  TapLeaf: Buffer.from([
    174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211,
    95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238, 174, 234, 143,
    220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181,
    64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238,
  ]),
  TapBranch: Buffer.from([
    25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247,
    33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21, 25,
    65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33,
    111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21,
  ]),
  TapSighash: Buffer.from([
    244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61,
    149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49, 244,
    10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149,
    253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49,
  ]),
  TapTweak: Buffer.from([
    232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66,
    156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233, 232,
    15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156,
    188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233,
  ]),
  'KeyAgg list': Buffer.from([
    72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126,
    215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240, 72, 28,
    151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49,
    156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240,
  ]),
  'KeyAgg coefficient': Buffer.from([
    191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100,
    130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129, 191,
    201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130,
    78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129,
  ]),
};
function taggedHash(prefix, data) {
  return sha256(Buffer.concat([exports.TAGGED_HASH_PREFIXES[prefix], data]));
}
exports.taggedHash = taggedHash;


/***/ }),

/***/ 66379:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEccLib = exports.initEccLib = void 0;
const _ECCLIB_CACHE = {};
function initEccLib(eccLib) {
  if (!eccLib) {
    // allow clearing the library
    _ECCLIB_CACHE.eccLib = eccLib;
  } else if (eccLib !== _ECCLIB_CACHE.eccLib) {
    // new instance, verify it
    verifyEcc(eccLib);
    _ECCLIB_CACHE.eccLib = eccLib;
  }
}
exports.initEccLib = initEccLib;
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib)
    throw new Error(
      'No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance',
    );
  return _ECCLIB_CACHE.eccLib;
}
exports.getEccLib = getEccLib;
const h = hex => Buffer.from(hex, 'hex');
function verifyEcc(ecc) {
  assert(typeof ecc.isXOnlyPoint === 'function');
  assert(
    ecc.isXOnlyPoint(
      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    ),
  );
  assert(
    ecc.isXOnlyPoint(
      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e'),
    ),
  );
  assert(
    ecc.isXOnlyPoint(
      h('f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9'),
    ),
  );
  assert(
    ecc.isXOnlyPoint(
      h('0000000000000000000000000000000000000000000000000000000000000001'),
    ),
  );
  assert(
    !ecc.isXOnlyPoint(
      h('0000000000000000000000000000000000000000000000000000000000000000'),
    ),
  );
  assert(
    !ecc.isXOnlyPoint(
      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
    ),
  );
  assert(typeof ecc.xOnlyPointAddTweak === 'function');
  tweakAddVectors.forEach(t => {
    const r = ecc.xOnlyPointAddTweak(h(t.pubkey), h(t.tweak));
    if (t.result === null) {
      assert(r === null);
    } else {
      assert(r !== null);
      assert(r.parity === t.parity);
      assert(Buffer.from(r.xOnlyPubkey).equals(h(t.result)));
    }
  });
}
function assert(bool) {
  if (!bool) throw new Error('ecc library invalid');
}
const tweakAddVectors = [
  {
    pubkey: '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    tweak: 'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140',
    parity: -1,
    result: null,
  },
  {
    pubkey: '1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b',
    tweak: 'a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac',
    parity: 1,
    result: 'e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf',
  },
  {
    pubkey: '2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991',
    tweak: '823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47',
    parity: 0,
    result: '9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c',
  },
];


/***/ }),

/***/ 17656:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
exports.Wi =
  exports.YW =
  __webpack_unused_export__ =
  exports._B =
  __webpack_unused_export__ =
  __webpack_unused_export__ =
  exports.PP =
  exports.QW =
  __webpack_unused_export__ =
  __webpack_unused_export__ =
    void 0;
const address = __webpack_require__(95488);
__webpack_unused_export__ = address;
const crypto = __webpack_require__(5525);
__webpack_unused_export__ = crypto;
const networks = __webpack_require__(74378);
exports.QW = networks;
const payments = __webpack_require__(84972);
exports.PP = payments;
const script = __webpack_require__(73357);
__webpack_unused_export__ = script;
var block_1 = __webpack_require__(87949);
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return block_1.Block;
  },
});
var psbt_1 = __webpack_require__(99930);
Object.defineProperty(exports, "_B", ({
  enumerable: true,
  get: function () {
    return psbt_1.Psbt;
  },
}));
var ops_1 = __webpack_require__(47334);
__webpack_unused_export__ = ({
  enumerable: true,
  get: function () {
    return ops_1.OPS;
  },
});
var transaction_1 = __webpack_require__(82737);
Object.defineProperty(exports, "YW", ({
  enumerable: true,
  get: function () {
    return transaction_1.Transaction;
  },
}));
var ecc_lib_1 = __webpack_require__(66379);
Object.defineProperty(exports, "Wi", ({
  enumerable: true,
  get: function () {
    return ecc_lib_1.initEccLib;
  },
}));


/***/ }),

/***/ 298:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fastMerkleRoot = void 0;
function fastMerkleRoot(values, digestFn) {
  if (!Array.isArray(values)) throw TypeError('Expected values Array');
  if (typeof digestFn !== 'function')
    throw TypeError('Expected digest Function');
  let length = values.length;
  const results = values.concat();
  while (length > 1) {
    let j = 0;
    for (let i = 0; i < length; i += 2, ++j) {
      const left = results[i];
      const right = i + 1 === length ? left : results[i + 1];
      const data = Buffer.concat([left, right]);
      results[j] = digestFn(data);
    }
    length = j;
  }
  return results[0];
}
exports.fastMerkleRoot = fastMerkleRoot;


/***/ }),

/***/ 74378:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.testnet = exports.regtest = exports.bitcoin = void 0;
exports.bitcoin = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'bc',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x00,
  scriptHash: 0x05,
  wif: 0x80,
};
exports.regtest = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'bcrt',
  bip32: {
    public: 0x043587cf,
    private: 0x04358394,
  },
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0xef,
};
exports.testnet = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'tb',
  bip32: {
    public: 0x043587cf,
    private: 0x04358394,
  },
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0xef,
};


/***/ }),

/***/ 47334:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.REVERSE_OPS = exports.OPS = void 0;
const OPS = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255,
};
exports.OPS = OPS;
const REVERSE_OPS = {};
exports.REVERSE_OPS = REVERSE_OPS;
for (const op of Object.keys(OPS)) {
  const code = OPS[op];
  REVERSE_OPS[code] = op;
}


/***/ }),

/***/ 12227:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tweakKey =
  exports.tapTweakHash =
  exports.tapleafHash =
  exports.findScriptPath =
  exports.toHashTree =
  exports.rootHashFromPath =
  exports.MAX_TAPTREE_DEPTH =
  exports.LEAF_VERSION_TAPSCRIPT =
    void 0;
const buffer_1 = __webpack_require__(48764);
const ecc_lib_1 = __webpack_require__(66379);
const bcrypto = __webpack_require__(5525);
const bufferutils_1 = __webpack_require__(9357);
const types_1 = __webpack_require__(41838);
exports.LEAF_VERSION_TAPSCRIPT = 0xc0;
exports.MAX_TAPTREE_DEPTH = 128;
const isHashBranch = ht => 'left' in ht && 'right' in ht;
function rootHashFromPath(controlBlock, leafHash) {
  if (controlBlock.length < 33)
    throw new TypeError(
      `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,
    );
  const m = (controlBlock.length - 33) / 32;
  let kj = leafHash;
  for (let j = 0; j < m; j++) {
    const ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);
    if (kj.compare(ej) < 0) {
      kj = tapBranchHash(kj, ej);
    } else {
      kj = tapBranchHash(ej, kj);
    }
  }
  return kj;
}
exports.rootHashFromPath = rootHashFromPath;
/**
 * Build a hash tree of merkle nodes from the scripts binary tree.
 * @param scriptTree - the tree of scripts to pairwise hash.
 */
function toHashTree(scriptTree) {
  if ((0, types_1.isTapleaf)(scriptTree))
    return { hash: tapleafHash(scriptTree) };
  const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];
  hashes.sort((a, b) => a.hash.compare(b.hash));
  const [left, right] = hashes;
  return {
    hash: tapBranchHash(left.hash, right.hash),
    left,
    right,
  };
}
exports.toHashTree = toHashTree;
/**
 * Given a HashTree, finds the path from a particular hash to the root.
 * @param node - the root of the tree
 * @param hash - the hash to search for
 * @returns - array of sibling hashes, from leaf (inclusive) to root
 * (exclusive) needed to prove inclusion of the specified hash. undefined if no
 * path is found
 */
function findScriptPath(node, hash) {
  if (isHashBranch(node)) {
    const leftPath = findScriptPath(node.left, hash);
    if (leftPath !== undefined) return [...leftPath, node.right.hash];
    const rightPath = findScriptPath(node.right, hash);
    if (rightPath !== undefined) return [...rightPath, node.left.hash];
  } else if (node.hash.equals(hash)) {
    return [];
  }
  return undefined;
}
exports.findScriptPath = findScriptPath;
function tapleafHash(leaf) {
  const version = leaf.version || exports.LEAF_VERSION_TAPSCRIPT;
  return bcrypto.taggedHash(
    'TapLeaf',
    buffer_1.Buffer.concat([
      buffer_1.Buffer.from([version]),
      serializeScript(leaf.output),
    ]),
  );
}
exports.tapleafHash = tapleafHash;
function tapTweakHash(pubKey, h) {
  return bcrypto.taggedHash(
    'TapTweak',
    buffer_1.Buffer.concat(h ? [pubKey, h] : [pubKey]),
  );
}
exports.tapTweakHash = tapTweakHash;
function tweakKey(pubKey, h) {
  if (!buffer_1.Buffer.isBuffer(pubKey)) return null;
  if (pubKey.length !== 32) return null;
  if (h && h.length !== 32) return null;
  const tweakHash = tapTweakHash(pubKey, h);
  const res = (0, ecc_lib_1.getEccLib)().xOnlyPointAddTweak(pubKey, tweakHash);
  if (!res || res.xOnlyPubkey === null) return null;
  return {
    parity: res.parity,
    x: buffer_1.Buffer.from(res.xOnlyPubkey),
  };
}
exports.tweakKey = tweakKey;
function tapBranchHash(a, b) {
  return bcrypto.taggedHash('TapBranch', buffer_1.Buffer.concat([a, b]));
}
function serializeScript(s) {
  const varintLen = bufferutils_1.varuint.encodingLength(s.length);
  const buffer = buffer_1.Buffer.allocUnsafe(varintLen); // better
  bufferutils_1.varuint.encode(s.length, buffer);
  return buffer_1.Buffer.concat([buffer, s]);
}


/***/ }),

/***/ 36648:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p2data = void 0;
const networks_1 = __webpack_require__(74378);
const bscript = __webpack_require__(73357);
const types_1 = __webpack_require__(41838);
const lazy = __webpack_require__(52691);
const OPS = bscript.OPS;
function stacksEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every((x, i) => {
    return x.equals(b[i]);
  });
}
// output: OP_RETURN ...
function p2data(a, opts) {
  if (!a.data && !a.output) throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
      data: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
    },
    a,
  );
  const network = a.network || networks_1.bitcoin;
  const o = { name: 'embed', network };
  lazy.prop(o, 'output', () => {
    if (!a.data) return;
    return bscript.compile([OPS.OP_RETURN].concat(a.data));
  });
  lazy.prop(o, 'data', () => {
    if (!a.output) return;
    return bscript.decompile(a.output).slice(1);
  });
  // extended validation
  if (opts.validate) {
    if (a.output) {
      const chunks = bscript.decompile(a.output);
      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');
      if (!chunks.slice(1).every(types_1.typeforce.Buffer))
        throw new TypeError('Output is invalid');
      if (a.data && !stacksEqual(a.data, o.data))
        throw new TypeError('Data mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2data = p2data;


/***/ }),

/***/ 84972:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p2tr =
  exports.p2wsh =
  exports.p2wpkh =
  exports.p2sh =
  exports.p2pkh =
  exports.p2pk =
  exports.p2ms =
  exports.embed =
    void 0;
const embed_1 = __webpack_require__(36648);
Object.defineProperty(exports, "embed", ({
  enumerable: true,
  get: function () {
    return embed_1.p2data;
  },
}));
const p2ms_1 = __webpack_require__(98793);
Object.defineProperty(exports, "p2ms", ({
  enumerable: true,
  get: function () {
    return p2ms_1.p2ms;
  },
}));
const p2pk_1 = __webpack_require__(97759);
Object.defineProperty(exports, "p2pk", ({
  enumerable: true,
  get: function () {
    return p2pk_1.p2pk;
  },
}));
const p2pkh_1 = __webpack_require__(44483);
Object.defineProperty(exports, "p2pkh", ({
  enumerable: true,
  get: function () {
    return p2pkh_1.p2pkh;
  },
}));
const p2sh_1 = __webpack_require__(21160);
Object.defineProperty(exports, "p2sh", ({
  enumerable: true,
  get: function () {
    return p2sh_1.p2sh;
  },
}));
const p2wpkh_1 = __webpack_require__(18810);
Object.defineProperty(exports, "p2wpkh", ({
  enumerable: true,
  get: function () {
    return p2wpkh_1.p2wpkh;
  },
}));
const p2wsh_1 = __webpack_require__(82401);
Object.defineProperty(exports, "p2wsh", ({
  enumerable: true,
  get: function () {
    return p2wsh_1.p2wsh;
  },
}));
const p2tr_1 = __webpack_require__(10079);
Object.defineProperty(exports, "p2tr", ({
  enumerable: true,
  get: function () {
    return p2tr_1.p2tr;
  },
}));
// TODO
// witness commitment


/***/ }),

/***/ 52691:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.value = exports.prop = void 0;
function prop(object, name, f) {
  Object.defineProperty(object, name, {
    configurable: true,
    enumerable: true,
    get() {
      const _value = f.call(this);
      this[name] = _value;
      return _value;
    },
    set(_value) {
      Object.defineProperty(this, name, {
        configurable: true,
        enumerable: true,
        value: _value,
        writable: true,
      });
    },
  });
}
exports.prop = prop;
function value(f) {
  let _value;
  return () => {
    if (_value !== undefined) return _value;
    _value = f();
    return _value;
  };
}
exports.value = value;


/***/ }),

/***/ 98793:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p2ms = void 0;
const networks_1 = __webpack_require__(74378);
const bscript = __webpack_require__(73357);
const types_1 = __webpack_require__(41838);
const lazy = __webpack_require__(52691);
const OPS = bscript.OPS;
const OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1
function stacksEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every((x, i) => {
    return x.equals(b[i]);
  });
}
// input: OP_0 [signatures ...]
// output: m [pubKeys ...] n OP_CHECKMULTISIG
function p2ms(a, opts) {
  if (
    !a.input &&
    !a.output &&
    !(a.pubkeys && a.m !== undefined) &&
    !a.signatures
  )
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  function isAcceptableSignature(x) {
    return (
      bscript.isCanonicalScriptSignature(x) ||
      (opts.allowIncomplete && x === OPS.OP_0) !== undefined
    );
  }
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      m: types_1.typeforce.maybe(types_1.typeforce.Number),
      n: types_1.typeforce.maybe(types_1.typeforce.Number),
      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
      pubkeys: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.isPoint),
      ),
      signatures: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(isAcceptableSignature),
      ),
      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
    },
    a,
  );
  const network = a.network || networks_1.bitcoin;
  const o = { network };
  let chunks = [];
  let decoded = false;
  function decode(output) {
    if (decoded) return;
    decoded = true;
    chunks = bscript.decompile(output);
    o.m = chunks[0] - OP_INT_BASE;
    o.n = chunks[chunks.length - 2] - OP_INT_BASE;
    o.pubkeys = chunks.slice(1, -2);
  }
  lazy.prop(o, 'output', () => {
    if (!a.m) return;
    if (!o.n) return;
    if (!a.pubkeys) return;
    return bscript.compile(
      [].concat(
        OP_INT_BASE + a.m,
        a.pubkeys,
        OP_INT_BASE + o.n,
        OPS.OP_CHECKMULTISIG,
      ),
    );
  });
  lazy.prop(o, 'm', () => {
    if (!o.output) return;
    decode(o.output);
    return o.m;
  });
  lazy.prop(o, 'n', () => {
    if (!o.pubkeys) return;
    return o.pubkeys.length;
  });
  lazy.prop(o, 'pubkeys', () => {
    if (!a.output) return;
    decode(a.output);
    return o.pubkeys;
  });
  lazy.prop(o, 'signatures', () => {
    if (!a.input) return;
    return bscript.decompile(a.input).slice(1);
  });
  lazy.prop(o, 'input', () => {
    if (!a.signatures) return;
    return bscript.compile([OPS.OP_0].concat(a.signatures));
  });
  lazy.prop(o, 'witness', () => {
    if (!o.input) return;
    return [];
  });
  lazy.prop(o, 'name', () => {
    if (!o.m || !o.n) return;
    return `p2ms(${o.m} of ${o.n})`;
  });
  // extended validation
  if (opts.validate) {
    if (a.output) {
      decode(a.output);
      if (!types_1.typeforce.Number(chunks[0]))
        throw new TypeError('Output is invalid');
      if (!types_1.typeforce.Number(chunks[chunks.length - 2]))
        throw new TypeError('Output is invalid');
      if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)
        throw new TypeError('Output is invalid');
      if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)
        throw new TypeError('Output is invalid');
      if (!o.pubkeys.every(x => (0, types_1.isPoint)(x)))
        throw new TypeError('Output is invalid');
      if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');
      if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');
      if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys))
        throw new TypeError('Pubkeys mismatch');
    }
    if (a.pubkeys) {
      if (a.n !== undefined && a.n !== a.pubkeys.length)
        throw new TypeError('Pubkey count mismatch');
      o.n = a.pubkeys.length;
      if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');
    }
    if (a.signatures) {
      if (a.signatures.length < o.m)
        throw new TypeError('Not enough signatures provided');
      if (a.signatures.length > o.m)
        throw new TypeError('Too many signatures provided');
    }
    if (a.input) {
      if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');
      if (
        o.signatures.length === 0 ||
        !o.signatures.every(isAcceptableSignature)
      )
        throw new TypeError('Input has invalid signature(s)');
      if (a.signatures && !stacksEqual(a.signatures, o.signatures))
        throw new TypeError('Signature mismatch');
      if (a.m !== undefined && a.m !== a.signatures.length)
        throw new TypeError('Signature count mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2ms = p2ms;


/***/ }),

/***/ 97759:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p2pk = void 0;
const networks_1 = __webpack_require__(74378);
const bscript = __webpack_require__(73357);
const types_1 = __webpack_require__(41838);
const lazy = __webpack_require__(52691);
const OPS = bscript.OPS;
// input: {signature}
// output: {pubKey} OP_CHECKSIG
function p2pk(a, opts) {
  if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
      pubkey: types_1.typeforce.maybe(types_1.isPoint),
      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
    },
    a,
  );
  const _chunks = lazy.value(() => {
    return bscript.decompile(a.input);
  });
  const network = a.network || networks_1.bitcoin;
  const o = { name: 'p2pk', network };
  lazy.prop(o, 'output', () => {
    if (!a.pubkey) return;
    return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);
  });
  lazy.prop(o, 'pubkey', () => {
    if (!a.output) return;
    return a.output.slice(1, -1);
  });
  lazy.prop(o, 'signature', () => {
    if (!a.input) return;
    return _chunks()[0];
  });
  lazy.prop(o, 'input', () => {
    if (!a.signature) return;
    return bscript.compile([a.signature]);
  });
  lazy.prop(o, 'witness', () => {
    if (!o.input) return;
    return [];
  });
  // extended validation
  if (opts.validate) {
    if (a.output) {
      if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)
        throw new TypeError('Output is invalid');
      if (!(0, types_1.isPoint)(o.pubkey))
        throw new TypeError('Output pubkey is invalid');
      if (a.pubkey && !a.pubkey.equals(o.pubkey))
        throw new TypeError('Pubkey mismatch');
    }
    if (a.signature) {
      if (a.input && !a.input.equals(o.input))
        throw new TypeError('Signature mismatch');
    }
    if (a.input) {
      if (_chunks().length !== 1) throw new TypeError('Input is invalid');
      if (!bscript.isCanonicalScriptSignature(o.signature))
        throw new TypeError('Input has invalid signature');
    }
  }
  return Object.assign(o, a);
}
exports.p2pk = p2pk;


/***/ }),

/***/ 44483:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p2pkh = void 0;
const bcrypto = __webpack_require__(5525);
const networks_1 = __webpack_require__(74378);
const bscript = __webpack_require__(73357);
const types_1 = __webpack_require__(41838);
const lazy = __webpack_require__(52691);
const bs58check = __webpack_require__(58334);
const OPS = bscript.OPS;
// input: {signature} {pubkey}
// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG
function p2pkh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(25)),
      pubkey: types_1.typeforce.maybe(types_1.isPoint),
      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
    },
    a,
  );
  const _address = lazy.value(() => {
    const payload = Buffer.from(bs58check.decode(a.address));
    const version = payload.readUInt8(0);
    const hash = payload.slice(1);
    return { version, hash };
  });
  const _chunks = lazy.value(() => {
    return bscript.decompile(a.input);
  });
  const network = a.network || networks_1.bitcoin;
  const o = { name: 'p2pkh', network };
  lazy.prop(o, 'address', () => {
    if (!o.hash) return;
    const payload = Buffer.allocUnsafe(21);
    payload.writeUInt8(network.pubKeyHash, 0);
    o.hash.copy(payload, 1);
    return bs58check.encode(payload);
  });
  lazy.prop(o, 'hash', () => {
    if (a.output) return a.output.slice(3, 23);
    if (a.address) return _address().hash;
    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
  });
  lazy.prop(o, 'output', () => {
    if (!o.hash) return;
    return bscript.compile([
      OPS.OP_DUP,
      OPS.OP_HASH160,
      o.hash,
      OPS.OP_EQUALVERIFY,
      OPS.OP_CHECKSIG,
    ]);
  });
  lazy.prop(o, 'pubkey', () => {
    if (!a.input) return;
    return _chunks()[1];
  });
  lazy.prop(o, 'signature', () => {
    if (!a.input) return;
    return _chunks()[0];
  });
  lazy.prop(o, 'input', () => {
    if (!a.pubkey) return;
    if (!a.signature) return;
    return bscript.compile([a.signature, a.pubkey]);
  });
  lazy.prop(o, 'witness', () => {
    if (!o.input) return;
    return [];
  });
  // extended validation
  if (opts.validate) {
    let hash = Buffer.from([]);
    if (a.address) {
      if (_address().version !== network.pubKeyHash)
        throw new TypeError('Invalid version or Network mismatch');
      if (_address().hash.length !== 20) throw new TypeError('Invalid address');
      hash = _address().hash;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash))
        throw new TypeError('Hash mismatch');
      else hash = a.hash;
    }
    if (a.output) {
      if (
        a.output.length !== 25 ||
        a.output[0] !== OPS.OP_DUP ||
        a.output[1] !== OPS.OP_HASH160 ||
        a.output[2] !== 0x14 ||
        a.output[23] !== OPS.OP_EQUALVERIFY ||
        a.output[24] !== OPS.OP_CHECKSIG
      )
        throw new TypeError('Output is invalid');
      const hash2 = a.output.slice(3, 23);
      if (hash.length > 0 && !hash.equals(hash2))
        throw new TypeError('Hash mismatch');
      else hash = hash2;
    }
    if (a.pubkey) {
      const pkh = bcrypto.hash160(a.pubkey);
      if (hash.length > 0 && !hash.equals(pkh))
        throw new TypeError('Hash mismatch');
      else hash = pkh;
    }
    if (a.input) {
      const chunks = _chunks();
      if (chunks.length !== 2) throw new TypeError('Input is invalid');
      if (!bscript.isCanonicalScriptSignature(chunks[0]))
        throw new TypeError('Input has invalid signature');
      if (!(0, types_1.isPoint)(chunks[1]))
        throw new TypeError('Input has invalid pubkey');
      if (a.signature && !a.signature.equals(chunks[0]))
        throw new TypeError('Signature mismatch');
      if (a.pubkey && !a.pubkey.equals(chunks[1]))
        throw new TypeError('Pubkey mismatch');
      const pkh = bcrypto.hash160(chunks[1]);
      if (hash.length > 0 && !hash.equals(pkh))
        throw new TypeError('Hash mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2pkh = p2pkh;


/***/ }),

/***/ 21160:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p2sh = void 0;
const bcrypto = __webpack_require__(5525);
const networks_1 = __webpack_require__(74378);
const bscript = __webpack_require__(73357);
const types_1 = __webpack_require__(41838);
const lazy = __webpack_require__(52691);
const bs58check = __webpack_require__(58334);
const OPS = bscript.OPS;
function stacksEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every((x, i) => {
    return x.equals(b[i]);
  });
}
// input: [redeemScriptSig ...] {redeemScript}
// witness: <?>
// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL
function p2sh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(23)),
      redeem: types_1.typeforce.maybe({
        network: types_1.typeforce.maybe(types_1.typeforce.Object),
        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        witness: types_1.typeforce.maybe(
          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
        ),
      }),
      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
      witness: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
    },
    a,
  );
  let network = a.network;
  if (!network) {
    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;
  }
  const o = { network };
  const _address = lazy.value(() => {
    const payload = Buffer.from(bs58check.decode(a.address));
    const version = payload.readUInt8(0);
    const hash = payload.slice(1);
    return { version, hash };
  });
  const _chunks = lazy.value(() => {
    return bscript.decompile(a.input);
  });
  const _redeem = lazy.value(() => {
    const chunks = _chunks();
    const lastChunk = chunks[chunks.length - 1];
    return {
      network,
      output: lastChunk === OPS.OP_FALSE ? Buffer.from([]) : lastChunk,
      input: bscript.compile(chunks.slice(0, -1)),
      witness: a.witness || [],
    };
  });
  // output dependents
  lazy.prop(o, 'address', () => {
    if (!o.hash) return;
    const payload = Buffer.allocUnsafe(21);
    payload.writeUInt8(o.network.scriptHash, 0);
    o.hash.copy(payload, 1);
    return bs58check.encode(payload);
  });
  lazy.prop(o, 'hash', () => {
    // in order of least effort
    if (a.output) return a.output.slice(2, 22);
    if (a.address) return _address().hash;
    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);
  });
  lazy.prop(o, 'output', () => {
    if (!o.hash) return;
    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);
  });
  // input dependents
  lazy.prop(o, 'redeem', () => {
    if (!a.input) return;
    return _redeem();
  });
  lazy.prop(o, 'input', () => {
    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;
    return bscript.compile(
      [].concat(bscript.decompile(a.redeem.input), a.redeem.output),
    );
  });
  lazy.prop(o, 'witness', () => {
    if (o.redeem && o.redeem.witness) return o.redeem.witness;
    if (o.input) return [];
  });
  lazy.prop(o, 'name', () => {
    const nameParts = ['p2sh'];
    if (o.redeem !== undefined && o.redeem.name !== undefined)
      nameParts.push(o.redeem.name);
    return nameParts.join('-');
  });
  if (opts.validate) {
    let hash = Buffer.from([]);
    if (a.address) {
      if (_address().version !== network.scriptHash)
        throw new TypeError('Invalid version or Network mismatch');
      if (_address().hash.length !== 20) throw new TypeError('Invalid address');
      hash = _address().hash;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash))
        throw new TypeError('Hash mismatch');
      else hash = a.hash;
    }
    if (a.output) {
      if (
        a.output.length !== 23 ||
        a.output[0] !== OPS.OP_HASH160 ||
        a.output[1] !== 0x14 ||
        a.output[22] !== OPS.OP_EQUAL
      )
        throw new TypeError('Output is invalid');
      const hash2 = a.output.slice(2, 22);
      if (hash.length > 0 && !hash.equals(hash2))
        throw new TypeError('Hash mismatch');
      else hash = hash2;
    }
    // inlined to prevent 'no-inner-declarations' failing
    const checkRedeem = redeem => {
      // is the redeem output empty/invalid?
      if (redeem.output) {
        const decompile = bscript.decompile(redeem.output);
        if (!decompile || decompile.length < 1)
          throw new TypeError('Redeem.output too short');
        if (redeem.output.byteLength > 520)
          throw new TypeError(
            'Redeem.output unspendable if larger than 520 bytes',
          );
        if (bscript.countNonPushOnlyOPs(decompile) > 201)
          throw new TypeError(
            'Redeem.output unspendable with more than 201 non-push ops',
          );
        // match hash against other sources
        const hash2 = bcrypto.hash160(redeem.output);
        if (hash.length > 0 && !hash.equals(hash2))
          throw new TypeError('Hash mismatch');
        else hash = hash2;
      }
      if (redeem.input) {
        const hasInput = redeem.input.length > 0;
        const hasWitness = redeem.witness && redeem.witness.length > 0;
        if (!hasInput && !hasWitness) throw new TypeError('Empty input');
        if (hasInput && hasWitness)
          throw new TypeError('Input and witness provided');
        if (hasInput) {
          const richunks = bscript.decompile(redeem.input);
          if (!bscript.isPushOnly(richunks))
            throw new TypeError('Non push-only scriptSig');
        }
      }
    };
    if (a.input) {
      const chunks = _chunks();
      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');
      if (!Buffer.isBuffer(_redeem().output))
        throw new TypeError('Input is invalid');
      checkRedeem(_redeem());
    }
    if (a.redeem) {
      if (a.redeem.network && a.redeem.network !== network)
        throw new TypeError('Network mismatch');
      if (a.input) {
        const redeem = _redeem();
        if (a.redeem.output && !a.redeem.output.equals(redeem.output))
          throw new TypeError('Redeem.output mismatch');
        if (a.redeem.input && !a.redeem.input.equals(redeem.input))
          throw new TypeError('Redeem.input mismatch');
      }
      checkRedeem(a.redeem);
    }
    if (a.witness) {
      if (
        a.redeem &&
        a.redeem.witness &&
        !stacksEqual(a.redeem.witness, a.witness)
      )
        throw new TypeError('Witness and redeem.witness mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2sh = p2sh;


/***/ }),

/***/ 10079:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p2tr = void 0;
const buffer_1 = __webpack_require__(48764);
const networks_1 = __webpack_require__(74378);
const bscript = __webpack_require__(73357);
const types_1 = __webpack_require__(41838);
const ecc_lib_1 = __webpack_require__(66379);
const bip341_1 = __webpack_require__(12227);
const lazy = __webpack_require__(52691);
const bech32_1 = __webpack_require__(27715);
const OPS = bscript.OPS;
const TAPROOT_WITNESS_VERSION = 0x01;
const ANNEX_PREFIX = 0x50;
function p2tr(a, opts) {
  if (
    !a.address &&
    !a.output &&
    !a.pubkey &&
    !a.internalPubkey &&
    !(a.witness && a.witness.length > 1)
  )
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),
      internalPubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
      pubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
      signature: types_1.typeforce.maybe(
        types_1.typeforce.anyOf(
          types_1.typeforce.BufferN(64),
          types_1.typeforce.BufferN(65),
        ),
      ),
      witness: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
      scriptTree: types_1.typeforce.maybe(types_1.isTaptree),
      redeem: types_1.typeforce.maybe({
        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),
        witness: types_1.typeforce.maybe(
          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
        ),
      }),
      redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),
    },
    a,
  );
  const _address = lazy.value(() => {
    const result = bech32_1.bech32m.decode(a.address);
    const version = result.words.shift();
    const data = bech32_1.bech32m.fromWords(result.words);
    return {
      version,
      prefix: result.prefix,
      data: buffer_1.Buffer.from(data),
    };
  });
  // remove annex if present, ignored by taproot
  const _witness = lazy.value(() => {
    if (!a.witness || !a.witness.length) return;
    if (
      a.witness.length >= 2 &&
      a.witness[a.witness.length - 1][0] === ANNEX_PREFIX
    ) {
      return a.witness.slice(0, -1);
    }
    return a.witness.slice();
  });
  const _hashTree = lazy.value(() => {
    if (a.scriptTree) return (0, bip341_1.toHashTree)(a.scriptTree);
    if (a.hash) return { hash: a.hash };
    return;
  });
  const network = a.network || networks_1.bitcoin;
  const o = { name: 'p2tr', network };
  lazy.prop(o, 'address', () => {
    if (!o.pubkey) return;
    const words = bech32_1.bech32m.toWords(o.pubkey);
    words.unshift(TAPROOT_WITNESS_VERSION);
    return bech32_1.bech32m.encode(network.bech32, words);
  });
  lazy.prop(o, 'hash', () => {
    const hashTree = _hashTree();
    if (hashTree) return hashTree.hash;
    const w = _witness();
    if (w && w.length > 1) {
      const controlBlock = w[w.length - 1];
      const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;
      const script = w[w.length - 2];
      const leafHash = (0, bip341_1.tapleafHash)({
        output: script,
        version: leafVersion,
      });
      return (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);
    }
    return null;
  });
  lazy.prop(o, 'output', () => {
    if (!o.pubkey) return;
    return bscript.compile([OPS.OP_1, o.pubkey]);
  });
  lazy.prop(o, 'redeemVersion', () => {
    if (a.redeemVersion) return a.redeemVersion;
    if (
      a.redeem &&
      a.redeem.redeemVersion !== undefined &&
      a.redeem.redeemVersion !== null
    ) {
      return a.redeem.redeemVersion;
    }
    return bip341_1.LEAF_VERSION_TAPSCRIPT;
  });
  lazy.prop(o, 'redeem', () => {
    const witness = _witness(); // witness without annex
    if (!witness || witness.length < 2) return;
    return {
      output: witness[witness.length - 2],
      witness: witness.slice(0, -2),
      redeemVersion:
        witness[witness.length - 1][0] & types_1.TAPLEAF_VERSION_MASK,
    };
  });
  lazy.prop(o, 'pubkey', () => {
    if (a.pubkey) return a.pubkey;
    if (a.output) return a.output.slice(2);
    if (a.address) return _address().data;
    if (o.internalPubkey) {
      const tweakedKey = (0, bip341_1.tweakKey)(o.internalPubkey, o.hash);
      if (tweakedKey) return tweakedKey.x;
    }
  });
  lazy.prop(o, 'internalPubkey', () => {
    if (a.internalPubkey) return a.internalPubkey;
    const witness = _witness();
    if (witness && witness.length > 1)
      return witness[witness.length - 1].slice(1, 33);
  });
  lazy.prop(o, 'signature', () => {
    if (a.signature) return a.signature;
    const witness = _witness(); // witness without annex
    if (!witness || witness.length !== 1) return;
    return witness[0];
  });
  lazy.prop(o, 'witness', () => {
    if (a.witness) return a.witness;
    const hashTree = _hashTree();
    if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {
      const leafHash = (0, bip341_1.tapleafHash)({
        output: a.redeem.output,
        version: o.redeemVersion,
      });
      const path = (0, bip341_1.findScriptPath)(hashTree, leafHash);
      if (!path) return;
      const outputKey = (0, bip341_1.tweakKey)(a.internalPubkey, hashTree.hash);
      if (!outputKey) return;
      const controlBock = buffer_1.Buffer.concat(
        [
          buffer_1.Buffer.from([o.redeemVersion | outputKey.parity]),
          a.internalPubkey,
        ].concat(path),
      );
      return [a.redeem.output, controlBock];
    }
    if (a.signature) return [a.signature];
  });
  // extended validation
  if (opts.validate) {
    let pubkey = buffer_1.Buffer.from([]);
    if (a.address) {
      if (network && network.bech32 !== _address().prefix)
        throw new TypeError('Invalid prefix or Network mismatch');
      if (_address().version !== TAPROOT_WITNESS_VERSION)
        throw new TypeError('Invalid address version');
      if (_address().data.length !== 32)
        throw new TypeError('Invalid address data');
      pubkey = _address().data;
    }
    if (a.pubkey) {
      if (pubkey.length > 0 && !pubkey.equals(a.pubkey))
        throw new TypeError('Pubkey mismatch');
      else pubkey = a.pubkey;
    }
    if (a.output) {
      if (
        a.output.length !== 34 ||
        a.output[0] !== OPS.OP_1 ||
        a.output[1] !== 0x20
      )
        throw new TypeError('Output is invalid');
      if (pubkey.length > 0 && !pubkey.equals(a.output.slice(2)))
        throw new TypeError('Pubkey mismatch');
      else pubkey = a.output.slice(2);
    }
    if (a.internalPubkey) {
      const tweakedKey = (0, bip341_1.tweakKey)(a.internalPubkey, o.hash);
      if (pubkey.length > 0 && !pubkey.equals(tweakedKey.x))
        throw new TypeError('Pubkey mismatch');
      else pubkey = tweakedKey.x;
    }
    if (pubkey && pubkey.length) {
      if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(pubkey))
        throw new TypeError('Invalid pubkey for p2tr');
    }
    const hashTree = _hashTree();
    if (a.hash && hashTree) {
      if (!a.hash.equals(hashTree.hash)) throw new TypeError('Hash mismatch');
    }
    if (a.redeem && a.redeem.output && hashTree) {
      const leafHash = (0, bip341_1.tapleafHash)({
        output: a.redeem.output,
        version: o.redeemVersion,
      });
      if (!(0, bip341_1.findScriptPath)(hashTree, leafHash))
        throw new TypeError('Redeem script not in tree');
    }
    const witness = _witness();
    // compare the provided redeem data with the one computed from witness
    if (a.redeem && o.redeem) {
      if (a.redeem.redeemVersion) {
        if (a.redeem.redeemVersion !== o.redeem.redeemVersion)
          throw new TypeError('Redeem.redeemVersion and witness mismatch');
      }
      if (a.redeem.output) {
        if (bscript.decompile(a.redeem.output).length === 0)
          throw new TypeError('Redeem.output is invalid');
        // output redeem is constructed from the witness
        if (o.redeem.output && !a.redeem.output.equals(o.redeem.output))
          throw new TypeError('Redeem.output and witness mismatch');
      }
      if (a.redeem.witness) {
        if (
          o.redeem.witness &&
          !stacksEqual(a.redeem.witness, o.redeem.witness)
        )
          throw new TypeError('Redeem.witness and witness mismatch');
      }
    }
    if (witness && witness.length) {
      if (witness.length === 1) {
        // key spending
        if (a.signature && !a.signature.equals(witness[0]))
          throw new TypeError('Signature mismatch');
      } else {
        // script path spending
        const controlBlock = witness[witness.length - 1];
        if (controlBlock.length < 33)
          throw new TypeError(
            `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,
          );
        if ((controlBlock.length - 33) % 32 !== 0)
          throw new TypeError(
            `The control-block length of ${controlBlock.length} is incorrect!`,
          );
        const m = (controlBlock.length - 33) / 32;
        if (m > 128)
          throw new TypeError(
            `The script path is too long. Got ${m}, expected max 128.`,
          );
        const internalPubkey = controlBlock.slice(1, 33);
        if (a.internalPubkey && !a.internalPubkey.equals(internalPubkey))
          throw new TypeError('Internal pubkey mismatch');
        if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(internalPubkey))
          throw new TypeError('Invalid internalPubkey for p2tr witness');
        const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;
        const script = witness[witness.length - 2];
        const leafHash = (0, bip341_1.tapleafHash)({
          output: script,
          version: leafVersion,
        });
        const hash = (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);
        const outputKey = (0, bip341_1.tweakKey)(internalPubkey, hash);
        if (!outputKey)
          // todo: needs test data
          throw new TypeError('Invalid outputKey for p2tr witness');
        if (pubkey.length && !pubkey.equals(outputKey.x))
          throw new TypeError('Pubkey mismatch for p2tr witness');
        if (outputKey.parity !== (controlBlock[0] & 1))
          throw new Error('Incorrect parity');
      }
    }
  }
  return Object.assign(o, a);
}
exports.p2tr = p2tr;
function stacksEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every((x, i) => {
    return x.equals(b[i]);
  });
}


/***/ }),

/***/ 18810:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p2wpkh = void 0;
const bcrypto = __webpack_require__(5525);
const networks_1 = __webpack_require__(74378);
const bscript = __webpack_require__(73357);
const types_1 = __webpack_require__(41838);
const lazy = __webpack_require__(52691);
const bech32_1 = __webpack_require__(27715);
const OPS = bscript.OPS;
const EMPTY_BUFFER = Buffer.alloc(0);
// witness: {signature} {pubKey}
// input: <>
// output: OP_0 {pubKeyHash}
function p2wpkh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(22)),
      pubkey: types_1.typeforce.maybe(types_1.isPoint),
      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
      witness: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
    },
    a,
  );
  const _address = lazy.value(() => {
    const result = bech32_1.bech32.decode(a.address);
    const version = result.words.shift();
    const data = bech32_1.bech32.fromWords(result.words);
    return {
      version,
      prefix: result.prefix,
      data: Buffer.from(data),
    };
  });
  const network = a.network || networks_1.bitcoin;
  const o = { name: 'p2wpkh', network };
  lazy.prop(o, 'address', () => {
    if (!o.hash) return;
    const words = bech32_1.bech32.toWords(o.hash);
    words.unshift(0x00);
    return bech32_1.bech32.encode(network.bech32, words);
  });
  lazy.prop(o, 'hash', () => {
    if (a.output) return a.output.slice(2, 22);
    if (a.address) return _address().data;
    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);
  });
  lazy.prop(o, 'output', () => {
    if (!o.hash) return;
    return bscript.compile([OPS.OP_0, o.hash]);
  });
  lazy.prop(o, 'pubkey', () => {
    if (a.pubkey) return a.pubkey;
    if (!a.witness) return;
    return a.witness[1];
  });
  lazy.prop(o, 'signature', () => {
    if (!a.witness) return;
    return a.witness[0];
  });
  lazy.prop(o, 'input', () => {
    if (!o.witness) return;
    return EMPTY_BUFFER;
  });
  lazy.prop(o, 'witness', () => {
    if (!a.pubkey) return;
    if (!a.signature) return;
    return [a.signature, a.pubkey];
  });
  // extended validation
  if (opts.validate) {
    let hash = Buffer.from([]);
    if (a.address) {
      if (network && network.bech32 !== _address().prefix)
        throw new TypeError('Invalid prefix or Network mismatch');
      if (_address().version !== 0x00)
        throw new TypeError('Invalid address version');
      if (_address().data.length !== 20)
        throw new TypeError('Invalid address data');
      hash = _address().data;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash))
        throw new TypeError('Hash mismatch');
      else hash = a.hash;
    }
    if (a.output) {
      if (
        a.output.length !== 22 ||
        a.output[0] !== OPS.OP_0 ||
        a.output[1] !== 0x14
      )
        throw new TypeError('Output is invalid');
      if (hash.length > 0 && !hash.equals(a.output.slice(2)))
        throw new TypeError('Hash mismatch');
      else hash = a.output.slice(2);
    }
    if (a.pubkey) {
      const pkh = bcrypto.hash160(a.pubkey);
      if (hash.length > 0 && !hash.equals(pkh))
        throw new TypeError('Hash mismatch');
      else hash = pkh;
      if (!(0, types_1.isPoint)(a.pubkey) || a.pubkey.length !== 33)
        throw new TypeError('Invalid pubkey for p2wpkh');
    }
    if (a.witness) {
      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');
      if (!bscript.isCanonicalScriptSignature(a.witness[0]))
        throw new TypeError('Witness has invalid signature');
      if (!(0, types_1.isPoint)(a.witness[1]) || a.witness[1].length !== 33)
        throw new TypeError('Witness has invalid pubkey');
      if (a.signature && !a.signature.equals(a.witness[0]))
        throw new TypeError('Signature mismatch');
      if (a.pubkey && !a.pubkey.equals(a.witness[1]))
        throw new TypeError('Pubkey mismatch');
      const pkh = bcrypto.hash160(a.witness[1]);
      if (hash.length > 0 && !hash.equals(pkh))
        throw new TypeError('Hash mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2wpkh = p2wpkh;


/***/ }),

/***/ 82401:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.p2wsh = void 0;
const bcrypto = __webpack_require__(5525);
const networks_1 = __webpack_require__(74378);
const bscript = __webpack_require__(73357);
const types_1 = __webpack_require__(41838);
const lazy = __webpack_require__(52691);
const bech32_1 = __webpack_require__(27715);
const OPS = bscript.OPS;
const EMPTY_BUFFER = Buffer.alloc(0);
function stacksEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every((x, i) => {
    return x.equals(b[i]);
  });
}
function chunkHasUncompressedPubkey(chunk) {
  if (
    Buffer.isBuffer(chunk) &&
    chunk.length === 65 &&
    chunk[0] === 0x04 &&
    (0, types_1.isPoint)(chunk)
  ) {
    return true;
  } else {
    return false;
  }
}
// input: <>
// witness: [redeemScriptSig ...] {redeemScript}
// output: OP_0 {sha256(redeemScript)}
function p2wsh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)
    throw new TypeError('Not enough data');
  opts = Object.assign({ validate: true }, opts || {});
  (0, types_1.typeforce)(
    {
      network: types_1.typeforce.maybe(types_1.typeforce.Object),
      address: types_1.typeforce.maybe(types_1.typeforce.String),
      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),
      redeem: types_1.typeforce.maybe({
        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        network: types_1.typeforce.maybe(types_1.typeforce.Object),
        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
        witness: types_1.typeforce.maybe(
          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
        ),
      }),
      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
      witness: types_1.typeforce.maybe(
        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),
      ),
    },
    a,
  );
  const _address = lazy.value(() => {
    const result = bech32_1.bech32.decode(a.address);
    const version = result.words.shift();
    const data = bech32_1.bech32.fromWords(result.words);
    return {
      version,
      prefix: result.prefix,
      data: Buffer.from(data),
    };
  });
  const _rchunks = lazy.value(() => {
    return bscript.decompile(a.redeem.input);
  });
  let network = a.network;
  if (!network) {
    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;
  }
  const o = { network };
  lazy.prop(o, 'address', () => {
    if (!o.hash) return;
    const words = bech32_1.bech32.toWords(o.hash);
    words.unshift(0x00);
    return bech32_1.bech32.encode(network.bech32, words);
  });
  lazy.prop(o, 'hash', () => {
    if (a.output) return a.output.slice(2);
    if (a.address) return _address().data;
    if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);
  });
  lazy.prop(o, 'output', () => {
    if (!o.hash) return;
    return bscript.compile([OPS.OP_0, o.hash]);
  });
  lazy.prop(o, 'redeem', () => {
    if (!a.witness) return;
    return {
      output: a.witness[a.witness.length - 1],
      input: EMPTY_BUFFER,
      witness: a.witness.slice(0, -1),
    };
  });
  lazy.prop(o, 'input', () => {
    if (!o.witness) return;
    return EMPTY_BUFFER;
  });
  lazy.prop(o, 'witness', () => {
    // transform redeem input to witness stack?
    if (
      a.redeem &&
      a.redeem.input &&
      a.redeem.input.length > 0 &&
      a.redeem.output &&
      a.redeem.output.length > 0
    ) {
      const stack = bscript.toStack(_rchunks());
      // assign, and blank the existing input
      o.redeem = Object.assign({ witness: stack }, a.redeem);
      o.redeem.input = EMPTY_BUFFER;
      return [].concat(stack, a.redeem.output);
    }
    if (!a.redeem) return;
    if (!a.redeem.output) return;
    if (!a.redeem.witness) return;
    return [].concat(a.redeem.witness, a.redeem.output);
  });
  lazy.prop(o, 'name', () => {
    const nameParts = ['p2wsh'];
    if (o.redeem !== undefined && o.redeem.name !== undefined)
      nameParts.push(o.redeem.name);
    return nameParts.join('-');
  });
  // extended validation
  if (opts.validate) {
    let hash = Buffer.from([]);
    if (a.address) {
      if (_address().prefix !== network.bech32)
        throw new TypeError('Invalid prefix or Network mismatch');
      if (_address().version !== 0x00)
        throw new TypeError('Invalid address version');
      if (_address().data.length !== 32)
        throw new TypeError('Invalid address data');
      hash = _address().data;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash))
        throw new TypeError('Hash mismatch');
      else hash = a.hash;
    }
    if (a.output) {
      if (
        a.output.length !== 34 ||
        a.output[0] !== OPS.OP_0 ||
        a.output[1] !== 0x20
      )
        throw new TypeError('Output is invalid');
      const hash2 = a.output.slice(2);
      if (hash.length > 0 && !hash.equals(hash2))
        throw new TypeError('Hash mismatch');
      else hash = hash2;
    }
    if (a.redeem) {
      if (a.redeem.network && a.redeem.network !== network)
        throw new TypeError('Network mismatch');
      // is there two redeem sources?
      if (
        a.redeem.input &&
        a.redeem.input.length > 0 &&
        a.redeem.witness &&
        a.redeem.witness.length > 0
      )
        throw new TypeError('Ambiguous witness source');
      // is the redeem output non-empty/valid?
      if (a.redeem.output) {
        const decompile = bscript.decompile(a.redeem.output);
        if (!decompile || decompile.length < 1)
          throw new TypeError('Redeem.output is invalid');
        if (a.redeem.output.byteLength > 3600)
          throw new TypeError(
            'Redeem.output unspendable if larger than 3600 bytes',
          );
        if (bscript.countNonPushOnlyOPs(decompile) > 201)
          throw new TypeError(
            'Redeem.output unspendable with more than 201 non-push ops',
          );
        // match hash against other sources
        const hash2 = bcrypto.sha256(a.redeem.output);
        if (hash.length > 0 && !hash.equals(hash2))
          throw new TypeError('Hash mismatch');
        else hash = hash2;
      }
      if (a.redeem.input && !bscript.isPushOnly(_rchunks()))
        throw new TypeError('Non push-only scriptSig');
      if (
        a.witness &&
        a.redeem.witness &&
        !stacksEqual(a.witness, a.redeem.witness)
      )
        throw new TypeError('Witness and redeem.witness mismatch');
      if (
        (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey)) ||
        (a.redeem.output &&
          (bscript.decompile(a.redeem.output) || []).some(
            chunkHasUncompressedPubkey,
          ))
      ) {
        throw new TypeError(
          'redeem.input or redeem.output contains uncompressed pubkey',
        );
      }
    }
    if (a.witness && a.witness.length > 0) {
      const wScript = a.witness[a.witness.length - 1];
      if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))
        throw new TypeError('Witness and redeem.output mismatch');
      if (
        a.witness.some(chunkHasUncompressedPubkey) ||
        (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey)
      )
        throw new TypeError('Witness contains uncompressed pubkey');
    }
  }
  return Object.assign(o, a);
}
exports.p2wsh = p2wsh;


/***/ }),

/***/ 99930:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Psbt = void 0;
const bip174_1 = __webpack_require__(95011);
const varuint = __webpack_require__(3493);
const utils_1 = __webpack_require__(96403);
const address_1 = __webpack_require__(95488);
const bufferutils_1 = __webpack_require__(9357);
const networks_1 = __webpack_require__(74378);
const payments = __webpack_require__(84972);
const bip341_1 = __webpack_require__(12227);
const bscript = __webpack_require__(73357);
const transaction_1 = __webpack_require__(82737);
const bip371_1 = __webpack_require__(23064);
const psbtutils_1 = __webpack_require__(87929);
/**
 * These are the default arguments for a Psbt instance.
 */
const DEFAULT_OPTS = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: networks_1.bitcoin,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5000, // satoshi per byte
};
/**
 * Psbt class can parse and generate a PSBT binary based off of the BIP174.
 * There are 6 roles that this class fulfills. (Explained in BIP174)
 *
 * Creator: This can be done with `new Psbt()`
 * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,
 *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to
 *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,
 *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`
 *   addInput requires hash: Buffer | string; and index: number; as attributes
 *   and can also include any attributes that are used in updateInput method.
 *   addOutput requires script: Buffer; and value: number; and likewise can include
 *   data for updateOutput.
 *   For a list of what attributes should be what types. Check the bip174 library.
 *   Also, check the integration tests for some examples of usage.
 * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input
 *   information for your pubkey or pubkeyhash, and only sign inputs where it finds
 *   your info. Or you can explicitly sign a specific input with signInput and
 *   signInputAsync. For the async methods you can create a SignerAsync object
 *   and use something like a hardware wallet to sign with. (You must implement this)
 * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`
 *   the psbt calling combine will always have precedence when a conflict occurs.
 *   Combine checks if the internal bitcoin transaction is the same, so be sure that
 *   all sequences, version, locktime, etc. are the same before combining.
 * Input Finalizer: This role is fairly important. Not only does it need to construct
 *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.
 *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`
 *   Running any finalize method will delete any data in the input(s) that are no longer
 *   needed due to the finalized scripts containing the information.
 * Transaction Extractor: This role will perform some checks before returning a
 *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.
 */
class Psbt {
  static fromBase64(data, opts = {}) {
    const buffer = Buffer.from(data, 'base64');
    return this.fromBuffer(buffer, opts);
  }
  static fromHex(data, opts = {}) {
    const buffer = Buffer.from(data, 'hex');
    return this.fromBuffer(buffer, opts);
  }
  static fromBuffer(buffer, opts = {}) {
    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);
    const psbt = new Psbt(opts, psbtBase);
    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);
    return psbt;
  }
  constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {
    this.data = data;
    // set defaults
    this.opts = Object.assign({}, DEFAULT_OPTS, opts);
    this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecesor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: false,
    };
    if (this.data.inputs.length === 0) this.setVersion(2);
    // Make data hidden when enumerating
    const dpew = (obj, attr, enumerable, writable) =>
      Object.defineProperty(obj, attr, {
        enumerable,
        writable,
      });
    dpew(this, '__CACHE', false, true);
    dpew(this, 'opts', false, true);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(version) {
    this.setVersion(version);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(locktime) {
    this.setLocktime(locktime);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map(input => ({
      hash: (0, bufferutils_1.cloneBuffer)(input.hash),
      index: input.index,
      sequence: input.sequence,
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map(output => {
      let address;
      try {
        address = (0, address_1.fromOutputScript)(
          output.script,
          this.opts.network,
        );
      } catch (_) {}
      return {
        script: (0, bufferutils_1.cloneBuffer)(output.script),
        value: output.value,
        address,
      };
    });
  }
  combine(...those) {
    this.data.combine(...those.map(o => o.data));
    return this;
  }
  clone() {
    // TODO: more efficient cloning
    const res = Psbt.fromBuffer(this.data.toBuffer());
    res.opts = JSON.parse(JSON.stringify(this.opts));
    return res;
  }
  setMaximumFeeRate(satoshiPerByte) {
    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw
    this.opts.maximumFeeRate = satoshiPerByte;
  }
  setVersion(version) {
    check32Bit(version);
    checkInputsForPartialSig(this.data.inputs, 'setVersion');
    const c = this.__CACHE;
    c.__TX.version = version;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  setLocktime(locktime) {
    check32Bit(locktime);
    checkInputsForPartialSig(this.data.inputs, 'setLocktime');
    const c = this.__CACHE;
    c.__TX.locktime = locktime;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  setInputSequence(inputIndex, sequence) {
    check32Bit(sequence);
    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');
    const c = this.__CACHE;
    if (c.__TX.ins.length <= inputIndex) {
      throw new Error('Input index too high');
    }
    c.__TX.ins[inputIndex].sequence = sequence;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  addInputs(inputDatas) {
    inputDatas.forEach(inputData => this.addInput(inputData));
    return this;
  }
  addInput(inputData) {
    if (
      arguments.length > 1 ||
      !inputData ||
      inputData.hash === undefined ||
      inputData.index === undefined
    ) {
      throw new Error(
        `Invalid arguments for Psbt.addInput. ` +
          `Requires single object with at least [hash] and [index]`,
      );
    }
    (0, bip371_1.checkTaprootInputFields)(inputData, inputData, 'addInput');
    checkInputsForPartialSig(this.data.inputs, 'addInput');
    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);
    const c = this.__CACHE;
    this.data.addInput(inputData);
    const txIn = c.__TX.ins[c.__TX.ins.length - 1];
    checkTxInputCache(c, txIn);
    const inputIndex = this.data.inputs.length - 1;
    const input = this.data.inputs[inputIndex];
    if (input.nonWitnessUtxo) {
      addNonWitnessTxCache(this.__CACHE, input, inputIndex);
    }
    c.__FEE = undefined;
    c.__FEE_RATE = undefined;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  addOutputs(outputDatas) {
    outputDatas.forEach(outputData => this.addOutput(outputData));
    return this;
  }
  addOutput(outputData) {
    if (
      arguments.length > 1 ||
      !outputData ||
      outputData.value === undefined ||
      (outputData.address === undefined && outputData.script === undefined)
    ) {
      throw new Error(
        `Invalid arguments for Psbt.addOutput. ` +
          `Requires single object with at least [script or address] and [value]`,
      );
    }
    checkInputsForPartialSig(this.data.inputs, 'addOutput');
    const { address } = outputData;
    if (typeof address === 'string') {
      const { network } = this.opts;
      const script = (0, address_1.toOutputScript)(address, network);
      outputData = Object.assign(outputData, { script });
    }
    (0, bip371_1.checkTaprootOutputFields)(outputData, outputData, 'addOutput');
    const c = this.__CACHE;
    this.data.addOutput(outputData);
    c.__FEE = undefined;
    c.__FEE_RATE = undefined;
    c.__EXTRACTED_TX = undefined;
    return this;
  }
  extractTransaction(disableFeeCheck) {
    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');
    const c = this.__CACHE;
    if (!disableFeeCheck) {
      checkFees(this, c, this.opts);
    }
    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;
    const tx = c.__TX.clone();
    inputFinalizeGetAmts(this.data.inputs, tx, c, true);
    return tx;
  }
  getFeeRate() {
    return getTxCacheValue(
      '__FEE_RATE',
      'fee rate',
      this.data.inputs,
      this.__CACHE,
    );
  }
  getFee() {
    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one
    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));
    return this;
  }
  finalizeInput(inputIndex, finalScriptsFunc) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    if ((0, bip371_1.isTaprootInput)(input))
      return this._finalizeTaprootInput(
        inputIndex,
        input,
        undefined,
        finalScriptsFunc,
      );
    return this._finalizeInput(inputIndex, input, finalScriptsFunc);
  }
  finalizeTaprootInput(
    inputIndex,
    tapLeafHashToFinalize,
    finalScriptsFunc = bip371_1.tapScriptFinalizer,
  ) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    if ((0, bip371_1.isTaprootInput)(input))
      return this._finalizeTaprootInput(
        inputIndex,
        input,
        tapLeafHashToFinalize,
        finalScriptsFunc,
      );
    throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);
  }
  _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts) {
    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(
      inputIndex,
      input,
      this.__CACHE,
    );
    if (!script) throw new Error(`No script found for input #${inputIndex}`);
    checkPartialSigSighashes(input);
    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(
      inputIndex,
      input,
      script,
      isSegwit,
      isP2SH,
      isP2WSH,
    );
    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });
    if (finalScriptWitness)
      this.data.updateInput(inputIndex, { finalScriptWitness });
    if (!finalScriptSig && !finalScriptWitness)
      throw new Error(`Unknown error finalizing input #${inputIndex}`);
    this.data.clearFinalizedInput(inputIndex);
    return this;
  }
  _finalizeTaprootInput(
    inputIndex,
    input,
    tapLeafHashToFinalize,
    finalScriptsFunc = bip371_1.tapScriptFinalizer,
  ) {
    if (!input.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${inputIndex}. Missing withness utxo.`,
      );
    // Check key spend first. Increased privacy and reduced block space.
    if (input.tapKeySig) {
      const payment = payments.p2tr({
        output: input.witnessUtxo.script,
        signature: input.tapKeySig,
      });
      const finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
        payment.witness,
      );
      this.data.updateInput(inputIndex, { finalScriptWitness });
    } else {
      const { finalScriptWitness } = finalScriptsFunc(
        inputIndex,
        input,
        tapLeafHashToFinalize,
      );
      this.data.updateInput(inputIndex, { finalScriptWitness });
    }
    this.data.clearFinalizedInput(inputIndex);
    return this;
  }
  getInputType(inputIndex) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);
    const result = getMeaningfulScript(
      script,
      inputIndex,
      'input',
      input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),
      input.witnessScript ||
        redeemFromFinalWitnessScript(input.finalScriptWitness),
    );
    const type = result.type === 'raw' ? '' : result.type + '-';
    const mainType = classifyScript(result.meaningfulScript);
    return type + mainType;
  }
  inputHasPubkey(inputIndex, pubkey) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);
  }
  inputHasHDKey(inputIndex, root) {
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    const derivationIsMine = bip32DerivationIsMine(root);
    return (
      !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine)
    );
  }
  outputHasPubkey(outputIndex, pubkey) {
    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);
    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);
  }
  outputHasHDKey(outputIndex, root) {
    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);
    const derivationIsMine = bip32DerivationIsMine(root);
    return (
      !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)
    );
  }
  validateSignaturesOfAllInputs(validator) {
    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one
    const results = range(this.data.inputs.length).map(idx =>
      this.validateSignaturesOfInput(idx, validator),
    );
    return results.reduce((final, res) => res === true && final, true);
  }
  validateSignaturesOfInput(inputIndex, validator, pubkey) {
    const input = this.data.inputs[inputIndex];
    if ((0, bip371_1.isTaprootInput)(input))
      return this.validateSignaturesOfTaprootInput(
        inputIndex,
        validator,
        pubkey,
      );
    return this._validateSignaturesOfInput(inputIndex, validator, pubkey);
  }
  _validateSignaturesOfInput(inputIndex, validator, pubkey) {
    const input = this.data.inputs[inputIndex];
    const partialSig = (input || {}).partialSig;
    if (!input || !partialSig || partialSig.length < 1)
      throw new Error('No signatures to validate');
    if (typeof validator !== 'function')
      throw new Error('Need validator function to validate signatures');
    const mySigs = pubkey
      ? partialSig.filter(sig => sig.pubkey.equals(pubkey))
      : partialSig;
    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');
    const results = [];
    let hashCache;
    let scriptCache;
    let sighashCache;
    for (const pSig of mySigs) {
      const sig = bscript.signature.decode(pSig.signature);
      const { hash, script } =
        sighashCache !== sig.hashType
          ? getHashForSig(
              inputIndex,
              Object.assign({}, input, { sighashType: sig.hashType }),
              this.__CACHE,
              true,
            )
          : { hash: hashCache, script: scriptCache };
      sighashCache = sig.hashType;
      hashCache = hash;
      scriptCache = script;
      checkScriptForPubkey(pSig.pubkey, script, 'verify');
      results.push(validator(pSig.pubkey, hash, sig.signature));
    }
    return results.every(res => res === true);
  }
  validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {
    const input = this.data.inputs[inputIndex];
    const tapKeySig = (input || {}).tapKeySig;
    const tapScriptSig = (input || {}).tapScriptSig;
    if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))
      throw new Error('No signatures to validate');
    if (typeof validator !== 'function')
      throw new Error('Need validator function to validate signatures');
    pubkey = pubkey && (0, bip371_1.toXOnly)(pubkey);
    const allHashses = pubkey
      ? getTaprootHashesForSig(
          inputIndex,
          input,
          this.data.inputs,
          pubkey,
          this.__CACHE,
        )
      : getAllTaprootHashesForSig(
          inputIndex,
          input,
          this.data.inputs,
          this.__CACHE,
        );
    if (!allHashses.length) throw new Error('No signatures for this pubkey');
    const tapKeyHash = allHashses.find(h => !h.leafHash);
    let validationResultCount = 0;
    if (tapKeySig && tapKeyHash) {
      const isValidTapkeySig = validator(
        tapKeyHash.pubkey,
        tapKeyHash.hash,
        trimTaprootSig(tapKeySig),
      );
      if (!isValidTapkeySig) return false;
      validationResultCount++;
    }
    if (tapScriptSig) {
      for (const tapSig of tapScriptSig) {
        const tapSigHash = allHashses.find(h => tapSig.pubkey.equals(h.pubkey));
        if (tapSigHash) {
          const isValidTapScriptSig = validator(
            tapSig.pubkey,
            tapSigHash.hash,
            trimTaprootSig(tapSig.signature),
          );
          if (!isValidTapScriptSig) return false;
          validationResultCount++;
        }
      }
    }
    return validationResultCount > 0;
  }
  signAllInputsHD(
    hdKeyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
      throw new Error('Need HDSigner to sign input');
    }
    const results = [];
    for (const i of range(this.data.inputs.length)) {
      try {
        this.signInputHD(i, hdKeyPair, sighashTypes);
        results.push(true);
      } catch (err) {
        results.push(false);
      }
    }
    if (results.every(v => v === false)) {
      throw new Error('No inputs were signed');
    }
    return this;
  }
  signAllInputsHDAsync(
    hdKeyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    return new Promise((resolve, reject) => {
      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
        return reject(new Error('Need HDSigner to sign input'));
      }
      const results = [];
      const promises = [];
      for (const i of range(this.data.inputs.length)) {
        promises.push(
          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(
            () => {
              results.push(true);
            },
            () => {
              results.push(false);
            },
          ),
        );
      }
      return Promise.all(promises).then(() => {
        if (results.every(v => v === false)) {
          return reject(new Error('No inputs were signed'));
        }
        resolve();
      });
    });
  }
  signInputHD(
    inputIndex,
    hdKeyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
      throw new Error('Need HDSigner to sign input');
    }
    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));
    return this;
  }
  signInputHDAsync(
    inputIndex,
    hdKeyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    return new Promise((resolve, reject) => {
      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
        return reject(new Error('Need HDSigner to sign input'));
      }
      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
      const promises = signers.map(signer =>
        this.signInputAsync(inputIndex, signer, sighashTypes),
      );
      return Promise.all(promises)
        .then(() => {
          resolve();
        })
        .catch(reject);
    });
  }
  signAllInputs(keyPair, sighashTypes) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error('Need Signer to sign input');
    // TODO: Add a pubkey/pubkeyhash cache to each input
    // as input information is added, then eventually
    // optimize this method.
    const results = [];
    for (const i of range(this.data.inputs.length)) {
      try {
        this.signInput(i, keyPair, sighashTypes);
        results.push(true);
      } catch (err) {
        results.push(false);
      }
    }
    if (results.every(v => v === false)) {
      throw new Error('No inputs were signed');
    }
    return this;
  }
  signAllInputsAsync(keyPair, sighashTypes) {
    return new Promise((resolve, reject) => {
      if (!keyPair || !keyPair.publicKey)
        return reject(new Error('Need Signer to sign input'));
      // TODO: Add a pubkey/pubkeyhash cache to each input
      // as input information is added, then eventually
      // optimize this method.
      const results = [];
      const promises = [];
      for (const [i] of this.data.inputs.entries()) {
        promises.push(
          this.signInputAsync(i, keyPair, sighashTypes).then(
            () => {
              results.push(true);
            },
            () => {
              results.push(false);
            },
          ),
        );
      }
      return Promise.all(promises).then(() => {
        if (results.every(v => v === false)) {
          return reject(new Error('No inputs were signed'));
        }
        resolve();
      });
    });
  }
  signInput(inputIndex, keyPair, sighashTypes) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error('Need Signer to sign input');
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    if ((0, bip371_1.isTaprootInput)(input)) {
      return this._signTaprootInput(
        inputIndex,
        input,
        keyPair,
        undefined,
        sighashTypes,
      );
    }
    return this._signInput(inputIndex, keyPair, sighashTypes);
  }
  signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error('Need Signer to sign input');
    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
    if ((0, bip371_1.isTaprootInput)(input))
      return this._signTaprootInput(
        inputIndex,
        input,
        keyPair,
        tapLeafHashToSign,
        sighashTypes,
      );
    throw new Error(`Input #${inputIndex} is not of type Taproot.`);
  }
  _signInput(
    inputIndex,
    keyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    const { hash, sighashType } = getHashAndSighashType(
      this.data.inputs,
      inputIndex,
      keyPair.publicKey,
      this.__CACHE,
      sighashTypes,
    );
    const partialSig = [
      {
        pubkey: keyPair.publicKey,
        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),
      },
    ];
    this.data.updateInput(inputIndex, { partialSig });
    return this;
  }
  _signTaprootInput(
    inputIndex,
    input,
    keyPair,
    tapLeafHashToSign,
    allowedSighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT],
  ) {
    const hashesForSig = this.checkTaprootHashesForSig(
      inputIndex,
      input,
      keyPair,
      tapLeafHashToSign,
      allowedSighashTypes,
    );
    const tapKeySig = hashesForSig
      .filter(h => !h.leafHash)
      .map(h =>
        (0, bip371_1.serializeTaprootSignature)(
          keyPair.signSchnorr(h.hash),
          input.sighashType,
        ),
      )[0];
    const tapScriptSig = hashesForSig
      .filter(h => !!h.leafHash)
      .map(h => ({
        pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),
        signature: (0, bip371_1.serializeTaprootSignature)(
          keyPair.signSchnorr(h.hash),
          input.sighashType,
        ),
        leafHash: h.leafHash,
      }));
    if (tapKeySig) {
      this.data.updateInput(inputIndex, { tapKeySig });
    }
    if (tapScriptSig.length) {
      this.data.updateInput(inputIndex, { tapScriptSig });
    }
    return this;
  }
  signInputAsync(inputIndex, keyPair, sighashTypes) {
    return Promise.resolve().then(() => {
      if (!keyPair || !keyPair.publicKey)
        throw new Error('Need Signer to sign input');
      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
      if ((0, bip371_1.isTaprootInput)(input))
        return this._signTaprootInputAsync(
          inputIndex,
          input,
          keyPair,
          undefined,
          sighashTypes,
        );
      return this._signInputAsync(inputIndex, keyPair, sighashTypes);
    });
  }
  signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {
    return Promise.resolve().then(() => {
      if (!keyPair || !keyPair.publicKey)
        throw new Error('Need Signer to sign input');
      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
      if ((0, bip371_1.isTaprootInput)(input))
        return this._signTaprootInputAsync(
          inputIndex,
          input,
          keyPair,
          tapLeafHash,
          sighashTypes,
        );
      throw new Error(`Input #${inputIndex} is not of type Taproot.`);
    });
  }
  _signInputAsync(
    inputIndex,
    keyPair,
    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],
  ) {
    const { hash, sighashType } = getHashAndSighashType(
      this.data.inputs,
      inputIndex,
      keyPair.publicKey,
      this.__CACHE,
      sighashTypes,
    );
    return Promise.resolve(keyPair.sign(hash)).then(signature => {
      const partialSig = [
        {
          pubkey: keyPair.publicKey,
          signature: bscript.signature.encode(signature, sighashType),
        },
      ];
      this.data.updateInput(inputIndex, { partialSig });
    });
  }
  async _signTaprootInputAsync(
    inputIndex,
    input,
    keyPair,
    tapLeafHash,
    sighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT],
  ) {
    const hashesForSig = this.checkTaprootHashesForSig(
      inputIndex,
      input,
      keyPair,
      tapLeafHash,
      sighashTypes,
    );
    const signaturePromises = [];
    const tapKeyHash = hashesForSig.filter(h => !h.leafHash)[0];
    if (tapKeyHash) {
      const tapKeySigPromise = Promise.resolve(
        keyPair.signSchnorr(tapKeyHash.hash),
      ).then(sig => {
        return {
          tapKeySig: (0, bip371_1.serializeTaprootSignature)(
            sig,
            input.sighashType,
          ),
        };
      });
      signaturePromises.push(tapKeySigPromise);
    }
    const tapScriptHashes = hashesForSig.filter(h => !!h.leafHash);
    if (tapScriptHashes.length) {
      const tapScriptSigPromises = tapScriptHashes.map(tsh => {
        return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(
          signature => {
            const tapScriptSig = [
              {
                pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),
                signature: (0, bip371_1.serializeTaprootSignature)(
                  signature,
                  input.sighashType,
                ),
                leafHash: tsh.leafHash,
              },
            ];
            return { tapScriptSig };
          },
        );
      });
      signaturePromises.push(...tapScriptSigPromises);
    }
    return Promise.all(signaturePromises).then(results => {
      results.forEach(v => this.data.updateInput(inputIndex, v));
    });
  }
  checkTaprootHashesForSig(
    inputIndex,
    input,
    keyPair,
    tapLeafHashToSign,
    allowedSighashTypes,
  ) {
    if (typeof keyPair.signSchnorr !== 'function')
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${inputIndex}.`,
      );
    const hashesForSig = getTaprootHashesForSig(
      inputIndex,
      input,
      this.data.inputs,
      keyPair.publicKey,
      this.__CACHE,
      tapLeafHashToSign,
      allowedSighashTypes,
    );
    if (!hashesForSig || !hashesForSig.length)
      throw new Error(
        `Can not sign for input #${inputIndex} with the key ${keyPair.publicKey.toString(
          'hex',
        )}`,
      );
    return hashesForSig;
  }
  toBuffer() {
    checkCache(this.__CACHE);
    return this.data.toBuffer();
  }
  toHex() {
    checkCache(this.__CACHE);
    return this.data.toHex();
  }
  toBase64() {
    checkCache(this.__CACHE);
    return this.data.toBase64();
  }
  updateGlobal(updateData) {
    this.data.updateGlobal(updateData);
    return this;
  }
  updateInput(inputIndex, updateData) {
    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);
    (0, bip371_1.checkTaprootInputFields)(
      this.data.inputs[inputIndex],
      updateData,
      'updateInput',
    );
    this.data.updateInput(inputIndex, updateData);
    if (updateData.nonWitnessUtxo) {
      addNonWitnessTxCache(
        this.__CACHE,
        this.data.inputs[inputIndex],
        inputIndex,
      );
    }
    return this;
  }
  updateOutput(outputIndex, updateData) {
    const outputData = this.data.outputs[outputIndex];
    (0, bip371_1.checkTaprootOutputFields)(
      outputData,
      updateData,
      'updateOutput',
    );
    this.data.updateOutput(outputIndex, updateData);
    return this;
  }
  addUnknownKeyValToGlobal(keyVal) {
    this.data.addUnknownKeyValToGlobal(keyVal);
    return this;
  }
  addUnknownKeyValToInput(inputIndex, keyVal) {
    this.data.addUnknownKeyValToInput(inputIndex, keyVal);
    return this;
  }
  addUnknownKeyValToOutput(outputIndex, keyVal) {
    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
    return this;
  }
  clearFinalizedInput(inputIndex) {
    this.data.clearFinalizedInput(inputIndex);
    return this;
  }
}
exports.Psbt = Psbt;
/**
 * This function is needed to pass to the bip174 base class's fromBuffer.
 * It takes the "transaction buffer" portion of the psbt buffer and returns a
 * Transaction (From the bip174 library) interface.
 */
const transactionFromBuffer = buffer => new PsbtTransaction(buffer);
/**
 * This class implements the Transaction interface from bip174 library.
 * It contains a bitcoinjs-lib Transaction object.
 */
class PsbtTransaction {
  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = transaction_1.Transaction.fromBuffer(buffer);
    checkTxEmpty(this.tx);
    Object.defineProperty(this, 'tx', {
      enumerable: false,
      writable: true,
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length,
    };
  }
  addInput(input) {
    if (
      input.hash === undefined ||
      input.index === undefined ||
      (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||
      typeof input.index !== 'number'
    ) {
      throw new Error('Error adding input.');
    }
    const hash =
      typeof input.hash === 'string'
        ? (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash, 'hex'))
        : input.hash;
    this.tx.addInput(hash, input.index, input.sequence);
  }
  addOutput(output) {
    if (
      output.script === undefined ||
      output.value === undefined ||
      !Buffer.isBuffer(output.script) ||
      typeof output.value !== 'number'
    ) {
      throw new Error('Error adding output.');
    }
    this.tx.addOutput(output.script, output.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(input, script, scriptType) {
  switch (scriptType) {
    case 'pubkey':
    case 'pubkeyhash':
    case 'witnesspubkeyhash':
      return hasSigs(1, input.partialSig);
    case 'multisig':
      const p2ms = payments.p2ms({ output: script });
      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);
    default:
      return false;
  }
}
function checkCache(cache) {
  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {
    throw new Error('Not BIP174 compliant, can not export');
  }
}
function hasSigs(neededSigs, partialSig, pubkeys) {
  if (!partialSig) return false;
  let sigs;
  if (pubkeys) {
    sigs = pubkeys
      .map(pkey => {
        const pubkey = compressPubkey(pkey);
        return partialSig.find(pSig => pSig.pubkey.equals(pubkey));
      })
      .filter(v => !!v);
  } else {
    sigs = partialSig;
  }
  if (sigs.length > neededSigs) throw new Error('Too many signatures');
  return sigs.length === neededSigs;
}
function isFinalized(input) {
  return !!input.finalScriptSig || !!input.finalScriptWitness;
}
function bip32DerivationIsMine(root) {
  return d => {
    if (!d.masterFingerprint.equals(root.fingerprint)) return false;
    if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;
    return true;
  };
}
function check32Bit(num) {
  if (
    typeof num !== 'number' ||
    num !== Math.floor(num) ||
    num > 0xffffffff ||
    num < 0
  ) {
    throw new Error('Invalid 32 bit integer');
  }
}
function checkFees(psbt, cache, opts) {
  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();
  const vsize = cache.__EXTRACTED_TX.virtualSize();
  const satoshis = feeRate * vsize;
  if (feeRate >= opts.maximumFeeRate) {
    throw new Error(
      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +
        `fees, which is ${feeRate} satoshi per byte for a transaction ` +
        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +
        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +
        `pass true to the first arg of extractTransaction.`,
    );
  }
}
function checkInputsForPartialSig(inputs, action) {
  inputs.forEach(input => {
    const throws = (0, bip371_1.isTaprootInput)(input)
      ? (0, bip371_1.checkTaprootInputForSigs)(input, action)
      : (0, psbtutils_1.checkInputForSig)(input, action);
    if (throws)
      throw new Error('Can not modify transaction, signatures exist.');
  });
}
function checkPartialSigSighashes(input) {
  if (!input.sighashType || !input.partialSig) return;
  const { partialSig, sighashType } = input;
  partialSig.forEach(pSig => {
    const { hashType } = bscript.signature.decode(pSig.signature);
    if (sighashType !== hashType) {
      throw new Error('Signature sighash does not match input sighash type');
    }
  });
}
function checkScriptForPubkey(pubkey, script, action) {
  if (!(0, psbtutils_1.pubkeyInScript)(pubkey, script)) {
    throw new Error(
      `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,
    );
  }
}
function checkTxEmpty(tx) {
  const isEmpty = tx.ins.every(
    input =>
      input.script &&
      input.script.length === 0 &&
      input.witness &&
      input.witness.length === 0,
  );
  if (!isEmpty) {
    throw new Error('Format Error: Transaction ScriptSigs are not empty');
  }
}
function checkTxForDupeIns(tx, cache) {
  tx.ins.forEach(input => {
    checkTxInputCache(cache, input);
  });
}
function checkTxInputCache(cache, input) {
  const key =
    (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash)).toString('hex') +
    ':' +
    input.index;
  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');
  cache.__TX_IN_CACHE[key] = 1;
}
function scriptCheckerFactory(payment, paymentScriptName) {
  return (inputIndex, scriptPubKey, redeemScript, ioType) => {
    const redeemScriptOutput = payment({
      redeem: { output: redeemScript },
    }).output;
    if (!scriptPubKey.equals(redeemScriptOutput)) {
      throw new Error(
        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`,
      );
    }
  };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');
const checkWitnessScript = scriptCheckerFactory(
  payments.p2wsh,
  'Witness script',
);
function getTxCacheValue(key, name, inputs, c) {
  if (!inputs.every(isFinalized))
    throw new Error(`PSBT must be finalized to calculate ${name}`);
  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;
  if (key === '__FEE' && c.__FEE) return c.__FEE;
  let tx;
  let mustFinalize = true;
  if (c.__EXTRACTED_TX) {
    tx = c.__EXTRACTED_TX;
    mustFinalize = false;
  } else {
    tx = c.__TX.clone();
  }
  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);
  if (key === '__FEE_RATE') return c.__FEE_RATE;
  else if (key === '__FEE') return c.__FEE;
}
function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {
  const scriptType = classifyScript(script);
  if (!canFinalize(input, script, scriptType))
    throw new Error(`Can not finalize input #${inputIndex}`);
  return prepareFinalScripts(
    script,
    scriptType,
    input.partialSig,
    isSegwit,
    isP2SH,
    isP2WSH,
  );
}
function prepareFinalScripts(
  script,
  scriptType,
  partialSig,
  isSegwit,
  isP2SH,
  isP2WSH,
) {
  let finalScriptSig;
  let finalScriptWitness;
  // Wow, the payments API is very handy
  const payment = getPayment(script, scriptType, partialSig);
  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });
  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });
  if (isSegwit) {
    if (p2wsh) {
      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
        p2wsh.witness,
      );
    } else {
      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
        payment.witness,
      );
    }
    if (p2sh) {
      finalScriptSig = p2sh.input;
    }
  } else {
    if (p2sh) {
      finalScriptSig = p2sh.input;
    } else {
      finalScriptSig = payment.input;
    }
  }
  return {
    finalScriptSig,
    finalScriptWitness,
  };
}
function getHashAndSighashType(
  inputs,
  inputIndex,
  pubkey,
  cache,
  sighashTypes,
) {
  const input = (0, utils_1.checkForInput)(inputs, inputIndex);
  const { hash, sighashType, script } = getHashForSig(
    inputIndex,
    input,
    cache,
    false,
    sighashTypes,
  );
  checkScriptForPubkey(pubkey, script, 'sign');
  return {
    hash,
    sighashType,
  };
}
function getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {
  const unsignedTx = cache.__TX;
  const sighashType =
    input.sighashType || transaction_1.Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(sighashType, sighashTypes);
  let hash;
  let prevout;
  if (input.nonWitnessUtxo) {
    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
      cache,
      input,
      inputIndex,
    );
    const prevoutHash = unsignedTx.ins[inputIndex].hash;
    const utxoHash = nonWitnessUtxoTx.getHash();
    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout
    if (!prevoutHash.equals(utxoHash)) {
      throw new Error(
        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,
      );
    }
    const prevoutIndex = unsignedTx.ins[inputIndex].index;
    prevout = nonWitnessUtxoTx.outs[prevoutIndex];
  } else if (input.witnessUtxo) {
    prevout = input.witnessUtxo;
  } else {
    throw new Error('Need a Utxo input item for signing');
  }
  const { meaningfulScript, type } = getMeaningfulScript(
    prevout.script,
    inputIndex,
    'input',
    input.redeemScript,
    input.witnessScript,
  );
  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {
    hash = unsignedTx.hashForWitnessV0(
      inputIndex,
      meaningfulScript,
      prevout.value,
      sighashType,
    );
  } else if ((0, psbtutils_1.isP2WPKH)(meaningfulScript)) {
    // P2WPKH uses the P2PKH template for prevoutScript when signing
    const signingScript = payments.p2pkh({
      hash: meaningfulScript.slice(2),
    }).output;
    hash = unsignedTx.hashForWitnessV0(
      inputIndex,
      signingScript,
      prevout.value,
      sighashType,
    );
  } else {
    // non-segwit
    if (
      input.nonWitnessUtxo === undefined &&
      cache.__UNSAFE_SIGN_NONSEGWIT === false
    )
      throw new Error(
        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +
          `${meaningfulScript.toString('hex')}`,
      );
    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)
      console.warn(
        'Warning: Signing non-segwit inputs without the full parent transaction ' +
          'means there is a chance that a miner could feed you incorrect information ' +
          "to trick you into paying large fees. This behavior is the same as Psbt's predecesor " +
          '(TransactionBuilder - now removed) when signing non-segwit scripts. You are not ' +
          'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +
          'BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n' +
          '*********************',
      );
    hash = unsignedTx.hashForSignature(
      inputIndex,
      meaningfulScript,
      sighashType,
    );
  }
  return {
    script: meaningfulScript,
    sighashType,
    hash,
  };
}
function getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {
  const allPublicKeys = [];
  if (input.tapInternalKey) {
    const key = getPrevoutTaprootKey(inputIndex, input, cache);
    if (key) {
      allPublicKeys.push(key);
    }
  }
  if (input.tapScriptSig) {
    const tapScriptPubkeys = input.tapScriptSig.map(tss => tss.pubkey);
    allPublicKeys.push(...tapScriptPubkeys);
  }
  const allHashes = allPublicKeys.map(pubicKey =>
    getTaprootHashesForSig(inputIndex, input, inputs, pubicKey, cache),
  );
  return allHashes.flat();
}
function getPrevoutTaprootKey(inputIndex, input, cache) {
  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);
  return (0, psbtutils_1.isP2TR)(script) ? script.subarray(2, 34) : null;
}
function trimTaprootSig(signature) {
  return signature.length === 64 ? signature : signature.subarray(0, 64);
}
function getTaprootHashesForSig(
  inputIndex,
  input,
  inputs,
  pubkey,
  cache,
  tapLeafHashToSign,
  allowedSighashTypes,
) {
  const unsignedTx = cache.__TX;
  const sighashType =
    input.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(sighashType, allowedSighashTypes);
  const prevOuts = inputs.map((i, index) =>
    getScriptAndAmountFromUtxo(index, i, cache),
  );
  const signingScripts = prevOuts.map(o => o.script);
  const values = prevOuts.map(o => o.value);
  const hashes = [];
  if (input.tapInternalKey && !tapLeafHashToSign) {
    const outputKey =
      getPrevoutTaprootKey(inputIndex, input, cache) || Buffer.from([]);
    if ((0, bip371_1.toXOnly)(pubkey).equals(outputKey)) {
      const tapKeyHash = unsignedTx.hashForWitnessV1(
        inputIndex,
        signingScripts,
        values,
        sighashType,
      );
      hashes.push({ pubkey, hash: tapKeyHash });
    }
  }
  const tapLeafHashes = (input.tapLeafScript || [])
    .filter(tapLeaf => (0, psbtutils_1.pubkeyInScript)(pubkey, tapLeaf.script))
    .map(tapLeaf => {
      const hash = (0, bip341_1.tapleafHash)({
        output: tapLeaf.script,
        version: tapLeaf.leafVersion,
      });
      return Object.assign({ hash }, tapLeaf);
    })
    .filter(
      tapLeaf => !tapLeafHashToSign || tapLeafHashToSign.equals(tapLeaf.hash),
    )
    .map(tapLeaf => {
      const tapScriptHash = unsignedTx.hashForWitnessV1(
        inputIndex,
        signingScripts,
        values,
        transaction_1.Transaction.SIGHASH_DEFAULT,
        tapLeaf.hash,
      );
      return {
        pubkey,
        hash: tapScriptHash,
        leafHash: tapLeaf.hash,
      };
    });
  return hashes.concat(tapLeafHashes);
}
function checkSighashTypeAllowed(sighashType, sighashTypes) {
  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {
    const str = sighashTypeToString(sighashType);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the ` +
        `sighashTypes array of whitelisted types. Sighash type: ${str}`,
    );
  }
}
function getPayment(script, scriptType, partialSig) {
  let payment;
  switch (scriptType) {
    case 'multisig':
      const sigs = getSortedSigs(script, partialSig);
      payment = payments.p2ms({
        output: script,
        signatures: sigs,
      });
      break;
    case 'pubkey':
      payment = payments.p2pk({
        output: script,
        signature: partialSig[0].signature,
      });
      break;
    case 'pubkeyhash':
      payment = payments.p2pkh({
        output: script,
        pubkey: partialSig[0].pubkey,
        signature: partialSig[0].signature,
      });
      break;
    case 'witnesspubkeyhash':
      payment = payments.p2wpkh({
        output: script,
        pubkey: partialSig[0].pubkey,
        signature: partialSig[0].signature,
      });
      break;
  }
  return payment;
}
function getScriptFromInput(inputIndex, input, cache) {
  const unsignedTx = cache.__TX;
  const res = {
    script: null,
    isSegwit: false,
    isP2SH: false,
    isP2WSH: false,
  };
  res.isP2SH = !!input.redeemScript;
  res.isP2WSH = !!input.witnessScript;
  if (input.witnessScript) {
    res.script = input.witnessScript;
  } else if (input.redeemScript) {
    res.script = input.redeemScript;
  } else {
    if (input.nonWitnessUtxo) {
      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
        cache,
        input,
        inputIndex,
      );
      const prevoutIndex = unsignedTx.ins[inputIndex].index;
      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
    } else if (input.witnessUtxo) {
      res.script = input.witnessUtxo.script;
    }
  }
  if (input.witnessScript || (0, psbtutils_1.isP2WPKH)(res.script)) {
    res.isSegwit = true;
  }
  return res;
}
function getSignersFromHD(inputIndex, inputs, hdKeyPair) {
  const input = (0, utils_1.checkForInput)(inputs, inputIndex);
  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {
    throw new Error('Need bip32Derivation to sign with HD');
  }
  const myDerivations = input.bip32Derivation
    .map(bipDv => {
      if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {
        return bipDv;
      } else {
        return;
      }
    })
    .filter(v => !!v);
  if (myDerivations.length === 0) {
    throw new Error(
      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',
    );
  }
  const signers = myDerivations.map(bipDv => {
    const node = hdKeyPair.derivePath(bipDv.path);
    if (!bipDv.pubkey.equals(node.publicKey)) {
      throw new Error('pubkey did not match bip32Derivation');
    }
    return node;
  });
  return signers;
}
function getSortedSigs(script, partialSig) {
  const p2ms = payments.p2ms({ output: script });
  // for each pubkey in order of p2ms script
  return p2ms.pubkeys
    .map(pk => {
      // filter partialSig array by pubkey being equal
      return (
        partialSig.filter(ps => {
          return ps.pubkey.equals(pk);
        })[0] || {}
      ).signature;
      // Any pubkey without a match will return undefined
      // this last filter removes all the undefined items in the array.
    })
    .filter(v => !!v);
}
function scriptWitnessToWitnessStack(buffer) {
  let offset = 0;
  function readSlice(n) {
    offset += n;
    return buffer.slice(offset - n, offset);
  }
  function readVarInt() {
    const vi = varuint.decode(buffer, offset);
    offset += varuint.decode.bytes;
    return vi;
  }
  function readVarSlice() {
    return readSlice(readVarInt());
  }
  function readVector() {
    const count = readVarInt();
    const vector = [];
    for (let i = 0; i < count; i++) vector.push(readVarSlice());
    return vector;
  }
  return readVector();
}
function sighashTypeToString(sighashType) {
  let text =
    sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY
      ? 'SIGHASH_ANYONECANPAY | '
      : '';
  const sigMod = sighashType & 0x1f;
  switch (sigMod) {
    case transaction_1.Transaction.SIGHASH_ALL:
      text += 'SIGHASH_ALL';
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
      text += 'SIGHASH_SINGLE';
      break;
    case transaction_1.Transaction.SIGHASH_NONE:
      text += 'SIGHASH_NONE';
      break;
  }
  return text;
}
function addNonWitnessTxCache(cache, input, inputIndex) {
  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;
  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);
  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;
  const self = cache;
  const selfIndex = inputIndex;
  delete input.nonWitnessUtxo;
  Object.defineProperty(input, 'nonWitnessUtxo', {
    enumerable: true,
    get() {
      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];
      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];
      if (buf !== undefined) {
        return buf;
      } else {
        const newBuf = txCache.toBuffer();
        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;
        return newBuf;
      }
    },
    set(data) {
      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;
    },
  });
}
function inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {
  let inputAmount = 0;
  inputs.forEach((input, idx) => {
    if (mustFinalize && input.finalScriptSig)
      tx.ins[idx].script = input.finalScriptSig;
    if (mustFinalize && input.finalScriptWitness) {
      tx.ins[idx].witness = scriptWitnessToWitnessStack(
        input.finalScriptWitness,
      );
    }
    if (input.witnessUtxo) {
      inputAmount += input.witnessUtxo.value;
    } else if (input.nonWitnessUtxo) {
      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);
      const vout = tx.ins[idx].index;
      const out = nwTx.outs[vout];
      inputAmount += out.value;
    }
  });
  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);
  const fee = inputAmount - outputAmount;
  if (fee < 0) {
    throw new Error('Outputs are spending more than Inputs');
  }
  const bytes = tx.virtualSize();
  cache.__FEE = fee;
  cache.__EXTRACTED_TX = tx;
  cache.__FEE_RATE = Math.floor(fee / bytes);
}
function nonWitnessUtxoTxFromCache(cache, input, inputIndex) {
  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;
  if (!c[inputIndex]) {
    addNonWitnessTxCache(cache, input, inputIndex);
  }
  return c[inputIndex];
}
function getScriptFromUtxo(inputIndex, input, cache) {
  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);
  return script;
}
function getScriptAndAmountFromUtxo(inputIndex, input, cache) {
  if (input.witnessUtxo !== undefined) {
    return {
      script: input.witnessUtxo.script,
      value: input.witnessUtxo.value,
    };
  } else if (input.nonWitnessUtxo !== undefined) {
    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
      cache,
      input,
      inputIndex,
    );
    const o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];
    return { script: o.script, value: o.value };
  } else {
    throw new Error("Can't find pubkey in input without Utxo data");
  }
}
function pubkeyInInput(pubkey, input, inputIndex, cache) {
  const script = getScriptFromUtxo(inputIndex, input, cache);
  const { meaningfulScript } = getMeaningfulScript(
    script,
    inputIndex,
    'input',
    input.redeemScript,
    input.witnessScript,
  );
  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);
}
function pubkeyInOutput(pubkey, output, outputIndex, cache) {
  const script = cache.__TX.outs[outputIndex].script;
  const { meaningfulScript } = getMeaningfulScript(
    script,
    outputIndex,
    'output',
    output.redeemScript,
    output.witnessScript,
  );
  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);
}
function redeemFromFinalScriptSig(finalScript) {
  if (!finalScript) return;
  const decomp = bscript.decompile(finalScript);
  if (!decomp) return;
  const lastItem = decomp[decomp.length - 1];
  if (
    !Buffer.isBuffer(lastItem) ||
    isPubkeyLike(lastItem) ||
    isSigLike(lastItem)
  )
    return;
  const sDecomp = bscript.decompile(lastItem);
  if (!sDecomp) return;
  return lastItem;
}
function redeemFromFinalWitnessScript(finalScript) {
  if (!finalScript) return;
  const decomp = scriptWitnessToWitnessStack(finalScript);
  const lastItem = decomp[decomp.length - 1];
  if (isPubkeyLike(lastItem)) return;
  const sDecomp = bscript.decompile(lastItem);
  if (!sDecomp) return;
  return lastItem;
}
function compressPubkey(pubkey) {
  if (pubkey.length === 65) {
    const parity = pubkey[64] & 1;
    const newKey = pubkey.slice(0, 33);
    newKey[0] = 2 | parity;
    return newKey;
  }
  return pubkey.slice();
}
function isPubkeyLike(buf) {
  return buf.length === 33 && bscript.isCanonicalPubKey(buf);
}
function isSigLike(buf) {
  return bscript.isCanonicalScriptSignature(buf);
}
function getMeaningfulScript(
  script,
  index,
  ioType,
  redeemScript,
  witnessScript,
) {
  const isP2SH = (0, psbtutils_1.isP2SHScript)(script);
  const isP2SHP2WSH =
    isP2SH && redeemScript && (0, psbtutils_1.isP2WSHScript)(redeemScript);
  const isP2WSH = (0, psbtutils_1.isP2WSHScript)(script);
  if (isP2SH && redeemScript === undefined)
    throw new Error('scriptPubkey is P2SH but redeemScript missing');
  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)
    throw new Error(
      'scriptPubkey or redeemScript is P2WSH but witnessScript missing',
    );
  let meaningfulScript;
  if (isP2SHP2WSH) {
    meaningfulScript = witnessScript;
    checkRedeemScript(index, script, redeemScript, ioType);
    checkWitnessScript(index, redeemScript, witnessScript, ioType);
    checkInvalidP2WSH(meaningfulScript);
  } else if (isP2WSH) {
    meaningfulScript = witnessScript;
    checkWitnessScript(index, script, witnessScript, ioType);
    checkInvalidP2WSH(meaningfulScript);
  } else if (isP2SH) {
    meaningfulScript = redeemScript;
    checkRedeemScript(index, script, redeemScript, ioType);
  } else {
    meaningfulScript = script;
  }
  return {
    meaningfulScript,
    type: isP2SHP2WSH
      ? 'p2sh-p2wsh'
      : isP2SH
      ? 'p2sh'
      : isP2WSH
      ? 'p2wsh'
      : 'raw',
  };
}
function checkInvalidP2WSH(script) {
  if (
    (0, psbtutils_1.isP2WPKH)(script) ||
    (0, psbtutils_1.isP2SHScript)(script)
  ) {
    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');
  }
}
function classifyScript(script) {
  if ((0, psbtutils_1.isP2WPKH)(script)) return 'witnesspubkeyhash';
  if ((0, psbtutils_1.isP2PKH)(script)) return 'pubkeyhash';
  if ((0, psbtutils_1.isP2MS)(script)) return 'multisig';
  if ((0, psbtutils_1.isP2PK)(script)) return 'pubkey';
  return 'nonstandard';
}
function range(n) {
  return [...Array(n).keys()];
}


/***/ }),

/***/ 23064:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkTaprootInputForSigs =
  exports.tapTreeFromList =
  exports.tapTreeToList =
  exports.tweakInternalPubKey =
  exports.checkTaprootOutputFields =
  exports.checkTaprootInputFields =
  exports.isTaprootOutput =
  exports.isTaprootInput =
  exports.serializeTaprootSignature =
  exports.tapScriptFinalizer =
  exports.toXOnly =
    void 0;
const types_1 = __webpack_require__(41838);
const transaction_1 = __webpack_require__(82737);
const psbtutils_1 = __webpack_require__(87929);
const bip341_1 = __webpack_require__(12227);
const payments_1 = __webpack_require__(84972);
const psbtutils_2 = __webpack_require__(87929);
const toXOnly = pubKey => (pubKey.length === 32 ? pubKey : pubKey.slice(1, 33));
exports.toXOnly = toXOnly;
/**
 * Default tapscript finalizer. It searches for the `tapLeafHashToFinalize` if provided.
 * Otherwise it will search for the tapleaf that has at least one signature and has the shortest path.
 * @param inputIndex the position of the PSBT input.
 * @param input the PSBT input.
 * @param tapLeafHashToFinalize optional, if provided the finalizer will search for a tapleaf that has this hash
 *                              and will try to build the finalScriptWitness.
 * @returns the finalScriptWitness or throws an exception if no tapleaf found.
 */
function tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {
  const tapLeaf = findTapLeafToFinalize(
    input,
    inputIndex,
    tapLeafHashToFinalize,
  );
  try {
    const sigs = sortSignatures(input, tapLeaf);
    const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);
    return {
      finalScriptWitness: (0, psbtutils_1.witnessStackToScriptWitness)(witness),
    };
  } catch (err) {
    throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);
  }
}
exports.tapScriptFinalizer = tapScriptFinalizer;
function serializeTaprootSignature(sig, sighashType) {
  const sighashTypeByte = sighashType
    ? Buffer.from([sighashType])
    : Buffer.from([]);
  return Buffer.concat([sig, sighashTypeByte]);
}
exports.serializeTaprootSignature = serializeTaprootSignature;
function isTaprootInput(input) {
  return (
    input &&
    !!(
      input.tapInternalKey ||
      input.tapMerkleRoot ||
      (input.tapLeafScript && input.tapLeafScript.length) ||
      (input.tapBip32Derivation && input.tapBip32Derivation.length) ||
      (input.witnessUtxo && (0, psbtutils_1.isP2TR)(input.witnessUtxo.script))
    )
  );
}
exports.isTaprootInput = isTaprootInput;
function isTaprootOutput(output, script) {
  return (
    output &&
    !!(
      output.tapInternalKey ||
      output.tapTree ||
      (output.tapBip32Derivation && output.tapBip32Derivation.length) ||
      (script && (0, psbtutils_1.isP2TR)(script))
    )
  );
}
exports.isTaprootOutput = isTaprootOutput;
function checkTaprootInputFields(inputData, newInputData, action) {
  checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);
  checkIfTapLeafInTree(inputData, newInputData, action);
}
exports.checkTaprootInputFields = checkTaprootInputFields;
function checkTaprootOutputFields(outputData, newOutputData, action) {
  checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);
  checkTaprootScriptPubkey(outputData, newOutputData);
}
exports.checkTaprootOutputFields = checkTaprootOutputFields;
function checkTaprootScriptPubkey(outputData, newOutputData) {
  if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;
  const tapInternalKey =
    newOutputData.tapInternalKey || outputData.tapInternalKey;
  const tapTree = newOutputData.tapTree || outputData.tapTree;
  if (tapInternalKey) {
    const { script: scriptPubkey } = outputData;
    const script = getTaprootScripPubkey(tapInternalKey, tapTree);
    if (scriptPubkey && !scriptPubkey.equals(script))
      throw new Error('Error adding output. Script or address missmatch.');
  }
}
function getTaprootScripPubkey(tapInternalKey, tapTree) {
  const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);
  const { output } = (0, payments_1.p2tr)({
    internalPubkey: tapInternalKey,
    scriptTree,
  });
  return output;
}
function tweakInternalPubKey(inputIndex, input) {
  const tapInternalKey = input.tapInternalKey;
  const outputKey =
    tapInternalKey &&
    (0, bip341_1.tweakKey)(tapInternalKey, input.tapMerkleRoot);
  if (!outputKey)
    throw new Error(
      `Cannot tweak tap internal key for input #${inputIndex}. Public key: ${
        tapInternalKey && tapInternalKey.toString('hex')
      }`,
    );
  return outputKey.x;
}
exports.tweakInternalPubKey = tweakInternalPubKey;
/**
 * Convert a binary tree to a BIP371 type list. Each element of the list is (according to BIP371):
 * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,
 * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that
 * the tree is correctly reconstructed.
 * @param tree the binary tap tree
 * @returns a list of BIP 371 tapleaves
 */
function tapTreeToList(tree) {
  if (!(0, types_1.isTaptree)(tree))
    throw new Error(
      'Cannot convert taptree to tapleaf list. Expecting a tapree structure.',
    );
  return _tapTreeToList(tree);
}
exports.tapTreeToList = tapTreeToList;
/**
 * Convert a BIP371 TapLeaf list to a TapTree (binary).
 * @param leaves a list of tapleaves where each element of the list is (according to BIP371):
 * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,
 * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that
 * the tree is correctly reconstructed.
 * @returns the corresponding taptree, or throws an exception if the tree cannot be reconstructed
 */
function tapTreeFromList(leaves = []) {
  if (leaves.length === 1 && leaves[0].depth === 0)
    return {
      output: leaves[0].script,
      version: leaves[0].leafVersion,
    };
  return instertLeavesInTree(leaves);
}
exports.tapTreeFromList = tapTreeFromList;
function checkTaprootInputForSigs(input, action) {
  const sigs = extractTaprootSigs(input);
  return sigs.some(sig =>
    (0, psbtutils_2.signatureBlocksAction)(sig, decodeSchnorrSignature, action),
  );
}
exports.checkTaprootInputForSigs = checkTaprootInputForSigs;
function decodeSchnorrSignature(signature) {
  return {
    signature: signature.slice(0, 64),
    hashType:
      signature.slice(64)[0] || transaction_1.Transaction.SIGHASH_DEFAULT,
  };
}
function extractTaprootSigs(input) {
  const sigs = [];
  if (input.tapKeySig) sigs.push(input.tapKeySig);
  if (input.tapScriptSig)
    sigs.push(...input.tapScriptSig.map(s => s.signature));
  if (!sigs.length) {
    const finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);
    if (finalTapKeySig) sigs.push(finalTapKeySig);
  }
  return sigs;
}
function getTapKeySigFromWithness(finalScriptWitness) {
  if (!finalScriptWitness) return;
  const witness = finalScriptWitness.slice(2);
  // todo: add schnorr signature validation
  if (witness.length === 64 || witness.length === 65) return witness;
}
function _tapTreeToList(tree, leaves = [], depth = 0) {
  if (depth > bip341_1.MAX_TAPTREE_DEPTH)
    throw new Error('Max taptree depth exceeded.');
  if (!tree) return [];
  if ((0, types_1.isTapleaf)(tree)) {
    leaves.push({
      depth,
      leafVersion: tree.version || bip341_1.LEAF_VERSION_TAPSCRIPT,
      script: tree.output,
    });
    return leaves;
  }
  if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);
  if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);
  return leaves;
}
function instertLeavesInTree(leaves) {
  let tree;
  for (const leaf of leaves) {
    tree = instertLeafInTree(leaf, tree);
    if (!tree) throw new Error(`No room left to insert tapleaf in tree`);
  }
  return tree;
}
function instertLeafInTree(leaf, tree, depth = 0) {
  if (depth > bip341_1.MAX_TAPTREE_DEPTH)
    throw new Error('Max taptree depth exceeded.');
  if (leaf.depth === depth) {
    if (!tree)
      return {
        output: leaf.script,
        version: leaf.leafVersion,
      };
    return;
  }
  if ((0, types_1.isTapleaf)(tree)) return;
  const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);
  if (leftSide) return [leftSide, tree && tree[1]];
  const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);
  if (rightSide) return [tree && tree[0], rightSide];
}
function checkMixedTaprootAndNonTaprootInputFields(
  inputData,
  newInputData,
  action,
) {
  const isBadTaprootUpdate =
    isTaprootInput(inputData) && hasNonTaprootFields(newInputData);
  const isBadNonTaprootUpdate =
    hasNonTaprootFields(inputData) && isTaprootInput(newInputData);
  const hasMixedFields =
    inputData === newInputData &&
    isTaprootInput(newInputData) &&
    hasNonTaprootFields(newInputData); // todo: bad? use !===
  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
    throw new Error(
      `Invalid arguments for Psbt.${action}. ` +
        `Cannot use both taproot and non-taproot fields.`,
    );
}
function checkMixedTaprootAndNonTaprootOutputFields(
  inputData,
  newInputData,
  action,
) {
  const isBadTaprootUpdate =
    isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);
  const isBadNonTaprootUpdate =
    hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);
  const hasMixedFields =
    inputData === newInputData &&
    isTaprootOutput(newInputData) &&
    hasNonTaprootFields(newInputData);
  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
    throw new Error(
      `Invalid arguments for Psbt.${action}. ` +
        `Cannot use both taproot and non-taproot fields.`,
    );
}
function checkIfTapLeafInTree(inputData, newInputData, action) {
  if (newInputData.tapMerkleRoot) {
    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>
      isTapLeafInTree(l, newInputData.tapMerkleRoot),
    );
    const oldLeafsInTree = (inputData.tapLeafScript || []).every(l =>
      isTapLeafInTree(l, newInputData.tapMerkleRoot),
    );
    if (!newLeafsInTree || !oldLeafsInTree)
      throw new Error(
        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,
      );
  } else if (inputData.tapMerkleRoot) {
    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>
      isTapLeafInTree(l, inputData.tapMerkleRoot),
    );
    if (!newLeafsInTree)
      throw new Error(
        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,
      );
  }
}
function isTapLeafInTree(tapLeaf, merkleRoot) {
  if (!merkleRoot) return true;
  const leafHash = (0, bip341_1.tapleafHash)({
    output: tapLeaf.script,
    version: tapLeaf.leafVersion,
  });
  const rootHash = (0, bip341_1.rootHashFromPath)(
    tapLeaf.controlBlock,
    leafHash,
  );
  return rootHash.equals(merkleRoot);
}
function sortSignatures(input, tapLeaf) {
  const leafHash = (0, bip341_1.tapleafHash)({
    output: tapLeaf.script,
    version: tapLeaf.leafVersion,
  });
  return (input.tapScriptSig || [])
    .filter(tss => tss.leafHash.equals(leafHash))
    .map(tss => addPubkeyPositionInScript(tapLeaf.script, tss))
    .sort((t1, t2) => t2.positionInScript - t1.positionInScript)
    .map(t => t.signature);
}
function addPubkeyPositionInScript(script, tss) {
  return Object.assign(
    {
      positionInScript: (0, psbtutils_1.pubkeyPositionInScript)(
        tss.pubkey,
        script,
      ),
    },
    tss,
  );
}
/**
 * Find tapleaf by hash, or get the signed tapleaf with the shortest path.
 */
function findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {
  if (!input.tapScriptSig || !input.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`,
    );
  const tapLeaf = (input.tapLeafScript || [])
    .sort((a, b) => a.controlBlock.length - b.controlBlock.length)
    .find(leaf =>
      canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize),
    );
  if (!tapLeaf)
    throw new Error(
      `Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`,
    );
  return tapLeaf;
}
function canFinalizeLeaf(leaf, tapScriptSig, hash) {
  const leafHash = (0, bip341_1.tapleafHash)({
    output: leaf.script,
    version: leaf.leafVersion,
  });
  const whiteListedHash = !hash || hash.equals(leafHash);
  return (
    whiteListedHash &&
    tapScriptSig.find(tss => tss.leafHash.equals(leafHash)) !== undefined
  );
}
function hasNonTaprootFields(io) {
  return (
    io &&
    !!(
      io.redeemScript ||
      io.witnessScript ||
      (io.bip32Derivation && io.bip32Derivation.length)
    )
  );
}


/***/ }),

/***/ 87929:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signatureBlocksAction =
  exports.checkInputForSig =
  exports.pubkeyInScript =
  exports.pubkeyPositionInScript =
  exports.witnessStackToScriptWitness =
  exports.isP2TR =
  exports.isP2SHScript =
  exports.isP2WSHScript =
  exports.isP2WPKH =
  exports.isP2PKH =
  exports.isP2PK =
  exports.isP2MS =
    void 0;
const varuint = __webpack_require__(3493);
const bscript = __webpack_require__(73357);
const transaction_1 = __webpack_require__(82737);
const crypto_1 = __webpack_require__(5525);
const payments = __webpack_require__(84972);
function isPaymentFactory(payment) {
  return script => {
    try {
      payment({ output: script });
      return true;
    } catch (err) {
      return false;
    }
  };
}
exports.isP2MS = isPaymentFactory(payments.p2ms);
exports.isP2PK = isPaymentFactory(payments.p2pk);
exports.isP2PKH = isPaymentFactory(payments.p2pkh);
exports.isP2WPKH = isPaymentFactory(payments.p2wpkh);
exports.isP2WSHScript = isPaymentFactory(payments.p2wsh);
exports.isP2SHScript = isPaymentFactory(payments.p2sh);
exports.isP2TR = isPaymentFactory(payments.p2tr);
function witnessStackToScriptWitness(witness) {
  let buffer = Buffer.allocUnsafe(0);
  function writeSlice(slice) {
    buffer = Buffer.concat([buffer, Buffer.from(slice)]);
  }
  function writeVarInt(i) {
    const currentLen = buffer.length;
    const varintLen = varuint.encodingLength(i);
    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);
    varuint.encode(i, buffer, currentLen);
  }
  function writeVarSlice(slice) {
    writeVarInt(slice.length);
    writeSlice(slice);
  }
  function writeVector(vector) {
    writeVarInt(vector.length);
    vector.forEach(writeVarSlice);
  }
  writeVector(witness);
  return buffer;
}
exports.witnessStackToScriptWitness = witnessStackToScriptWitness;
function pubkeyPositionInScript(pubkey, script) {
  const pubkeyHash = (0, crypto_1.hash160)(pubkey);
  const pubkeyXOnly = pubkey.slice(1, 33); // slice before calling?
  const decompiled = bscript.decompile(script);
  if (decompiled === null) throw new Error('Unknown script error');
  return decompiled.findIndex(element => {
    if (typeof element === 'number') return false;
    return (
      element.equals(pubkey) ||
      element.equals(pubkeyHash) ||
      element.equals(pubkeyXOnly)
    );
  });
}
exports.pubkeyPositionInScript = pubkeyPositionInScript;
function pubkeyInScript(pubkey, script) {
  return pubkeyPositionInScript(pubkey, script) !== -1;
}
exports.pubkeyInScript = pubkeyInScript;
function checkInputForSig(input, action) {
  const pSigs = extractPartialSigs(input);
  return pSigs.some(pSig =>
    signatureBlocksAction(pSig, bscript.signature.decode, action),
  );
}
exports.checkInputForSig = checkInputForSig;
function signatureBlocksAction(signature, signatureDecodeFn, action) {
  const { hashType } = signatureDecodeFn(signature);
  const whitelist = [];
  const isAnyoneCanPay =
    hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;
  if (isAnyoneCanPay) whitelist.push('addInput');
  const hashMod = hashType & 0x1f;
  switch (hashMod) {
    case transaction_1.Transaction.SIGHASH_ALL:
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
    case transaction_1.Transaction.SIGHASH_NONE:
      whitelist.push('addOutput');
      whitelist.push('setInputSequence');
      break;
  }
  if (whitelist.indexOf(action) === -1) {
    return true;
  }
  return false;
}
exports.signatureBlocksAction = signatureBlocksAction;
function extractPartialSigs(input) {
  let pSigs = [];
  if ((input.partialSig || []).length === 0) {
    if (!input.finalScriptSig && !input.finalScriptWitness) return [];
    pSigs = getPsigsFromInputFinalScripts(input);
  } else {
    pSigs = input.partialSig;
  }
  return pSigs.map(p => p.signature);
}
function getPsigsFromInputFinalScripts(input) {
  const scriptItems = !input.finalScriptSig
    ? []
    : bscript.decompile(input.finalScriptSig) || [];
  const witnessItems = !input.finalScriptWitness
    ? []
    : bscript.decompile(input.finalScriptWitness) || [];
  return scriptItems
    .concat(witnessItems)
    .filter(item => {
      return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);
    })
    .map(sig => ({ signature: sig }));
}


/***/ }),

/***/ 79937:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decode = exports.encode = exports.encodingLength = void 0;
const ops_1 = __webpack_require__(47334);
function encodingLength(i) {
  return i < ops_1.OPS.OP_PUSHDATA1 ? 1 : i <= 0xff ? 2 : i <= 0xffff ? 3 : 5;
}
exports.encodingLength = encodingLength;
function encode(buffer, num, offset) {
  const size = encodingLength(num);
  // ~6 bit
  if (size === 1) {
    buffer.writeUInt8(num, offset);
    // 8 bit
  } else if (size === 2) {
    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA1, offset);
    buffer.writeUInt8(num, offset + 1);
    // 16 bit
  } else if (size === 3) {
    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA2, offset);
    buffer.writeUInt16LE(num, offset + 1);
    // 32 bit
  } else {
    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA4, offset);
    buffer.writeUInt32LE(num, offset + 1);
  }
  return size;
}
exports.encode = encode;
function decode(buffer, offset) {
  const opcode = buffer.readUInt8(offset);
  let num;
  let size;
  // ~6 bit
  if (opcode < ops_1.OPS.OP_PUSHDATA1) {
    num = opcode;
    size = 1;
    // 8 bit
  } else if (opcode === ops_1.OPS.OP_PUSHDATA1) {
    if (offset + 2 > buffer.length) return null;
    num = buffer.readUInt8(offset + 1);
    size = 2;
    // 16 bit
  } else if (opcode === ops_1.OPS.OP_PUSHDATA2) {
    if (offset + 3 > buffer.length) return null;
    num = buffer.readUInt16LE(offset + 1);
    size = 3;
    // 32 bit
  } else {
    if (offset + 5 > buffer.length) return null;
    if (opcode !== ops_1.OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode');
    num = buffer.readUInt32LE(offset + 1);
    size = 5;
  }
  return {
    opcode,
    number: num,
    size,
  };
}
exports.decode = decode;


/***/ }),

/***/ 73357:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signature =
  exports.number =
  exports.isCanonicalScriptSignature =
  exports.isDefinedHashType =
  exports.isCanonicalPubKey =
  exports.toStack =
  exports.fromASM =
  exports.toASM =
  exports.decompile =
  exports.compile =
  exports.countNonPushOnlyOPs =
  exports.isPushOnly =
  exports.OPS =
    void 0;
const bip66 = __webpack_require__(77617);
const ops_1 = __webpack_require__(47334);
Object.defineProperty(exports, "OPS", ({
  enumerable: true,
  get: function () {
    return ops_1.OPS;
  },
}));
const pushdata = __webpack_require__(79937);
const scriptNumber = __webpack_require__(45815);
const scriptSignature = __webpack_require__(24362);
const types = __webpack_require__(41838);
const { typeforce } = types;
const OP_INT_BASE = ops_1.OPS.OP_RESERVED; // OP_1 - 1
function isOPInt(value) {
  return (
    types.Number(value) &&
    (value === ops_1.OPS.OP_0 ||
      (value >= ops_1.OPS.OP_1 && value <= ops_1.OPS.OP_16) ||
      value === ops_1.OPS.OP_1NEGATE)
  );
}
function isPushOnlyChunk(value) {
  return types.Buffer(value) || isOPInt(value);
}
function isPushOnly(value) {
  return types.Array(value) && value.every(isPushOnlyChunk);
}
exports.isPushOnly = isPushOnly;
function countNonPushOnlyOPs(value) {
  return value.length - value.filter(isPushOnlyChunk).length;
}
exports.countNonPushOnlyOPs = countNonPushOnlyOPs;
function asMinimalOP(buffer) {
  if (buffer.length === 0) return ops_1.OPS.OP_0;
  if (buffer.length !== 1) return;
  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];
  if (buffer[0] === 0x81) return ops_1.OPS.OP_1NEGATE;
}
function chunksIsBuffer(buf) {
  return Buffer.isBuffer(buf);
}
function chunksIsArray(buf) {
  return types.Array(buf);
}
function singleChunkIsBuffer(buf) {
  return Buffer.isBuffer(buf);
}
function compile(chunks) {
  // TODO: remove me
  if (chunksIsBuffer(chunks)) return chunks;
  typeforce(types.Array, chunks);
  const bufferSize = chunks.reduce((accum, chunk) => {
    // data chunk
    if (singleChunkIsBuffer(chunk)) {
      // adhere to BIP62.3, minimal push policy
      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {
        return accum + 1;
      }
      return accum + pushdata.encodingLength(chunk.length) + chunk.length;
    }
    // opcode
    return accum + 1;
  }, 0.0);
  const buffer = Buffer.allocUnsafe(bufferSize);
  let offset = 0;
  chunks.forEach(chunk => {
    // data chunk
    if (singleChunkIsBuffer(chunk)) {
      // adhere to BIP62.3, minimal push policy
      const opcode = asMinimalOP(chunk);
      if (opcode !== undefined) {
        buffer.writeUInt8(opcode, offset);
        offset += 1;
        return;
      }
      offset += pushdata.encode(buffer, chunk.length, offset);
      chunk.copy(buffer, offset);
      offset += chunk.length;
      // opcode
    } else {
      buffer.writeUInt8(chunk, offset);
      offset += 1;
    }
  });
  if (offset !== buffer.length) throw new Error('Could not decode chunks');
  return buffer;
}
exports.compile = compile;
function decompile(buffer) {
  // TODO: remove me
  if (chunksIsArray(buffer)) return buffer;
  typeforce(types.Buffer, buffer);
  const chunks = [];
  let i = 0;
  while (i < buffer.length) {
    const opcode = buffer[i];
    // data chunk
    if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {
      const d = pushdata.decode(buffer, i);
      // did reading a pushDataInt fail?
      if (d === null) return null;
      i += d.size;
      // attempt to read too much data?
      if (i + d.number > buffer.length) return null;
      const data = buffer.slice(i, i + d.number);
      i += d.number;
      // decompile minimally
      const op = asMinimalOP(data);
      if (op !== undefined) {
        chunks.push(op);
      } else {
        chunks.push(data);
      }
      // opcode
    } else {
      chunks.push(opcode);
      i += 1;
    }
  }
  return chunks;
}
exports.decompile = decompile;
function toASM(chunks) {
  if (chunksIsBuffer(chunks)) {
    chunks = decompile(chunks);
  }
  return chunks
    .map(chunk => {
      // data?
      if (singleChunkIsBuffer(chunk)) {
        const op = asMinimalOP(chunk);
        if (op === undefined) return chunk.toString('hex');
        chunk = op;
      }
      // opcode!
      return ops_1.REVERSE_OPS[chunk];
    })
    .join(' ');
}
exports.toASM = toASM;
function fromASM(asm) {
  typeforce(types.String, asm);
  return compile(
    asm.split(' ').map(chunkStr => {
      // opcode?
      if (ops_1.OPS[chunkStr] !== undefined) return ops_1.OPS[chunkStr];
      typeforce(types.Hex, chunkStr);
      // data!
      return Buffer.from(chunkStr, 'hex');
    }),
  );
}
exports.fromASM = fromASM;
function toStack(chunks) {
  chunks = decompile(chunks);
  typeforce(isPushOnly, chunks);
  return chunks.map(op => {
    if (singleChunkIsBuffer(op)) return op;
    if (op === ops_1.OPS.OP_0) return Buffer.allocUnsafe(0);
    return scriptNumber.encode(op - OP_INT_BASE);
  });
}
exports.toStack = toStack;
function isCanonicalPubKey(buffer) {
  return types.isPoint(buffer);
}
exports.isCanonicalPubKey = isCanonicalPubKey;
function isDefinedHashType(hashType) {
  const hashTypeMod = hashType & ~0x80;
  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE
  return hashTypeMod > 0x00 && hashTypeMod < 0x04;
}
exports.isDefinedHashType = isDefinedHashType;
function isCanonicalScriptSignature(buffer) {
  if (!Buffer.isBuffer(buffer)) return false;
  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;
  return bip66.check(buffer.slice(0, -1));
}
exports.isCanonicalScriptSignature = isCanonicalScriptSignature;
exports.number = scriptNumber;
exports.signature = scriptSignature;


/***/ }),

/***/ 45815:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encode = exports.decode = void 0;
function decode(buffer, maxLength, minimal) {
  maxLength = maxLength || 4;
  minimal = minimal === undefined ? true : minimal;
  const length = buffer.length;
  if (length === 0) return 0;
  if (length > maxLength) throw new TypeError('Script number overflow');
  if (minimal) {
    if ((buffer[length - 1] & 0x7f) === 0) {
      if (length <= 1 || (buffer[length - 2] & 0x80) === 0)
        throw new Error('Non-minimally encoded script number');
    }
  }
  // 40-bit
  if (length === 5) {
    const a = buffer.readUInt32LE(0);
    const b = buffer.readUInt8(4);
    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);
    return b * 0x100000000 + a;
  }
  // 32-bit / 24-bit / 16-bit / 8-bit
  let result = 0;
  for (let i = 0; i < length; ++i) {
    result |= buffer[i] << (8 * i);
  }
  if (buffer[length - 1] & 0x80)
    return -(result & ~(0x80 << (8 * (length - 1))));
  return result;
}
exports.decode = decode;
function scriptNumSize(i) {
  return i > 0x7fffffff
    ? 5
    : i > 0x7fffff
    ? 4
    : i > 0x7fff
    ? 3
    : i > 0x7f
    ? 2
    : i > 0x00
    ? 1
    : 0;
}
function encode(_number) {
  let value = Math.abs(_number);
  const size = scriptNumSize(value);
  const buffer = Buffer.allocUnsafe(size);
  const negative = _number < 0;
  for (let i = 0; i < size; ++i) {
    buffer.writeUInt8(value & 0xff, i);
    value >>= 8;
  }
  if (buffer[size - 1] & 0x80) {
    buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);
  } else if (negative) {
    buffer[size - 1] |= 0x80;
  }
  return buffer;
}
exports.encode = encode;


/***/ }),

/***/ 24362:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encode = exports.decode = void 0;
const bip66 = __webpack_require__(77617);
const types = __webpack_require__(41838);
const { typeforce } = types;
const ZERO = Buffer.alloc(1, 0);
function toDER(x) {
  let i = 0;
  while (x[i] === 0) ++i;
  if (i === x.length) return ZERO;
  x = x.slice(i);
  if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length);
  return x;
}
function fromDER(x) {
  if (x[0] === 0x00) x = x.slice(1);
  const buffer = Buffer.alloc(32, 0);
  const bstart = Math.max(0, 32 - x.length);
  x.copy(buffer, bstart);
  return buffer;
}
// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)
function decode(buffer) {
  const hashType = buffer.readUInt8(buffer.length - 1);
  const hashTypeMod = hashType & ~0x80;
  if (hashTypeMod <= 0 || hashTypeMod >= 4)
    throw new Error('Invalid hashType ' + hashType);
  const decoded = bip66.decode(buffer.slice(0, -1));
  const r = fromDER(decoded.r);
  const s = fromDER(decoded.s);
  const signature = Buffer.concat([r, s], 64);
  return { signature, hashType };
}
exports.decode = decode;
function encode(signature, hashType) {
  typeforce(
    {
      signature: types.BufferN(64),
      hashType: types.UInt8,
    },
    { signature, hashType },
  );
  const hashTypeMod = hashType & ~0x80;
  if (hashTypeMod <= 0 || hashTypeMod >= 4)
    throw new Error('Invalid hashType ' + hashType);
  const hashTypeBuffer = Buffer.allocUnsafe(1);
  hashTypeBuffer.writeUInt8(hashType, 0);
  const r = toDER(signature.slice(0, 32));
  const s = toDER(signature.slice(32, 64));
  return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);
}
exports.encode = encode;


/***/ }),

/***/ 82737:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Transaction = void 0;
const bufferutils_1 = __webpack_require__(9357);
const bcrypto = __webpack_require__(5525);
const bscript = __webpack_require__(73357);
const script_1 = __webpack_require__(73357);
const types = __webpack_require__(41838);
const { typeforce } = types;
function varSliceSize(someScript) {
  const length = someScript.length;
  return bufferutils_1.varuint.encodingLength(length) + length;
}
function vectorSize(someVector) {
  const length = someVector.length;
  return (
    bufferutils_1.varuint.encodingLength(length) +
    someVector.reduce((sum, witness) => {
      return sum + varSliceSize(witness);
    }, 0)
  );
}
const EMPTY_BUFFER = Buffer.allocUnsafe(0);
const EMPTY_WITNESS = [];
const ZERO = Buffer.from(
  '0000000000000000000000000000000000000000000000000000000000000000',
  'hex',
);
const ONE = Buffer.from(
  '0000000000000000000000000000000000000000000000000000000000000001',
  'hex',
);
const VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');
const BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  valueBuffer: VALUE_UINT64_MAX,
};
function isOutput(out) {
  return out.value !== undefined;
}
class Transaction {
  constructor() {
    this.version = 1;
    this.locktime = 0;
    this.ins = [];
    this.outs = [];
  }
  static fromBuffer(buffer, _NO_STRICT) {
    const bufferReader = new bufferutils_1.BufferReader(buffer);
    const tx = new Transaction();
    tx.version = bufferReader.readInt32();
    const marker = bufferReader.readUInt8();
    const flag = bufferReader.readUInt8();
    let hasWitnesses = false;
    if (
      marker === Transaction.ADVANCED_TRANSACTION_MARKER &&
      flag === Transaction.ADVANCED_TRANSACTION_FLAG
    ) {
      hasWitnesses = true;
    } else {
      bufferReader.offset -= 2;
    }
    const vinLen = bufferReader.readVarInt();
    for (let i = 0; i < vinLen; ++i) {
      tx.ins.push({
        hash: bufferReader.readSlice(32),
        index: bufferReader.readUInt32(),
        script: bufferReader.readVarSlice(),
        sequence: bufferReader.readUInt32(),
        witness: EMPTY_WITNESS,
      });
    }
    const voutLen = bufferReader.readVarInt();
    for (let i = 0; i < voutLen; ++i) {
      tx.outs.push({
        value: bufferReader.readUInt64(),
        script: bufferReader.readVarSlice(),
      });
    }
    if (hasWitnesses) {
      for (let i = 0; i < vinLen; ++i) {
        tx.ins[i].witness = bufferReader.readVector();
      }
      // was this pointless?
      if (!tx.hasWitnesses())
        throw new Error('Transaction has superfluous witness data');
    }
    tx.locktime = bufferReader.readUInt32();
    if (_NO_STRICT) return tx;
    if (bufferReader.offset !== buffer.length)
      throw new Error('Transaction has unexpected data');
    return tx;
  }
  static fromHex(hex) {
    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);
  }
  static isCoinbaseHash(buffer) {
    typeforce(types.Hash256bit, buffer);
    for (let i = 0; i < 32; ++i) {
      if (buffer[i] !== 0) return false;
    }
    return true;
  }
  isCoinbase() {
    return (
      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)
    );
  }
  addInput(hash, index, sequence, scriptSig) {
    typeforce(
      types.tuple(
        types.Hash256bit,
        types.UInt32,
        types.maybe(types.UInt32),
        types.maybe(types.Buffer),
      ),
      arguments,
    );
    if (types.Null(sequence)) {
      sequence = Transaction.DEFAULT_SEQUENCE;
    }
    // Add the input and return the input's index
    return (
      this.ins.push({
        hash,
        index,
        script: scriptSig || EMPTY_BUFFER,
        sequence: sequence,
        witness: EMPTY_WITNESS,
      }) - 1
    );
  }
  addOutput(scriptPubKey, value) {
    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);
    // Add the output and return the output's index
    return (
      this.outs.push({
        script: scriptPubKey,
        value,
      }) - 1
    );
  }
  hasWitnesses() {
    return this.ins.some(x => {
      return x.witness.length !== 0;
    });
  }
  weight() {
    const base = this.byteLength(false);
    const total = this.byteLength(true);
    return base * 3 + total;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(_ALLOW_WITNESS = true) {
    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
    return (
      (hasWitnesses ? 10 : 8) +
      bufferutils_1.varuint.encodingLength(this.ins.length) +
      bufferutils_1.varuint.encodingLength(this.outs.length) +
      this.ins.reduce((sum, input) => {
        return sum + 40 + varSliceSize(input.script);
      }, 0) +
      this.outs.reduce((sum, output) => {
        return sum + 8 + varSliceSize(output.script);
      }, 0) +
      (hasWitnesses
        ? this.ins.reduce((sum, input) => {
            return sum + vectorSize(input.witness);
          }, 0)
        : 0)
    );
  }
  clone() {
    const newTx = new Transaction();
    newTx.version = this.version;
    newTx.locktime = this.locktime;
    newTx.ins = this.ins.map(txIn => {
      return {
        hash: txIn.hash,
        index: txIn.index,
        script: txIn.script,
        sequence: txIn.sequence,
        witness: txIn.witness,
      };
    });
    newTx.outs = this.outs.map(txOut => {
      return {
        script: txOut.script,
        value: txOut.value,
      };
    });
    return newTx;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(inIndex, prevOutScript, hashType) {
    typeforce(
      types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number),
      arguments,
    );
    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29
    if (inIndex >= this.ins.length) return ONE;
    // ignore OP_CODESEPARATOR
    const ourScript = bscript.compile(
      bscript.decompile(prevOutScript).filter(x => {
        return x !== script_1.OPS.OP_CODESEPARATOR;
      }),
    );
    const txTmp = this.clone();
    // SIGHASH_NONE: ignore all outputs? (wildcard payee)
    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {
      txTmp.outs = [];
      // ignore sequence numbers (except at inIndex)
      txTmp.ins.forEach((input, i) => {
        if (i === inIndex) return;
        input.sequence = 0;
      });
      // SIGHASH_SINGLE: ignore all outputs, except at the same index?
    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {
      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60
      if (inIndex >= this.outs.length) return ONE;
      // truncate outputs after
      txTmp.outs.length = inIndex + 1;
      // "blank" outputs before
      for (let i = 0; i < inIndex; i++) {
        txTmp.outs[i] = BLANK_OUTPUT;
      }
      // ignore sequence numbers (except at inIndex)
      txTmp.ins.forEach((input, y) => {
        if (y === inIndex) return;
        input.sequence = 0;
      });
    }
    // SIGHASH_ANYONECANPAY: ignore inputs entirely?
    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {
      txTmp.ins = [txTmp.ins[inIndex]];
      txTmp.ins[0].script = ourScript;
      // SIGHASH_ALL: only ignore input scripts
    } else {
      // "blank" others input scripts
      txTmp.ins.forEach(input => {
        input.script = EMPTY_BUFFER;
      });
      txTmp.ins[inIndex].script = ourScript;
    }
    // serialize and hash
    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);
    buffer.writeInt32LE(hashType, buffer.length - 4);
    txTmp.__toBuffer(buffer, 0, false);
    return bcrypto.hash256(buffer);
  }
  hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {
    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message
    typeforce(
      types.tuple(
        types.UInt32,
        typeforce.arrayOf(types.Buffer),
        typeforce.arrayOf(types.Satoshi),
        types.UInt32,
      ),
      arguments,
    );
    if (
      values.length !== this.ins.length ||
      prevOutScripts.length !== this.ins.length
    ) {
      throw new Error('Must supply prevout script and value for all inputs');
    }
    const outputType =
      hashType === Transaction.SIGHASH_DEFAULT
        ? Transaction.SIGHASH_ALL
        : hashType & Transaction.SIGHASH_OUTPUT_MASK;
    const inputType = hashType & Transaction.SIGHASH_INPUT_MASK;
    const isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;
    const isNone = outputType === Transaction.SIGHASH_NONE;
    const isSingle = outputType === Transaction.SIGHASH_SINGLE;
    let hashPrevouts = EMPTY_BUFFER;
    let hashAmounts = EMPTY_BUFFER;
    let hashScriptPubKeys = EMPTY_BUFFER;
    let hashSequences = EMPTY_BUFFER;
    let hashOutputs = EMPTY_BUFFER;
    if (!isAnyoneCanPay) {
      let bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        36 * this.ins.length,
      );
      this.ins.forEach(txIn => {
        bufferWriter.writeSlice(txIn.hash);
        bufferWriter.writeUInt32(txIn.index);
      });
      hashPrevouts = bcrypto.sha256(bufferWriter.end());
      bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        8 * this.ins.length,
      );
      values.forEach(value => bufferWriter.writeUInt64(value));
      hashAmounts = bcrypto.sha256(bufferWriter.end());
      bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        prevOutScripts.map(varSliceSize).reduce((a, b) => a + b),
      );
      prevOutScripts.forEach(prevOutScript =>
        bufferWriter.writeVarSlice(prevOutScript),
      );
      hashScriptPubKeys = bcrypto.sha256(bufferWriter.end());
      bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        4 * this.ins.length,
      );
      this.ins.forEach(txIn => bufferWriter.writeUInt32(txIn.sequence));
      hashSequences = bcrypto.sha256(bufferWriter.end());
    }
    if (!(isNone || isSingle)) {
      const txOutsSize = this.outs
        .map(output => 8 + varSliceSize(output.script))
        .reduce((a, b) => a + b);
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);
      this.outs.forEach(out => {
        bufferWriter.writeUInt64(out.value);
        bufferWriter.writeVarSlice(out.script);
      });
      hashOutputs = bcrypto.sha256(bufferWriter.end());
    } else if (isSingle && inIndex < this.outs.length) {
      const output = this.outs[inIndex];
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        8 + varSliceSize(output.script),
      );
      bufferWriter.writeUInt64(output.value);
      bufferWriter.writeVarSlice(output.script);
      hashOutputs = bcrypto.sha256(bufferWriter.end());
    }
    const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);
    // Length calculation from:
    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-14
    // With extension from:
    // https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#signature-validation
    const sigMsgSize =
      174 -
      (isAnyoneCanPay ? 49 : 0) -
      (isNone ? 32 : 0) +
      (annex ? 32 : 0) +
      (leafHash ? 37 : 0);
    const sigMsgWriter = bufferutils_1.BufferWriter.withCapacity(sigMsgSize);
    sigMsgWriter.writeUInt8(hashType);
    // Transaction
    sigMsgWriter.writeInt32(this.version);
    sigMsgWriter.writeUInt32(this.locktime);
    sigMsgWriter.writeSlice(hashPrevouts);
    sigMsgWriter.writeSlice(hashAmounts);
    sigMsgWriter.writeSlice(hashScriptPubKeys);
    sigMsgWriter.writeSlice(hashSequences);
    if (!(isNone || isSingle)) {
      sigMsgWriter.writeSlice(hashOutputs);
    }
    // Input
    sigMsgWriter.writeUInt8(spendType);
    if (isAnyoneCanPay) {
      const input = this.ins[inIndex];
      sigMsgWriter.writeSlice(input.hash);
      sigMsgWriter.writeUInt32(input.index);
      sigMsgWriter.writeUInt64(values[inIndex]);
      sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);
      sigMsgWriter.writeUInt32(input.sequence);
    } else {
      sigMsgWriter.writeUInt32(inIndex);
    }
    if (annex) {
      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
        varSliceSize(annex),
      );
      bufferWriter.writeVarSlice(annex);
      sigMsgWriter.writeSlice(bcrypto.sha256(bufferWriter.end()));
    }
    // Output
    if (isSingle) {
      sigMsgWriter.writeSlice(hashOutputs);
    }
    // BIP342 extension
    if (leafHash) {
      sigMsgWriter.writeSlice(leafHash);
      sigMsgWriter.writeUInt8(0);
      sigMsgWriter.writeUInt32(0xffffffff);
    }
    // Extra zero byte because:
    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-19
    return bcrypto.taggedHash(
      'TapSighash',
      Buffer.concat([Buffer.from([0x00]), sigMsgWriter.end()]),
    );
  }
  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {
    typeforce(
      types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),
      arguments,
    );
    let tbuffer = Buffer.from([]);
    let bufferWriter;
    let hashOutputs = ZERO;
    let hashPrevouts = ZERO;
    let hashSequence = ZERO;
    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {
      tbuffer = Buffer.allocUnsafe(36 * this.ins.length);
      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
      this.ins.forEach(txIn => {
        bufferWriter.writeSlice(txIn.hash);
        bufferWriter.writeUInt32(txIn.index);
      });
      hashPrevouts = bcrypto.hash256(tbuffer);
    }
    if (
      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&
      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&
      (hashType & 0x1f) !== Transaction.SIGHASH_NONE
    ) {
      tbuffer = Buffer.allocUnsafe(4 * this.ins.length);
      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
      this.ins.forEach(txIn => {
        bufferWriter.writeUInt32(txIn.sequence);
      });
      hashSequence = bcrypto.hash256(tbuffer);
    }
    if (
      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&
      (hashType & 0x1f) !== Transaction.SIGHASH_NONE
    ) {
      const txOutsSize = this.outs.reduce((sum, output) => {
        return sum + 8 + varSliceSize(output.script);
      }, 0);
      tbuffer = Buffer.allocUnsafe(txOutsSize);
      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
      this.outs.forEach(out => {
        bufferWriter.writeUInt64(out.value);
        bufferWriter.writeVarSlice(out.script);
      });
      hashOutputs = bcrypto.hash256(tbuffer);
    } else if (
      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&
      inIndex < this.outs.length
    ) {
      const output = this.outs[inIndex];
      tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));
      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
      bufferWriter.writeUInt64(output.value);
      bufferWriter.writeVarSlice(output.script);
      hashOutputs = bcrypto.hash256(tbuffer);
    }
    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));
    bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
    const input = this.ins[inIndex];
    bufferWriter.writeInt32(this.version);
    bufferWriter.writeSlice(hashPrevouts);
    bufferWriter.writeSlice(hashSequence);
    bufferWriter.writeSlice(input.hash);
    bufferWriter.writeUInt32(input.index);
    bufferWriter.writeVarSlice(prevOutScript);
    bufferWriter.writeUInt64(value);
    bufferWriter.writeUInt32(input.sequence);
    bufferWriter.writeSlice(hashOutputs);
    bufferWriter.writeUInt32(this.locktime);
    bufferWriter.writeUInt32(hashType);
    return bcrypto.hash256(tbuffer);
  }
  getHash(forWitness) {
    // wtxid for coinbase is always 32 bytes of 0x00
    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);
    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));
  }
  getId() {
    // transaction hash's are displayed in reverse order
    return (0, bufferutils_1.reverseBuffer)(this.getHash(false)).toString(
      'hex',
    );
  }
  toBuffer(buffer, initialOffset) {
    return this.__toBuffer(buffer, initialOffset, true);
  }
  toHex() {
    return this.toBuffer(undefined, undefined).toString('hex');
  }
  setInputScript(index, scriptSig) {
    typeforce(types.tuple(types.Number, types.Buffer), arguments);
    this.ins[index].script = scriptSig;
  }
  setWitness(index, witness) {
    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);
    this.ins[index].witness = witness;
  }
  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {
    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));
    const bufferWriter = new bufferutils_1.BufferWriter(
      buffer,
      initialOffset || 0,
    );
    bufferWriter.writeInt32(this.version);
    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
    if (hasWitnesses) {
      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);
      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);
    }
    bufferWriter.writeVarInt(this.ins.length);
    this.ins.forEach(txIn => {
      bufferWriter.writeSlice(txIn.hash);
      bufferWriter.writeUInt32(txIn.index);
      bufferWriter.writeVarSlice(txIn.script);
      bufferWriter.writeUInt32(txIn.sequence);
    });
    bufferWriter.writeVarInt(this.outs.length);
    this.outs.forEach(txOut => {
      if (isOutput(txOut)) {
        bufferWriter.writeUInt64(txOut.value);
      } else {
        bufferWriter.writeSlice(txOut.valueBuffer);
      }
      bufferWriter.writeVarSlice(txOut.script);
    });
    if (hasWitnesses) {
      this.ins.forEach(input => {
        bufferWriter.writeVector(input.witness);
      });
    }
    bufferWriter.writeUInt32(this.locktime);
    // avoid slicing unless necessary
    if (initialOffset !== undefined)
      return buffer.slice(initialOffset, bufferWriter.offset);
    return buffer;
  }
}
exports.Transaction = Transaction;
Transaction.DEFAULT_SEQUENCE = 0xffffffff;
Transaction.SIGHASH_DEFAULT = 0x00;
Transaction.SIGHASH_ALL = 0x01;
Transaction.SIGHASH_NONE = 0x02;
Transaction.SIGHASH_SINGLE = 0x03;
Transaction.SIGHASH_ANYONECANPAY = 0x80;
Transaction.SIGHASH_OUTPUT_MASK = 0x03;
Transaction.SIGHASH_INPUT_MASK = 0x80;
Transaction.ADVANCED_TRANSACTION_MARKER = 0x00;
Transaction.ADVANCED_TRANSACTION_FLAG = 0x01;


/***/ }),

/***/ 41838:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.oneOf =
  exports.Null =
  exports.BufferN =
  exports.Function =
  exports.UInt32 =
  exports.UInt8 =
  exports.tuple =
  exports.maybe =
  exports.Hex =
  exports.Buffer =
  exports.String =
  exports.Boolean =
  exports.Array =
  exports.Number =
  exports.Hash256bit =
  exports.Hash160bit =
  exports.Buffer256bit =
  exports.isTaptree =
  exports.isTapleaf =
  exports.TAPLEAF_VERSION_MASK =
  exports.Network =
  exports.ECPoint =
  exports.Satoshi =
  exports.Signer =
  exports.BIP32Path =
  exports.UInt31 =
  exports.isPoint =
  exports.typeforce =
    void 0;
const buffer_1 = __webpack_require__(48764);
exports.typeforce = __webpack_require__(2401);
const ZERO32 = buffer_1.Buffer.alloc(32, 0);
const EC_P = buffer_1.Buffer.from(
  'fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f',
  'hex',
);
function isPoint(p) {
  if (!buffer_1.Buffer.isBuffer(p)) return false;
  if (p.length < 33) return false;
  const t = p[0];
  const x = p.slice(1, 33);
  if (x.compare(ZERO32) === 0) return false;
  if (x.compare(EC_P) >= 0) return false;
  if ((t === 0x02 || t === 0x03) && p.length === 33) {
    return true;
  }
  const y = p.slice(33);
  if (y.compare(ZERO32) === 0) return false;
  if (y.compare(EC_P) >= 0) return false;
  if (t === 0x04 && p.length === 65) return true;
  return false;
}
exports.isPoint = isPoint;
const UINT31_MAX = Math.pow(2, 31) - 1;
function UInt31(value) {
  return exports.typeforce.UInt32(value) && value <= UINT31_MAX;
}
exports.UInt31 = UInt31;
function BIP32Path(value) {
  return (
    exports.typeforce.String(value) && !!value.match(/^(m\/)?(\d+'?\/)*\d+'?$/)
  );
}
exports.BIP32Path = BIP32Path;
BIP32Path.toJSON = () => {
  return 'BIP32 derivation path';
};
function Signer(obj) {
  return (
    (exports.typeforce.Buffer(obj.publicKey) ||
      typeof obj.getPublicKey === 'function') &&
    typeof obj.sign === 'function'
  );
}
exports.Signer = Signer;
const SATOSHI_MAX = 21 * 1e14;
function Satoshi(value) {
  return exports.typeforce.UInt53(value) && value <= SATOSHI_MAX;
}
exports.Satoshi = Satoshi;
// external dependent types
exports.ECPoint = exports.typeforce.quacksLike('Point');
// exposed, external API
exports.Network = exports.typeforce.compile({
  messagePrefix: exports.typeforce.oneOf(
    exports.typeforce.Buffer,
    exports.typeforce.String,
  ),
  bip32: {
    public: exports.typeforce.UInt32,
    private: exports.typeforce.UInt32,
  },
  pubKeyHash: exports.typeforce.UInt8,
  scriptHash: exports.typeforce.UInt8,
  wif: exports.typeforce.UInt8,
});
exports.TAPLEAF_VERSION_MASK = 0xfe;
function isTapleaf(o) {
  if (!o || !('output' in o)) return false;
  if (!buffer_1.Buffer.isBuffer(o.output)) return false;
  if (o.version !== undefined)
    return (o.version & exports.TAPLEAF_VERSION_MASK) === o.version;
  return true;
}
exports.isTapleaf = isTapleaf;
function isTaptree(scriptTree) {
  if (!(0, exports.Array)(scriptTree)) return isTapleaf(scriptTree);
  if (scriptTree.length !== 2) return false;
  return scriptTree.every(t => isTaptree(t));
}
exports.isTaptree = isTaptree;
exports.Buffer256bit = exports.typeforce.BufferN(32);
exports.Hash160bit = exports.typeforce.BufferN(20);
exports.Hash256bit = exports.typeforce.BufferN(32);
exports.Number = exports.typeforce.Number;
exports.Array = exports.typeforce.Array;
exports.Boolean = exports.typeforce.Boolean;
exports.String = exports.typeforce.String;
exports.Buffer = exports.typeforce.Buffer;
exports.Hex = exports.typeforce.Hex;
exports.maybe = exports.typeforce.maybe;
exports.tuple = exports.typeforce.tuple;
exports.UInt8 = exports.typeforce.UInt8;
exports.UInt32 = exports.typeforce.UInt32;
exports.Function = exports.typeforce.Function;
exports.BufferN = exports.typeforce.BufferN;
exports.Null = exports.typeforce.Null;
exports.oneOf = exports.typeforce.oneOf;


/***/ }),

/***/ 77191:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const basex = __webpack_require__(58162)
const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'

module.exports = basex(ALPHABET)


/***/ }),

/***/ 53310:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var base58 = __webpack_require__(77191)

module.exports = function (checksumFn) {
  // Encode a buffer as a base58-check encoded string
  function encode (payload) {
    var payloadU8 = Uint8Array.from(payload)
    var checksum = checksumFn(payloadU8)
    var length = payloadU8.length + 4
    var both = new Uint8Array(length)
    both.set(payloadU8, 0)
    both.set(checksum.subarray(0, 4), payloadU8.length)
    return base58.encode(both, length)
  }

  function decodeRaw (buffer) {
    var payload = buffer.slice(0, -4)
    var checksum = buffer.slice(-4)
    var newChecksum = checksumFn(payload)

    if (checksum[0] ^ newChecksum[0] |
        checksum[1] ^ newChecksum[1] |
        checksum[2] ^ newChecksum[2] |
        checksum[3] ^ newChecksum[3]) return

    return payload
  }

  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
  function decodeUnsafe (string) {
    var buffer = base58.decodeUnsafe(string)
    if (!buffer) return

    return decodeRaw(buffer)
  }

  function decode (string) {
    var buffer = base58.decode(string)
    var payload = decodeRaw(buffer, checksumFn)
    if (!payload) throw new Error('Invalid checksum')
    return payload
  }

  return {
    encode: encode,
    decode: decode,
    decodeUnsafe: decodeUnsafe
  }
}


/***/ }),

/***/ 58334:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var { sha256 } = __webpack_require__(23061)
var bs58checkBase = __webpack_require__(53310)

// SHA256(SHA256(buffer))
function sha256x2 (buffer) {
  return sha256(sha256(buffer))
}

module.exports = bs58checkBase(sha256x2)


/***/ }),

/***/ 82234:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: function() { return /* binding */ useCount; }
/* harmony export */ });
/* unused harmony export inCountRange */
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91);
/* harmony import */ var _babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1413);
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71002);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62435);



var _excluded = ["show"];

/**
 * Cut `value` by the `count.max` prop.
 */
function inCountRange(value, countConfig) {
  if (!countConfig.max) {
    return true;
  }
  var count = countConfig.strategy(value);
  return count <= countConfig.max;
}
function useCount(count, showCount) {
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {
    var mergedConfig = {};
    if (showCount) {
      mergedConfig.show = (0,_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(showCount) === 'object' && showCount.formatter ? showCount.formatter : !!showCount;
    }
    mergedConfig = (0,_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)((0,_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)({}, mergedConfig), count);
    var _ref = mergedConfig,
      show = _ref.show,
      rest = (0,_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(_ref, _excluded);
    return (0,_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)((0,_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)({}, rest), {}, {
      show: !!show,
      showFormatter: typeof show === 'function' ? show : undefined,
      strategy: rest.strategy || function (value) {
        return value.length;
      }
    });
  }, [count, showCount]);
}

/***/ }),

/***/ 67656:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Q: function() { return /* reexport */ es_BaseInput; },
  Z: function() { return /* binding */ es; }
});

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__(1413);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(87462);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(4942);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__(71002);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(93967);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: ./node_modules/@umijs/preset-umi/node_modules/react/index.js
var react = __webpack_require__(62435);
// EXTERNAL MODULE: ./node_modules/rc-input/es/utils/commonUtils.js
var commonUtils = __webpack_require__(87887);
;// CONCATENATED MODULE: ./node_modules/rc-input/es/BaseInput.js







var BaseInput = function BaseInput(props) {
  var _element$props, _element$props2;
  var inputEl = props.inputElement,
    children = props.children,
    prefixCls = props.prefixCls,
    prefix = props.prefix,
    suffix = props.suffix,
    addonBefore = props.addonBefore,
    addonAfter = props.addonAfter,
    className = props.className,
    style = props.style,
    disabled = props.disabled,
    readOnly = props.readOnly,
    focused = props.focused,
    triggerFocus = props.triggerFocus,
    allowClear = props.allowClear,
    value = props.value,
    handleReset = props.handleReset,
    hidden = props.hidden,
    classes = props.classes,
    classNames = props.classNames,
    dataAttrs = props.dataAttrs,
    styles = props.styles,
    components = props.components;
  var inputElement = children !== null && children !== void 0 ? children : inputEl;
  var AffixWrapperComponent = (components === null || components === void 0 ? void 0 : components.affixWrapper) || 'span';
  var GroupWrapperComponent = (components === null || components === void 0 ? void 0 : components.groupWrapper) || 'span';
  var WrapperComponent = (components === null || components === void 0 ? void 0 : components.wrapper) || 'span';
  var GroupAddonComponent = (components === null || components === void 0 ? void 0 : components.groupAddon) || 'span';
  var containerRef = (0,react.useRef)(null);
  var onInputClick = function onInputClick(e) {
    var _containerRef$current;
    if ((_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(e.target)) {
      triggerFocus === null || triggerFocus === void 0 || triggerFocus();
    }
  };
  var hasAffix = (0,commonUtils/* hasPrefixSuffix */.X3)(props);
  var element = /*#__PURE__*/(0,react.cloneElement)(inputElement, {
    value: value,
    className: classnames_default()(inputElement.props.className, !hasAffix && (classNames === null || classNames === void 0 ? void 0 : classNames.variant)) || null
  });

  // ================== Prefix & Suffix ================== //
  if (hasAffix) {
    var _clsx2;
    // ================== Clear Icon ================== //
    var clearIcon = null;
    if (allowClear) {
      var _clsx;
      var needClear = !disabled && !readOnly && value;
      var clearIconCls = "".concat(prefixCls, "-clear-icon");
      var iconNode = (0,esm_typeof/* default */.Z)(allowClear) === 'object' && allowClear !== null && allowClear !== void 0 && allowClear.clearIcon ? allowClear.clearIcon : '✖';
      clearIcon = /*#__PURE__*/react.createElement("span", {
        onClick: handleReset
        // Do not trigger onBlur when clear input
        // https://github.com/ant-design/ant-design/issues/31200
        ,
        onMouseDown: function onMouseDown(e) {
          return e.preventDefault();
        },
        className: classnames_default()(clearIconCls, (_clsx = {}, (0,defineProperty/* default */.Z)(_clsx, "".concat(clearIconCls, "-hidden"), !needClear), (0,defineProperty/* default */.Z)(_clsx, "".concat(clearIconCls, "-has-suffix"), !!suffix), _clsx)),
        role: "button",
        tabIndex: -1
      }, iconNode);
    }
    var affixWrapperPrefixCls = "".concat(prefixCls, "-affix-wrapper");
    var affixWrapperCls = classnames_default()(affixWrapperPrefixCls, (_clsx2 = {}, (0,defineProperty/* default */.Z)(_clsx2, "".concat(prefixCls, "-disabled"), disabled), (0,defineProperty/* default */.Z)(_clsx2, "".concat(affixWrapperPrefixCls, "-disabled"), disabled), (0,defineProperty/* default */.Z)(_clsx2, "".concat(affixWrapperPrefixCls, "-focused"), focused), (0,defineProperty/* default */.Z)(_clsx2, "".concat(affixWrapperPrefixCls, "-readonly"), readOnly), (0,defineProperty/* default */.Z)(_clsx2, "".concat(affixWrapperPrefixCls, "-input-with-clear-btn"), suffix && allowClear && value), _clsx2), classes === null || classes === void 0 ? void 0 : classes.affixWrapper, classNames === null || classNames === void 0 ? void 0 : classNames.affixWrapper, classNames === null || classNames === void 0 ? void 0 : classNames.variant);
    var suffixNode = (suffix || allowClear) && /*#__PURE__*/react.createElement("span", {
      className: classnames_default()("".concat(prefixCls, "-suffix"), classNames === null || classNames === void 0 ? void 0 : classNames.suffix),
      style: styles === null || styles === void 0 ? void 0 : styles.suffix
    }, clearIcon, suffix);
    element = /*#__PURE__*/react.createElement(AffixWrapperComponent, (0,esm_extends/* default */.Z)({
      className: affixWrapperCls,
      style: styles === null || styles === void 0 ? void 0 : styles.affixWrapper,
      onClick: onInputClick
    }, dataAttrs === null || dataAttrs === void 0 ? void 0 : dataAttrs.affixWrapper, {
      ref: containerRef
    }), prefix && /*#__PURE__*/react.createElement("span", {
      className: classnames_default()("".concat(prefixCls, "-prefix"), classNames === null || classNames === void 0 ? void 0 : classNames.prefix),
      style: styles === null || styles === void 0 ? void 0 : styles.prefix
    }, prefix), element, suffixNode);
  }

  // ================== Addon ================== //
  if ((0,commonUtils/* hasAddon */.He)(props)) {
    var wrapperCls = "".concat(prefixCls, "-group");
    var addonCls = "".concat(wrapperCls, "-addon");
    var groupWrapperCls = "".concat(wrapperCls, "-wrapper");
    var mergedWrapperClassName = classnames_default()("".concat(prefixCls, "-wrapper"), wrapperCls, classes === null || classes === void 0 ? void 0 : classes.wrapper, classNames === null || classNames === void 0 ? void 0 : classNames.wrapper);
    var mergedGroupClassName = classnames_default()(groupWrapperCls, (0,defineProperty/* default */.Z)({}, "".concat(groupWrapperCls, "-disabled"), disabled), classes === null || classes === void 0 ? void 0 : classes.group, classNames === null || classNames === void 0 ? void 0 : classNames.groupWrapper);

    // Need another wrapper for changing display:table to display:inline-block
    // and put style prop in wrapper
    element = /*#__PURE__*/react.createElement(GroupWrapperComponent, {
      className: mergedGroupClassName
    }, /*#__PURE__*/react.createElement(WrapperComponent, {
      className: mergedWrapperClassName
    }, addonBefore && /*#__PURE__*/react.createElement(GroupAddonComponent, {
      className: addonCls
    }, addonBefore), element, addonAfter && /*#__PURE__*/react.createElement(GroupAddonComponent, {
      className: addonCls
    }, addonAfter)));
  }

  // `className` and `style` are always on the root element
  return /*#__PURE__*/react.cloneElement(element, {
    className: classnames_default()((_element$props = element.props) === null || _element$props === void 0 ? void 0 : _element$props.className, className) || null,
    style: (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, (_element$props2 = element.props) === null || _element$props2 === void 0 ? void 0 : _element$props2.style), style),
    hidden: hidden
  });
};
/* harmony default export */ var es_BaseInput = (BaseInput);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 2 modules
var toConsumableArray = __webpack_require__(74902);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js + 1 modules
var slicedToArray = __webpack_require__(97685);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js + 1 modules
var objectWithoutProperties = __webpack_require__(91);
// EXTERNAL MODULE: ./node_modules/rc-util/es/hooks/useMergedState.js
var useMergedState = __webpack_require__(21770);
// EXTERNAL MODULE: ./node_modules/rc-util/es/omit.js
var omit = __webpack_require__(98423);
// EXTERNAL MODULE: ./node_modules/rc-input/es/hooks/useCount.js
var useCount = __webpack_require__(82234);
;// CONCATENATED MODULE: ./node_modules/rc-input/es/Input.js






var _excluded = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "count", "type", "classes", "classNames", "styles", "onCompositionStart", "onCompositionEnd"];







var Input = /*#__PURE__*/(0,react.forwardRef)(function (props, ref) {
  var autoComplete = props.autoComplete,
    onChange = props.onChange,
    onFocus = props.onFocus,
    onBlur = props.onBlur,
    onPressEnter = props.onPressEnter,
    onKeyDown = props.onKeyDown,
    _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-input' : _props$prefixCls,
    disabled = props.disabled,
    htmlSize = props.htmlSize,
    className = props.className,
    maxLength = props.maxLength,
    suffix = props.suffix,
    showCount = props.showCount,
    count = props.count,
    _props$type = props.type,
    type = _props$type === void 0 ? 'text' : _props$type,
    classes = props.classes,
    classNames = props.classNames,
    styles = props.styles,
    _onCompositionStart = props.onCompositionStart,
    onCompositionEnd = props.onCompositionEnd,
    rest = (0,objectWithoutProperties/* default */.Z)(props, _excluded);
  var _useState = (0,react.useState)(false),
    _useState2 = (0,slicedToArray/* default */.Z)(_useState, 2),
    focused = _useState2[0],
    setFocused = _useState2[1];
  var compositionRef = (0,react.useRef)(false);
  var inputRef = (0,react.useRef)(null);
  var focus = function focus(option) {
    if (inputRef.current) {
      (0,commonUtils/* triggerFocus */.nH)(inputRef.current, option);
    }
  };

  // ====================== Value =======================
  var _useMergedState = (0,useMergedState/* default */.Z)(props.defaultValue, {
      value: props.value
    }),
    _useMergedState2 = (0,slicedToArray/* default */.Z)(_useMergedState, 2),
    value = _useMergedState2[0],
    setValue = _useMergedState2[1];
  var formatValue = value === undefined || value === null ? '' : String(value);

  // =================== Select Range ===================
  var _useState3 = (0,react.useState)(null),
    _useState4 = (0,slicedToArray/* default */.Z)(_useState3, 2),
    selection = _useState4[0],
    setSelection = _useState4[1];

  // ====================== Count =======================
  var countConfig = (0,useCount/* default */.Z)(count, showCount);
  var mergedMax = countConfig.max || maxLength;
  var valueLength = countConfig.strategy(formatValue);
  var isOutOfRange = !!mergedMax && valueLength > mergedMax;

  // ======================= Ref ========================
  (0,react.useImperativeHandle)(ref, function () {
    return {
      focus: focus,
      blur: function blur() {
        var _inputRef$current;
        (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.blur();
      },
      setSelectionRange: function setSelectionRange(start, end, direction) {
        var _inputRef$current2;
        (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.setSelectionRange(start, end, direction);
      },
      select: function select() {
        var _inputRef$current3;
        (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 || _inputRef$current3.select();
      },
      input: inputRef.current
    };
  });
  (0,react.useEffect)(function () {
    setFocused(function (prev) {
      return prev && disabled ? false : prev;
    });
  }, [disabled]);
  var triggerChange = function triggerChange(e, currentValue, info) {
    var cutValue = currentValue;
    if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
      cutValue = countConfig.exceedFormatter(currentValue, {
        max: countConfig.max
      });
      if (currentValue !== cutValue) {
        var _inputRef$current4, _inputRef$current5;
        setSelection([((_inputRef$current4 = inputRef.current) === null || _inputRef$current4 === void 0 ? void 0 : _inputRef$current4.selectionStart) || 0, ((_inputRef$current5 = inputRef.current) === null || _inputRef$current5 === void 0 ? void 0 : _inputRef$current5.selectionEnd) || 0]);
      }
    } else if (info.source === 'compositionEnd') {
      // Avoid triggering twice
      // https://github.com/ant-design/ant-design/issues/46587
      return;
    }
    setValue(cutValue);
    if (inputRef.current) {
      (0,commonUtils/* resolveOnChange */.rJ)(inputRef.current, e, onChange, cutValue);
    }
  };
  (0,react.useEffect)(function () {
    if (selection) {
      var _inputRef$current6;
      (_inputRef$current6 = inputRef.current) === null || _inputRef$current6 === void 0 || _inputRef$current6.setSelectionRange.apply(_inputRef$current6, (0,toConsumableArray/* default */.Z)(selection));
    }
  }, [selection]);
  var onInternalChange = function onInternalChange(e) {
    triggerChange(e, e.target.value, {
      source: 'change'
    });
  };
  var onInternalCompositionEnd = function onInternalCompositionEnd(e) {
    compositionRef.current = false;
    triggerChange(e, e.currentTarget.value, {
      source: 'compositionEnd'
    });
    onCompositionEnd === null || onCompositionEnd === void 0 || onCompositionEnd(e);
  };
  var handleKeyDown = function handleKeyDown(e) {
    if (onPressEnter && e.key === 'Enter') {
      onPressEnter(e);
    }
    onKeyDown === null || onKeyDown === void 0 || onKeyDown(e);
  };
  var handleFocus = function handleFocus(e) {
    setFocused(true);
    onFocus === null || onFocus === void 0 || onFocus(e);
  };
  var handleBlur = function handleBlur(e) {
    setFocused(false);
    onBlur === null || onBlur === void 0 || onBlur(e);
  };
  var handleReset = function handleReset(e) {
    setValue('');
    focus();
    if (inputRef.current) {
      (0,commonUtils/* resolveOnChange */.rJ)(inputRef.current, e, onChange);
    }
  };

  // ====================== Input =======================
  var outOfRangeCls = isOutOfRange && "".concat(prefixCls, "-out-of-range");
  var getInputElement = function getInputElement() {
    // Fix https://fb.me/react-unknown-prop
    var otherProps = (0,omit/* default */.Z)(props, ['prefixCls', 'onPressEnter', 'addonBefore', 'addonAfter', 'prefix', 'suffix', 'allowClear',
    // Input elements must be either controlled or uncontrolled,
    // specify either the value prop, or the defaultValue prop, but not both.
    'defaultValue', 'showCount', 'count', 'classes', 'htmlSize', 'styles', 'classNames']);
    return /*#__PURE__*/react.createElement("input", (0,esm_extends/* default */.Z)({
      autoComplete: autoComplete
    }, otherProps, {
      onChange: onInternalChange,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyDown: handleKeyDown,
      className: classnames_default()(prefixCls, (0,defineProperty/* default */.Z)({}, "".concat(prefixCls, "-disabled"), disabled), classNames === null || classNames === void 0 ? void 0 : classNames.input),
      style: styles === null || styles === void 0 ? void 0 : styles.input,
      ref: inputRef,
      size: htmlSize,
      type: type,
      onCompositionStart: function onCompositionStart(e) {
        compositionRef.current = true;
        _onCompositionStart === null || _onCompositionStart === void 0 || _onCompositionStart(e);
      },
      onCompositionEnd: onInternalCompositionEnd
    }));
  };
  var getSuffix = function getSuffix() {
    // Max length value
    var hasMaxLength = Number(mergedMax) > 0;
    if (suffix || countConfig.show) {
      var dataCount = countConfig.showFormatter ? countConfig.showFormatter({
        value: formatValue,
        count: valueLength,
        maxLength: mergedMax
      }) : "".concat(valueLength).concat(hasMaxLength ? " / ".concat(mergedMax) : '');
      return /*#__PURE__*/react.createElement(react.Fragment, null, countConfig.show && /*#__PURE__*/react.createElement("span", {
        className: classnames_default()("".concat(prefixCls, "-show-count-suffix"), (0,defineProperty/* default */.Z)({}, "".concat(prefixCls, "-show-count-has-suffix"), !!suffix), classNames === null || classNames === void 0 ? void 0 : classNames.count),
        style: (0,objectSpread2/* default */.Z)({}, styles === null || styles === void 0 ? void 0 : styles.count)
      }, dataCount), suffix);
    }
    return null;
  };

  // ====================== Render ======================
  return /*#__PURE__*/react.createElement(es_BaseInput, (0,esm_extends/* default */.Z)({}, rest, {
    prefixCls: prefixCls,
    className: classnames_default()(className, outOfRangeCls),
    handleReset: handleReset,
    value: formatValue,
    focused: focused,
    triggerFocus: focus,
    suffix: getSuffix(),
    disabled: disabled,
    classes: classes,
    classNames: classNames,
    styles: styles
  }), getInputElement());
});
/* harmony default export */ var es_Input = (Input);
;// CONCATENATED MODULE: ./node_modules/rc-input/es/index.js



/* harmony default export */ var es = (es_Input);

/***/ }),

/***/ 87887:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   He: function() { return /* binding */ hasAddon; },
/* harmony export */   X3: function() { return /* binding */ hasPrefixSuffix; },
/* harmony export */   nH: function() { return /* binding */ triggerFocus; },
/* harmony export */   rJ: function() { return /* binding */ resolveOnChange; }
/* harmony export */ });
function hasAddon(props) {
  return !!(props.addonBefore || props.addonAfter);
}
function hasPrefixSuffix(props) {
  return !!(props.prefix || props.suffix || props.allowClear);
}

// TODO: It's better to use `Proxy` replace the `element.value`. But we still need support IE11.
function cloneEvent(event, target, value) {
  // A bug report filed on WebKit's Bugzilla tracker, dating back to 2009, specifically addresses the issue of cloneNode() not copying files of <input type="file"> elements.
  // As of the last update, this bug was still marked as "NEW," indicating that it might not have been resolved yet​​.
  // https://bugs.webkit.org/show_bug.cgi?id=28123
  var currentTarget = target.cloneNode(true);

  // click clear icon
  var newEvent = Object.create(event, {
    target: {
      value: currentTarget
    },
    currentTarget: {
      value: currentTarget
    }
  });

  // Fill data
  currentTarget.value = value;

  // Fill selection. Some type like `email` not support selection
  // https://github.com/ant-design/ant-design/issues/47833
  if (typeof target.selectionStart === 'number' && typeof target.selectionEnd === 'number') {
    currentTarget.selectionStart = target.selectionStart;
    currentTarget.selectionEnd = target.selectionEnd;
  }
  return newEvent;
}
function resolveOnChange(target, e, onChange, targetValue) {
  if (!onChange) {
    return;
  }
  var event = e;
  if (e.type === 'click') {
    // Clone a new target for event.
    // Avoid the following usage, the setQuery method gets the original value.
    //
    // const [query, setQuery] = React.useState('');
    // <Input
    //   allowClear
    //   value={query}
    //   onChange={(e)=> {
    //     setQuery((prevStatus) => e.target.value);
    //   }}
    // />

    event = cloneEvent(e, target, '');
    onChange(event);
    return;
  }

  // Trigger by composition event, this means we need force change the input value
  // https://github.com/ant-design/ant-design/issues/45737
  // https://github.com/ant-design/ant-design/issues/46598
  if (target.type !== 'file' && targetValue !== undefined) {
    event = cloneEvent(e, target, targetValue);
    onChange(event);
    return;
  }
  onChange(event);
}
function triggerFocus(element, option) {
  if (!element) return;
  element.focus(option);

  // Selection content
  var _ref = option || {},
    cursor = _ref.cursor;
  if (cursor) {
    var len = element.value.length;
    switch (cursor) {
      case 'start':
        element.setSelectionRange(0, 0);
        break;
      case 'end':
        element.setSelectionRange(len, len);
        break;
      default:
        element.setSelectionRange(0, len);
    }
  }
}

/***/ }),

/***/ 9220:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: function() { return /* binding */ es; }
});

// UNUSED EXPORTS: _rs

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(87462);
// EXTERNAL MODULE: ./node_modules/@umijs/preset-umi/node_modules/react/index.js
var react = __webpack_require__(62435);
// EXTERNAL MODULE: ./node_modules/rc-util/es/Children/toArray.js
var toArray = __webpack_require__(50344);
// EXTERNAL MODULE: ./node_modules/rc-util/es/warning.js
var warning = __webpack_require__(80334);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__(1413);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__(71002);
// EXTERNAL MODULE: ./node_modules/rc-util/es/Dom/findDOMNode.js
var findDOMNode = __webpack_require__(34203);
// EXTERNAL MODULE: ./node_modules/rc-util/es/ref.js
var es_ref = __webpack_require__(42550);
;// CONCATENATED MODULE: ./node_modules/rc-resize-observer/es/Collection.js

var CollectionContext = /*#__PURE__*/react.createContext(null);
/**
 * Collect all the resize event from children ResizeObserver
 */
function Collection(_ref) {
  var children = _ref.children,
    onBatchResize = _ref.onBatchResize;
  var resizeIdRef = react.useRef(0);
  var resizeInfosRef = react.useRef([]);
  var onCollectionResize = react.useContext(CollectionContext);
  var onResize = react.useCallback(function (size, element, data) {
    resizeIdRef.current += 1;
    var currentId = resizeIdRef.current;
    resizeInfosRef.current.push({
      size: size,
      element: element,
      data: data
    });
    Promise.resolve().then(function () {
      if (currentId === resizeIdRef.current) {
        onBatchResize === null || onBatchResize === void 0 || onBatchResize(resizeInfosRef.current);
        resizeInfosRef.current = [];
      }
    });

    // Continue bubbling if parent exist
    onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(size, element, data);
  }, [onBatchResize, onCollectionResize]);
  return /*#__PURE__*/react.createElement(CollectionContext.Provider, {
    value: onResize
  }, children);
}
;// CONCATENATED MODULE: ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.Math === Math) {
        return __webpack_require__.g;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

/* harmony default export */ var ResizeObserver_es = (index);

;// CONCATENATED MODULE: ./node_modules/rc-resize-observer/es/utils/observerUtil.js

// =============================== Const ===============================
var elementListeners = new Map();
function onResize(entities) {
  entities.forEach(function (entity) {
    var _elementListeners$get;
    var target = entity.target;
    (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 || _elementListeners$get.forEach(function (listener) {
      return listener(target);
    });
  });
}

// Note: ResizeObserver polyfill not support option to measure border-box resize
var resizeObserver = new ResizeObserver_es(onResize);

// Dev env only
var _el = (/* unused pure expression or super */ null && ( false ? 0 : null)); // eslint-disable-line
var _rs = (/* unused pure expression or super */ null && ( false ? 0 : null)); // eslint-disable-line

// ============================== Observe ==============================
function observe(element, callback) {
  if (!elementListeners.has(element)) {
    elementListeners.set(element, new Set());
    resizeObserver.observe(element);
  }
  elementListeners.get(element).add(callback);
}
function unobserve(element, callback) {
  if (elementListeners.has(element)) {
    elementListeners.get(element).delete(callback);
    if (!elementListeners.get(element).size) {
      resizeObserver.unobserve(element);
      elementListeners.delete(element);
    }
  }
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
var classCallCheck = __webpack_require__(15671);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
var createClass = __webpack_require__(43144);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js + 1 modules
var inherits = __webpack_require__(32531);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createSuper.js
var createSuper = __webpack_require__(29388);
;// CONCATENATED MODULE: ./node_modules/rc-resize-observer/es/SingleObserver/DomWrapper.js





/**
 * Fallback to findDOMNode if origin ref do not provide any dom element
 */
var DomWrapper = /*#__PURE__*/function (_React$Component) {
  (0,inherits/* default */.Z)(DomWrapper, _React$Component);
  var _super = (0,createSuper/* default */.Z)(DomWrapper);
  function DomWrapper() {
    (0,classCallCheck/* default */.Z)(this, DomWrapper);
    return _super.apply(this, arguments);
  }
  (0,createClass/* default */.Z)(DomWrapper, [{
    key: "render",
    value: function render() {
      return this.props.children;
    }
  }]);
  return DomWrapper;
}(react.Component);

;// CONCATENATED MODULE: ./node_modules/rc-resize-observer/es/SingleObserver/index.js








function SingleObserver(props, ref) {
  var children = props.children,
    disabled = props.disabled;
  var elementRef = react.useRef(null);
  var wrapperRef = react.useRef(null);
  var onCollectionResize = react.useContext(CollectionContext);

  // =========================== Children ===========================
  var isRenderProps = typeof children === 'function';
  var mergedChildren = isRenderProps ? children(elementRef) : children;

  // ============================= Size =============================
  var sizeRef = react.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  });

  // ============================= Ref ==============================
  var canRef = !isRenderProps && /*#__PURE__*/react.isValidElement(mergedChildren) && (0,es_ref/* supportRef */.Yr)(mergedChildren);
  var originRef = canRef ? mergedChildren.ref : null;
  var mergedRef = (0,es_ref/* useComposeRef */.x1)(originRef, elementRef);
  var getDom = function getDom() {
    var _elementRef$current;
    return (0,findDOMNode/* default */.Z)(elementRef.current) || (
    // Support `nativeElement` format
    elementRef.current && (0,esm_typeof/* default */.Z)(elementRef.current) === 'object' ? (0,findDOMNode/* default */.Z)((_elementRef$current = elementRef.current) === null || _elementRef$current === void 0 ? void 0 : _elementRef$current.nativeElement) : null) || (0,findDOMNode/* default */.Z)(wrapperRef.current);
  };
  react.useImperativeHandle(ref, function () {
    return getDom();
  });

  // =========================== Observe ============================
  var propsRef = react.useRef(props);
  propsRef.current = props;

  // Handler
  var onInternalResize = react.useCallback(function (target) {
    var _propsRef$current = propsRef.current,
      onResize = _propsRef$current.onResize,
      data = _propsRef$current.data;
    var _target$getBoundingCl = target.getBoundingClientRect(),
      width = _target$getBoundingCl.width,
      height = _target$getBoundingCl.height;
    var offsetWidth = target.offsetWidth,
      offsetHeight = target.offsetHeight;

    /**
     * Resize observer trigger when content size changed.
     * In most case we just care about element size,
     * let's use `boundary` instead of `contentRect` here to avoid shaking.
     */
    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);
    if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
      var size = {
        width: fixedWidth,
        height: fixedHeight,
        offsetWidth: offsetWidth,
        offsetHeight: offsetHeight
      };
      sizeRef.current = size;

      // IE is strange, right?
      var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
      var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
      var sizeInfo = (0,objectSpread2/* default */.Z)((0,objectSpread2/* default */.Z)({}, size), {}, {
        offsetWidth: mergedOffsetWidth,
        offsetHeight: mergedOffsetHeight
      });

      // Let collection know what happened
      onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(sizeInfo, target, data);
      if (onResize) {
        // defer the callback but not defer to next frame
        Promise.resolve().then(function () {
          onResize(sizeInfo, target);
        });
      }
    }
  }, []);

  // Dynamic observe
  react.useEffect(function () {
    var currentElement = getDom();
    if (currentElement && !disabled) {
      observe(currentElement, onInternalResize);
    }
    return function () {
      return unobserve(currentElement, onInternalResize);
    };
  }, [elementRef.current, disabled]);

  // ============================ Render ============================
  return /*#__PURE__*/react.createElement(DomWrapper, {
    ref: wrapperRef
  }, canRef ? /*#__PURE__*/react.cloneElement(mergedChildren, {
    ref: mergedRef
  }) : mergedChildren);
}
var RefSingleObserver = /*#__PURE__*/react.forwardRef(SingleObserver);
if (false) {}
/* harmony default export */ var es_SingleObserver = (RefSingleObserver);
;// CONCATENATED MODULE: ./node_modules/rc-resize-observer/es/index.js






var INTERNAL_PREFIX_KEY = 'rc-observer-key';


function es_ResizeObserver(props, ref) {
  var children = props.children;
  var childNodes = typeof children === 'function' ? [children] : (0,toArray/* default */.Z)(children);
  if (false) {}
  return childNodes.map(function (child, index) {
    var key = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index);
    return /*#__PURE__*/react.createElement(es_SingleObserver, (0,esm_extends/* default */.Z)({}, props, {
      key: key,
      ref: index === 0 ? ref : undefined
    }), child);
  });
}
var RefResizeObserver = /*#__PURE__*/react.forwardRef(es_ResizeObserver);
if (false) {}
RefResizeObserver.Collection = Collection;
/* harmony default export */ var es = (RefResizeObserver);

/***/ }),

/***/ 31131:
/***/ (function(__unused_webpack_module, __webpack_exports__) {

"use strict";
/* harmony default export */ __webpack_exports__.Z = (function () {
  if (typeof navigator === 'undefined' || typeof window === 'undefined') {
    return false;
  }
  var agent = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
});

/***/ }),

/***/ 89509:
/***/ (function(module, exports, __webpack_require__) {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(48764)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 96647:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var native = __webpack_require__(30247)

function getTypeName (fn) {
  return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1]
}

function getValueTypeName (value) {
  return native.Nil(value) ? '' : getTypeName(value.constructor)
}

function getValue (value) {
  if (native.Function(value)) return ''
  if (native.String(value)) return JSON.stringify(value)
  if (value && native.Object(value)) return ''
  return value
}

function captureStackTrace (e, t) {
  if (Error.captureStackTrace) {
    Error.captureStackTrace(e, t)
  }
}

function tfJSON (type) {
  if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type)
  if (native.Array(type)) return 'Array'
  if (type && native.Object(type)) return 'Object'

  return type !== undefined ? type : ''
}

function tfErrorString (type, value, valueTypeName) {
  var valueJson = getValue(value)

  return 'Expected ' + tfJSON(type) + ', got' +
    (valueTypeName !== '' ? ' ' + valueTypeName : '') +
    (valueJson !== '' ? ' ' + valueJson : '')
}

function TfTypeError (type, value, valueTypeName) {
  valueTypeName = valueTypeName || getValueTypeName(value)
  this.message = tfErrorString(type, value, valueTypeName)

  captureStackTrace(this, TfTypeError)
  this.__type = type
  this.__value = value
  this.__valueTypeName = valueTypeName
}

TfTypeError.prototype = Object.create(Error.prototype)
TfTypeError.prototype.constructor = TfTypeError

function tfPropertyErrorString (type, label, name, value, valueTypeName) {
  var description = '" of type '
  if (label === 'key') description = '" with key type '

  return tfErrorString('property "' + tfJSON(name) + description + tfJSON(type), value, valueTypeName)
}

function TfPropertyTypeError (type, property, label, value, valueTypeName) {
  if (type) {
    valueTypeName = valueTypeName || getValueTypeName(value)
    this.message = tfPropertyErrorString(type, label, property, value, valueTypeName)
  } else {
    this.message = 'Unexpected property "' + property + '"'
  }

  captureStackTrace(this, TfTypeError)
  this.__label = label
  this.__property = property
  this.__type = type
  this.__value = value
  this.__valueTypeName = valueTypeName
}

TfPropertyTypeError.prototype = Object.create(Error.prototype)
TfPropertyTypeError.prototype.constructor = TfTypeError

function tfCustomError (expected, actual) {
  return new TfTypeError(expected, {}, actual)
}

function tfSubError (e, property, label) {
  // sub child?
  if (e instanceof TfPropertyTypeError) {
    property = property + '.' + e.__property

    e = new TfPropertyTypeError(
      e.__type, property, e.__label, e.__value, e.__valueTypeName
    )

  // child?
  } else if (e instanceof TfTypeError) {
    e = new TfPropertyTypeError(
      e.__type, property, label, e.__value, e.__valueTypeName
    )
  }

  captureStackTrace(e)
  return e
}

module.exports = {
  TfTypeError: TfTypeError,
  TfPropertyTypeError: TfPropertyTypeError,
  tfCustomError: tfCustomError,
  tfSubError: tfSubError,
  tfJSON: tfJSON,
  getValueTypeName: getValueTypeName
}


/***/ }),

/***/ 74307:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* provided dependency */ var Buffer = __webpack_require__(48764)["Buffer"];
var NATIVE = __webpack_require__(30247)
var ERRORS = __webpack_require__(96647)

function _Buffer (value) {
  return Buffer.isBuffer(value)
}

function Hex (value) {
  return typeof value === 'string' && /^([0-9a-f]{2})+$/i.test(value)
}

function _LengthN (type, length) {
  var name = type.toJSON()

  function Length (value) {
    if (!type(value)) return false
    if (value.length === length) return true

    throw ERRORS.tfCustomError(name + '(Length: ' + length + ')', name + '(Length: ' + value.length + ')')
  }
  Length.toJSON = function () { return name }

  return Length
}

var _ArrayN = _LengthN.bind(null, NATIVE.Array)
var _BufferN = _LengthN.bind(null, _Buffer)
var _HexN = _LengthN.bind(null, Hex)
var _StringN = _LengthN.bind(null, NATIVE.String)

function Range (a, b, f) {
  f = f || NATIVE.Number
  function _range (value, strict) {
    return f(value, strict) && (value > a) && (value < b)
  }
  _range.toJSON = function () {
    return `${f.toJSON()} between [${a}, ${b}]`
  }
  return _range
}

var INT53_MAX = Math.pow(2, 53) - 1

function Finite (value) {
  return typeof value === 'number' && isFinite(value)
}
function Int8 (value) { return ((value << 24) >> 24) === value }
function Int16 (value) { return ((value << 16) >> 16) === value }
function Int32 (value) { return (value | 0) === value }
function Int53 (value) {
  return typeof value === 'number' &&
    value >= -INT53_MAX &&
    value <= INT53_MAX &&
    Math.floor(value) === value
}
function UInt8 (value) { return (value & 0xff) === value }
function UInt16 (value) { return (value & 0xffff) === value }
function UInt32 (value) { return (value >>> 0) === value }
function UInt53 (value) {
  return typeof value === 'number' &&
    value >= 0 &&
    value <= INT53_MAX &&
    Math.floor(value) === value
}

var types = {
  ArrayN: _ArrayN,
  Buffer: _Buffer,
  BufferN: _BufferN,
  Finite: Finite,
  Hex: Hex,
  HexN: _HexN,
  Int8: Int8,
  Int16: Int16,
  Int32: Int32,
  Int53: Int53,
  Range: Range,
  StringN: _StringN,
  UInt8: UInt8,
  UInt16: UInt16,
  UInt32: UInt32,
  UInt53: UInt53
}

for (var typeName in types) {
  types[typeName].toJSON = function (t) {
    return t
  }.bind(null, typeName)
}

module.exports = types


/***/ }),

/***/ 2401:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var ERRORS = __webpack_require__(96647)
var NATIVE = __webpack_require__(30247)

// short-hand
var tfJSON = ERRORS.tfJSON
var TfTypeError = ERRORS.TfTypeError
var TfPropertyTypeError = ERRORS.TfPropertyTypeError
var tfSubError = ERRORS.tfSubError
var getValueTypeName = ERRORS.getValueTypeName

var TYPES = {
  arrayOf: function arrayOf (type, options) {
    type = compile(type)
    options = options || {}

    function _arrayOf (array, strict) {
      if (!NATIVE.Array(array)) return false
      if (NATIVE.Nil(array)) return false
      if (options.minLength !== undefined && array.length < options.minLength) return false
      if (options.maxLength !== undefined && array.length > options.maxLength) return false
      if (options.length !== undefined && array.length !== options.length) return false

      return array.every(function (value, i) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          throw tfSubError(e, i)
        }
      })
    }
    _arrayOf.toJSON = function () {
      var str = '[' + tfJSON(type) + ']'
      if (options.length !== undefined) {
        str += '{' + options.length + '}'
      } else if (options.minLength !== undefined || options.maxLength !== undefined) {
        str += '{' +
          (options.minLength === undefined ? 0 : options.minLength) + ',' +
          (options.maxLength === undefined ? Infinity : options.maxLength) + '}'
      }
      return str
    }

    return _arrayOf
  },

  maybe: function maybe (type) {
    type = compile(type)

    function _maybe (value, strict) {
      return NATIVE.Nil(value) || type(value, strict, maybe)
    }
    _maybe.toJSON = function () { return '?' + tfJSON(type) }

    return _maybe
  },

  map: function map (propertyType, propertyKeyType) {
    propertyType = compile(propertyType)
    if (propertyKeyType) propertyKeyType = compile(propertyKeyType)

    function _map (value, strict) {
      if (!NATIVE.Object(value)) return false
      if (NATIVE.Nil(value)) return false

      for (var propertyName in value) {
        try {
          if (propertyKeyType) {
            typeforce(propertyKeyType, propertyName, strict)
          }
        } catch (e) {
          throw tfSubError(e, propertyName, 'key')
        }

        try {
          var propertyValue = value[propertyName]
          typeforce(propertyType, propertyValue, strict)
        } catch (e) {
          throw tfSubError(e, propertyName)
        }
      }

      return true
    }

    if (propertyKeyType) {
      _map.toJSON = function () {
        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}'
      }
    } else {
      _map.toJSON = function () { return '{' + tfJSON(propertyType) + '}' }
    }

    return _map
  },

  object: function object (uncompiled) {
    var type = {}

    for (var typePropertyName in uncompiled) {
      type[typePropertyName] = compile(uncompiled[typePropertyName])
    }

    function _object (value, strict) {
      if (!NATIVE.Object(value)) return false
      if (NATIVE.Nil(value)) return false

      var propertyName

      try {
        for (propertyName in type) {
          var propertyType = type[propertyName]
          var propertyValue = value[propertyName]

          typeforce(propertyType, propertyValue, strict)
        }
      } catch (e) {
        throw tfSubError(e, propertyName)
      }

      if (strict) {
        for (propertyName in value) {
          if (type[propertyName]) continue

          throw new TfPropertyTypeError(undefined, propertyName)
        }
      }

      return true
    }
    _object.toJSON = function () { return tfJSON(type) }

    return _object
  },

  anyOf: function anyOf () {
    var types = [].slice.call(arguments).map(compile)

    function _anyOf (value, strict) {
      return types.some(function (type) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          return false
        }
      })
    }
    _anyOf.toJSON = function () { return types.map(tfJSON).join('|') }

    return _anyOf
  },

  allOf: function allOf () {
    var types = [].slice.call(arguments).map(compile)

    function _allOf (value, strict) {
      return types.every(function (type) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          return false
        }
      })
    }
    _allOf.toJSON = function () { return types.map(tfJSON).join(' & ') }

    return _allOf
  },

  quacksLike: function quacksLike (type) {
    function _quacksLike (value) {
      return type === getValueTypeName(value)
    }
    _quacksLike.toJSON = function () { return type }

    return _quacksLike
  },

  tuple: function tuple () {
    var types = [].slice.call(arguments).map(compile)

    function _tuple (values, strict) {
      if (NATIVE.Nil(values)) return false
      if (NATIVE.Nil(values.length)) return false
      if (strict && (values.length !== types.length)) return false

      return types.every(function (type, i) {
        try {
          return typeforce(type, values[i], strict)
        } catch (e) {
          throw tfSubError(e, i)
        }
      })
    }
    _tuple.toJSON = function () { return '(' + types.map(tfJSON).join(', ') + ')' }

    return _tuple
  },

  value: function value (expected) {
    function _value (actual) {
      return actual === expected
    }
    _value.toJSON = function () { return expected }

    return _value
  }
}

// TODO: deprecate
TYPES.oneOf = TYPES.anyOf

function compile (type) {
  if (NATIVE.String(type)) {
    if (type[0] === '?') return TYPES.maybe(type.slice(1))

    return NATIVE[type] || TYPES.quacksLike(type)
  } else if (type && NATIVE.Object(type)) {
    if (NATIVE.Array(type)) {
      if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1')
      return TYPES.arrayOf(type[0])
    }

    return TYPES.object(type)
  } else if (NATIVE.Function(type)) {
    return type
  }

  return TYPES.value(type)
}

function typeforce (type, value, strict, surrogate) {
  if (NATIVE.Function(type)) {
    if (type(value, strict)) return true

    throw new TfTypeError(surrogate || type, value)
  }

  // JIT
  return typeforce(compile(type), value, strict)
}

// assign types to typeforce function
for (var typeName in NATIVE) {
  typeforce[typeName] = NATIVE[typeName]
}

for (typeName in TYPES) {
  typeforce[typeName] = TYPES[typeName]
}

var EXTRA = __webpack_require__(74307)
for (typeName in EXTRA) {
  typeforce[typeName] = EXTRA[typeName]
}

typeforce.compile = compile
typeforce.TfTypeError = TfTypeError
typeforce.TfPropertyTypeError = TfPropertyTypeError

module.exports = typeforce


/***/ }),

/***/ 30247:
/***/ (function(module) {

var types = {
  Array: function (value) { return value !== null && value !== undefined && value.constructor === Array },
  Boolean: function (value) { return typeof value === 'boolean' },
  Function: function (value) { return typeof value === 'function' },
  Nil: function (value) { return value === undefined || value === null },
  Number: function (value) { return typeof value === 'number' },
  Object: function (value) { return typeof value === 'object' },
  String: function (value) { return typeof value === 'string' },
  '': function () { return true }
}

// TODO: deprecate
types.Null = types.Nil

for (var typeName in types) {
  types[typeName].toJSON = function (t) {
    return t
  }.bind(null, typeName)
}

module.exports = types


/***/ }),

/***/ 57795:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var Buffer = (__webpack_require__(89509).Buffer)

// Number.MAX_SAFE_INTEGER
var MAX_SAFE_INTEGER = 9007199254740991

function checkUInt53 (n) {
  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range')
}

function encode (number, buffer, offset) {
  checkUInt53(number)

  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(number))
  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')
  if (!offset) offset = 0

  // 8 bit
  if (number < 0xfd) {
    buffer.writeUInt8(number, offset)
    encode.bytes = 1

  // 16 bit
  } else if (number <= 0xffff) {
    buffer.writeUInt8(0xfd, offset)
    buffer.writeUInt16LE(number, offset + 1)
    encode.bytes = 3

  // 32 bit
  } else if (number <= 0xffffffff) {
    buffer.writeUInt8(0xfe, offset)
    buffer.writeUInt32LE(number, offset + 1)
    encode.bytes = 5

  // 64 bit
  } else {
    buffer.writeUInt8(0xff, offset)
    buffer.writeUInt32LE(number >>> 0, offset + 1)
    buffer.writeUInt32LE((number / 0x100000000) | 0, offset + 5)
    encode.bytes = 9
  }

  return buffer
}

function decode (buffer, offset) {
  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')
  if (!offset) offset = 0

  var first = buffer.readUInt8(offset)

  // 8 bit
  if (first < 0xfd) {
    decode.bytes = 1
    return first

  // 16 bit
  } else if (first === 0xfd) {
    decode.bytes = 3
    return buffer.readUInt16LE(offset + 1)

  // 32 bit
  } else if (first === 0xfe) {
    decode.bytes = 5
    return buffer.readUInt32LE(offset + 1)

  // 64 bit
  } else {
    decode.bytes = 9
    var lo = buffer.readUInt32LE(offset + 1)
    var hi = buffer.readUInt32LE(offset + 5)
    var number = hi * 0x0100000000 + lo
    checkUInt53(number)

    return number
  }
}

function encodingLength (number) {
  checkUInt53(number)

  return (
    number < 0xfd ? 1
      : number <= 0xffff ? 3
        : number <= 0xffffffff ? 5
          : 9
  )
}

module.exports = { encode: encode, decode: decode, encodingLength: encodingLength }


/***/ }),

/***/ 96446:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(37923);
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}
module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 96936:
/***/ (function(module) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 88619:
/***/ (function(module) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 19632:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(96446);
var iterableToArray = __webpack_require__(96936);
var unsupportedIterableToArray = __webpack_require__(96263);
var nonIterableSpread = __webpack_require__(88619);
function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}
module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 70155:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  __initializeContext: function() { return /* binding */ __initializeContext; },
  isPoint: function() { return /* binding */ lib_isPoint; },
  isPointCompressed: function() { return /* binding */ lib_isPointCompressed; },
  isPrivate: function() { return /* binding */ lib_isPrivate; },
  isXOnlyPoint: function() { return /* binding */ lib_isXOnlyPoint; },
  pointAdd: function() { return /* binding */ lib_pointAdd; },
  pointAddScalar: function() { return /* binding */ lib_pointAddScalar; },
  pointCompress: function() { return /* binding */ lib_pointCompress; },
  pointFromScalar: function() { return /* binding */ lib_pointFromScalar; },
  pointMultiply: function() { return /* binding */ lib_pointMultiply; },
  privateAdd: function() { return /* binding */ lib_privateAdd; },
  privateNegate: function() { return /* binding */ lib_privateNegate; },
  privateSub: function() { return /* binding */ lib_privateSub; },
  recover: function() { return /* binding */ lib_recover; },
  sign: function() { return /* binding */ lib_sign; },
  signRecoverable: function() { return /* binding */ lib_signRecoverable; },
  signSchnorr: function() { return /* binding */ lib_signSchnorr; },
  verify: function() { return /* binding */ lib_verify; },
  verifySchnorr: function() { return /* binding */ lib_verifySchnorr; },
  xOnlyPointAddTweak: function() { return /* binding */ lib_xOnlyPointAddTweak; },
  xOnlyPointAddTweakCheck: function() { return /* binding */ lib_xOnlyPointAddTweakCheck; },
  xOnlyPointFromPoint: function() { return /* binding */ lib_xOnlyPointFromPoint; },
  xOnlyPointFromScalar: function() { return /* binding */ lib_xOnlyPointFromScalar; }
});

// NAMESPACE OBJECT: ./node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/validate_error.js
var validate_error_namespaceObject = {};
__webpack_require__.r(validate_error_namespaceObject);
__webpack_require__.d(validate_error_namespaceObject, {
  ERROR_BAD_EXTRA_DATA: function() { return ERROR_BAD_EXTRA_DATA; },
  ERROR_BAD_HASH: function() { return ERROR_BAD_HASH; },
  ERROR_BAD_PARITY: function() { return ERROR_BAD_PARITY; },
  ERROR_BAD_POINT: function() { return ERROR_BAD_POINT; },
  ERROR_BAD_PRIVATE: function() { return ERROR_BAD_PRIVATE; },
  ERROR_BAD_RECOVERY_ID: function() { return ERROR_BAD_RECOVERY_ID; },
  ERROR_BAD_SIGNATURE: function() { return ERROR_BAD_SIGNATURE; },
  ERROR_BAD_TWEAK: function() { return ERROR_BAD_TWEAK; },
  throwError: function() { return throwError; }
});

// NAMESPACE OBJECT: ./node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/rand.browser.js
var rand_browser_namespaceObject = {};
__webpack_require__.r(rand_browser_namespaceObject);
__webpack_require__.d(rand_browser_namespaceObject, {
  generateInt32: function() { return generateInt32; }
});

// NAMESPACE OBJECT: ./node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/secp256k1.asm.js
var secp256k1_asm_namespaceObject = {};
__webpack_require__.r(secp256k1_asm_namespaceObject);
__webpack_require__.d(secp256k1_asm_namespaceObject, {
  EXTRA_DATA_INPUT: function() { return EXTRA_DATA_INPUT; },
  HASH_INPUT: function() { return HASH_INPUT; },
  PRIVATE_INPUT: function() { return PRIVATE_INPUT; },
  PUBLIC_KEY_INPUT: function() { return PUBLIC_KEY_INPUT; },
  PUBLIC_KEY_INPUT2: function() { return PUBLIC_KEY_INPUT2; },
  SIGNATURE_INPUT: function() { return SIGNATURE_INPUT; },
  TWEAK_INPUT: function() { return TWEAK_INPUT; },
  X_ONLY_PUBLIC_KEY_INPUT: function() { return X_ONLY_PUBLIC_KEY_INPUT; },
  X_ONLY_PUBLIC_KEY_INPUT2: function() { return X_ONLY_PUBLIC_KEY_INPUT2; },
  __data_end: function() { return __data_end; },
  __heap_base: function() { return __heap_base; },
  initializeContext: function() { return initializeContext; },
  isPoint: function() { return secp256k1_asm_isPoint; },
  memory: function() { return memory; },
  pointAdd: function() { return pointAdd; },
  pointAddScalar: function() { return pointAddScalar; },
  pointCompress: function() { return pointCompress; },
  pointFromScalar: function() { return pointFromScalar; },
  pointMultiply: function() { return pointMultiply; },
  privateAdd: function() { return privateAdd; },
  privateNegate: function() { return privateNegate; },
  privateSub: function() { return privateSub; },
  recover: function() { return recover; },
  rustsecp256k1_v0_8_1_default_error_callback_fn: function() { return rustsecp256k1_v0_8_1_default_error_callback_fn; },
  rustsecp256k1_v0_8_1_default_illegal_callback_fn: function() { return rustsecp256k1_v0_8_1_default_illegal_callback_fn; },
  sign: function() { return sign; },
  signRecoverable: function() { return signRecoverable; },
  signSchnorr: function() { return signSchnorr; },
  verify: function() { return verify; },
  verifySchnorr: function() { return verifySchnorr; },
  xOnlyPointAddTweak: function() { return xOnlyPointAddTweak; },
  xOnlyPointAddTweakCheck: function() { return xOnlyPointAddTweakCheck; },
  xOnlyPointFromPoint: function() { return xOnlyPointFromPoint; },
  xOnlyPointFromScalar: function() { return xOnlyPointFromScalar; }
});

;// CONCATENATED MODULE: ./node_modules/uint8array-tools/src/mjs/browser.js
const HEX_STRINGS = "0123456789abcdefABCDEF";
const HEX_CODES = HEX_STRINGS.split("").map((c) => c.codePointAt(0));
const HEX_CODEPOINTS = Array(256)
    .fill(true)
    .map((_, i) => {
    const s = String.fromCodePoint(i);
    const index = HEX_STRINGS.indexOf(s);
    // ABCDEF will use 10 - 15
    return index < 0 ? undefined : index < 16 ? index : index - 6;
});
const ENCODER = new TextEncoder();
const DECODER = new TextDecoder("ascii");
// There are two implementations.
// One optimizes for length of the bytes, and uses TextDecoder.
// One optimizes for iteration count, and appends strings.
// This removes the overhead of TextDecoder.
function toHex(bytes) {
    const b = bytes || new Uint8Array();
    return b.length > 512 ? _toHexLengthPerf(b) : _toHexIterPerf(b);
}
function _toHexIterPerf(bytes) {
    let s = "";
    for (let i = 0; i < bytes.length; ++i) {
        s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] >> 4]]];
        s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] & 15]]];
    }
    return s;
}
function _toHexLengthPerf(bytes) {
    const hexBytes = new Uint8Array(bytes.length * 2);
    for (let i = 0; i < bytes.length; ++i) {
        hexBytes[i * 2] = HEX_CODES[bytes[i] >> 4];
        hexBytes[i * 2 + 1] = HEX_CODES[bytes[i] & 15];
    }
    return DECODER.decode(hexBytes);
}
// Mimics Buffer.from(x, 'hex') logic
// Stops on first non-hex string and returns
// https://github.com/nodejs/node/blob/v14.18.1/src/string_bytes.cc#L246-L261
function fromHex(hexString) {
    const hexBytes = ENCODER.encode(hexString || "");
    const resultBytes = new Uint8Array(Math.floor(hexBytes.length / 2));
    let i;
    for (i = 0; i < resultBytes.length; i++) {
        const a = HEX_CODEPOINTS[hexBytes[i * 2]];
        const b = HEX_CODEPOINTS[hexBytes[i * 2 + 1]];
        if (a === undefined || b === undefined) {
            break;
        }
        resultBytes[i] = (a << 4) | b;
    }
    return i === resultBytes.length ? resultBytes : resultBytes.slice(0, i);
}
// Same behavior as Buffer.compare()
function compare(v1, v2) {
    const minLength = Math.min(v1.length, v2.length);
    for (let i = 0; i < minLength; ++i) {
        if (v1[i] !== v2[i]) {
            return v1[i] < v2[i] ? -1 : 1;
        }
    }
    return v1.length === v2.length ? 0 : v1.length > v2.length ? 1 : -1;
}

;// CONCATENATED MODULE: ./node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/validate_error.js
const ERROR_BAD_PRIVATE = 0;
const ERROR_BAD_POINT = 1;
const ERROR_BAD_TWEAK = 2;
const ERROR_BAD_HASH = 3;
const ERROR_BAD_SIGNATURE = 4;
const ERROR_BAD_EXTRA_DATA = 5;
const ERROR_BAD_PARITY = 6;
const ERROR_BAD_RECOVERY_ID = 7;
const ERRORS_MESSAGES = {
    [ERROR_BAD_PRIVATE.toString()]: "Expected Private",
    [ERROR_BAD_POINT.toString()]: "Expected Point",
    [ERROR_BAD_TWEAK.toString()]: "Expected Tweak",
    [ERROR_BAD_HASH.toString()]: "Expected Hash",
    [ERROR_BAD_SIGNATURE.toString()]: "Expected Signature",
    [ERROR_BAD_EXTRA_DATA.toString()]: "Expected Extra Data (32 bytes)",
    [ERROR_BAD_PARITY.toString()]: "Expected Parity (1 | 0)",
    [ERROR_BAD_RECOVERY_ID.toString()]: "Bad Recovery Id",
};
function throwError(errcode) {
    const message = ERRORS_MESSAGES[errcode.toString()] || `Unknow error code: ${errcode}`;
    throw new TypeError(message);
}

;// CONCATENATED MODULE: ./node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/validate.js

const PRIVATE_KEY_SIZE = 32;
const PUBLIC_KEY_COMPRESSED_SIZE = 33;
const PUBLIC_KEY_UNCOMPRESSED_SIZE = 65;
const X_ONLY_PUBLIC_KEY_SIZE = 32;
const TWEAK_SIZE = 32;
const HASH_SIZE = 32;
const EXTRA_DATA_SIZE = 32;
const SIGNATURE_SIZE = 64;
const BN32_ZERO = new Uint8Array(32);
const BN32_N = new Uint8Array([
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65,
]);
// Difference between field and order
const BN32_P_MINUS_N = new Uint8Array([
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 69, 81, 35, 25, 80, 183, 95,
    196, 64, 45, 161, 114, 47, 201, 186, 238,
]);
function isUint8Array(value) {
    return value instanceof Uint8Array;
}
function cmpBN32(data1, data2) {
    for (let i = 0; i < 32; ++i) {
        if (data1[i] !== data2[i]) {
            return data1[i] < data2[i] ? -1 : 1;
        }
    }
    return 0;
}
function isZero(x) {
    return cmpBN32(x, BN32_ZERO) === 0;
}
function isPrivate(x) {
    return (isUint8Array(x) &&
        x.length === PRIVATE_KEY_SIZE &&
        cmpBN32(x, BN32_ZERO) > 0 &&
        cmpBN32(x, BN32_N) < 0);
}
function isPoint(p) {
    return (isUint8Array(p) &&
        (p.length === PUBLIC_KEY_COMPRESSED_SIZE ||
            p.length === PUBLIC_KEY_UNCOMPRESSED_SIZE ||
            p.length === X_ONLY_PUBLIC_KEY_SIZE));
}
function isXOnlyPoint(p) {
    return isUint8Array(p) && p.length === X_ONLY_PUBLIC_KEY_SIZE;
}
function isDERPoint(p) {
    return (isUint8Array(p) &&
        (p.length === PUBLIC_KEY_COMPRESSED_SIZE ||
            p.length === PUBLIC_KEY_UNCOMPRESSED_SIZE));
}
function isPointCompressed(p) {
    return isUint8Array(p) && p.length === PUBLIC_KEY_COMPRESSED_SIZE;
}
function isTweak(tweak) {
    return (isUint8Array(tweak) &&
        tweak.length === TWEAK_SIZE &&
        cmpBN32(tweak, BN32_N) < 0);
}
function isHash(h) {
    return isUint8Array(h) && h.length === HASH_SIZE;
}
function isExtraData(e) {
    return e === undefined || (isUint8Array(e) && e.length === EXTRA_DATA_SIZE);
}
function isSignature(signature) {
    return (isUint8Array(signature) &&
        signature.length === 64 &&
        cmpBN32(signature.subarray(0, 32), BN32_N) < 0 &&
        cmpBN32(signature.subarray(32, 64), BN32_N) < 0);
}
function isSigrLessThanPMinusN(signature) {
    return (isUint8Array(signature) &&
        signature.length === 64 &&
        cmpBN32(signature.subarray(0, 32), BN32_P_MINUS_N) < 0);
}
function validateParity(p) {
    if (p !== 0 && p !== 1)
        throwError(ERROR_BAD_PARITY);
}
function validatePrivate(d) {
    if (!isPrivate(d))
        throwError(ERROR_BAD_PRIVATE);
}
function validatePoint(p) {
    if (!isPoint(p))
        throwError(ERROR_BAD_POINT);
}
function validateXOnlyPoint(p) {
    if (!isXOnlyPoint(p))
        throwError(ERROR_BAD_POINT);
}
function validateTweak(tweak) {
    if (!isTweak(tweak))
        throwError(ERROR_BAD_TWEAK);
}
function validateHash(h) {
    if (!isHash(h))
        throwError(ERROR_BAD_HASH);
}
function validateExtraData(e) {
    if (!isExtraData(e))
        throwError(ERROR_BAD_EXTRA_DATA);
}
function validateSignature(signature) {
    if (!isSignature(signature))
        throwError(ERROR_BAD_SIGNATURE);
}
function validateSignatureCustom(validatorFn) {
    if (!validatorFn())
        throwError(ERROR_BAD_SIGNATURE);
}
function validateSignatureNonzeroRS(signature) {
    if (isZero(signature.subarray(0, 32)))
        throwError(ERROR_BAD_SIGNATURE);
    if (isZero(signature.subarray(32, 64)))
        throwError(ERROR_BAD_SIGNATURE);
}
function validateSigrPMinusN(signature) {
    if (!isSigrLessThanPMinusN(signature))
        throwError(ERROR_BAD_RECOVERY_ID);
}

;// CONCATENATED MODULE: ./node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/rand.browser.js
function get4RandomBytes() {
    const bytes = new Uint8Array(4);
    if (typeof crypto === "undefined") {
        throw new Error("The crypto object is unavailable. This may occur if your environment does not support the Web Cryptography API.");
    }
    crypto.getRandomValues(bytes);
    return bytes;
}
// Only to be used to initialize the context for rust-secp256k1
function generateInt32() {
    const array = get4RandomBytes();
    return ((array[0] << (3 * 8)) +
        (array[1] << (2 * 8)) +
        (array[2] << (1 * 8)) +
        array[3]);
}

;// CONCATENATED MODULE: ./node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/secp256k1.asm.js



  var bufferView;
  var base64ReverseLookup = new Uint8Array(123/*'z'+1*/);
  for (var i = 25; i >= 0; --i) {
    base64ReverseLookup[48+i] = 52+i; // '0-9'
    base64ReverseLookup[65+i] = i; // 'A-Z'
    base64ReverseLookup[97+i] = 26+i; // 'a-z'
  }
  base64ReverseLookup[43] = 62; // '+'
  base64ReverseLookup[47] = 63; // '/'
  /** @noinline Inlining this function would mean expanding the base64 string 4x times in the source code, which Closure seems to be happy to do. */
  function base64DecodeToExistingUint8Array(uint8Array, offset, b64) {
    var b1, b2, i = 0, j = offset, bLength = b64.length, end = offset + (bLength*3>>2) - (b64[bLength-2] == '=') - (b64[bLength-1] == '=');
    for (; i < bLength; i += 4) {
      b1 = base64ReverseLookup[b64.charCodeAt(i+1)];
      b2 = base64ReverseLookup[b64.charCodeAt(i+2)];
      uint8Array[j++] = base64ReverseLookup[b64.charCodeAt(i)] << 2 | b1 >> 4;
      if (j < end) uint8Array[j++] = b1 << 4 | b2 >> 2;
      if (j < end) uint8Array[j++] = b2 << 6 | base64ReverseLookup[b64.charCodeAt(i+3)];
    }
  }
function initActiveSegments(imports) {
  base64DecodeToExistingUint8Array(bufferView, 655360, "AQAAAAQAAAAEAAAAAgAAAAEAAAAEAAAABAAAAAM=");
  base64DecodeToExistingUint8Array(bufferView, 655716, "MHgwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OQAAmBf4FluB8lnZKM4t2/ybAgcLh86VYqBVrLvc+X5mvnm41BD7j9BHnBlUhaZItBf9qAgRDvz7pF1lxKMmd9o6SPk24LwT8QGGsJlvg0XIMbUpUp34hU80SRDDWJIBijD5cua4hHX9uWwbI8I0makAZVbzNyrmN+MPFOgtYw97jzjk70CyadWoy7eaYdy9hIvoKFFcCiWntFWTIAcaTd6LL9ZirKY6fajcQGgNqxsniPcmxMmm3anb1Nbj5TYmIqzYvPnEyu3dK+mc4zADfptBPQ566vJl85ij6rRdbmTwvVzaZHIIKCYIpbXn/RO40BOo21Qahm2NF6NgWSW6QMrratrAxJ5MRHsbNaM+cnhWjOguFh+YrcE5kjNfO/bSuWiPgv8fUHm/PPL9C1GV/izqu10hvrbCkB3ehjkGui2fKmb6CTjS7bjiGL5U2VGzXIT9CB9F8mMzqYsin1Auvh04OFLtHzMYdXC9TfLYMsv8gTbMsQ5SpQWUsNwXuQ8KLaPkEKPCl0gmpD4wJhJApa6G8aGZRqqCG5L25io35CQnJknQ3idegbZBDM74X6cSNhZtOzAUl1b6LFr5q6e8c+c3EzEtvc55sIQTjdsG/1YazE344nfks1Pi1ZAMJBqMVgbjRG5UkoNAK2kmODe+QoC8/7YNfX8QK4+IYEKTeONvrA61SwS6SOXO+9Bs3ggfe4FWUka1IcBa65rsPu1uc9OeOkqXx0UMAULSwQ5gjpgXdatpaU+euGPG3yPAyb0oWcx7WO+rUE98P2ARl3hK+ITmXPxKT6cBPBNOVyjLw3V2TeRL+xsenEtXtaMgU7Ib0mSMIG4ACmzYahniLC7+L7a8JXBHje6bJFAzcGJpSbFgS5Eepc3WkSUI528WGIGkmNpq6zrsoxod3wAHDE0IAN/dHIW6LRHavKegd3iE863fNMJDVz96KlVh7dGVOp8t+YZPfsrpTJXqELn7TSZj6EqpACMIBDfOF3HtD2xVGc96VUFnBNgGFDPnFY/Q0mrx91N/gU9lTXPsZQnD1ibLn8AHq3n0wc4vLze4svfNHOtihBslkMwMBxjRo5JDwKIYpO7kM33D+ydk3lUdiae0VWcvBrvSCyaNvjpZ7dDP8cHRcMyFxwC+KU/LDzwR2ZyZX7XDqhUQbXeYJ/ZxggbfMvPizV4Iax1FH2ocWiKWVgt5RYm5sKrWa9LD0di9Mq+m9c2j3M9sCU0UYu5CUSUaQRu0pMM07gCUAuDWVaOhLs0d22LSRqFyrcqfKWzlnilqf9466L+atwke32JNjXVD8dky5Fv6PTTlH2JKMH/5dcZnr9QhGbYSpZbONbDzGWwg5bloqdRBH1+ekjOFGoUqAKf+0BPPzQvSenGq+aSBGYe5mcJy6zWnTxlgAUmLQRjekelqP5FLAk3JGzBm+9qJfMyHJ3NRAJct3Qrl8oTzQBoB6H5LeVK056gw2AEAnRCjyM5nvpT5EMrdi3dZMvngpgOCwhTL+7vZCOi9nlXXQXqgmhbkBXbd7LbEKhO3JOxCOt8YN6o1VlcBmEsciALMGQXhi+ud9s8DtkW31ww1sLatSEhcyibWNhGwvoNRMlTPQVQykDv4smW+0IS5134YdkCBeq7lPNdnchkPk358vlKdha+Kfrfh9+S5mz3adPJ/SV1R8HhGtIXIQiy/uUi0YekfLYeWP+nhVa0/dtReClSHZNqGVn9xF3NFOwfL2xKZXszs9wdHTuBX+ixECod2BAqFZMxvZUZVoWLAoLLMaC5XN7z10Ms7uXyDofveppHSrF98dUQGPp+JN2rZRFgNwIoHmRlH5rWxOoZEK/LloyxBrsNUCp4jLDMqWiUtmIxH4qAPNeusewFu2VBDBIuzntiR5JXj2NdBHuUBDcY7fnA53ck1UHspg4g0QtvzdKcEOCznV7T7YX4RuWEp2plPO2Nv/hCcBfrlyQIAq1nCw7tay+N0fyI2Ca2UjC1etOIYBrZ4xuuGNWHLMBvioBaN4Z17ao+RpHUIeWDX8IlMvea2Yw85w8uRj1+Z6zRtJgA1tx+sjR7lKuE54zGqIxVEqPcz4znZ4Yxe9gx+WQz9pJUxE5LPvPq4VUXsziGelYuiuKQsJL9UjEl/3oeeV316iKNWBZTpmimwjrDbM6W+5Fi1K2BRI4VAJZFkp6vL9Q2L5z4bqsekA5Y6F9A9jD9kfbGm18605bhU7cX6f3cSVWUhDJo5Kks8gwBvHSpS1aj0SK/NiRokPzU0zR6sZuscLd7ja39y7p+gO8x6f3duFV6NiQjCdc7hftugrVqPO+WgDeGIDez5WjaYI21g4Iwl8vZkYebmsXx66DJn21kFPuSCjLNTduQvBFZ2rbl68lfoZHprxfrpSdBbMtwzCySd9IcPnoNWTGsZ8JxI/m+R0oNGSjDfm2u3Z9Y2YsBsJekhsF+uljZg03RLm7I3fmISfdH+QeKTdNVQVeQYtjaNXGs2aOc584S12vu1FCu61xJCJuwUZ8/2/hmmZ4jdxm2p8Rb55P0xHHnLnpfJ6nh7wdiaCjQcoe7asQnxMbQZ3z3jVUi0ap74LpsjW97UZlf1c5dEMh2yMtfMbRTzxndzZDegrEsoIqc0oPw8nfvZmwDrLdt7UVAw+vre/w21yuO5RrC0UGPz050BwpMcHfClRFduxr87LE+dIjU2cemJQ3NEfX2GENK02C7IqSQfjeuQtU9lN1jIyP8GIj9lZeucswdDuem7usEm+KnBhvP8QsDapInFhEGEV3su/94uMnDZmlwteAbrAPLTQmVVE+OvViCLwxtS9a/Lly12ZJKzXEBlpbsnQAmDAAZc8+m50HQPMqE+ln05Sk3nYGFN3ZRmu3brBw0X8Eer7m3f36Uyp8L6gI5/CVNDLYz889YDcsZiAvm3AkjvXznAIh58Ro57zjwUjrzhHesLgcRfKIhzULfU7q82l2qBVPXCh2T9gOiiidfg2UGOyT9V/+/OqHFhaMnnGFNgQXmrq2Hu0jRJhKI7aVaGTRTtenQ7SwIR2Zb8FFbCzxTA9lyGBN2f0E5S393vehgn/zCxl8Neg+I/E76bUp76S1vGh+rxZWMP3g5ZKHQ89zWs/1q9/IUA+k55jtMZwesGim6vHbns0rO+Mo2ZdK9S4bZnNuoPm82xsRE5kpk6GGdRDt1X6kwQHQFt97yEJFnSi2PpRhttMwwpOcLD+m1FSQBQleYZFCT8r7h2oYSJNwejGhKkigoXSY/mjVVFJmJW9/CTsktG43IWWIrwL0w4upSZCw9C8Sn4MAulBIoQcfS/fPLa/jOwsUyi3At7Yg3+U49FgHbhek+7UOssQGr/OZ8hC/mP5hPsY0fBPrB0o7BTxc4B7RP7JguX6o4dJvgHJOovyNbaNXi/ppYdsjrkYf0z/UCeSWiYR2hu+3fuPN518iF78fMAXg+oqR8hCGtCRnxmm9xmXJ+gKimmuUu8B2u32U0FAxazekDZKZ+9zgm8EW9ylWS57GKoOZIEDl1zXGM/oRI6p+cdb4kAsGBQWDjqRe4Snv25lk1Dr9nzzCFeT9E1klpdnGp99/AS9M/Zktn8DItADa+TOIoVdP5+q9HK+R3f3f6uBMr9OKtpuu7WwM/wIVatnwHjHnPkrRjwzL3DyVRkRPSttiQPYelJpEOrwlQc0en7y/Fj0+SmHhTCHBOOrEAxDoTuWNO4CujpZ36Dve6ZWlG0ExtjVcCLmnl7CkGG5qk4rdO0yY6BuychwTA27/FOkWobsbo63s7wiHQwi4JjiBfKd5TlYAcNOhG5gWdbNx8TSW9m0pXlyJZlMZydnQiOMJDhJ0gqNSyB3RK8S6AjXBOvI9ip8iyo7jCJNC2UARX5n2Awsck3dlUSPvw5orsGFJpx/zvAlNHBwdEoaHtxcmExtEeCDlMAJtXGxkGByjnecrxL1oeTXjG2OHUljC64ntPxHks8y1H0VboovAwi4StduFRgh+XP6kv/lCadETFXWKGnM90bq7sKJbC9xs21SEBW80prYadCrCTkwIYxjD49h+T5KoBaDmH0UzfvjVc5VjFYPnYKGe1AiItn9F8YktAYW8JZoTTXjnFfflz4g6YvRriF2laxeLHTsmkUL51L9IWO3W68qWrb/lOo6Rc/+XvZ4JtC50n/j1Z0D8VzAEwhdaCsuo/AMayLV50DJpieZ0Yn/F2e/wdieTacC6dhUg59I8ZHa8Ip48p4ar8RAOZ2JmiUqO0rFr4W3fTJqJZTwNHtnNSF8Z9Ng5Ybyikh0Fp4ptkYOhDrnER7A8O5+9vCW+Couv/lG+vTbDIqvXAKFuD8igUClluUU8wUTzLer2XNuEMF+n6oXLoCEHkjK8iTI2gcF/oBMavnu7cuj8ZHbLuLaCSfgIidn6RnSYa20twY9FILjRF4Fl4A/bZmSUCgqjP5EhUr7XubR41Wv1cCrAu6MPvrMApAZzAKS3AJKmK0vLw+tHYmCwz3oD6N39EeJFO/tx2aUu9ccdB9m8a5pkfGj47tVHrFldQeLltFBQV0ldKKY+Oa40soXs1npawr3ZHeC10zWZJD8E6AAJtKLWvIpVPDteFiBUrJhNkt0RchE6XK75rrc95STTgeAg1efYcen7pb7V92ShxbwtWKJfuY1hBQOENVMMLb/PUoYP25YkICejMTsNyEmIvtFn++43nmyqtXfMn6SIkNBTZY4XHW+8F54RgPaz7ochb20GWYV+0oZWhmdBRYCzLi9zbJDmTKJMDs6yRw7gyBLY1cdIoV5IcPJ3kGJ4FMDtQkWRmx3XdbM6EAeGxyrVWA0OGghoKM89Va/+qsYZstu5hFfX2ZFi7NUDtzI+tEiMDPi3DcX7u7AmT69UFZ4Z2PCJeNi8A7nNENgiP7gVfKcYf5md6XqRteTzt54F4GrWqu6fU7c7an1jTZy1Usj9tZpwiV3b2/8FXibW3y2/FM5lOoA3Lc9sb4IuMu0oVb2fS5goXzVbfWWDmAiPPiScExh4XLLJhstViEBcsAP0S/pNmyJnstsc8Em0lz0LWFa7CleWelLV38uLVKqHNvTaxsNwj8PhckebxROx5FjTbOY8FJ3YgzJxO/zSodlqYP9JGtbroz5UU9QvFcCYFeBLt4GaeV+hhXR4XSZ8pMpqmy/DoQCj7YIWILxVRYjr3c2AbLeQhzSr1m0ktjCGWTWVmT39Gx43jlEpKQScVoFwByh1rwUVqDHUplpCxyhiwevPVZUc1YFHVRcxZoxm1Ztp6cYKJRTcCY8GZme+SpYtfJDyZh+9jYGSeylWm+June16qFtnwCRcr65UyreYxImuN5rUeB0lkDByD8GDjleUV/CDFQJz5usFm0h4gkTYIzkZd27qJcHMA5aBZg2n20HJgOuSEHPNNNuVYmPPh2f7XOXwWka64HeiaN7/pmMMoJNB0PzZ+pwCjPCoOnWDoZ87R0rlrqzibcZPSpF+KNohj0OaNDHTZRmMBOqv+qG6pLWAP7XrvXuUtRPCDYz4/cw42dy97oRwpb3hcC7WQo8ZsovBG4Adib7Zn5Z4aBvRnHUS6RY17xOsDde8ekpyVkjob/7jrXpPCeE6vvAc6NsWcgd7b+cEecRPGr5YgBM9XXBr2UtSlqeZBp6oEUA3N3CBrNS43qfVlH/GK6Vg9ti+EYC+Jj86qn4Tr5Rdc4M0yYaouHJAsyO80gnmnSNk8JwrXtz8OwrAD4m87vZUquukUc7oMzwe9lDTcCZtxJNLikEOTfAwIx7Siu9ge9zSafBkUYMuyL9dZ4bvVsyCGgbZw3tzqbIn7BCZr4NDFlpYl24gppFFyN95HMJEzGu+mw+ostPws574eJ95lhGTUC6TfzMeH1oRY5QascdpG9bfKOsg/ww9MmBZe3570RMP0XhdplNUAc6fffcgLxrsKdrl3Xn2d9PefZkQELj76ISy7F0w0if1IRMvLOReyeMHY/zy9rZLIYHEQK4Ul3BuO1QpbjAI+EiM/HL0AHrJteYYXsnDZVYjXtAAUoZ70mybeagVpSoZng8mEyTiNwYGOwyQ4L5Lh8wjJp7sqNIPkiWQMys/PMjzpn8pNsWnhrtCsMO2nJSfJrI57vPlmA2bWA3geDukiaL2nDzaDJpzw9oGLXkrynkjAlqfGsPj5FyJ5ulGZjCaKcC3mzWELUetrdH4ST4QYVFVEB7PYvP5eGUEAlp4vnHXjPJWcQsGDrlowJtwtmRvxj5t+O+yBdeLhNbcT7Lgi5Iezwh89MYjiJt2yE9HIHPGpVRA4twEKRImvwOdUZlGwyv16dWCRdoKVZ1GnZJ6omtJlMQq/uviVCBkMhfSVXt7+ddbvmti8BN7GboKQ4ujqrmKYPQJA8tAuYOGODJJMVZH95edvUQ/1fxjj4Rt9+jWJWcmT97ru34I5nN+Gw79oXRbi/z7risj3F+BPU+8/zJwZNJFw7RUh+Aoo8b1l4JTNf2TFcDusLSk1jEgmjXyzHWFPhvx2KbHx8GjBaC8zalzx8AGA4KVAGigzfUk9wmurGP0JB8JFEm3LOPOrcfnVcFonE7wenkiz6dG8Hpd0J+Lj3Y21ByVtia9CQWhzAlIRhbHxl5/LG1HpFWyPDlempmMvizitQK6jdcrqJtYBt842mjAuTC/aLHjpAm1VGQqRuvQMQP/1oiGL3rroSGrTxcJk3/497UrXWwKZCpVmCS7Sit4gIqkRHSNS8N6LuHADh9zMybQoMpwaSs++mMeRRu69CGFWU5tDAPFLSeXHAy8IBclcvDarLAzN7PmX05cfeG1Ii0K/6HLuYd6EIK1A/3OW1fd3BvNMZVlvzfhUH6LnLUPyBqSLRnS4D2WvEuF3iAMN2hlV4UvM/UYt/TGJIufXJrBTvxJQ3BgB62Qs58tSuYIf9bpf51xfB6sior1rYxtP8aaKKBuryNxsiqgdTTGkprKx0Veld0B6hMMp5ojcyUreimkjotB+xA/eIghH9yTV01s3zdpTzPV1X4BiXBdolaIel8dxTvf3fUL0tTttJPBGeFA0oEIRS1KQLPTdQ41bnvDZH0LrbuG2zi/mfUJx4z/2wnnx0IQVGsNwSficq584wtuk1s4Qg2HGrxcqykVB1inzyYaGqNMey8+ZFFeL+BeOYcY6rhL8mHK6dVvF3rVPKtTTbrCXhT7WgqTBXrozeWUZQbboL0yOEzEEd7YLdbskOqPA5AW7BpRinXiYjm71fmPiosAG253c2P88GeWd+7y1Mx1l8MlaSxvH4e5sMeCmlJ+iNVef6ZNMmg4zfu4kKZYug9bOh5A9k/uweggNxsJfb4meRdgL/QNMwD/PC7HyEQD00u4GHRw1mPHdZEtGvffYSueXGAEsM2/ShPlDEWQ6lnq+pr3pHtgSnC6LIvzVWARWqltZZuZw7BKpLS2ZXQeppL9TWvOUV8bLqKP4vUgCBdnhKBodCl1tOK0MRTeQDShKxQYOcf6oLFakOCYRBMapW8yDr1cC7gRNDMraJU2edBbiFxQTNjn1Wk6OcfLO5cDBxrktvht4cmhZ60kWWmfpJLWW5QY9SsdHbD4xoDDAQi8+mpEfMuix9XPdv1QWXmBsghEMoGHCJJORDhp3fxVYIySzXfZX82y5viRF/P8WZYYt6OaZEdpGHisADkkDSeXCb6YhQb054GxVVkCc27aHKRjrR+nMewhDNwQQZPl2NbSklbBkDsJwQoGKM+q+E49A7e3xIYZZIqqoJ+MM8ApnvB3bhUQPDb8reuClyIiEhf0OnBbT7iLTVOqrhlh2x7PvXpTRCvfiLVqv8R0oFCn3wkDBRdlHw7Qk+dzFDTNZ95JODU9aamSShrzJ8IvJZcgQ74Ga/YXBnCaAOb34pqN5/tM+I8XBDEq2t2N//SBOiZkh13WotSrLqP9qrQ4MCpg6WmoZkf7qp8ETGwa4nW0MLKMr8S5GKJe+YKYWsG111YptCeRgvqx5s7ipcNh89/FOS8ZIzSWwjvtfNz+9hk3lnnnuARLTiOnZwo6898Cf/tUSMLwUYwR8P68yAaJUxVjxyYsVIF53wPY/Nh/jt7kvgVUhYUw7o1fvjxe6GjS46bH0flc+YMs8TdI3C2AHTpSJL2bUqqWPXecH9UI+YomGJf4uctlxGOneUXvHXVmgHhM6bx4AtEnNsKchnE0xIGa2ZUgM0l1/IAv1yC2eIi9TFBXquZI5OREzNkv7krWOUB8kyDVyXMkRcDTssWovJLxPnnCVX5cE2MalH5vlPfA+IAtp/FcyCFJllSiEqUVPTmTwLFoOiE7HmsiLnp+a4Ll/1gBfgslr6QMwTW8fKPEe+cWczNn+NIhetTtp9oMRcyMHfZlYf7Hq3+4zmIB4qiqAysy/qlI5PL56jT/XoSHEfxqinmBgm/1BmPyt19bEtZnR5X1Ap/Kkb8Suo/CljXw+dqlYgUuiOX04124YNVng4sVNWeOG1lbxvAufuQ5F5qngL2i+JhI2dL/RgKNW/fSADR4bxzT5mm4ZoeTduJ5VhTeY5Y0HQlHkE3wvEwySc8s02UtKP73fLxwKiZKz4z/lo27s6qlCC5tzIGAk7ZNj5aOwN9mHi3lZ8m0I/Qdx3Ji/EFrVwSbtAob7Y6TQFuhw7B5+Oxih6EFQmFJUQ2nnELbbNejfqqbCYEJD/WuWzDQPdJ+lh8OuqstiGddoTnuIoYHWtAYNQJRIK/ffsKGIZZjdunDf5hgqtdXtWn0qn3HXPPZ8niIsh9A3TCD68IQ9ey/soRC7WVCLeKY3piu5mQ196UhiD0IPuN7+jGoVUB4IHgIpmljWaBSO0ShFeh6jd6xzfoa3nFniT45MzQhfIrrEyd/teA2ZdSuVQn/YO8M5p+j8mpm9NZ51V9Gx+os5w98gk086p4dx8MBdaEC+6i+JEwEccIwasx9sMbTwxJ5QLbFHfG6j+DPSykEi+M25thR+b6znnFT4KogN13XdMpYM7LRpmyPe2sovbigugCD6VGbiIULSaeMNO0JzKU14qd+JsOZ0GpmsOmWBcR0wflPdK1vAJwlHSMzHAUJjbGhwuf+VPuGQwCBXpnZyJoOXWNM7fmyD5r7WyIDGtrJfXeB2Oaj4/I3CMtv883b5gNrgMIUdXBISCY1N4RRkUViXvKFc5/2eIZG7bmxcesYZzl3zA+1XIyi/l9BB6TQkDxoWa3rJ+KT0PqCeVp+11XwJH7Hl/Wybw5fbRyZBawzj4Yz+SuKq0lJ7dxLEu4LchJF6HkwmqX+SHUQ3tazOUK/okVcLG9vF3WlcHC65rv/ZEuEYVcpUkxnKNH2BrEci91tHd2QvCQL8sgu0TLzdTG4JGOmUsiDTfBCDepnxHt9wDGRt0PVgr2XtzEE4NEAbzNoLAbGmREjFpATvXgQ8QdgnJtqVzI13+Y4Ex1wp4fmhpvjhM1vq8IvZ6pjcMdIBSMf3mdSmBH+VdymwZPB1JdAVdDCsMYIrFnnyKyOXTF5oLvDY5jyMDIZYyLTUz30NJecUim+br+LWC8J6wu3ZmdVQKWQi/c8wR5fAsd/IoZKlEBH4h15Sm6QPVba+2zPf4bKwoPWXk/bX5TB3OSS0JpDUqdwOjOvIGcToAT699gWbAaXOxPBjvHlPHD9Lp/7k2D6w3tWfJBUZYvYNcjf/nqDDM2wqwBV8bILomeVQW3g6pPoT6adz2GwOC5Es8nJraX4trAoqX3lVK8UUv3/AOOhO+1nopVG73lR/dxRY72jJhHKpur2F6+he1/asyvu0QKy70Ez9XcAp0B81qwhJnFf8CTob2ldI6vZohO+Lc8MhFw21byKzic3Js/q8V5RgV1fxjCUll/6985PPyv85oHjhe8pCCdPodvLHwjoSfM4vfLowIcxBmDpG+jANAwbvfynfAJlVzMu81CYzu671mUHoMUzvG5H+sjFsng5jUXpSa3S/lb2wNnrUROb9bypEO8OdpeE+SrdvIx8tGVDemz+fICrWjBltVGObsGI3w2G5gRgYXktHXnaBnL3AF6ixUmYNzJAaD2+tXCZEjHalGVJukx4/V+imXqO2iTzFOU7VvPpHHUM/tc+gAtyte9joojruUheAZdyDs/WjzuNbP1uWmku+dFfu253B96OD+2spB8aZ/VdJRNBy3Z7omOQG6j6TRxH0PZgCQAIvxF9sQTKy9mshLm6Mcv4Tsq4JfgNRFiCfgdPXVQVpEUTTMWy+Z8Nif371Cci9xHBh5M9+GOnqHNhrBUpEtl8tVwbYYqyni4Lrly44qXPnaHdVqkHLP5GMAuy0R/MCa/Nwb9Li4r9rp7m47UrPjsJWYJX2xRnyq7fk1EMx1X/2ez44APMrS9HI1XIsMbQRtQHconRdyD2u53jT8jxK76TwAqa52pqrwcIQQSEZxAP9vbFVtESU6WMPsBPCrRuF/vxHE8wPPv+c5SynxmQzwqROBjytHxy70J1WzajO/13J91ZcBDKomi56D0MANyHNNiG+XOB7FtkBS01ZT5smHWYfLHjd4XXO/oLKl5roxZQeAoZ3Vzyy2Bi5B130Bd2h0nVxIG0V2zLqiwdHP3Y8jhmhD4DJ08ya1bkapw0oqL7oBYOYL38FgkGJczwlVdVooWQ0o/74zp0Z8fEyfhOVGzz4r1Xa2qCQApOY6VO32PBEk76wzgqeFB8llAJVVuF2HMzWRlk6K9LwlaaYVTE1LV9oYdnxa1DSJ+MN/bC5g+R0JjUSUfQXHDH0ETJBswPf/ZHrb204lTY9lQYVPGu0JB5S7kNavAi88I/ZKwHqD7/lX0FC1l1iz+qZixJohvAzFzTtwcBfS+py7R4Jf4ZPXbUjf15snwv3dm2ZaLng4TbgGhEZmrQrlr6G11/s5rYKqy06ofP0r/kR6X+mVhfOt62UgtmgKXLtMHAZNtB/lK3MhyxwNQFrfnOloBmSbqDWNUBsgJ31KvQ8rI5e7wcdGcwD0pJvQ1FLNUuhotoJNbANZnclMcQ1X2HMhjppPr9Mv0gpqx48Ol2LKQsdGIF28jO+cv42PRSCY8lahDA7nZQXQCI2gEk22xz1uF0WSBl9roxSPTAdXpMnyVzPW6FMx+yWi2RI0LSvt1h0jDMELRHubt/QiApdXk0/kf4ugzpoz6eXtvPBQcCIf3SqkU2YZS4zySglRUaDPMt9HF3kfZyIEyNWRWjzg+aFyYD9N3QOpRQZ/Ef1e84OE+0djZPzDAgyviu4rEcP/ATjTX3prxuxEm2zdCndlUxzFU4MjMFWcF1eH22T1X1DQ0kOeWy2AUrsq2qjm/3HLA7PdmKqaIwHEUBjwhPrlO5GLGQfUZeFxQQD1ABpPd9PfP2im6QlskheXTMS2GVtBONCu65nd0tvPnt70/9KL+masZwWItiMWHRKrfBUNN9V9e8xmpcw8foeJi+/op3RFSp4coQ0LMonrGSjiTMnRKKXGoSjZdSLXw05BMa9aa6eNkUlLhC4yEsEZngg4pRvkMed81X9b7VSww99uSV1YgrYxm4ikQmvxWhTU4X77YM7ZgX4IXtYu7qMNcIl5BR2EZzCT38VAV5Wb3LCJ8JoUOzsUW/UkYxbXsrBHuo+KRQ1CTxELr/qdl48mnq/fKOowHcByQH1tJunP+SjggrRx/0pFfU5NYkANphlDFHKCukf8UQgiok9zIrp8C6Hf7eAyFinLFlUP86reze6DJqCIqng8YcB8v1zOYRMvQrWzVnE0lHpuA42AgahZ5TvHhin/SsR86cLHCnYszFDLkBcLXitIvUhXRNKYoFDx7PzSsMd0VVtErOo/sztfR5Y1NKXPWDrIzD28BBA6biKbvvd/T3AGx6s2apWUo0ry+K58+jjWS8zrP1cgs669gSVcXqJcPKB7Z5FPTDmBbgsxAFAytVaA4rvmu2CR/Z+De1rEBuGAHF1tUiX2LnUGdIYjHAKc6ltaM/YgrbEzj9qvQXSQWZwER8C1raz6nhvAOoS+sAh4MvXHcx3KJYaDdmVvxDLEmvojWhZseQqvC3TQFB2+/XtENGpDomR7AVYBj6BpZ28iRnVPUasDqgzBOtMBLjZ4IAmOSerxY3d6PsASK4jm4SnPN8moYO/yYSyhd7317AyiqiYcHisReqteSSs2LbRvnu0vbeP0W0xZcAJEEMg0XMaztpgr5oOSJHeVilOYj1FiY3Kfh1OjvFXbtEGXk8A+Tu2QE2/XNeRr7XE8/SiEx93X95j+8czIm6eiOIBAuidA58gwPVin2Ed+Af2xLboYBB8TAmn5xlij9EVzvC2DdoWMlvxFajNyeS3Hc3ofFBvCqK3t8IakUtdQUWsOj83DtUdKnZXxcOWLOYw8JEbqolqtKbaGfZESHwIY/tE8hpJpwHtBpO0h9GZjccExA1nbeCQkieLRCJ63YOMHSJPvAj/iJEOoM50ZXBlw18KyWFhHf2gOdi9+p+dQJjz4953yjyDRk9nfTokUdKR22ObBdMioDwP8HPp64HqSNcJz9bGL+cLdRFKJAiaRRglibryA19WHKGA6eLDc5oaAFcKELmET1e1efrMSvUP2XEFBasP0Fw84AEc8P7BuOteI5VMXzwv+/r3pe8IG/fSmhNA1UK8/46nflpJM3yLtwxw6PT1qzw03IPEKZkN/Qr+EGaO4kN57R65COFZaSAZJ4n/VfgrzCd1Sl5rlPlgC+PumdpMDJpgSBaZSjANF2ie/Fmtm/rl+OKjtsB6arOeD2qCF1PG+5IvY778JZ6pwoM6s44BgGYET9QfuPtqOPYygX0Ij3ZQOde9g+f/Y/p0c/JOYBk0fo/yAnCBvwi6qGTWyFhVYw2+/BPQtMAr56YIsQStXLqQu9xKGaUmns7RlnH/ScM9Zu5NteRUMPkm4u7Ix/9a9vPn97/kMKg4ZbE1Ro1NRL17YNVZ5uRmxUhMDzsCyzu6RsIvbZfMQ3m9/WkhxYESrAb6k5iv1GmfUvWnvtJqqZxbBhyPqA6GeiKpADhhsnOIJagAgN3vH46sQNaK3seiMGH8BAQX/fTTHMycBsqTXXaGVZePXZ3Lv+jeIP4bybjPuHD0sEq6YURfHV5bNtaJLdUj3JVJ75fMrg49ICiGQfoLckxK9n+OpRNdIK1zKHzlVMiW0LWnyjGRAbTJOUp4bUjILBBHtVJWxTvZbBBKSGzZijT37f3Fcp+InYr+jWVR/y3G8IwLFfGiqkbqcoKsM+UtMC/mFjPhB/SaYIHBfueJ50CQYXbgJpkGLaxCOTIBaqum5VJuX1pCOyuzA/8SMuDk0JaYJeNkV71gRsSly144AzGCWR/9uKzhR6Rw6yw0jA7ouEJyyN0J2c6BU31leWRfbrN0PnwYG4WFIPVHrPSbo2Tg9b0fiqFTJ1m///BbT10ZwE8tZ5JAho19DMcHmcWOI2pAmW7PhPRWBPyPqjRZz1Y82emZUpUbec6TsvNsTT560WBVq+K6B1k+HiqBI3un5K3o22a6SYrSgS0jRwsVhXA6+ceFup4lYnHFaXc23LRLscq4vBk9O5FpDgPNEILSV+Ti2mcy42Q4UhbulhLMpkrU5g9WvH5TEptQx7rRWzElgiaKKZQGRzudJk5C2CtqPmxUM9L+PS+lwwZLpiV2mwVZU4aNYpUWz7CZ/MdhpeuKFcKq6AuYEVrQZlfMal8lEQcmtWRFkbhW+iYwvv7Nni6MZQyni9WE7BCqc647EW6pZPzdOUckaasqL182j2RH7DL5Wcgls4cfXF+Ar4PgGRqyf/RoMOOE0tEhdJ+8U9GeSKXF6FzWke21Hwu1W9/N3PNMtkUYbJW1eabl0dx10ZU3BRwSmV/pVEn+KgKJ9ojxRMLzTXbFzH/c8fy/MhKNGrKR8+uOqVclLrAmYlfzXql6FlUcdtanMFS7lWpYZOv1fSsRF+W/o5E5pLeL+aUG6+oMVO8ufajxF38LGM87V1sUC1l/OJeT2tENMLkOjwO1+Z3q81HBDYomzvPt5eAbEvB9P5y5XZA7a393KqXV+2mZ5GCAR0BxzfOMeKKnOg81pJe5w2pYl3cDiB2WLgzOZjC+dK7/7WThUYC/1ryvsOb74BqYg7fjse/ihs9+B6ZRVMQLQTGctMd6wMulBmCEBYhITDfu3TKtiT0+D4jVHmOiRvych/yzSaFnZu/w5DJsSqVNm0cXY/UUR6RtfhlY50f74gWo88CSo66iQYIOKZYjkaAAUrZ6lLMqzcA2dXF8JhKH9xowg43XU4Ju3g/4dcOQDkJyO+Ybi+EvF03XSfnuOm/QgWkXvByqR3aYzdbr8X5k0AY3QdefqVfjR2H/N8j2eBSIIL00ivBrOIKV+bOgya9EL3VanS6p4iWT0mV4eya16zSlcSx0QclqWeirYCw5xEK68FGxW2+Gwuvw1/rDRRYz8JY8xIPkDtV6uO2r9OjIEullQkVZ4Y/I2oh9EMznD9HwGYW69aM7HBdVxh+RRxjiRSKcFDxEWOwrp9t+TT3lNiSc1+BAveHAt0AGVGPZcDY0XLWVhB2+L9DOBvugNZIq6GPYKj36WmfqApiasc/RTGcOqGQR+j2M4XBaoWa/MKaLYPvwl8ERxrWOG63TnTamCW9ZL77bIzqzHBX5JEAROrDfbYU+Eodl0yBzznGB9VkRgbMIM7I66usgZJpSy7A6Rdcfa7NHBnYPsSE0UgQ4nfT94SAAgzCZWVUzLPss8qOH8vt1m4yub+nYBF0sECvlsbWWyK5SnQFyq6ZDf8QuIlmiYRaoUBloY+xcUYDGOXYMqNi5+4FsOtk9XLD40Z+1xxbJy+/IZt+0iZUZ20k6hOWojQh8IS3402HqWd3NJRbsuAQYfUpGTEp+MuuhRAl4dbOUO8TSwL0I7NJSQ9kBHPXKo+5x+Sj8IUEOc8WuGmsS1VsKD+dXYu/UbiSm8FsAbH7k/9lCF54C+0t111seIxRZ/LN0R7TbJKIPnzQBtnEUslfwouZJA2I6NwnGoaAaplZkU/DffFhOkJjdnF95GEC/vYGfDfxHQvG0DWUQuRMJv+3yw4HWhlFA+t8M61ira26w1uJFdDC9o0nwA+vOUZZEugvxPQ3iS3PxbyRGLAM3WdwpayRgu+lrk7YatDemuV/sy9z9jIi+aLjeX9Mt0HlN+RwmCLyH28oDO6i+pyr2ze/LILZAHNRCzurRkl83NLNSrT/x2d/T+uoCh/+5btZanY+t/94yT01fn1oKfyI3GEpWDvzpPv1/ZIYYmyMJ32MTUlcN6mnc3xuoznQlNhHNari6JWZiF38OZRyAjMuekRKQ3C3600sgdvpzF2fzwaLFCwmq0T9yr+HRWOTAqTrS4VBTTgk0a41ckkcdfSvB0UlvnFHpEz0sS3oKUzXWHb+TLpMVyIkWfohLhsoLZi60Eg56CtVp93WSkebKEQOegbLczwYBLQ7bGAG+Ts/9QYcmleqVpJRtkUe+7kwG2sGURRMQ75NdK+C8RWVJ/mjtRv+apOFMPQToG+QyBXPA++lNQjRGSnjAG0TlgqC2g8YT66jKdSuTkMkLI1icoJRjJm/xxo1JBWhgwbIUzgu7zHRzTivV5LsTv96Zgdu/JVxQNH/Ep8JvZahAMQV869wUeWw8pDcj8i1r7GXJlJmNQWusszGDVgjDfoKZ8coEjOJLqNddnr7h4OS88SSOeBvR6Onp1q0H94NsOE64InX+qg0LjxvhfxRV9e2qpgXGswhqNQV4z92ByR6S72op2hM1e8owNoCQ88x516tAUUHUZC7YP6TeuuypylFYyAUoLyJSKpYgLBPFxUDZAiD6vvhN2c03OkJuZTx50bbCtOwC7OMr9R6j4AeIUZu70Ti55tC0qPotWfOr/4aXl2W7Qp4uTUScd2UBMWiDtPthJ5MzLYZWzNHP/QHq4rAJvuol0Anq05fXIBAKU9pzGJj9n+pLoHRg3jslRen1eifAO45HplPb3p9+2alzUr4hjh9ONQb/QOhqcc5ahVQHUMj2qCpCEO3o9CK7kZZ52crLP8BNHEzBjLs9T5Hfss4mwBfJxRHJrBbtD7wR4dopEIwnDF7vryqWguLmwCnTtuOI/6Yj5gY3zsbx4G1V2rCi95rJa1tI3+Q2sJexAKyK9Or9UTau1BhROg+sBzEkYD09ski4LEvL6RvW73E79+ctu22QatDHA983ULV4xLfVP/ETHXDAT1/wyfPRryHsb2TGKNOnLWRMekPs+mCIZK09KCvS44bj3KwB/+53zyXMYNlOyKIVTe0dGjd4wRyJkV9iT3hxA8EDmcgy+jztYSegxnn8TfQo5PoLcvJCooTkYVGNEgna1sgAXV3BUAEmp0evIOioFH+P8mp1tUnFiuOodHJ4cCYPsz/Y73kULuHDwfGbKv1bpa6B5ABdmWVB9bX4ZuxN9vEf/+zUY+CunEMQdEIN+6xrns2ySXBQLUEfWpXdrLCxs09kWNMx1oYyBt7EiINxt9lhDvHvv8Tmez4azMLC4CHTEoIXHbkTKs1u3sGVrQZis2/gNs6vbuUIVwZPilkwJkqUN1ymZB8cxYsaA/3+Uij9oxqHvcrejh5idit2WlSbDPKqlqCfYM52msM4AwtiEenqqcSpRKNh52OnwXelrQB4iA6+8OUJPqRI2nW71mzm+Db79sTclbNxbr6LA8K2w71zPnnqyOaNFGPzTTf7J0/8owMm55SC+cNFcrs14wqjWffMkehvutci6im5TUTVjg77MEnDBm7qrYMA4eBR63NA6k19wlz3IoxfSgeE0z+befpldeCsXcqmRqtyTnT5KqvP+X8NxlXeWvfkdVpKKD900FCgGZ2epvdnQWhypBb235TgmEnomUiXCNctF8upgHbZst6P1BDwPWGZb9OZqGSV5u4V4p1WFLiLM86IQGQMvh9KI3SGoadI6nREaAd7ZtOKqOZinHketRPK+IFCcDoj7n4bhc8KYNE6JRktetVkmBfgltH5agpMYKhQ0e7Vunb0XWltzjG8KB/34qLYiZA9H5r2w3yNAqI6ARCrfWzze+Zyw9YnbWMOXLwyngrGTdUxe3MxUKKeK/GqlQ/HNqMdPm7kaARESwv2t6/puUXrfQ7UEgG1XbyQP1qWr0a6cF4SfXK5ozqKueCQ525itHjOpQV/Vo8arrQ0pvpiR8kTWwn2+aRhv9pIAcqmNObzIYSnV7kNA2UJykeKpYC9rq6ixdYHsweQVcCIzI6/fxFEfKfAiBC5CH5ygLROdxSsFTrZoGhhZPTYNNxTW4Z3T1Q6wMq5RxFjMgCk9/ph59Tl1Uj99KSJElNYA/wqbQ5b88A+ShzKahrdfDXZizoelNGne/k7zaY8iUlNkuGzhL1YNczSr6kHGu4SssFwC2G+/WZ7Qiyi5BCt6bD9t4986cCx2N86pidr5AndjqPadEtxPu6E4I2gEmpqAD2jQhaHprQOOnh4ETgzyVxnf/C3KVT1fPzmOkUeTUCMrZBHUAbe6YgJIp9RgdFZsvPWkTtfkptNbupxYC+jR35GE7mu9r6fgdQhGk4oCFLv+fl7SjPJ1oU/2k0wUTFlABhgCfBVy43Miz0NOnQWUbd74BjJJBgZvQ9Y3BP3qEHQjeDMAxqtMLQmLH59ZOYMl01uyVfbPZV6ONTYKDOnqcyxTif3vID3+5SfjlgkF77uLOmuFEQpGdtMUAIUlh9lyqWvPOD9MjqoyGTG6ReXGYClzR9g8n++qa+ZWjh+e0ucWBOqUmelic4zgX4Ct1y9Cfw0oLqfeTccOHFNTZG1Ij9vgzRYINFp2Pzf5CYZIMqweU70AXDv5GtwXQHdc36LQ9xnA8Pa3dKT1MlyTMY0Yx4ayT5i2iLPPoCUVxqZVlE0b87hd64Y96wjKlL1AelSdIpMsF2dems+Kn5EtuhnYPPU7I6Cfe1qnqxCfYSO/0AB6ERG4PzOW4TUXszIf0tqqZbCHVkRKJZVSSIVIPjr7rejizsZj4lukeNXocaJ755kBVCF25E4RAKdttf02dcHLELwqr94jZiwEmbDwisy4P426lpkSbCPEh+wjCWvpk5jOxDk+/nBIkCbhB6CoYbDWY4Vatwq+pfdP2am+5otw7PEbnjzkXP9ePvtylAHBn31hG6YlbTagKBsbjezo7xAUOPrPsLPSTWWi16YH+pGZsgf0uPjSHjj1o5/79Nk+gHB5frG6NsXaoMG6vwEOtD+yK7Jr8LdCv2eRm45ECilc9mQWzsZXnqgY0oDwa8U4Ite2c8FBoxzSSc5lswTPBMMCQKzSiYn1YIuPYAbEXUs7cl8E1DFl0nXdNXnnVegX6g428fbSFDWMxBu4qiArK/f+3ywrEXHA3hPaEvW+im3YuEM+Cn66vRNqH0skYPIr+hsXu3dykCaHW7M0OaY1Q+Xr+fpNu7Br108W0ICEV72Sygj31/3l37oIBwA+gJ27WtjpNs+ERWweK9N+UoUrI2xH6hFxOh0bfMkVOXE0mbQOK37HTQ/xPyDOoOTvQAJ6j5fqiEnvCvAXCHLpxtQDrufLkwk0/8KroQ350YMUX/0A/UhQmLSZ5PDXwnzUKr+dsTDePxY526gte1c3IJoE3sZtP09VWLGSYB1qGDjIQ2zL7zIvRCYjJ+u1yob5VG1WR/QBXUGKon6cRfCMCq1Xyu0uNa+7IdAtPhctuxvOyC575xp/UYOiWB9XGpGsOktzKakO8b9hBsR6sTuaKZIhKg1wHIVmO0Z48vOF6ckWRS3jU4DQdHvcp9qO9g24xRVN8GfeiXHyjG4vBBJpmssaYvSTn/vdWXCCdMaoeBUFH7Uy/OlJPSb8SGS9egqm2tG4VSQEh4vhXKnehlWOYbQ4B1s3/Hu+/Bm15eTPbo74HjRqqVzMBUfhwJ+7DyODJ7/Ww+2Ks0PDXs9TU5lFTXLiniImx8oNtLALFKAaAH1srapACMr4jFohUsG68+XYgbN0cY3LVVV8T1ed0C92yrbfJqRYsj/li2DoIaiQk+VX/W3zt7trQo/bY33Za5zy4cuDJSKaC11yuAb/8hUcKPF7yKjOeRStbn0p28xgvH6omTpbwJ429Yj9Sv0AKkXKXB5azLU/uJ3etFFeauz6PHJjuB9hewg2KhIauTMZxml4fUOXwQQeWP/lN/XxNPvdCnCmLhlplJDaMtZ0bX6xGLheqyqZhgYcTPk5tf2C/BYnsf6ep2saQrNcxpvQOHvpqOHJv12HuVBSLdhkDkuxt9OluEqr/eupcpmJLXFDJEOwVHe0G9gVEVPK1BxftdIiDHpMrxyDfnQzkfTgsNIb9KNPjLZqmXwpwRaNmSO147ynkw7ptp56xXto1CbXhZSG+XyXypKVREdMynM/7EVp3NThIBK1wPyu42JQuWUWFrae079EgRyBHRXeweFsVTur4os20LyPcX2+Sd3mI1/q7bFjeqE+C2cbZhqzS1gOuMeK2+nKRGE6hs3TQzfURaLva9lff1vpIr01D4scp0oXtiJNwn7994E34xdhgNILucwUGScMjH/qYecT+wl/0LkoXXIp2P2y4BXOwwD8imhZ/8YFqZVRHI18jFrAUmj+KcNIqHc4SLvEtC18SKof3XmXyTdTbXkRCGCPT3eGK0NGVo0g9rHMaK+KxWEc58tSxGcKjJOb34GhtmVPuX5nl0/vo08LtcvH3BHiriWh3ln41Y6xQTjqJQ5kMg+ohNmSqVkArZG35hQCWOjNP0oXHnwkxBX7QtMw8jDKmXFF5DyUBi8CM8I8OwgOSYoidIpjnxqMSQotx8QRaBqEgtb51krAmEhfFep2hq/WHRJmdzlu0/HrN6nORPHVx1As1IhazLV4eKXgy81t3Zid2yQtccBhI94zCx26Dc+9KSOjP6on4t/HZN2gB4pltlStLB8vpbAxrb9xk1Wu1j3QaBT9iu0lOFMlRiF60cedL+KbL4Ngx5uO5BneF/3A+JkDvMgHNbeqsGulz1YZDwyP3gwUl9BWD7kK74i2DfXrMwzfBwBfbBG5n4pZkN5xuqYMtDEfLtbQfZxzt/4wozhs1qXEWM1uq9cAaL/PUNQGKvvsUrNwoJ/opB/b8pY33le3ENLlV8n1QL9Lfw5g2zVLB4sUjW4iP33LXWUN2mW51fyJa+Ggd61+ihYGP9hp/EmNnNRu8qxtEhFUu5EqYYPXR2FeOHyY6Cwu3/KS/89PAv1bMUaJVMHg9dsu8EqIVOPLB1DriPvegIEWlSwKSrvGyvvpRLkzYnz4kGDXltAlsiYuVP2t9eaoAAFrEuvfskY2jD/nDQolYgJMImfz81WIoP8dGGDQkea8fNxNDOyFjItlRVAJMQwhfFRArZt5uFfUSwEbM0tvwcuaO+e2ruccIxwnxYyayZhJKE5FaP7KM5iE2gLrS7qVRiVITcqZs7D53cwvR0iZJIXDw/+2sXKB0LRxRoq1sX+2IGP+odLaT+WDRgOKoFRgGa8qzPxh1kLDFBIcC64bl2tLYhb/u+cy1uLoyMsiPe8RwcRHegYyb0AEN0bsAXpcHPFjocVuHMpDmMJhrh8yHMiNZ1rWIB3YLRj47HDS7yxvchcVTv6wnpwIj7YkUJwB2csLPSWnjaGxP8d73qDXsRb8FgWcrELJdkrUaSiV3ynl7RtiPnwWwrrZM9fVLadj11UjqIjM3CeB41w3NNryjOLS73oVQeQcYiwlpwRcTZAHoPLhlYDSUxPbeWVCE/V+WlGES0dePAAOXHQIRQ9W5dzhEc6fZYRdfZNpb6cMOUlGxfoA6b8VujMmilJWQeqJU3uNDSnRZT4ep0IA4dI7uanI/VYeixZNO86nZiDkLeJQlwzqzz0HgfmSeFN6jQNXBtaBGZoE+Tklka6waYEmtbeO4b3ujoMLXQvZqjLKx2lIYbkze/Y+33dgb7rRIm2kpROmBhw97l0IUQqnjNXb+4LuhKBm7iMowdcCx6J2sMNxk/6fq5MJFhxFVi0hvYmHntMnLBeK+xbklheufwJQCItuH7mRrw3Es5x00g2olnhCry+CXVZcq1mqlsZ9Hc3mHM1SNrDhxZpR6eFhYUZ9/GyQPCodon8kt0gy/5RKeQKh55WFEQdks1qGYTUx4so2G7scgRRv8jUf4AfZZTB9lHB9ebRI8UwlIg10qPaaMBsP5UpiByjv0LA322HrIZfvkp7ZbM22quUpSkd5VtvjPOduMMTzc1bTL+8YTy0M5o/wHrIPtzu080X5W6AyEVNOCcgZEAYf+T0PxTkNWT/Y9DlfJZbIAVhE65/qaUU7j9283Zcflbk4kRqbL/4qycHaDGmIFvDBtnI/zzq++pdlx5Ip6FdB+G6ADmOh3Pc0R5ZGULije1u6wAjM9uPes+jiutlu+d1Z4Z55Mc7Wh9RjXzlYsmLbWb1MAGs8vyPVMzcS43A5dbh8CUA5hor9Ea4RwcUL6suT9qKA750exJMK7n9JmXDtqr9ki9tX8eVV7RVSXLbkW+6zZJSEtRulgzTnjHGzTvd2gyLt518hFttH3Q+jUZyjcuEUU2yLC8Jq8yavieDfLemUGuRKs5MwuIqiTNfbDe8V+DY4yqfPsHN5ZCp9cVG5kz3p7Cjj+JiD3dYHgKAQOcR9nZTc+Mg2dRAKN9iEEGYvrjWooZCERFjQu9y80XN5GFsVNiytFOJDIVBwKXmA4dreoeonsNRh5+sombrDxqz2M+PhaCAunN8tAxvaWhRgwKSrkLr5Wt5gwbbFqGCQ/jWRf5NuW0UfSe5tNwkJCJTmOKm5KFnCXXQILqYCJELspcCvXMkzEj/bFtdOjkLeFlSbqgfvxHMGiGUdoQE/iPCVSc0IKUs7kJQa6UhNFGYfilaR2fpxyIZZDGkgLH4hS4yfcSPJTqXtpLmm07qhwi95jLhQUVnE4C6RkMibej5nOjm5HedfanOHAhKWMBWAGpWsI5HaG71oPNV1/6oWOyZg2LE9rFpHog4+Ayn/qxLy+3SvdsFVhaRFr3CQRddlh+VzNWxxEjJyLqhNAEthtVzCcAxsvRslxRFQhgT1Fz5H7HTMe280qd+vOUqamWo/k/2G8gwKRsSleN3dzASUD3K4xs511SbsbrHflG4/3k+CyGuNxRO9nmNl6Vk5I6er01y59e2EBvYp5RBGMKtdfH/24K+PVdemoKcqH4eKrJQKIY6aKeVlTzWTDz1FL/r9gNMkLIBJbKq25/SC6kC4rqu6eZvfRzuKQ4Nz6xfr16v/vlSMPGHOl1c5j9HRFrJdAkZ8A6ziKUP9JUj/fPZP3XCQdS8JETkvl903uQT58c/cncr353ZP0LMwT7+NWK/5DRLt6yBwGI/DA/CUkUsiIVxkfirnMKJ2Abce4FNqOcSW6mmBKFbbLVr6Bu2393FpoRbj19lVxunpyB+KC5+y+7UJKsXescvgauAXSj4bXRV6ii31soxubvM7lvFm0KQJzlIAspEnoO7cIufP8tqbB5rhs/HmA9hVt7YlxOIOzFnB7vlkPdqzoXh/dYMzHkgICdq20VJuXBAPNc00pK8LgM1HV+2sEdikL78etHRr+L+Ny9kp/vOoaDNxc5HH6SjwDPuWFLhCxNlTtz0yaAmt9G+MWAf6pPzkmSqzL18A5Yq/t9UDuBjMUtOqB0yAOeHnlY38ZbEj0J+Knh7ooXECmK0CUI1/OQEk6ZflmGc4pvThiQVh/GoorX7dWJ8AqByugRDcgC1kEqtZtLig1RrQb0Y+LsTCwRl2aJ2RQ0EjEqeDCSeVaawICVoU4/gdw0BXsR/1BH9ognP6NKpoVH7J7GlUYkuK8Qb4F/NDpSX73yi6hX3qp26mVvev2WMVnjZE86e+0qkogv3smXY9ij/mF1CAAfbLtS6tRLN/P/+imoOi+zdn/bwjBieG86kmq1nmw4AmfyDNknXz1z4Ne9hikOiY65WUS9Io2XoJnmU5MxOoea4Gyf4GKqVG7PUd63etwiEPgIYaAV/nOhqqhAVtFNuEGp+MCbsmpn/vyXtEwgMXWgmrED2jmZWSRe0azWeyVDnd3I7uEyepyIQdlqpB6W6orB4FNS0EAmIV3M5fUzp51oVsCAPJQt6+W+u9JHufe8uwHgdvv1LNHcqLtYLOMcYvDHNXpouu5+CwDbWsPUMUGwBG2o1OEouo9TF1NvqtluxCtTcBrgHA2/rXX9Foz8m7gVsa005ZT+UFd20E+Y36xcPl0auePJzkM5dzD5cl2j2HSz0ordL15222sna90US4cgUSpe/imeHC9fNIE0+OW5hHrcP/VeZLEDO/C8VL4e7tHa+I88Mmmdn5KBbxsMAGUZbRlaiow6IVelpBgzrv7eimvtivTt8ZaLmP1ruWn3vLzLa0VzxQ1iKyR6bEDKXfd80Bn26vNm7HjqE8M2mri7zAAUem2l8Ut4fXZk6ps4qKpyoFTxqMmTPonSgde+gpOnvYEquXuZV2txCygkYL9b51XjWNImmgLqgZnBrbFAbLxNeVf8lzw5fV6yv6An4tvlkVF/bbiGM1YD5x7IvoPm7PXlDaPJXimL6zJytY4aeAmN2DfG7QsYjR7S0tWuyohCzDxEsZr+vBysCjNG6PeSCIPFJJRvJmJQQ5EWco4IV6b4u7V/bpCjWT0AFGuEoGaQTldN5gbeyQhHzqGIL9YyFrn76NWarml9OY92tItNGH/GdWOUR4Q4kp6+ZWXQkXa3t6YWz8A+bxDzamuWdKak6QOFdMO/Pcmc9AZJFVnYzdiu5AXYyyUDE1zfuQM1EGSqIqTpwvQowkBfKNTpvf4+CdJF8ALYv96w2dkZd5Zw95GD8swAkYAnOL+osGZeKi4nKG27NT5s6ZgmXhzgLihNMGwG/mt/RGeg5n+Jx6k2x/XtBQOPMgTMJs0jzp9i4rgojI1lgqndBCHeKbZi6By0NmdYpa3qQmlKya+uf/HVQCL9RmwGCToVh5itS/uHhKooq32SIgYXw22B/1asqlXPyaho6UOdI9P7busc7JMJEfLeHYXCj7lVkSw+JBR4E6TAku9rbI8VO1aIW0PFBIDUpTYVr/8Zu61d3d/VxoJPFOxONCnRMpkRYSHSQubkjqpHgBnX11b96ak9eggsPpEPh76OwffNI8l5iR/A9n6QuLr/NQKKf4sC4VQgtSlEPSO8RSGMiSYYDAs/eZtQkl/Fyo7Uhq2b4wL3ELXdM6s57AE6WFySkA4MMFoqcwFOUomXWp47RsDngukSN89YkcmDn7u8Hr+IO8iskrfv0qW0umgnc6wpReVDHDSYnYafQaGEIA/l0sKIUcptb7PLikC6Ai7aGjgUFymt8vSN1AQYvSxjJAXbDwiOplT5zglqSToHh2bRcrHBLNr7OeJncu0SWHGCaDwSaOaONyhIMl1ZlihKuoUyEelwinRfEX5INfgLCefpVNVwrvpWcPcnfY3uBVVQevJyZyWcuLB2l0FMOQQLqHfyxWftQxH0yYrh4zBn82LtqBZvyxHZZY+5P3FLSkbRrF/z5DQxz/wAFBG0YF9ArR49rHeBWAudKuPLIM5SvFYonOc7IWn5ejzLpcbIpMQlnO0EXxJWl2VxkQ9PeWmLlyOdS6ThFMw581rxNcxuGfUKGJKmQHZRZ9lP6xOCYg6CbpHDDcU2vKUptx21NHuehAe1fSEk9Q+8RCv+WmUmnJUqEwcgqg/frL4/CpamnTbtlO6qk/9yp6WxLH5YN+1X6pLNOfSv1vRdqKzy4Twoi6+gnpXSJKwizrnqr8y2xcnQuoyFlG1Jo5cXH/blDDbrtlJmWJlT8byE+yeA5bGPJQplG6iZFnoElg+LtZDYRd2Vx4cO5XKUvNTbRVX/Ve/tm2cHccmI923wAlVaWfKWXkeDwtdPdbZpU+j0aFDKlamgcsCUOAVV99SuCH/9PQykS0qX1YH+gSVDZfdbNJ8hSp7XXzTV1Mpdw9ulJFhS2izW5Utu1h5oy8auEp/HBZ+TPHbLnOxEo7bpzUEn30ruEavw1aP6u1VhI0e87ksj5QXPEKcRpsT3hvpJgleXAFyGpTksod9zbyEgwyluRjAZ4kVNP9L+/Z46E/YfdkXQDjzlUTD/ZoPoBkmRLNoZe2kVR53P0hsXb1KptqhQSngZmwsYpU1UPtrtjeSUbOObq8gYMh94GzvQITZ7MwzL/cu7oI8Udv8rPUcIJZpJYTvJPpCQMYQP1EFwulK19Ens8EO8UcfpjToPC8ELjjsLTqtbqKbsaIm72FW8910RQ5JW8ohSRStSASGfszjnflq6i53G/zjS8PUk6aIELzwjw2fw+8S7fx9i7j3Du07XXrN0d0poC6qD1nFK2itIVRghXEUkorZQC9h34NBaTi4x6U0bi9GTod1gLs/ItmZtVJM294wkHQjtd+Z4E9tLvUgudrcbPxeTeiY3kh9H7C4Ny43GSXnQzeZggsyip7vG7ZU4vzwwF9tTPjHKTtvwNWQJm5pYsVyfbBU7iiFlY7obztHON9hXmT4sMO2dSCwrKTh+GhofzVrH72OAa3iGMaNoaEUIhwCP+/14dhhxxTDqHN1wrGXX3XLyN67EW2NarZRxgQ1lBg6EJjBez9GQURTtk93Ujbbxb/2vZnTtmhxHmBq+C1QBEKDvKhLLiRTtNnWxcCmLj27fPMSDmajvAZ7lKyP6E74mwjZyZk+ZNLCZYi5ceiWgj06Vsz13BlRRULZK6KXBucVjvlhJKdzRu4CKD7VhVhsFplk5vAomrMMVinViko1fTKrjrpId+E5iBps/q3El7o0ML+8sbYAf7RIfBXw/ZfHt3v2mdF2FoY4+Dg70zS1pBI6ScgENzYG3y97qtZDm/2sp4ZmwYV1b/D7qtkuMY8be+xKK1xTLqLXC8WlhCypoA0EhjtVnVlxa2DWlvykXiBUBsA6XqdRn6xXz5iAfUWpHjhabOji9VuHa1zwF6bpmJn3VkEnsFaw1IElxqN5+YrceCD6LUWg0Z+2stOoGXoGRBUieykxx72TPTMqDtsCDskmcLgLd+LfVUZItdVC8OhP0DKV6UQUHMk1RSSq0yfGrWfcrOPgI/oEuf1ms+3wjUyEsoWP6kifqQvH+vuXOJhPMN0gqjwEme3nFwdmLQNIG+ZUj+yauErmaD4LTY6f+0tp/Pz4PbWdSml3pFREjs5ROE4WQY/4Oxp6E/PCZwtGkhGEsU9uvJypnQZ/TzW0GFqpkkh7PDNLCpB8B/4UDVZJHRv2JhCOsQbA8t1j/6q9LxdRK2FwhqLShH7Uif/SvvVtRnlh40JTFeSBOQUAht4sB9SwMA6YQYoyiY/brPLEC5viZJFvGSpUHJ9kv0sFTJkGsXLmc8mrqaTv69bokKsizDEq8H3jtwfC8O2t8JE2DvhQkLNHWy9gz0JVnIFS8U4q6eRpLzWZfOtOXQEqcbphkh1AUoc9AALvyRNgGfhP8azLpv4XMXj6E9ApV9uNea1k45MgPm5VyZu46OV2nelodAxtV0DXkyzcI0ahdJIzBXnMdOqbwTW+wNHvl9SBv0RURUVDUTK+MRZ7Uy9+l7OZUBtRDyhH19Q2QE5Pf+Q5v+WSvtpR6yTPTGM4nuZDi9ZSorHvllG1MmS4ScPO77yEry3MZwfndvpO3rVHSczuePI9qExsUOV9Gaf1vYBaBo/FLNhqyPy7+i0CgB5gOTUVt798JuYKwWcaEC2MGf1nMDt6hvJRxit91/g1vJtHxyOw4sVv1M9BvaP8t7e6pga8lcPxzc1kO+vckojNkJKIkrZ1eoCQf2Aenvd5i6WM8mmSwuEspiwvpb2pj398Ox9HDv8/fQ3wM20d41MQsivZEL4gkGTwYUKK4TATH87AZ2Dcyjd72f36Q8vAGWYefkZO238XqAKs7rRIEFM/WxgtqEqTvSOcvN7xjoM8AvJnL1hsjGSgdzRTHkGrwSJWY8oor4G0FgE13qX0nymzLrW++a5Hk9mz35y3KtC9n3b+luxc3W5KkiNeZbVgaLsKs9b/QuQXzKFdw7uyda+VW1Tpn5I9T5l+iwnBTtaoh2OPMHj8lYilxB8vd93E8hYLQ1fDLejJMsAlIeKEMxg7Gds48p7N6PLaRyfSSm63UP4GqGy3xub1GMIKDTbgZTw9B6kFxPtXuoRnjT+k3QDN1cPbi47VBLGZfWQnsQfAqkLwI6qKMoQnyPA4CrXEwU8YJLamNijAgBoT3z0iOtKbFvO5ZxadHgN3bzF3+o5A3rQ588NGpggBtfFvYJ5ST9F73BT0sGD1zwsqXZnhSyRP6Fdosjoa7Bh+VAlqO694vXKA6peVxZGYlAD9b/6RgNw+TOS9/gfgzmb8771eXxNbNqCKipz/91OHCxtrdV5b430yjbiky8mUd78JWZ1G37HmcGRALc91Vxpvsp21q6M7bPWySP23kTLfgo7P1AoAWA9XzQB0/IDYRcbyd2/58QKcnPpysneVTVjELBduf2YXW3ToI4z+1e+Y0eI5x8HPAQ805pS0tU4v/8kHduNHlSO4VNOnr03OGnLkDjeIvF4ku2wu/1t/BpcD/wpoxZoCB2FFAaFzzM/ngZNF7MjH1vInXz6plvYqTMRQR3a/Bjo2/jP3Wi3ftzKZT02og2EFFr7sDOpHXgjMxTqJqZzVJXmXrxeGePWi5KRUKeWicq1JOBKZHP/Prvok7tGH935Tf/nQ9qs0IAVKC4UOvP+e+hYVu2Kahrb1A2bwYPDbV83xWDsy0FXW8vmG/VfEnQE23p81VKRoYxj196WBFAke/JtKnLp6WaYcuWtsbAFy55orhEW1gFW4vSklXHvsblgZEzqm7xkfmKKdUKbZivkD2M3Fe+WCF32sfwjs0JIMoZJCWWy2EO/krTpY1kxaAbOS1ACL+19u2ps4d0EckFRGE0+UoYeYxeXXIENrARxY7RmGEhOnK8EPxRxJM9Ok01ZLGLkPgg6zPtGXw5HhO0bqtGNzU1RbpikdS/YLe6eItRc3QKBjNlpBt7pQ7L0A4FDU7fq10bcnDiwPiQgyqNkvBvpQCf9cn0sPLLKc27mLTe3vOU9SM0JtN6MVutbD19EGWYM0cD3dnrvg4cfIi3uMvTjKNZfW/uTgcddaNDSbhFES5nNIgRUdHUp1HwnqI7WF1isQcPCT9/8Wbfb+4frtTlw9nTVOGlT3pnz65MAYlLVBkbJF+mKgaBeGlEdltOoXGiDvHkmWtudgq4saP2wQGNWI0I0TPQ6cEjLaCb3/PWjdaCy0QoGGCjKwPqSeVgsA7nnyIw7dGF/eIco5XQ1fUW9Rti5S1PWoumUQfg7g31X4HTPKVpyIKixHTWmUVZd59hCX4dmHb54CsIUUs0pzMPiqV7rLo0ZrorX5tTjwnqHiCE90z6AOepZeze2sYTNGC7qnwuAu/z3P+IgVDRwMBuBBEEBQM8nGQnd9A8r1CJTiOMxNVAW34wXk2VomSku7i1yvKmMK1xJSGUcArMoB6Vkj/VigEJw/zqydbl2zcslmS+sEib/s5RZU3idLs9vtete2ORh9urXWw/z0CyNL3hGYC1QvOOHMVNSoyq1iZHHhSHkGY9t7uDMuXOzakyCnF5Kne05SCNDMCCXjv4Hcf8WqBhrC2LzkLoz//png3J0AAfZPmahMUWar7SZk8iUPTA40jFi8IZb3Vtp6/hG4vbeXhdL6gDH59PD5mv/2QGn1Z73NIwuRKY/+6Idc9q0MlZV4iHwqjukS3d2InA+ZKvvnZd78e0i8WVdJiGMVAtQkDt98N5i0Jp/6QSpwi0heqoFu5pkSd6pV64/kD3IZM0+vSt3qhywTniymD2J3aA88yecIwD7tvzwix+qq/8/jYnnzLbKuLAdCkvzKgZ9NyR2cwDkMVjxL7k5f5wcXDtdzM0HEYSWqKX23iq8TLCn4EolmVI2FAnhgAT98rLZUNiN3a8xuWONKDAwC6EXsnUX2Z4Be7TmQX5YNCIRewKcEgCB/Rfb3WHd/+aPLRGFdNWCd90PQYnVqM4hIqDMoA1QxUD006Si13vNXvUUjthLjfL2vljxlpbz/L2K7B0DKQ+L20Z/vK3NBnGD1+GaT/5kEneVtIvXwivAH0L+qm16pzp922YnJKymPd5IZP9YApy7ZhEXH4JMpRqvQs3EbaD1g39jf50P2g2mjieQME4kpStvq42P5s/HAtixkLOfP+Vz+GS3icCq/54do/ivgDl9dpQMfbZ6sUSg7BOqucfRR/uyIOmDf998I58SjV7JIL/KOnLFxNjo5AcHMt/RRSze4M+lmmDulQaw8FV6a7gri3kO5cZoCY6Jt9hYGesJHL7s0k+AoSe3gYrI2QTAF3N3qHOKhZJX/dU+bMozEa8ThsKLqfzHFhuLXMWmaF5X7wLVVymnkrcBDtIyYKCWf4+D7QSMf2197HxR3vGHDvJXAJcqARQKIx9GNy4KwyGviM8WTsLPxcJ+w0WS1DXTdAhK4zh4xuo/t7EpFp93tLEvaG2/TINsakJG3Z64/Qo9YGbsdUhDyUmaJN6F0g/dI3Gic3ZAgJQctYfYPllLFEojjk7xemLjQ5MCwM28J4ti6L6BZ5ktEgKtzkXGMC3Ne99prBU8+I8f9TwIck9asJEb332dQ7o2o83K5AfU964HXsNQ6d0FkOLKbHpHFWMk5wJMhaX8GZmpJJ3wNWvYzyt8hRjoBMFcmiSEBCB2JdsJyRz2bFVwHiG79CQDo/CAF33cVPMma9KnmEn25GRTYItJzIDUx/Kd9p8IIERG65JO0cAsshV2gm6EWZPww7PBbUdpJ4ZEjxt4Cb6bEtkmVvUCmNub4cK4c0l0zXrDgWDMHuvMPu9QmsQrJg8+IaPY5RnR3eTC+TIeqx3ds3yKqgWm2hqSFh0WYostNeUowB9YbqB4N3i26fwoMxUyuJ5Hq4EX1UlgW67q0M9wi6mvS/ifb9qdFSOXivyT53QwbXp10/NlmvFg05usgVDv/mXOL3ZFf4XPISCGj4VvD+ewgmMdhTdZ0Y1r0epfponiI6Evh0+Mwu/RVESjovmxLEo/VlR6dPRtPw+CSxJRW+YFbfSakqPNx0cOxxtLXdQ+vu0sD3trISEkqCcwbcqvSTfGyGFmv95ps34Uj1RiZ0W6E8PBXJYzZo7oN1+IxPR89yfNUIkc9BeVsmdf3eHHLNhCy5S/l/eIOlfC9y16xqOvtN2vhgi1giqoW7w0MXXP4Lw+cBf6Ig7f0DkruxZR+D4N1qeOqXUijA76o5y6I36tAPmdJe8/17YFOm2gX2pDOpJ0fwhymN+yA5lCy6CKW0VVSUaEQe+0bWhHYOO+auNplTjJHu4Wb09NL6/uoVZs+gFov1gZulgifJmS9H9jw/rol+wj7c1axqBwyc0A55aTfmmMyN9+UOWF7+1788hhQ7Y1MqCJihdsGyMXV0twnEf8kPd/ncPr+99+23OWBOIm3LXqvZu4jQYaNLgH3tSTFgHMSMbPxF3zkEcootbAtFB5oOLVEc4zEBVYax4bOnx+QphUDIeXmcOyUmxEmPJiNNtBPpXpy4GMiZzDICkfUgMAts0d5y1Nl/60na6N65mBJpCtxX8wvyff5W8qRIHmoX0bQWjgKB6S9/LgPlbY8gXLVDgYWwBWhu6K4My8reImOWny4JLxWp7WFwcV4dLf5Iaa6yFL4ClUH2+XSwlo/EvR+Dlalb/hxPAP9De5/BO+uUT5wAu2pnH3Xmle0ms0O1J3GLJmooHYdeLZEBe5TQJuVAhF5Mocim/hoF1jMltOJZeSxLi/7H2RUAsBGD4zlbmw/gB3waY0n3ioiLqMy24gCe2PSQDcQ05Zxu4eguEozgEzsRUQGgh5jcU62niD85SgyrUDncpBBxCtWypNjm9jYxfz8iXxBulz0KYQgrzldD1lWIiYbUP3Fe9g6N9w65DZWnPwoKRjgq3HhROFerTJ7QSaN7npTX2bLUi6ClvywC+NEse9873qXhyZlSX/tHKdk9piYC+KctyLfOX1PCoGMAHECzfLsO0bsOsL5mg6bQEhL/YI16J/KeQuL0QvIXl5Tw3YgK4CT9xNl1V7a7R329VtE48jv0L445onWEfVpdl8YTgb2yGNX847r13BYfq3TumKHGAz5f6FnaOVvR3Bx2peEPtPE38Mg5nfz4585iEzEFvZV/s0UmbdH/KWXFjogDIP8QjFhSk2FawIGrZ+x0zfqKgZ6KuFuQRaFbKAyKenU93j9Mao65P0OvSaRNb4BoruDVwVzb0gr11QgTBCfV8M8UJMYNj1Ip/8maEBeUG3G7pBdAqCvnq3IAr1Sr/Yjy3AYFDjrK8FiUHeRpHuuRfRHtS0VQOgXDmFvdVTP2MJRM9w6//HrEdgS6FnCj2boVdYzTXd0L2cN87d6G8x/AIvJsn7Rk5IrsvIhkwInUCsph/re5IENlN9wV1FrOmDmjRXOWbkN0ba0g4BqWCwCdK5ZhubUpJcwpaoH2V4JpAZ8GNPRmZ2EuIlQzrvpaw1G5baaRn9gaYagXJMblHSginbt2dL5qraWK1beeQFIEZ4CH03oMq+81tje5CvHIAdxcALOm2avFq0vaDO90BRcMZwtwdRoocau2SirB1gxLJJCO8V85imk7EqlLg9ZyML9918DzRAi8EYXhf5eQTPJIMJGWW5GPm0jPRAHwD9urzMAjNSED2uaZuQBEdgH8ktL8mWqgaZI31S9JoBnPnH6+1u6JqINljpFR71e3thMRsiwn41/XfUhaLCEPhUAtvb6STCPjEVZBiqL5shQIJZWlkphlckfdwqr6V+fQ/IBLv1ZNx7GAaQ4lDPLxJDJ6+wsUWkNnYdLO3GsmyyMtMK69sGFY5E+OrDcpE7i5lN3Bw5TfAqHyQ3/N9+n9VFpCjYSNTViPwfF/Yn5WnfOUjonGZhIlb1Q/SrnQ2HrFJ52TcgVMz0joMZIElw+AemQNiNXVVMnDNjtlq8sauEw2VH/UNk9+jlyAqnt90GuFLJ0JrYe34FbXFFFFPgmIZU7NSqwGBj96BOAZDGH7VToMifVblfmdIEnSQm3xbClPwtgmi3oxcH06M50KQYvbhE/cpl2NYZe8hQSc+7PxCEsHo7EZGBJGePHZ52YCWVZm3bQ+ps57lnYR+Ti2A7iDXpbejU5Bv5qmktfYrTzkga3p8tCzp06Lnr33mxFKBI48E4xuzb/U/ABkCuqQh5kFI8du308VA16DlDDbey9dQRo66LcR6BKUrNSvcwEK8n6iNH7oB6vPpEVN+AA+bzx12hwqHGL94qkQ0APwH8INtT75Z4K2lGUgqCP1IwbP2T7IErIB4zXtMSjFfNbRmyCOuDkMKlRkLAFGPQa/nz8tK80u/Vo1nN8p1bsv+MFFcmj1+Py/xWcF4wETfEEwI/yYaRiVtL28o8dRQcPRGa1I9mkscwP4bkpWc5QpHfLRMYUQrYBFyogas/I2fPo8+SrDO8S0khoOoeqdg+knLRJhlj/HEZqYgBi5rHTieZknb4tckOcFnF9iUuu6ekkZU3Z5o9K3GANgExGMlIDkeOK1ZsdiS4SDFFZpZ74wkufJfB8Ko2E1G9yt3Z0KK5AwBpTaJefnTiLQwgwHbTExnqROOY1K4AsAWbYMu/Zd/qlntz/eWrCuqKObfIo6P/3xti2SqnQntons1tdRrYLMTxFaUlJ87N7/fU4oEuO9RhdBeaQC7rlYbv7qVYpT/YaPh28D3S0ZP+F3dZPc193u4H3sqvA9TGfK4w5CSU6ZpnRmW+qwz6b7aQopFBbGaKDljvPpEY8lHbSU6CXIG1VVqW97leOpaZBs2qrXiITk39QscY4boVOTodPKeefe90hp5ItWohciZmHBn8esN00ed8vQySThYr09m3bDddQtdITr4mzvoLvBaOSxrDQv3kpkm8UzPSf63faVzeKejE/9jOZWVAA0tZHvbDWoweSvs/CDP4jb8JjuVPqNUOmLLV/80P7tiWw3upPim20nBUPDUf9L3XVqW0ajBlzv6neGb12ZIKRP9xORKVBop0VeBwIHyhA5nOwN3aZeHynVw0MjRHXH5b5Mw5rGJjKN0Phq1V/QVMQ5vGd0RIPeffnRcFO4z/fHTtKf8liqRoqBWJSctLnN8HXVphZr0ZgGnnmumrcuoHaRtjJtshOKkD6riIOR01EqgkNzWzH3k8EXE/mw/Ihnt2VLSjvJTaNhVgMzV1VKABQzzH+hdtC0w9Uz9JTA5eyJQcfMl6XuOrDcdv++EORDEs1ZOkIFJaEovaQ5eMKy/bZVPXxfh1raTuP/eX+YKC1wnUAcb/0P39cG6pcytsq9QBo1/HNPa3UJMlsyEccF0uUvcB+qX+zY3F61FNmfdqBGDQc8vHekK/3SUSoE9HCPRneFf9O8LP2DD3HHK9GsHXkd3msXa1VU0uvjZ+kodsHD3AzeSJEWyDuKrJ/WJU+vRkYxMtlodkNkBcASyqXgAKtOhdg80xJS/Vrfo9PPmeLqKIXxIFxbYmxK6UlqZ9uZ4d1BgJFegwbqdmOhSi/TRlFvoO1/cGW8bn45CkdeiazLZpu8ZXJfoqRphTB7xYZ5MVDG400pTO133+lY9l0YlJsytTpcZoHAweiZ4wRxKVEQI+s7pvQSyh5UjGEARqeSB23ysOQHGEKqmk+X5A4Py+Sdo96UpdpYNc1NCIeAnPIAtQnXvWiH56qr3RoWCBeXtSb3YPczd2bqUu9kkrjCGeMsA7tR/JJZh0SaGO/UdRxQUMo3tMT+M8xoBXiA29AIOliEuGgqL0OBy6zcQDVPcXrgFmcLLJT58kbJspHt121strIjIeHuhEr049FuaEPUAibz60TmQXoVeumoBAjctJgXlLwbckytTPdkF1T8YXSkEDXHbEtAMJ7hlaO9k9o/8UxLEYTY0KJvhnzj7CJiWiHY9aIqyvEQUZl9+v6CuCIHKP92z+fe4gWyKHRIuiXZVfGZc42KWvsrkun8ZyamjUK39V633mXW90V6xzOs8SIYM4RtNqGBNipeNtMtss6eGFDgoxUZmJc8kUdLl/PnLQBfWIrfhNjLAo6ApYzDqOmSIGuBqn8UShTT6OGMbNlYge3mcCthDGOVDi+bC3dCULgaASm/g16Yuw+zdg0V3EgXdqnPyEcNRLAPGusyV0zbctPkQDQt67nLD2Cuv0tlthRSUeSh2ygdOw/jMofU0Sxe8G+Z7SVxcinQPd54QSn2W9PbKDsS0rWzqmtMfkLOaQ64c+YXmv9iORLWVXRPjDeZENjXndY2o0W0987UbA/EqHUhrL8PFJ8sS0eTgM9q1iQeW22zL50gKinkRqvVLFIaXIFeIziIVcukxEquVvwfVn7ccOHfId3jKQtSeHHNpxMXdZ5mlyPFHnlRYaEffF1Qvs8vMifKZXbilCPoLvAPDFWxZP8wXjEo/V1BKdJN0JFOiSn2AGlSZx9QrK8WCgAxwvtXvZHG0dE8RN6vjtyyw0xg/6Ex8Ad6Xb5E5Ky7dvqEKUdimX4er5xMhgGXS7b3e3K1+zryUMNtmgyNf1Wz8hpjovmRv3op/yw8XeFGFZWgAPTsAvf83/i1bLUQSwC5BhWym/rxWtXzJOydVRpQl0Os4kaAaHGE8wgUzAsCXhm+Ulv7rPp+yD2s9M5Iwen/4YI4GU3aXkGESu0dwbqatHgVxkxt2e2c1dsLENYjLuoZnX3Lg3RpJuZ9tK6ZUUnWgb+ogrGEcJi5qPgfl1m7dDEZbXN5GW9wbs4+WFqjkliXqgJsfnAiEMIagHf/Aeta7TdB5xOGS5aDtmNWCJhn0xinjS4YL35V7VG0FjwsCTuttl8yeX+mdkmDAhO55nZfKomugmOVRrxrf10jfMJNMMdF9TjoHAYTXuJsev9P3M9t5eRYSUP88QaFlnoWBKR1bAZRCkDCgfK8xioc27+bglQXf6Zckl9bW/z0HQUIXGHCNPxg8i33O5XNDB1B1JAQiTumL9Pf4ZuOFXxzSDq5JIBE27eId9NGHN2sG7unKIoWbK2KNzRgDzEcJAxrH/sVXxhyIWOqcZVkDHFcAqTdZHlU4haBl5Jor5BcMKKkiKFkxapIghZgetHhGqywKhOZBpx8WWinuuV4JmCnY2mui+sllcCz+dLxJFThUbmiwwN2y4LdKAXtrCdKOBrGMn/yea7s8/25iVfKSwW9ZVDVKnC/D/tGKCHIfBunBX25SuJFVZO6nKQXJt+LtwzuCNuafzo5AjRxBCRPN0UoLRZOhtjnEavaWM2j5ogmIOAyfqwfKOJxaA5WKKHc0ylFYQkCGKk3eiKrb8u74grO4VDJ1I4iWsHgz/O0RcaH5cJop7jUA/h+49RCVzO0ZgaIAV9br9/liaDDbxajGC+jKVQuDSUOmbmaHuBhAvRFpRmUZeU297ipQzt2Flk5KHuVOGCTroV5RLeVIffodGIo69i8lrw6MEbu22XhaWPyqPYBNW+QUz+gsCakdNTVgT5d3JmxtMoe6xJA28ylcDTs9C4fl8UHMpxhnQOPrhZklZGng4NOSVE+9Przxlj8iQtRGK0V0zuqmierKPJDJbDDUZerD397w9fEnQaMMwOvG11mgmvBNISuFR1xl00cYLSqLyhOpY+O0II7j2cs5rg3Fa/VfKA8TKSPCkzziPiWMshyq5lHjI5wE2n7jBTfBWMftWsgr3nZFiyg2jrTht9K0dpFjB9Xc7qd9kx2Zy/ZYZSP5v9pds3CiE9714kEktJFlw5qTnLYJIw/RPgaALmQPmXLVxuu/iYD3CS5foe1PV8z4eMOwuUdALU80GqFbE/nFzCJ1mOL6LqUEdewqd4dGsIuMucN1gZic0bkIbr3e87bAgG5tCzO1DI2CKvKlvmJp7luRS1TciW2BZB2HWt5z4yRgJ40uGaqMGGFhdR5NBTO720B+9HNOq6xMUw1JyIW3Y9ILLanxkPpdGyY2IpzsFg4Z/ZU1r/NIghJyIOlrZF7bLyLIEysXggVvtClNAgV1mjedLi+37wqM8vTyX9NciKJy8RWo1Q24SD5HcE6/Nz1whA9MelNY4d9d8r87zjM6mqam7UejTX+OlwXh27rU8t9baUrAG3Zq9kM8sgj6Dp6vabDphf1O9jIKHSyIhG0euyqlnVXxwPawaDublWKIHLCxSkRGlCtTuumKevu7izUdybHbAAhK5TPLoR5M0DX22C9opQmhChLUHNLvD85R74kKbxhnNLqTl6QZIwVT2CjTODfzwDrQUds5pnxm5mEt/ktH41O/XwV9m0Aa5xcqJ80MvYr6GA1IpyUwGnmoWuKKJUaHtQLA12zalo4kN87HeEcudf4FUKZrLQl8TFqm57uwLvgO5u35UU0EAzpoHH05eMCQiiDMa1h68V503l+pLu3QQcqnpC2IivHc1bj5iPUEdyq7saVrX28MT2XoR/ODbUN7kTDwiOEgueqk09jqDwNIYHJm99M+n5pTl99swdN8biPbZLFGWv2OjKGwxQXfxW8tXEUw3DcMvItu1Wg8cSUqjYiV8lp6yZXwIIkI2YkmtLp4lIiJfN7RPAGJgylliW5/rvwJwGWKfDKWEM7Njvg9ctRxM4my2dYbxV18gfvjlVssXOIXBpiO1o6837HlCmGs0FAouX3MseaYBX6YtNoz8Ds+QWr32RZoqCDKbm9cajKPtuJZ8g/5QuTZa1A6l9umdXKDwgKR+cZP6++TwoS15lJEP97K9j+soswIta7WUmDrGl0YZ8fzNRNDXwVMUJzVheE7bG2YVhRZQXyR2zRDI0znoe1tJSnhw2kZ/8hRTVn51f0aOfqE8vBQOi7HSPCrS/h6kughplQPOA0AEDV8tW4ihiaZLb/+crCKbATDXYIdVJRx9AH3Hf+H86MuFtRjeHloDmTGaKMbX6d/ryMI3YhLL0lCiEVJzWi9z2uX63Gy48d5wdp9xdEQP62noW50ey+zeLBo/IFMJ44qYgvjY1swRyFppVTlb8v9VnaTEpLrSKI2UgAniZmboh2kQpUBAbAE6nteQXV+huAfbMVY7xqhmSPjAID2nOoJCc34bxqMDnTbN0XAjt+PefDWKXhHB2iiMnF+VQ+gcG094nqMkN3eOF+H2cezXRTHY10XbF2mNzF1EZUngSIZf8tT8rnkFCpdM+OYyI+l+zOHBBbt0h0cRzIwgPyP16v6M5QuxmB3LwMWBxfHC+z+oc7oH5nb3Q1e+91s+yOb2R/pyPXf33v0arR3BdmR2QYBJ6biP8sictnJZaNKBbAhCOtH5wsLrgsvzwYqqnnM/WquzFBO0AiNReSgIefOx4bDWOwAAkmP8SM6u4or+Bb273aF6mCheYNH5qPhX69CNX4LUmt0BKbqwhsp181MNHNQIpTBLHzw6p5vOkAuQ99rH0zqdErsRADsX/u7jfec7oeWRMwY0yQZGwkZgbVStKslogQvKrSVgUOJKuiwwRWieHysmjwKbJMkhZbQt0J6MKKaAbPJ5VOGjDRUz5Wk5PM5aSBl5oIoc1UZ8NzMwg+7jj8qIk7J7SRiYrBB103UMUINHKVVxu2sdTYFplT6UV/cBrrgaWkjbp4M7h9M1FTnelyKKZOxGmwigBWVtdRiBlaTjVIG51T3dI+Js4iuW2uBPJr9p3XOswajYZ7+e/ae6yE8Gtqn+E6eXcoguefxjhGfcPRdBMasqIVWVoex26gGD4oZhN1tNLKWO6j7Xrnu6s8VHyU4DV9eOMXOMc0CzyF3u8KzRLMHik55OaKfffVrRsxyEx+nBvn80GzflGig4vFz9Z0khx2DF0S54yPuPRCXorSGQ5xTIq7z6ki359Is6zduhHNqti/SVE2W5z8iwaEbsm0vd+FECGXtlxAzQa+VhnHfHFBUkkU2yr3yExCdxSA4+7BcLgQF0euOSENeE6Y3BAFvcAsJrqbOw5zgkRn8ksQIQLqYXSHNsp1i5TICy/NKPtUGu5ol+nS7U9a7MkAbE+0dEjngP+zmeDvZ1x64WHGh0nES3+xVhM0hVEplInitfwvmdwit5RvuQAQXReNhmB/oaCdbVxKa3z4SrqTN0L68TTHN284pE6V+Sd9bRCPdOJsLH7ELaNr88YmGQHHd8e0NV1siHmbOtJ+MeuLpWIN8HUfyUoCMAYXA1eoVKDdluo/fzqa0rpaPLZsRuBL5eaPbDRIW6nhLhn6x1kP0En+v697QRjdcoQUzWJQe4XbZ/sq1eHjzuP8S3+2IYB3MqKfTFqTERdUsJA7rqNmFYaI1Ti2JgMD33/9c7b+PAIEBazlfXpBRT1OsEkgZAJ21GTeCqZteDVZ70xkirnNbDnjbNkAoBfz29Xrs0Edi/+bZjyLH6tvHqZpTOqLc+ZPqedSS3sxTFDOAZfRYakAWh/qljeknnLAUap1rJsXV2Iy0eYRdcKwkfReHR2QDhHZxzJjAQ/sheuvn/JjJVo9m1TDDlAB6AKT31OTe9+vB4Rho2xtqLmPfWDzonrKx4zB4xf4xsRPisntAOdaUjzZ18AiQP1jnSCS+89+yZj3WojgIZgbovzibg1yDYjU6PQ1cFYKEKsEkh3KVwVqanGYQeihoP6MwbXZd0c30ZuYF8AgWJess5PA/WrUfiMsGHOP+tm4rwxM7EaIUbJKzk6JE6RaylSlAz+ZhVd7DgXYakkyg7tqThbxl4c3QYTseJlA+dXrsN+vMg2AjlX/c9wCAyhMj46VBO8W4x9xClqOavQACiKmls3G0KT/eUv7yqEssMuPHysTJohvwUAKbNHk4pHeu8hYsqU45XpzxuldKR0WU/YfW7ruMKsb9kgix1PEnNEa+V2G8GApkMLmFX1cXUgPqrxxzac4BVBkDB9R8u0HhY8evYjhXoegvysSlzQgcwNBmawcJ5Hlxh+02amjH5ikZrxqqCvPIs2irqvFzqt0UK97v65kt1ufGle9o5VtZiYl/rrIw5A36nj8ZAdQoMtpomNyr/31jWkLqeFRTmCYENE2AslyFw+XnG4xhpdKxru2F/pzXhZbMnmaKXRGWnAhtCuAxsdPoU/LlDyAvZxL4Z6A0WRXT7pS58Pk0NhMZ6FKKRCu4IFwK/mFm8XpWKo/ZVktqQvN57Vc8GVrWW2D5dQrLyH70Qh4KTAQnYcBYQ81wBLhJ62g8Tcr3NGtdJ88VE+2WYH1QmCzNDD30lAahWvaaMhY3OejSGEMy4/zylTh9xkwvRf8VkKT/BJgi0vKokgjOCXuUfg0Ubh5NUClwB4lUAm4hD+vnK/bUXjs35jyRVbNb5VIAabTwweVHcIjHEhm/wk+j0K2KfTOMW27F9TjGNInV8y1mC0RmD3vaW7mPM+WAWQuu4EhQU2T0E9hCAaznu3sqV4k7LzAV9hfkUL6EP4u6PaNUoZxHVXd9mYLe+E3eLb3JkeJcTHRDp+8ZpRReVisrxX7e62upeNkfXY70IenxuutmUAv0DMbqffcvDLyF9SnnWb/tuJ6YRlInCEeF84dVqKXBywaKeYtjgxAJX5maDPxn6uzMF+wkJLMM2xqKjIiBYdumisGvX2oJ2Q4pY6neih9oxYyCMdRzT2qzOzBw1wTlAVLckEyITozElcmTXHfBKHDGKFt+lsNveoQDZMudRo0S7ToWHAI0wXMpcJHLN4EPJbAOKfsQe8Me94P9Q5LrAWt+cyMuaWZE1vOp/3Gr9ksrtwhbqFD3Wpl+4qCCG6m77NUnlJ+lIrW0vXr3kO6b3IbvTMCXCLrLst6Kr7TrDK0pfXiUIsmLEIV15vjgVoAhQycLu6+IVJ63Ev3R5jNoIQOTLeQB+5StZGY4tkFGrXRO0ubL71cO9Sl0H6gOPNKv7f0nhqm/uzLbbqGURJHiDvsv2dPs1tlvSOnF+8+HKUK1MGeOfP8QlvKby3q5jXlpqlGBYH7gye+qv2JnrQ6SqMVrtucaA8JXfUodwa+G4b6wvK6ib4DzgbUqhEtVfCj6vFb/l9LVRD4khZs3+awcql0RMGcye97mixwee9RZ6fAxysEWPvFXyojB0RFGiBhUrg2q4hlwd1RW1j5L2kI2mVNesuK3hywWJRtTURLnUBoiq0xmJdDJDVo+EfTPlJ82HJUyKOGiSlVMmsN6tKqFrVaFRJPQTIMSvTZCeyLpxdPPkHFiqWt7r3lSzpvczdjLhnd8ppL8deGcpQIftnpX10FjwTKiheOYuawYVm7OR3VmTTjwKoWQY4VlKaIygn3C1wFSSF988iwVqntP1XlYFyE2iupymxq/4XCTlJr9RM5eJIEm0yekCI8Ixldbndqg/hLeL19DO0U3RvRGIT3Uf0G8npPlIRnMneOnVy1hqsUe7BS7ZrJXenckyzXxjl/jwjAl7BQWrYZvD8e1nsEgZBrbQBooTVen2DjPd0bmZLDJ3Th098gpyXtarzut8WYs6np/h+zwfOqg9MwtMj8qChhYrIjWNDW3Vv1wm9ygUPEazt2ykPTJB32QB2TuhIscLN3hyMVwXol3XKoSwW4PtMcbVzyt2BbQLM18Lsgc1igmK2pdEEZHT1AycebGmpRQGY8Dw2ug/mesw4qLZ/Hii7xoFXNdxypKYoNpQoWg38XbT5z2SAQVKIUKl+pYDDZ/dR1cmqw8S8eK6GHeBPkGJCwr9LyfL3RkgPAg9AbJ82zleL0EyClwY39l2K0yRoPxHfOhQYh1XFUXbtYf9xDuGbi+KkfYvNj/I054XU6DxeFMFb3a2GOKMh1QKiAeUc1y9HVWljpkorpPim4sGkjITyT4VkJqUP8rEU6Me0Da57Bv/pm2m4FpV6ESQyAQW9uMTqIVBRSL2UcTG5j+yv2WCgKEugmnS4FUuJr7gz3pvRiHNNqy3L2EL7U02mWpIBpraMAe8oLjXZJI1SJWVIDdJIt1Ui93pqZZPkMp+z0PPE6bY/3yvXf4R+qhgJTrTBm0g3AE8xW631JE/WFAZGSiEn672liPCGw2KMdG9PpFLYNoYvSSM+0Kr3CPt73YSx6xVJMOqNGWAp0fMvegYH4Gno9EU/+E+3H/QltnxjIQpmhr8TPLfEh1sJ/sIcsACRwMv6nGm0xBkMbUE9y3IfyIqPTbk4Hk2edQrXHb++Jcl3FUZb5kMFquUkPRhBe8tb+iUryMRwbJir2UgdgkpJH6cJ9rUVYMxmm6HUOnkxLL0yqhg0TkwNJTwpn1XyW2nqLV9SX8/0toI06wt0UYKEUtt5Ke49S+SwYjGkKk3kAVFPkC2ippTmbDEXvCjbIatLrHDQVmDlZ5cIu1XABe2MJ5IL7NIx2RMCgaFXecfz3tqt0t/MA+1HxitQhBBUUFqz+uMD7COW9yfyIZPTaptvqM7wgog/GklNVXEzwF5wDOj5j05ugd9sprKDWD9hVToOuTyEM/buG9H3cwpJUynnYYp/6ia3pDD/RcJTyUN33TmjI1E1Eh4ADmgw3pxPiQQc1ceATEmqQKKjuGnP2b9Jj2iAnKgOO+dcO3TluJ99xXia6ez8OSxfyuryyLpxLerT6qsV2D74xdGnq2hHfu7X9KVx6WvtElhQfdpfrddn2H4Bazn01tWXXIkiyMgLutWqYwowmsEO9ZmxpuRZgtOiyfX8AnnmjulN9YFTDdfLbOJBsk/xOTi9njRktMujYoVdFByiOQ1eVZdu16OmGgtWa3Ce4uA/2TxX9nyYH9eWxCwe0I3FJV5NT+QrrPzdkBYtu1jestKp+FTRneemWy1ip3UOoYZhsVMJ7h1sj0d6jsWZwJQa4l0YdxkTv7nrKiHrD2hABVFWOhVGGmkMKNYT3W13zmQ9dIYCRBcR5Hcr1re3tz7768E2mNrT/ekDgIdkX2j0XR2xk1LPXMBvjWZcFP+raxe4HNC7B1Z8amPRv3p2Ncv8CHJRl6UImdTFgHnLS0afGkr74WHzly5OCXtk9V3qMUW7aFW3hA/g7SDVRNURFut1m3P4wI/Ajvb6/FAwySi7z9tJH0VJX9FQB/BvBz8s8zmzC+/krNgKDul6y6ajDYPHS3e521/hbGT62DG4KxeoZeXnZNQ0V0+jjearaemSQKrd8/FyKe3wW1VyRQiWdRc53HEC+n9ZS7PcG0LSTV6H4+z85t11OA4TyFuhrLBB5YMTjwk7SSxxMhSfdmpVleB39U0vqORvBJgxkYsIsCbTaneiDUzXjKh2xvyJSTSy9hHC2dQr2MiAXwuz6AVJn9m37MBbU4GZ9Ol4bTY05VrgLELnk4uvefU54d5wo7Ilke7Z5CSZ7UuD7fyBbLOhIpd35IdK75JRv3QOyKh1WJHS/AqlorLo3UQWLO741l7WIkG6t1cWMolOH4C/Rm2cUAsWYa/A3ev9LLzL/AnnaXEHUOiDM4iKXO5MrKFexkqv0Q4kr1PnzizV1zol2Z4bkObUNmWsP8mAJMQlmeU//txKCroBMgXF/QUdU+8FYHNjDyq/IUWpdSnR7Cap4LW8Bm0Mnc59cShhM6wx0TXdsZ+OTKAuy1IAaGfgqCOKNIyup8HnKY2WVeqBX8/yKRiQGNLiNTAhvCG0xRzujpk+oU5Fxcrc9cinB2niD6CjXYm6ZPu746uhageYDjkQxk8HTFf6ni8RLFcFBsVvT/quKJ+LHdNYcp8JzvmIZAz7TqJ3bA8lXm/jHlXrUhZq8thAp/d6Kh/vVzdbyP1cxcphPlooylJJnTTZjzThgWZGtDC6AgsVEiNShPYbzd7VQ5jMwukoiaI0v+01AxuViM8v67kiR1iT0mc8t6ycyi/It245JxLuy98t4tlq0qgObZza6f8NERUXKroyE8nAWaJd09CF/jU+iKww8befKCH2yQqRFcjiq2WyjiqfCbApMK9FxUH929ic+7T5TfNdVal4jgVwk1n9Pw9pcOAEjJtetuilbIWL1vEc9RXGGGM8rcbNoPWTXaLoFWZrZyKyPCSvO1enGG1PiGis3rG5RQryPBT4esgeISMc/5sP6/SgWERNkuG9hHV7COj8rA4lpsK6OKMzHCs+B3he0x1O65iFmnXlyZFx2g8tGjGb2q5s+FGyEChnqaT9s6QzMelY6zKMTJj6YT+BxT0ZAXa4DEN8dbbHqsxGsaDf0+8kzCjCqfNlVnKl8de+IEbEdP3CF6ZBpCOJkbH8aem9JStv3ob736u+WRKznq29MIhuaB5hGEM9HfVHvwLhsVOIZ29KSj7uI8mLoooUgv/2Q1xEu4DUsPzwiMnqsvL/vSYpWy25P5rVT3QQ4MyMPM357d4UaC4yDho0SXdQuF+aXdMmf151++tciqgeo7ZPl6mWuXnoJvoB8MIOTubEmgWpwhChikpDI7U92CgIVP1xNRRvJWzYjVCiuN09E457WBt1kXpgcDHsRpdkjRi5WSw+hK3YvjFYyIwai3Q5gVBrLonw6e1YRauWN34juhLZbXyqVQqNAae0IAS2ckYo4NU4MeBeBohpgnrGb8r0yLUOWK5/uyZlrf9Fh7aiL8KRTI0z4LhjSGrv0F7zwO4P2bxPE/Lt6TH7DQWmW2+/jK0RftYAx2O3eJsCrPxl9q32pcunBNgM5idfxxOtBsOg6bOIg+PScT1pYgrosvH72FdV1B0+Pg2RJTmmDWtu9ZkHj5K863CQAoaYhjn0LV3Wy0YPPqaZIGi42AdtXkNBwyJehIaSvKg4riPcOtDLhdbaiP0RlS+nSlvRC5Z2XTMYDEtCsI9WS/U7Bn5gDBGFkrBYJEzI0g5Yz00jXJFumbGpg/WdVyddWmx4Q0gZSpaS3cvlGxliVqrByZ90IAU8UkaeMAOFi+iUWhRI+9+VOTwxDnkEx9mMjY8hFxROuPMD9pjAp/Fy65MYu6dJG/rbzD5R0hkvdS+iPXtevFY9MzZn2cqLvliOYvUUaLJ8HcM25Y0UJONIKN/Gh3eGdTbU25U2iskkEVLYQ6xJ0hfNVxUxycLWCoXmnMfqP/x33rT+bp+CKCKQYDvthnBBuaBmiBlZVbSH84GVIZFCbWQZbLaKm2CA5KTxRNh5UxAsN2cql5kTXG47i4bEOY71cqX4wP38DF7nX7WnZbg7WnUktJdWTlghEjwI7hVAyHF7oCVPJoCwsdTavSXYpGGp6AkbwADVZeHuv94AcWvepj6VwjRsk5Op3L2TcJJXEFTA+XUlcsmgqhrLC9dm7frycA1e+S7nWHabXuEKWj+YSZSOLiwaPRPvLsYT4FOTxbxKx7kwkvm5QwCz2nEbc8gcHfQprAcYoXF2uy9wZDLsVxq5+TLFKlL2BooAQRnxGMhe5l6ME4VsvIR6NqFqYBinkW5VbapZg3lDTai8BcHnL0aiM3Kmg8j07n2jXNMHxaYtBx9N9i5XNpNNR8DdRNxxe4LEOCQ5kFs6QqIRSL/TSAunSpOhCUlu6CxqtpflboYfasEAtBCxCQHyHkxtndnJOyEEkZTnCdQ/xDDGdbcsZAATmZSh6n5UV+plno8rL7c8xpNO0fDTvJ55lDr4zfjglkanFyehpzzmaGbKXZiaUDH+s1Z7lYpwv0BhVnVhRTGptwvu1Sg2m1KgZblmLU5ybQFbewlCmxE8/G0lFOND4ffvHz7IVdttxgoxBaKVE7RxIFQ7C3q5IMviSJ3qtHd+xwHVywynA4nutvxko83HgcedPLdnJTaBbUNiFCKM9ruKMsDWVE/ObiqevstHYRW4SZvYrmS+B/XhH0/pezMYbqM2Q==");
  base64DecodeToExistingUint8Array(bufferView, 689368, "BgAAAAAAAAAG");
  base64DecodeToExistingUint8Array(bufferView, 689392, "BgAAAAAAAAByZXQASW52YWxpZCBmbGFncwBzZWxmIHRlc3QgZmFpbGVkAEZvciB0aGlzIHNhbXBsZSwgdGhpcyA2My1ieXRlIHN0cmluZyB3aWxsIGJlIHVzZWQgYXMgaW5wdXQgZGF0YQAoZmxhZ3MgJiBTRUNQMjU2SzFfRkxBR1NfVFlQRV9NQVNLKSA9PSBTRUNQMjU2SzFfRkxBR1NfVFlQRV9DT01QUkVTU0lPTgBzZWNrZXkgIT0gTlVMTAB4b25seV9wdWJrZXkgIT0gTlVMTABvdXRwdXRfcHVia2V5ICE9IE5VTEwAaW50ZXJuYWxfcHVia2V5ICE9IE5VTEwAb3V0cHV0ICE9IE5VTEwAaW5wdXQgIT0gTlVMTABwdWJub25jZXMgIT0gTlVMTABrZXlwYWlyICE9IE5VTEwAc2lnaW4gIT0gTlVMTABvdXRwdXRsZW4gIT0gTlVMTABzaWcgIT0gTlVMTABzaWduYXR1cmUgIT0gTlVMTABwdWJub25jZSAhPSBOVUxMAHJlY2lkICE9IE5VTEwAcHVibm9uY2VzW2ldICE9IE5VTEwAb3V0cHV0NjQgIT0gTlVMTABpbnB1dDY0ICE9IE5VTEwAc2lnNjQgIT0gTlVMTABzZWNrZXkzMiAhPSBOVUxMAHR3ZWFrZWRfcHVia2V5MzIgIT0gTlVMTABvdXRwdXQzMiAhPSBOVUxMAGlucHV0MzIgIT0gTlVMTAB0d2VhazMyICE9IE5VTEwAbXNnaGFzaDMyICE9IE5VTEwAcmVjaWQgPj0gMCAmJiByZWNpZCA8PSAzAG4gPj0gMQBtc2cgIT0gTlVMTCB8fCBtc2dsZW4gPT0gMABydXN0c2VjcDI1NmsxX3YwXzhfMV9lY211bHRfZ2VuX2NvbnRleHRfaXNfYnVpbHQoJmN0eC0+ZWNtdWx0X2dlbl9jdHgpACFydXN0c2VjcDI1NmsxX3YwXzhfMV9mZV9pc196ZXJvKCZnZS0+eCkAKm91dHB1dGxlbiA+PSAoKGZsYWdzICYgU0VDUDI1NksxX0ZMQUdTX0JJVF9DT01QUkVTU0lPTikgPyAzM3UgOiA2NXUpAAAAAAAABgAAAAAAAAAEAAAAAAAAAAE=");
  base64DecodeToExistingUint8Array(bufferView, 690288, "8Ip4y7ruCCsFKuBwjzL6HlDFxCGqdyul27QGoupr40JBQTbQjF7SP+6AIr2ac7sq6/////////8=");
  base64DecodeToExistingUint8Array(bufferView, 690353, "AQAAAAAAAMFOd6qZAPI0AAEAAAAAAACYF/gWW4ECAJ+VjeLcsg0A/JsCBwuHDgBcKQZaxboLANz5fma+eQAAuNQQ+4/QBwDEmUFVaIoEALQX/agIEQ4AwL9P2lVGDACjJnfaOkg=");
  base64DecodeToExistingUint8Array(bufferView, 690464, "L/z///7///8=");
  base64DecodeToExistingUint8Array(bufferView, 690497, "AQAAAAAAAM/K2i3i9scngA==");
  base64DecodeToExistingUint8Array(bufferView, 690576, "w+S/Cql/VG8oiA4B1n5D5A==");
  base64DecodeToExistingUint8Array(bufferView, 690608, "LFaxPajNZddtNHQHxQooiv7///////////////////8xsNtFmiCT6H/K6HEUiqo9FeuEkuSQbOjNa9SnIdKGMHF/xIqutHEVxgb1nawIEiLE5L8KqX9UbyiIDgHWfkPkcr0jG3yWAt94ZoEg6iIuElpkEogCHCal4DBcwEytY1NCSVAwMzQwL25vbmNl");
  base64DecodeToExistingUint8Array(bufferView, 690752, "MIQK");
}
function wasm2js_trap() { throw new Error('abort'); }

function asmFunc(imports) {
 var buffer = new ArrayBuffer(720896);
 var HEAP8 = new Int8Array(buffer);
 var HEAP16 = new Int16Array(buffer);
 var HEAP32 = new Int32Array(buffer);
 var HEAPU8 = new Uint8Array(buffer);
 var HEAPU16 = new Uint16Array(buffer);
 var HEAPU32 = new Uint32Array(buffer);
 var HEAPF32 = new Float32Array(buffer);
 var HEAPF64 = new Float64Array(buffer);
 var Math_imul = Math.imul;
 var Math_fround = Math.fround;
 var Math_abs = Math.abs;
 var Math_clz32 = Math.clz32;
 var Math_min = Math.min;
 var Math_max = Math.max;
 var Math_floor = Math.floor;
 var Math_ceil = Math.ceil;
 var Math_trunc = Math.trunc;
 var Math_sqrt = Math.sqrt;
 var $_rand_js = imports["./rand.js"];
 var fimport$0 = $_rand_js.generateInt32;
 var $_validate_error_js = imports["./validate_error.js"];
 var fimport$1 = $_validate_error_js.throwError;
 var global$0 = 655360;
 var global$1 = 690820;
 var global$2 = 655584;
 var global$3 = 690949;
 var global$4 = 690885;
 var global$5 = 690917;
 var global$6 = 690788;
 var global$7 = 655649;
 var global$8 = 655681;
 var global$9 = 690981;
 var global$10 = 691052;
 var global$11 = 691056;
 var i64toi32_i32$HIGH_BITS = 0;
 function $0($0_1, $1_1) {
  $0_1 = $0_1 | 0;
  $1_1 = $1_1 | 0;
  var $2_1 = 0, $3_1 = 0, $4_1 = 0;
  $4_1 = global$0 - 128 | 0;
  global$0 = $4_1;
  $0_1 = HEAP32[$0_1 >> 2];
  label$1 : {
   label$2 : {
    label$3 : {
     label$4 : {
      $2_1 = HEAP32[$1_1 + 24 >> 2];
      if (!($2_1 & 16)) {
       if ($2_1 & 32) {
        break label$4
       }
       $0_1 = HEAP32[$0_1 >> 2];
       $2_1 = ($0_1 | 0) >= 0;
       $0_1 = $1($2_1 ? $0_1 : 0 - $0_1 | 0, $2_1 ? 0 : 0 - (($0_1 >> 31) + (($0_1 | 0) != 0) | 0) | 0, $2_1, $1_1);
       break label$3;
      }
      $0_1 = HEAP32[$0_1 >> 2];
      $2_1 = 0;
      while (1) {
       $3_1 = $0_1 & 15;
       HEAP8[($2_1 + $4_1 | 0) + 127 | 0] = $3_1 + ($3_1 >>> 0 < 10 ? 48 : 87);
       $2_1 = $2_1 - 1 | 0;
       $3_1 = $0_1 >>> 0 > 15;
       $0_1 = $0_1 >>> 4 | 0;
       if ($3_1) {
        continue
       }
       break;
      };
      if ($2_1 + 128 >>> 0 >= 129) {
       break label$2
      }
      $0_1 = $2($1_1, 1, 2, ($2_1 + $4_1 | 0) + 128 | 0, 0 - $2_1 | 0);
      break label$3;
     }
     $0_1 = HEAP32[$0_1 >> 2];
     $2_1 = 0;
     while (1) {
      $3_1 = $0_1 & 15;
      HEAP8[($2_1 + $4_1 | 0) + 127 | 0] = $3_1 + ($3_1 >>> 0 < 10 ? 48 : 55);
      $2_1 = $2_1 - 1 | 0;
      $3_1 = $0_1 >>> 0 > 15;
      $0_1 = $0_1 >>> 4 | 0;
      if ($3_1) {
       continue
      }
      break;
     };
     if ($2_1 + 128 >>> 0 >= 129) {
      break label$1
     }
     $0_1 = $2($1_1, 1, 2, ($2_1 + $4_1 | 0) + 128 | 0, 0 - $2_1 | 0);
    }
    global$0 = $4_1 + 128 | 0;
    return $0_1 | 0;
   }
   wasm2js_trap();
  }
  wasm2js_trap();
 }
 
 function $1($0_1, $1_1, $2_1, $3_1) {
  var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0;
  $10_1 = global$0 - 48 | 0;
  global$0 = $10_1;
  $7_1 = 39;
  if (!(!$1_1 & $0_1 >>> 0 < 1e4)) {
   while (1) {
    $13_1 = ($10_1 + 9 | 0) + $7_1 | 0;
    $14_1 = $13_1 - 4 | 0;
    $5_1 = $0_1;
    $9_1 = 0;
    $11_1 = 0;
    __inlined_func$_ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E$2 : {
     folding_inner0 : {
      if (!$1_1) {
       $0_1 = ($5_1 >>> 0) / 1e4 | 0;
       break folding_inner0;
      }
      $6_1 = 51 - Math_clz32($1_1) | 0;
      $4_1 = 0 - $6_1 | 0;
      $8_1 = $6_1 & 63;
      $0_1 = $8_1 & 31;
      if ($8_1 >>> 0 >= 32) {
       $8_1 = $1_1 >>> $0_1 | 0
      } else {
       $9_1 = $1_1 >>> $0_1 | 0;
       $8_1 = ((1 << $0_1) - 1 & $1_1) << 32 - $0_1 | $5_1 >>> $0_1;
      }
      $4_1 = $4_1 & 63;
      $0_1 = $4_1 & 31;
      if ($4_1 >>> 0 >= 32) {
       $4_1 = $5_1 << $0_1;
       $0_1 = 0;
      } else {
       $4_1 = (1 << $0_1) - 1 & $5_1 >>> 32 - $0_1 | $1_1 << $0_1;
       $0_1 = $5_1 << $0_1;
      }
      if ($6_1) {
       while (1) {
        $15_1 = $9_1 << 1 | $8_1 >>> 31;
        $12_1 = $8_1 << 1 | $4_1 >>> 31;
        $16_1 = 0 - ($15_1 + ($12_1 >>> 0 > 9999) | 0) >> 31;
        $9_1 = $16_1 & 1e4;
        $8_1 = $12_1 - $9_1 | 0;
        $9_1 = $15_1 - ($9_1 >>> 0 > $12_1 >>> 0) | 0;
        $4_1 = $4_1 << 1 | $0_1 >>> 31;
        $0_1 = $0_1 << 1 | $11_1;
        $11_1 = $16_1 & 1;
        $6_1 = $6_1 - 1 | 0;
        if ($6_1) {
         continue
        }
        break;
       }
      }
      i64toi32_i32$HIGH_BITS = $4_1 << 1 | $0_1 >>> 31;
      $0_1 = $0_1 << 1 | $11_1;
      break __inlined_func$_ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E$2;
     }
     i64toi32_i32$HIGH_BITS = 0;
    }
    $8_1 = i64toi32_i32$HIGH_BITS;
    $4_1 = __wasm_i64_mul($0_1, $8_1, 55536, 0) + $5_1 | 0;
    $9_1 = (($4_1 & 65535) >>> 0) / 100 | 0;
    $6_1 = ($9_1 << 1) + 655718 | 0;
    $6_1 = HEAPU8[$6_1 | 0] | HEAPU8[$6_1 + 1 | 0] << 8;
    HEAP8[$14_1 | 0] = $6_1;
    HEAP8[$14_1 + 1 | 0] = $6_1 >>> 8;
    $6_1 = $13_1 - 2 | 0;
    $4_1 = ((Math_imul($9_1, -100) + $4_1 & 65535) << 1) + 655718 | 0;
    $4_1 = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8;
    HEAP8[$6_1 | 0] = $4_1;
    HEAP8[$6_1 + 1 | 0] = $4_1 >>> 8;
    $7_1 = $7_1 - 4 | 0;
    $5_1 = !$1_1 & $5_1 >>> 0 > 99999999 | ($1_1 | 0) != 0;
    $1_1 = $8_1;
    if ($5_1) {
     continue
    }
    break;
   }
  }
  if ($0_1 >>> 0 > 99) {
   $7_1 = $7_1 - 2 | 0;
   $1_1 = $7_1 + ($10_1 + 9 | 0) | 0;
   $8_1 = $0_1;
   $0_1 = (($0_1 & 65535) >>> 0) / 100 | 0;
   $5_1 = (($8_1 + Math_imul($0_1, -100) & 65535) << 1) + 655718 | 0;
   $5_1 = HEAPU8[$5_1 | 0] | HEAPU8[$5_1 + 1 | 0] << 8;
   HEAP8[$1_1 | 0] = $5_1;
   HEAP8[$1_1 + 1 | 0] = $5_1 >>> 8;
  }
  label$5 : {
   if ($0_1 >>> 0 >= 10) {
    $7_1 = $7_1 - 2 | 0;
    $1_1 = $7_1 + ($10_1 + 9 | 0) | 0;
    $0_1 = ($0_1 << 1) + 655718 | 0;
    $0_1 = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8;
    HEAP8[$1_1 | 0] = $0_1;
    HEAP8[$1_1 + 1 | 0] = $0_1 >>> 8;
    break label$5;
   }
   $7_1 = $7_1 - 1 | 0;
   HEAP8[$7_1 + ($10_1 + 9 | 0) | 0] = $0_1 + 48;
  }
  $0_1 = $2($3_1, $2_1, 0, ($10_1 + 9 | 0) + $7_1 | 0, 39 - $7_1 | 0);
  global$0 = $10_1 + 48 | 0;
  return $0_1;
 }
 
 function $2($0_1, $1_1, $2_1, $3_1, $4_1) {
  var $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0;
  $9_1 = 655716;
  label$1 : {
   if ($1_1) {
    $5_1 = HEAP32[$0_1 + 24 >> 2];
    $1_1 = $5_1 & 1;
    $10_1 = $1_1 ? 43 : 1114112;
    $6_1 = $1_1 + $4_1 | 0;
    break label$1;
   }
   $5_1 = HEAP32[$0_1 + 24 >> 2];
   $10_1 = 45;
   $6_1 = $4_1 + 1 | 0;
  }
  label$3 : {
   if (!($5_1 & 4)) {
    $9_1 = 0;
    break label$3;
   }
   label$5 : {
    if (!$2_1) {
     break label$5
    }
    $7_1 = $2_1 & 3;
    if (!$7_1) {
     break label$5
    }
    $1_1 = 655716;
    while (1) {
     $8_1 = $8_1 + (HEAP8[$1_1 | 0] > -65) | 0;
     $1_1 = $1_1 + 1 | 0;
     $7_1 = $7_1 - 1 | 0;
     if ($7_1) {
      continue
     }
     break;
    };
   }
   $6_1 = $6_1 + $8_1 | 0;
  }
  label$7 : {
   label$8 : {
    if (!HEAP32[$0_1 + 8 >> 2]) {
     $1_1 = 1;
     $6_1 = HEAP32[$0_1 >> 2];
     $0_1 = HEAP32[$0_1 + 4 >> 2];
     if ($27($6_1, $0_1, $10_1, $9_1, $2_1)) {
      break label$8
     }
     break label$7;
    }
    label$10 : {
     label$11 : {
      label$12 : {
       label$13 : {
        $7_1 = HEAP32[$0_1 + 12 >> 2];
        if ($7_1 >>> 0 > $6_1 >>> 0) {
         if ($5_1 & 8) {
          break label$10
         }
         $5_1 = $7_1 - $6_1 | 0;
         $6_1 = $5_1;
         $1_1 = HEAPU8[$0_1 + 32 | 0];
         $1_1 = ($1_1 | 0) == 3 ? 1 : $1_1;
         switch ($1_1 - 1 | 0) {
         case 1:
          break label$12;
         case 0:
          break label$13;
         default:
          break label$11;
         };
        }
        $1_1 = 1;
        $6_1 = HEAP32[$0_1 >> 2];
        $0_1 = HEAP32[$0_1 + 4 >> 2];
        if ($27($6_1, $0_1, $10_1, $9_1, $2_1)) {
         break label$8
        }
        break label$7;
       }
       $6_1 = 0;
       $1_1 = $5_1;
       break label$11;
      }
      $1_1 = $5_1 >>> 1 | 0;
      $6_1 = $5_1 + 1 >>> 1 | 0;
     }
     $1_1 = $1_1 + 1 | 0;
     $5_1 = HEAP32[$0_1 + 4 >> 2];
     $8_1 = HEAP32[$0_1 + 28 >> 2];
     $7_1 = HEAP32[$0_1 >> 2];
     label$15 : {
      while (1) {
       $1_1 = $1_1 - 1 | 0;
       if (!$1_1) {
        break label$15
       }
       if (!(FUNCTION_TABLE[HEAP32[$5_1 + 16 >> 2]]($7_1, $8_1) | 0)) {
        continue
       }
       break;
      };
      return 1;
     }
     $1_1 = 1;
     if (($8_1 | 0) == 1114112) {
      break label$8
     }
     if ($27($7_1, $5_1, $10_1, $9_1, $2_1)) {
      break label$8
     }
     if (FUNCTION_TABLE[HEAP32[$5_1 + 12 >> 2]]($7_1, $3_1, $4_1) | 0) {
      break label$8
     }
     $1_1 = 0;
     label$17 : {
      while (1) {
       $0_1 = $6_1;
       if (($0_1 | 0) == ($1_1 | 0)) {
        break label$17
       }
       $1_1 = $1_1 + 1 | 0;
       if (!(FUNCTION_TABLE[HEAP32[$5_1 + 16 >> 2]]($7_1, $8_1) | 0)) {
        continue
       }
       break;
      };
      $0_1 = $1_1 - 1 | 0;
     }
     $1_1 = $0_1 >>> 0 < $6_1 >>> 0;
     break label$8;
    }
    $11_1 = HEAP32[$0_1 + 28 >> 2];
    HEAP32[$0_1 + 28 >> 2] = 48;
    $12_1 = HEAPU8[$0_1 + 32 | 0];
    $1_1 = 1;
    HEAP8[$0_1 + 32 | 0] = 1;
    $5_1 = HEAP32[$0_1 >> 2];
    $8_1 = HEAP32[$0_1 + 4 >> 2];
    if ($27($5_1, $8_1, $10_1, $9_1, $2_1)) {
     break label$8
    }
    $1_1 = ($7_1 - $6_1 | 0) + 1 | 0;
    label$19 : {
     while (1) {
      $1_1 = $1_1 - 1 | 0;
      if (!$1_1) {
       break label$19
      }
      if (!(FUNCTION_TABLE[HEAP32[$8_1 + 16 >> 2]]($5_1, 48) | 0)) {
       continue
      }
      break;
     };
     return 1;
    }
    $1_1 = 1;
    if (FUNCTION_TABLE[HEAP32[$8_1 + 12 >> 2]]($5_1, $3_1, $4_1) | 0) {
     break label$8
    }
    HEAP8[$0_1 + 32 | 0] = $12_1;
    HEAP32[$0_1 + 28 >> 2] = $11_1;
    return 0;
   }
   return $1_1;
  }
  return FUNCTION_TABLE[HEAP32[$0_1 + 12 >> 2]]($6_1, $3_1, $4_1) | 0;
 }
 
 function $3($0_1, $1_1) {
  $0_1 = $0_1 | 0;
  $1_1 = $1_1 | 0;
  var $2_1 = 0, $3_1 = 0, $4_1 = 0;
  $4_1 = global$0 - 128 | 0;
  global$0 = $4_1;
  $0_1 = HEAP32[$0_1 >> 2];
  label$1 : {
   label$2 : {
    label$3 : {
     label$4 : {
      $2_1 = HEAP32[$1_1 + 24 >> 2];
      if (!($2_1 & 16)) {
       if ($2_1 & 32) {
        break label$4
       }
       $0_1 = $1(HEAP32[$0_1 >> 2], 0, 1, $1_1);
       break label$3;
      }
      $0_1 = HEAP32[$0_1 >> 2];
      $2_1 = 0;
      while (1) {
       $3_1 = $0_1 & 15;
       HEAP8[($2_1 + $4_1 | 0) + 127 | 0] = $3_1 + ($3_1 >>> 0 < 10 ? 48 : 87);
       $2_1 = $2_1 - 1 | 0;
       $3_1 = $0_1 >>> 0 > 15;
       $0_1 = $0_1 >>> 4 | 0;
       if ($3_1) {
        continue
       }
       break;
      };
      if ($2_1 + 128 >>> 0 >= 129) {
       break label$2
      }
      $0_1 = $2($1_1, 1, 2, ($2_1 + $4_1 | 0) + 128 | 0, 0 - $2_1 | 0);
      break label$3;
     }
     $0_1 = HEAP32[$0_1 >> 2];
     $2_1 = 0;
     while (1) {
      $3_1 = $0_1 & 15;
      HEAP8[($2_1 + $4_1 | 0) + 127 | 0] = $3_1 + ($3_1 >>> 0 < 10 ? 48 : 55);
      $2_1 = $2_1 - 1 | 0;
      $3_1 = $0_1 >>> 0 > 15;
      $0_1 = $0_1 >>> 4 | 0;
      if ($3_1) {
       continue
      }
      break;
     };
     if ($2_1 + 128 >>> 0 >= 129) {
      break label$1
     }
     $0_1 = $2($1_1, 1, 2, ($2_1 + $4_1 | 0) + 128 | 0, 0 - $2_1 | 0);
    }
    global$0 = $4_1 + 128 | 0;
    return $0_1 | 0;
   }
   wasm2js_trap();
  }
  wasm2js_trap();
 }
 
 function $4($0_1) {
  $0_1 = $0_1 | 0;
 }
 
 function $5($0_1) {
  var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0;
  $3_1 = global$0 - 32 | 0;
  global$0 = $3_1;
  $1_1 = $0_1 + 16 | 0;
  $4_1 = HEAP32[$1_1 + 4 >> 2];
  $2_1 = $3_1 + 8 | 0;
  $5_1 = $2_1 + 16 | 0;
  HEAP32[$5_1 >> 2] = HEAP32[$1_1 >> 2];
  HEAP32[$5_1 + 4 >> 2] = $4_1;
  $1_1 = $0_1 + 8 | 0;
  $4_1 = HEAP32[$1_1 + 4 >> 2];
  $2_1 = $2_1 + 8 | 0;
  HEAP32[$2_1 >> 2] = HEAP32[$1_1 >> 2];
  HEAP32[$2_1 + 4 >> 2] = $4_1;
  $1_1 = HEAP32[$0_1 + 4 >> 2];
  HEAP32[$3_1 + 8 >> 2] = HEAP32[$0_1 >> 2];
  HEAP32[$3_1 + 12 >> 2] = $1_1;
  wasm2js_trap();
 }
 
 function $6() {
  var $0_1 = 0, $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;
  $33_1 = global$0 - 32 | 0;
  global$0 = $33_1;
  label$1 : {
   if (HEAPU8[690756]) {
    $47_1 = HEAP32[172762];
    break label$1;
   }
   HEAP32[$33_1 >> 2] = 192;
   HEAP32[$33_1 + 4 >> 2] = 192;
   $0_1 = global$0 - 144 | 0;
   global$0 = $0_1;
   HEAP32[$0_1 + 104 >> 2] = 0;
   HEAP32[$0_1 + 108 >> 2] = 0;
   HEAP32[$0_1 + 32 >> 2] = 528734635;
   HEAP32[$0_1 + 36 >> 2] = 1541459225;
   HEAP32[$0_1 + 24 >> 2] = 1359893119;
   HEAP32[$0_1 + 28 >> 2] = -1694144372;
   HEAP32[$0_1 + 16 >> 2] = 1013904242;
   HEAP32[$0_1 + 20 >> 2] = -1521486534;
   HEAP32[$0_1 + 8 >> 2] = 1779033703;
   HEAP32[$0_1 + 12 >> 2] = -1150833019;
   $1_1 = $0_1 + 8 | 0;
   $29($1_1, 689435, 63);
   $30($1_1, $0_1 + 112 | 0);
   while (1) {
    $4_1 = HEAPU8[($0_1 + 112 | 0) + $3_1 | 0] - HEAPU8[$3_1 + 690288 | 0] | 0;
    if (!$4_1) {
     $1_1 = ($3_1 | 0) != 31;
     $3_1 = $3_1 + 1 | 0;
     if ($1_1) {
      continue
     }
    }
    break;
   };
   if ($4_1) {
    $28(689418, 0)
   }
   HEAP32[163880] = 0;
   HEAP32[163881] = 0;
   HEAP32[163878] = 1;
   HEAP32[163879] = 0;
   $1_1 = HEAP32[172349];
   HEAP32[163892] = HEAP32[172348];
   HEAP32[163893] = $1_1;
   $1_1 = HEAP32[172559];
   HEAP32[163890] = HEAP32[172558];
   HEAP32[163891] = $1_1;
   $1_1 = HEAP32[172595];
   HEAP32[163858] = HEAP32[172594];
   HEAP32[163859] = $1_1;
   $1_1 = HEAP32[172597];
   HEAP32[163860] = HEAP32[172596];
   HEAP32[163861] = $1_1;
   $1_1 = HEAP32[172599];
   HEAP32[163862] = HEAP32[172598];
   HEAP32[163863] = $1_1;
   $1_1 = HEAP32[172601];
   HEAP32[163864] = HEAP32[172600];
   HEAP32[163865] = $1_1;
   $1_1 = HEAP32[172603];
   HEAP32[163866] = HEAP32[172602];
   HEAP32[163867] = $1_1;
   HEAP32[163882] = 0;
   HEAP32[163883] = 0;
   HEAP32[163884] = 0;
   HEAP32[163885] = 0;
   HEAP32[163886] = 0;
   HEAP32[163887] = 0;
   HEAP32[163888] = 0;
   HEAP32[163876] = 629725529;
   HEAP32[163877] = 243653;
   HEAP32[163874] = 632307772;
   HEAP32[163875] = 3389866;
   HEAP32[163872] = 1459808328;
   HEAP32[163873] = 3272439;
   HEAP32[163870] = -1430362568;
   HEAP32[163871] = 3896727;
   HEAP32[163868] = 82779140;
   HEAP32[163869] = 3682156;
   HEAP32[163856] = 0;
   HEAP32[163857] = 0;
   HEAP32[163850] = 1;
   HEAP32[163851] = 0;
   HEAP32[163854] = 0;
   HEAP32[163855] = 0;
   HEAP32[163852] = 0;
   HEAP32[163853] = 0;
   HEAP32[163894] = 0;
   HEAP32[163848] = 1;
   global$0 = $0_1 + 144 | 0;
   $47_1 = 655392;
   (wasm2js_i32$0 = 690756, wasm2js_i32$1 = fimport$0() | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
   (wasm2js_i32$0 = 690760, wasm2js_i32$1 = fimport$0() | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
   (wasm2js_i32$0 = 690764, wasm2js_i32$1 = fimport$0() | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
   (wasm2js_i32$0 = 690768, wasm2js_i32$1 = fimport$0() | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
   (wasm2js_i32$0 = 690772, wasm2js_i32$1 = fimport$0() | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
   (wasm2js_i32$0 = 690776, wasm2js_i32$1 = fimport$0() | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
   (wasm2js_i32$0 = 690780, wasm2js_i32$1 = fimport$0() | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
   (wasm2js_i32$0 = 690784, wasm2js_i32$1 = fimport$0() | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
   $14_1 = global$0 - 720 | 0;
   global$0 = $14_1;
   if (HEAP32[163848]) {
    $0_1 = HEAPU8[690760] | HEAPU8[690761] << 8 | (HEAPU8[690762] << 16 | HEAPU8[690763] << 24);
    $12_1 = $14_1 + 336 | 0;
    $13_1 = $12_1 + 32 | 0;
    HEAP32[$13_1 >> 2] = HEAPU8[690756] | HEAPU8[690757] << 8 | (HEAPU8[690758] << 16 | HEAPU8[690759] << 24);
    HEAP32[$13_1 + 4 >> 2] = $0_1;
    $0_1 = HEAPU8[690768] | HEAPU8[690769] << 8 | (HEAPU8[690770] << 16 | HEAPU8[690771] << 24);
    $10_1 = $12_1 + 40 | 0;
    HEAP32[$10_1 >> 2] = HEAPU8[690764] | HEAPU8[690765] << 8 | (HEAPU8[690766] << 16 | HEAPU8[690767] << 24);
    HEAP32[$10_1 + 4 >> 2] = $0_1;
    $0_1 = HEAPU8[690776] | HEAPU8[690777] << 8 | (HEAPU8[690778] << 16 | HEAPU8[690779] << 24);
    $7_1 = $14_1 + 384 | 0;
    HEAP32[$7_1 >> 2] = HEAPU8[690772] | HEAPU8[690773] << 8 | (HEAPU8[690774] << 16 | HEAPU8[690775] << 24);
    HEAP32[$7_1 + 4 >> 2] = $0_1;
    $0_1 = HEAPU8[690784] | HEAPU8[690785] << 8 | (HEAPU8[690786] << 16 | HEAPU8[690787] << 24);
    $8_1 = $14_1 + 392 | 0;
    HEAP32[$8_1 >> 2] = HEAPU8[690780] | HEAPU8[690781] << 8 | (HEAPU8[690782] << 16 | HEAPU8[690783] << 24);
    HEAP32[$8_1 + 4 >> 2] = $0_1;
    $4_1 = HEAP32[163850];
    $5_1 = $4_1 << 8 & 16711680 | $4_1 << 24;
    $2_1 = $4_1 >>> 8 | 0;
    $1_1 = HEAP32[163851];
    $3_1 = ($2_1 | $1_1 << 24) & 65280;
    $4_1 = $4_1 >>> 24 | 0;
    $5_1 = $5_1 | ($3_1 | ($4_1 | $1_1 << 8) & 255);
    $0_1 = $1_1;
    $3_1 = ($2_1 | ($0_1 & 255) << 24) & -16777216;
    $3_1 = $3_1 | ($4_1 | ($0_1 & 16777215) << 8) & 16711680;
    $9_1 = $12_1 + 24 | 0;
    HEAP32[$9_1 >> 2] = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $3_1;
    HEAP32[$9_1 + 4 >> 2] = $5_1;
    $4_1 = HEAP32[163852];
    $5_1 = $4_1 << 8 & 16711680 | $4_1 << 24;
    $1_1 = HEAP32[163853];
    $3_1 = ($1_1 << 24 | $4_1 >>> 8) & 65280;
    $5_1 = $5_1 | ($3_1 | ($1_1 << 8 | $4_1 >>> 24) & 255);
    $0_1 = $1_1;
    $3_1 = (($0_1 & 255) << 24 | $4_1 >>> 8) & -16777216;
    $3_1 = $3_1 | (($0_1 & 16777215) << 8 | $4_1 >>> 24) & 16711680;
    $11_1 = $12_1 + 16 | 0;
    HEAP32[$11_1 >> 2] = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $3_1;
    HEAP32[$11_1 + 4 >> 2] = $5_1;
    $4_1 = HEAP32[163856];
    $5_1 = $4_1 << 8 & 16711680 | $4_1 << 24;
    $1_1 = HEAP32[163857];
    $3_1 = ($1_1 << 24 | $4_1 >>> 8) & 65280;
    $5_1 = $5_1 | ($3_1 | ($1_1 << 8 | $4_1 >>> 24) & 255);
    $0_1 = $1_1;
    $3_1 = (($0_1 & 255) << 24 | $4_1 >>> 8) & -16777216;
    $3_1 = $3_1 | (($0_1 & 16777215) << 8 | $4_1 >>> 24) & 16711680;
    $2_1 = $14_1;
    HEAP32[$2_1 + 336 >> 2] = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $3_1;
    HEAP32[$2_1 + 340 >> 2] = $5_1;
    $4_1 = HEAP32[163854];
    $5_1 = $4_1 << 8 & 16711680 | $4_1 << 24;
    $1_1 = HEAP32[163855];
    $3_1 = ($1_1 << 24 | $4_1 >>> 8) & 65280;
    $5_1 = $5_1 | ($3_1 | ($1_1 << 8 | $4_1 >>> 24) & 255);
    $0_1 = $1_1;
    $3_1 = (($0_1 & 255) << 24 | $4_1 >>> 8) & -16777216;
    $3_1 = $3_1 | (($0_1 & 16777215) << 8 | $4_1 >>> 24) & 16711680;
    HEAP32[$2_1 + 344 >> 2] = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $3_1;
    HEAP32[$2_1 + 348 >> 2] = $5_1;
    $39_1 = $2_1 + 408 | 0;
    $45($39_1, $12_1, 64);
    HEAP32[$8_1 >> 2] = 0;
    HEAP32[$8_1 + 4 >> 2] = 0;
    HEAP32[$7_1 >> 2] = 0;
    HEAP32[$7_1 + 4 >> 2] = 0;
    HEAP32[$10_1 >> 2] = 0;
    HEAP32[$10_1 + 4 >> 2] = 0;
    HEAP32[$13_1 >> 2] = 0;
    HEAP32[$13_1 + 4 >> 2] = 0;
    HEAP32[$9_1 >> 2] = 0;
    HEAP32[$9_1 + 4 >> 2] = 0;
    HEAP32[$11_1 >> 2] = 0;
    HEAP32[$11_1 + 4 >> 2] = 0;
    HEAP32[$2_1 + 344 >> 2] = 0;
    HEAP32[$2_1 + 348 >> 2] = 0;
    HEAP32[$2_1 + 336 >> 2] = 0;
    HEAP32[$2_1 + 340 >> 2] = 0;
    $34_1 = $2_1 + 480 | 0;
    $46($39_1, $34_1);
    $1_1 = HEAPU8[$2_1 + 497 | 0];
    $0_1 = $1_1 >>> 24 | 0;
    $3_1 = HEAPU8[$2_1 + 498 | 0] | $1_1 << 8;
    $1_1 = $0_1;
    $45_1 = $34_1 + 16 | 0;
    $4_1 = HEAPU8[$45_1 | 0];
    $0_1 = $4_1 >>> 16 | 0;
    $3_1 = $4_1 << 16 | $3_1;
    $4_1 = $0_1 | $1_1;
    $1_1 = HEAPU8[$2_1 + 495 | 0];
    $0_1 = $1_1 >>> 8 | 0;
    $3_1 = $3_1 | $1_1 << 24;
    $11_1 = HEAPU8[$2_1 + 492 | 0];
    $4_1 = HEAPU8[$2_1 + 494 | 0] | ($0_1 | $4_1) | HEAPU8[$2_1 + 493 | 0] << 8 | ($11_1 & 15) << 16;
    $1_1 = HEAPU8[$2_1 + 484 | 0];
    $0_1 = $1_1 >>> 24 | 0;
    $6_1 = HEAPU8[$2_1 + 485 | 0] | $1_1 << 8;
    $1_1 = $0_1;
    $5_1 = HEAPU8[$2_1 + 483 | 0];
    $0_1 = $5_1 >>> 16 | 0;
    $6_1 = $5_1 << 16 | $6_1;
    $5_1 = $0_1 | $1_1;
    $1_1 = HEAPU8[$2_1 + 482 | 0];
    $0_1 = $1_1 >>> 8 | 0;
    $12_1 = $1_1 << 24 | $6_1;
    $13_1 = HEAPU8[$2_1 + 481 | 0] | ($0_1 | $5_1) | HEAPU8[$2_1 + 480 | 0] << 8;
    $1_1 = HEAPU8[$2_1 + 491 | 0];
    $0_1 = $1_1 >>> 28 | 0;
    $6_1 = $1_1 << 4 | $11_1 >>> 4;
    $1_1 = $0_1;
    $5_1 = HEAPU8[$2_1 + 490 | 0];
    $0_1 = $5_1 >>> 20 | 0;
    $6_1 = $5_1 << 12 | $6_1;
    $5_1 = $0_1 | $1_1;
    $1_1 = HEAPU8[$2_1 + 489 | 0];
    $0_1 = $1_1 >>> 12 | 0;
    $6_1 = $1_1 << 20 | $6_1;
    $5_1 = $0_1 | $5_1;
    $1_1 = HEAPU8[$2_1 + 488 | 0];
    $0_1 = $1_1 >>> 4 | 0;
    $10_1 = $1_1 << 28 | $6_1;
    $7_1 = $0_1 | $5_1 | HEAPU8[$2_1 + 487 | 0] << 4 | HEAPU8[$2_1 + 486 | 0] << 12;
    $46_1 = $34_1 + 24 | 0;
    $1_1 = HEAPU8[$46_1 | 0];
    $0_1 = $1_1 >>> 28 | 0;
    $8_1 = HEAPU8[$2_1 + 505 | 0];
    $6_1 = $1_1 << 4 | $8_1 >>> 4;
    $1_1 = $0_1;
    $5_1 = HEAPU8[$2_1 + 503 | 0];
    $0_1 = $5_1 >>> 20 | 0;
    $6_1 = $5_1 << 12 | $6_1;
    $5_1 = $0_1 | $1_1;
    $1_1 = HEAPU8[$2_1 + 502 | 0];
    $0_1 = $1_1 >>> 12 | 0;
    $6_1 = $1_1 << 20 | $6_1;
    $5_1 = $0_1 | $5_1;
    $1_1 = HEAPU8[$2_1 + 501 | 0];
    $0_1 = $1_1 >>> 4 | 0;
    $9_1 = $1_1 << 28 | $6_1;
    $20_1 = $0_1 | $5_1 | HEAPU8[$2_1 + 500 | 0] << 4 | HEAPU8[$2_1 + 499 | 0] << 12;
    $11_1 = $20_1;
    $1_1 = HEAPU8[$2_1 + 510 | 0];
    $0_1 = $1_1 >>> 24 | 0;
    $6_1 = HEAPU8[$2_1 + 511 | 0] | $1_1 << 8;
    $1_1 = $0_1;
    $5_1 = HEAPU8[$2_1 + 509 | 0];
    $0_1 = $5_1 >>> 16 | 0;
    $6_1 = $5_1 << 16 | $6_1;
    $5_1 = $0_1 | $1_1;
    $1_1 = HEAPU8[$2_1 + 508 | 0];
    $0_1 = $1_1 >>> 8 | 0;
    $29_1 = $2_1 + 520 | 0;
    $40_1 = $29_1 + 32 | 0;
    $1_1 = $6_1 | $1_1 << 24;
    $8_1 = HEAPU8[$2_1 + 507 | 0] | ($0_1 | $5_1) | HEAPU8[$2_1 + 506 | 0] << 8 | ($8_1 & 15) << 16;
    $0_1 = !($12_1 | ($10_1 | ($3_1 | ($1_1 | $9_1))) | ($13_1 | ($7_1 | ($4_1 | ($8_1 | $11_1))))) | ($3_1 & $9_1 & $10_1) == -1 & ($4_1 & $11_1 & $7_1) == 1048575 & (($12_1 | 0) == -1 & ($13_1 | 0) == 65535) & (($8_1 | 0) == 1048574 & $1_1 >>> 0 > 4294966318 | $8_1 >>> 0 > 1048574);
    $5_1 = $0_1 - 1 | 0;
    $11_1 = $5_1 & $12_1;
    HEAP32[$40_1 >> 2] = $11_1;
    $6_1 = $13_1;
    $13_1 = 0 - !$0_1 | 0;
    $6_1 = $6_1 & $13_1;
    HEAP32[$40_1 + 4 >> 2] = $6_1;
    $41_1 = $29_1 + 24 | 0;
    $23_1 = $5_1 & $10_1;
    HEAP32[$41_1 >> 2] = $23_1;
    $24_1 = $7_1 & $13_1;
    HEAP32[$41_1 + 4 >> 2] = $24_1;
    $42_1 = $29_1 + 16 | 0;
    $18_1 = $3_1 & $5_1;
    HEAP32[$42_1 >> 2] = $18_1;
    $15_1 = $4_1 & $13_1;
    HEAP32[$42_1 + 4 >> 2] = $15_1;
    $43_1 = $29_1 + 8 | 0;
    $21_1 = $5_1 & $9_1;
    HEAP32[$43_1 >> 2] = $21_1;
    $16_1 = $13_1 & $20_1;
    HEAP32[$43_1 + 4 >> 2] = $16_1;
    $5_1 = $1_1 & $5_1 | $0_1;
    HEAP32[$2_1 + 520 >> 2] = $5_1;
    $0_1 = $8_1 & $13_1;
    $20_1 = $0_1;
    HEAP32[$2_1 + 524 >> 2] = $0_1;
    $12_1 = $2_1 + 128 | 0;
    $30_1 = $5_1 << 1;
    $25_1 = $0_1 << 1 | $5_1 >>> 31;
    $69($12_1, $30_1, $25_1, 0, 0, $23_1, $24_1, 0, 0);
    $13_1 = $2_1 + 192 | 0;
    $4_1 = $21_1 << 1;
    $3_1 = $16_1 << 1 | $21_1 >>> 31;
    $69($13_1, $4_1, $3_1, 0, 0, $18_1, $15_1, 0, 0);
    $7_1 = $2_1 + 320 | 0;
    $69($7_1, $11_1, $6_1, 0, 0, $11_1, $6_1, 0, 0);
    $8_1 = $2_1 + 304 | 0;
    $69($8_1, HEAP32[$2_1 + 320 >> 2], HEAP32[$2_1 + 324 >> 2], 0, 0, 15632, 16, 0, 0);
    $1_1 = $11_1;
    $0_1 = $6_1 << 1 | $1_1 >>> 31;
    $35_1 = $2_1 + 80 | 0;
    $44_1 = $1_1 << 1;
    $26_1 = $0_1;
    $69($35_1, $44_1, $0_1, 0, 0, $5_1, $20_1, 0, 0);
    $36_1 = $2_1 + 176 | 0;
    $69($36_1, $4_1, $3_1, 0, 0, $23_1, $24_1, 0, 0);
    $37_1 = $2_1 + 240 | 0;
    $69($37_1, $18_1, $15_1, 0, 0, $18_1, $15_1, 0, 0);
    $10_1 = $2_1 + 288 | 0;
    $0_1 = $7_1 + 8 | 0;
    $69($10_1, HEAP32[$0_1 >> 2], HEAP32[$0_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $69($2_1, $5_1, $20_1, 0, 0, $5_1, $20_1, 0, 0);
    $48_1 = $2_1 + 160 | 0;
    $69($48_1, $44_1, $26_1, 0, 0, $21_1, $16_1, 0, 0);
    $31_1 = $2_1 + 208 | 0;
    $69($31_1, $18_1 << 1, $15_1 << 1 | $18_1 >>> 31, 0, 0, $23_1, $24_1, 0, 0);
    $7_1 = HEAP32[$2_1 + 132 >> 2];
    $0_1 = $7_1 + HEAP32[$2_1 + 196 >> 2] | 0;
    $5_1 = HEAP32[$2_1 + 128 >> 2];
    $4_1 = HEAP32[$2_1 + 192 >> 2];
    $1_1 = $5_1 + $4_1 | 0;
    $3_1 = HEAP32[$2_1 + 304 >> 2];
    $20_1 = $1_1 + $3_1 | 0;
    $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $4_1 + HEAP32[$2_1 + 308 >> 2] | 0;
    $3_1 = $3_1 >>> 0 > $20_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $9_1 = ($4_1 | 0) == ($3_1 | 0) & $1_1 >>> 0 > $20_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
    $0_1 = $8_1 + 8 | 0;
    $11_1 = HEAP32[$0_1 >> 2];
    $6_1 = HEAP32[$0_1 + 4 >> 2];
    $5_1 = ($4_1 | 0) == ($7_1 | 0) & $1_1 >>> 0 < $5_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0;
    $4_1 = $13_1 + 8 | 0;
    $1_1 = HEAP32[$4_1 >> 2];
    $0_1 = $12_1 + 8 | 0;
    $8_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $0_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $1_1 = $5_1 + $8_1 | 0;
    $0_1 = ($1_1 >>> 0 < $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $6_1 | 0;
    $4_1 = $1_1;
    $1_1 = $1_1 + $11_1 | 0;
    $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $9_1 | 0;
    $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $12_1 = $3_1;
    $11_1 = $1_1 << 12 | $3_1 >>> 20;
    $4_1 = $0_1;
    $5_1 = $0_1 << 12 | $1_1 >>> 20;
    $38_1 = HEAP32[$2_1 + 176 >> 2];
    $1_1 = HEAP32[$2_1 + 240 >> 2];
    $9_1 = $38_1 + $1_1 | 0;
    $32_1 = HEAP32[$2_1 + 180 >> 2];
    $0_1 = $32_1 + HEAP32[$2_1 + 244 >> 2] | 0;
    $0_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $1_1 = HEAP32[$2_1 + 80 >> 2];
    $6_1 = $1_1 + $9_1 | 0;
    $7_1 = $0_1;
    $0_1 = $0_1 + HEAP32[$2_1 + 84 >> 2] | 0;
    $0_1 = $1_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $1_1 = HEAP32[$2_1 + 288 >> 2];
    $3_1 = $1_1 + $6_1 | 0;
    $8_1 = $0_1;
    $0_1 = $0_1 + HEAP32[$2_1 + 292 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $1_1 + $5_1 | 0;
    $27_1 = $2_1 + 16 | 0;
    $11_1 = $3_1 + $11_1 | 0;
    $5_1 = $11_1 >>> 0 < $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $22_1 = ($1_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
    $28_1 = ($1_1 | 0) == ($8_1 | 0) & $6_1 >>> 0 > $3_1 >>> 0 | $1_1 >>> 0 < $8_1 >>> 0;
    $0_1 = $10_1 + 8 | 0;
    $17_1 = HEAP32[$0_1 >> 2];
    $19_1 = HEAP32[$0_1 + 4 >> 2];
    $13_1 = ($7_1 | 0) == ($8_1 | 0) & $6_1 >>> 0 < $9_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
    $0_1 = $35_1 + 8 | 0;
    $10_1 = HEAP32[$0_1 >> 2];
    $8_1 = HEAP32[$0_1 + 4 >> 2];
    $6_1 = ($7_1 | 0) == ($32_1 | 0) & $9_1 >>> 0 < $38_1 >>> 0 | $7_1 >>> 0 < $32_1 >>> 0;
    $3_1 = $37_1 + 8 | 0;
    $1_1 = HEAP32[$3_1 >> 2];
    $0_1 = $36_1 + 8 | 0;
    $9_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $0_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $1_1 = $6_1 + $9_1 | 0;
    $0_1 = ($1_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $8_1 | 0;
    $3_1 = $1_1;
    $1_1 = $1_1 + $10_1 | 0;
    $0_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $3_1 = $1_1;
    $1_1 = $1_1 + $13_1 | 0;
    $0_1 = ($3_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $19_1 | 0;
    $3_1 = $1_1;
    $1_1 = $1_1 + $17_1 | 0;
    $0_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $3_1 = $1_1 + $28_1 | 0;
    $0_1 = $3_1 >>> 0 < $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $3_1 + $4_1 | 0;
    $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $22_1 | 0;
    $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $4_1 = $5_1;
    $6_1 = $1_1 << 12 | $4_1 >>> 20;
    $3_1 = $0_1;
    $9_1 = $0_1 << 12 | $1_1 >>> 20;
    $17_1 = HEAP32[$2_1 + 164 >> 2];
    $0_1 = $17_1 + HEAP32[$2_1 + 212 >> 2] | 0;
    $10_1 = HEAP32[$2_1 + 160 >> 2];
    $1_1 = HEAP32[$2_1 + 208 >> 2];
    $5_1 = $10_1 + $1_1 | 0;
    $8_1 = $5_1;
    $6_1 = $5_1 + $6_1 | 0;
    $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $1_1 + $9_1 | 0;
    $7_1 = $6_1 << 4 & -16;
    $5_1 = $6_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $9_1 = ($5_1 << 4 | $6_1 >>> 28) & 16777215;
    $13_1 = $4_1;
    $69($27_1, $7_1 | $4_1 >>> 16 & 15, $9_1, 0, 0, 977, 1, 0, 0);
    $22_1 = HEAP32[$2_1 + 20 >> 2];
    $0_1 = $22_1 + HEAP32[$2_1 + 4 >> 2] | 0;
    $28_1 = HEAP32[$2_1 + 16 >> 2];
    $4_1 = HEAP32[$2_1 >> 2];
    $9_1 = $28_1 + $4_1 | 0;
    HEAP32[$2_1 + 560 >> 2] = $9_1;
    $4_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    HEAP32[$2_1 + 564 >> 2] = $4_1 & 1048575;
    $35_1 = $2_1 + 112 | 0;
    $69($35_1, $30_1, $25_1, 0, 0, $21_1, $16_1, 0, 0);
    $36_1 = $2_1 + 224 | 0;
    $69($36_1, $44_1, $26_1, 0, 0, $18_1, $15_1, 0, 0);
    $37_1 = $2_1 + 272 | 0;
    $69($37_1, $23_1, $24_1, 0, 0, $23_1, $24_1, 0, 0);
    $38_1 = $2_1 - -64 | 0;
    $19_1 = $38_1;
    $7_1 = ($1_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 < $8_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
    $8_1 = ($1_1 | 0) == ($17_1 | 0) & $8_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
    $6_1 = $31_1 + 8 | 0;
    $1_1 = HEAP32[$6_1 >> 2];
    $0_1 = $48_1 + 8 | 0;
    $10_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$6_1 + 4 >> 2] | 0;
    $0_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $6_1 = $8_1 + $10_1 | 0;
    $0_1 = $6_1 >>> 0 < $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $3_1 = $3_1 >>> 20 | 0;
    $1_1 = $6_1 + $3_1 | 0;
    $0_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $3_1 = $1_1;
    $1_1 = $1_1 + $7_1 | 0;
    $0_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $8_1 = $1_1 << 12 | $5_1 >>> 20;
    $6_1 = $0_1;
    $5_1 = $0_1 << 12 | $1_1 >>> 20;
    $32_1 = HEAP32[$2_1 + 224 >> 2];
    $1_1 = HEAP32[$2_1 + 272 >> 2];
    $17_1 = $32_1 + $1_1 | 0;
    $31_1 = HEAP32[$2_1 + 228 >> 2];
    $0_1 = $31_1 + HEAP32[$2_1 + 276 >> 2] | 0;
    $3_1 = $1_1 >>> 0 > $17_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $3_1 + $5_1 | 0;
    $10_1 = $8_1 + $17_1 | 0;
    $0_1 = $10_1 >>> 0 < $17_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $8_1 = $0_1;
    $69($19_1, $10_1, $0_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $9_1 = ($4_1 | 0) == ($22_1 | 0) & $9_1 >>> 0 < $28_1 >>> 0 | $4_1 >>> 0 < $22_1 >>> 0;
    $5_1 = $2_1 + 8 | 0;
    $1_1 = HEAP32[$5_1 >> 2];
    $0_1 = $27_1 + 8 | 0;
    $7_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
    $0_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $1_1 = $7_1 + $9_1 | 0;
    $0_1 = $1_1 >>> 0 < $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $7_1 = $1_1 << 12 | $4_1 >>> 20;
    $5_1 = $0_1;
    $9_1 = $0_1 << 12 | $1_1 >>> 20;
    $22_1 = HEAP32[$2_1 + 64 >> 2];
    $1_1 = HEAP32[$2_1 + 112 >> 2];
    $19_1 = $22_1 + $1_1 | 0;
    $27_1 = HEAP32[$2_1 + 68 >> 2];
    $0_1 = $27_1 + HEAP32[$2_1 + 116 >> 2] | 0;
    $4_1 = $1_1 >>> 0 > $19_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $4_1 + $9_1 | 0;
    $7_1 = $7_1 + $19_1 | 0;
    $0_1 = $7_1 >>> 0 < $19_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    HEAP32[$2_1 + 568 >> 2] = $7_1;
    $9_1 = $0_1;
    HEAP32[$2_1 + 572 >> 2] = $0_1 & 1048575;
    $28_1 = $2_1 + 96 | 0;
    $69($28_1, $30_1, $25_1, 0, 0, $18_1, $15_1, 0, 0);
    $30_1 = $2_1 + 144 | 0;
    $69($30_1, $21_1, $16_1, 0, 0, $21_1, $16_1, 0, 0);
    $21_1 = $2_1 + 256 | 0;
    $69($21_1, $44_1, $26_1, 0, 0, $23_1, $24_1, 0, 0);
    $18_1 = $2_1 + 48 | 0;
    $15_1 = ($3_1 | 0) == ($8_1 | 0) & $10_1 >>> 0 < $17_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
    $10_1 = ($3_1 | 0) == ($31_1 | 0) & $17_1 >>> 0 < $32_1 >>> 0 | $3_1 >>> 0 < $31_1 >>> 0;
    $3_1 = $37_1 + 8 | 0;
    $1_1 = HEAP32[$3_1 >> 2];
    $0_1 = $36_1 + 8 | 0;
    $16_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
    $0_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $3_1 = $10_1 + $16_1 | 0;
    $0_1 = $3_1 >>> 0 < $16_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $6_1 = $6_1 >>> 20 | 0;
    $1_1 = $6_1 + $3_1 | 0;
    $0_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $3_1 = $1_1;
    $1_1 = $1_1 + $15_1 | 0;
    $0_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $16_1 = $1_1 << 12 | $8_1 >>> 20;
    $6_1 = HEAP32[$2_1 + 256 >> 2];
    $8_1 = $16_1 + $6_1 | 0;
    $3_1 = $0_1;
    $25_1 = $0_1 << 12 | $1_1 >>> 20;
    $0_1 = $25_1 + HEAP32[$2_1 + 260 >> 2] | 0;
    $10_1 = $6_1 >>> 0 > $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $69($18_1, $8_1, $10_1, 0, 0, 15632, 16, 0, 0);
    $6_1 = $2_1;
    $7_1 = ($4_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $19_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
    $2_1 = ($4_1 | 0) == ($27_1 | 0) & $19_1 >>> 0 < $22_1 >>> 0 | $4_1 >>> 0 < $27_1 >>> 0;
    $4_1 = $35_1 + 8 | 0;
    $1_1 = HEAP32[$4_1 >> 2];
    $0_1 = $38_1 + 8 | 0;
    $15_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $0_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $4_1 = $2_1 + $15_1 | 0;
    $0_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $5_1 = $5_1 >>> 20 | 0;
    $1_1 = $5_1 + $4_1 | 0;
    $0_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $7_1 | 0;
    $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $2_1 = $1_1 << 12 | $9_1 >>> 20;
    $4_1 = $0_1;
    $5_1 = $0_1 << 12 | $1_1 >>> 20;
    $17_1 = HEAP32[$6_1 + 96 >> 2];
    $1_1 = HEAP32[$6_1 + 144 >> 2];
    $7_1 = $17_1 + $1_1 | 0;
    $26_1 = HEAP32[$6_1 + 100 >> 2];
    $0_1 = $26_1 + HEAP32[$6_1 + 148 >> 2] | 0;
    $0_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $1_1 = HEAP32[$6_1 + 48 >> 2];
    $9_1 = $1_1 + $7_1 | 0;
    $15_1 = $0_1;
    $0_1 = $0_1 + HEAP32[$6_1 + 52 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $1_1 + $5_1 | 0;
    $2_1 = $2_1 + $9_1 | 0;
    $0_1 = $2_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    HEAP32[$6_1 + 576 >> 2] = $2_1;
    $5_1 = $0_1;
    HEAP32[$6_1 + 580 >> 2] = $0_1 & 1048575;
    $19_1 = $6_1 + 32 | 0;
    $16_1 = ($10_1 | 0) == ($25_1 | 0) & $8_1 >>> 0 < $16_1 >>> 0 | $10_1 >>> 0 < $25_1 >>> 0;
    $0_1 = $21_1 + 8 | 0;
    $10_1 = HEAP32[$0_1 >> 2];
    $0_1 = HEAP32[$0_1 + 4 >> 2];
    $3_1 = $3_1 >>> 20 | 0;
    $8_1 = $3_1;
    $3_1 = $3_1 + $10_1 | 0;
    $0_1 = $8_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $8_1 = $3_1;
    $3_1 = $3_1 + $16_1 | 0;
    $0_1 = $8_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $69($19_1, $3_1, $0_1, 0, 0, 64028672, 65536, 0, 0);
    $3_1 = $6_1;
    $16_1 = ($1_1 | 0) == ($5_1 | 0) & $2_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
    $10_1 = ($1_1 | 0) == ($15_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 < $15_1 >>> 0;
    $0_1 = $18_1 + 8 | 0;
    $8_1 = HEAP32[$0_1 >> 2];
    $9_1 = HEAP32[$0_1 + 4 >> 2];
    $2_1 = ($15_1 | 0) == ($26_1 | 0) & $7_1 >>> 0 < $17_1 >>> 0 | $15_1 >>> 0 < $26_1 >>> 0;
    $6_1 = $30_1 + 8 | 0;
    $1_1 = HEAP32[$6_1 >> 2];
    $0_1 = $28_1 + 8 | 0;
    $7_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$6_1 + 4 >> 2] | 0;
    $0_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $1_1 = $2_1 + $7_1 | 0;
    $0_1 = ($1_1 >>> 0 < $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $9_1 | 0;
    $6_1 = $1_1;
    $1_1 = $1_1 + $8_1 | 0;
    $0_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $6_1 = $1_1 + $10_1 | 0;
    $0_1 = $6_1 >>> 0 < $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $4_1 = $4_1 >>> 20 | 0;
    $1_1 = $6_1 + $4_1 | 0;
    $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $4_1 = $1_1;
    $1_1 = $1_1 + $16_1 | 0;
    $0_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $9_1 = $1_1 << 12 | $5_1 >>> 20;
    $4_1 = $0_1;
    $5_1 = $0_1 << 12 | $1_1 >>> 20;
    $7_1 = HEAP32[$3_1 + 32 >> 2];
    $1_1 = $20_1 & -2;
    $6_1 = $7_1 + $1_1 | 0;
    $10_1 = HEAP32[$3_1 + 36 >> 2];
    $0_1 = $10_1 + ($12_1 & 1048575) | 0;
    $2_1 = $1_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $2_1 + $5_1 | 0;
    $5_1 = $6_1 + $9_1 | 0;
    $0_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    HEAP32[$3_1 + 584 >> 2] = $5_1;
    $1_1 = $0_1;
    HEAP32[$3_1 + 588 >> 2] = $0_1 & 1048575;
    $8_1 = $13_1 & 65535;
    $9_1 = ($0_1 | 0) == ($2_1 | 0) & $6_1 >>> 0 > $5_1 >>> 0 | $0_1 >>> 0 < $2_1 >>> 0;
    $3_1 = ($2_1 | 0) == ($10_1 | 0) & $6_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $10_1 >>> 0;
    $0_1 = $19_1 + 8 | 0;
    $5_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
    $0_1 = HEAP32[$0_1 + 4 >> 2];
    $0_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $4_1 = $4_1 >>> 20 | 0;
    $3_1 = $4_1;
    $4_1 = $5_1 + $4_1 | 0;
    $0_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $3_1 = $4_1;
    $4_1 = $4_1 + $9_1 | 0;
    $0_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $1_1 = $4_1 << 12 | $1_1 >>> 20;
    $3_1 = $1_1 + $11_1 | 0;
    $0_1 = $8_1 + ($0_1 << 12 | $4_1 >>> 20) | 0;
    HEAP32[$14_1 + 592 >> 2] = $3_1;
    HEAP32[$14_1 + 596 >> 2] = $1_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $18_1 = $14_1 + 560 | 0;
    $34(655432, 655432, $18_1);
    $34(655472, 655472, $18_1);
    $34(655472, 655472, $29_1);
    $34(655512, 655512, $29_1);
    HEAP32[$43_1 >> 2] = 0;
    HEAP32[$43_1 + 4 >> 2] = 0;
    HEAP32[$42_1 >> 2] = 0;
    HEAP32[$42_1 + 4 >> 2] = 0;
    HEAP32[$41_1 >> 2] = 0;
    HEAP32[$41_1 + 4 >> 2] = 0;
    HEAP32[$40_1 >> 2] = 0;
    HEAP32[$40_1 + 4 >> 2] = 0;
    HEAP32[$14_1 + 520 >> 2] = 0;
    HEAP32[$14_1 + 524 >> 2] = 0;
    $46($39_1, $34_1);
    $17_1 = $14_1 + 688 | 0;
    $38($17_1, $34_1, 0);
    $1_1 = $17_1 + 24 | 0;
    $7_1 = HEAP32[$1_1 >> 2];
    $4_1 = $17_1 + 16 | 0;
    $10_1 = HEAP32[$4_1 >> 2];
    $3_1 = $17_1 + 8 | 0;
    $12_1 = HEAP32[$3_1 >> 2];
    $13_1 = HEAP32[$14_1 + 688 >> 2];
    $8_1 = $7_1 | ($10_1 | ($12_1 | $13_1));
    $6_1 = HEAP32[$1_1 + 4 >> 2];
    $11_1 = HEAP32[$4_1 + 4 >> 2];
    $9_1 = HEAP32[$3_1 + 4 >> 2];
    $2_1 = HEAP32[$14_1 + 692 >> 2];
    $5_1 = $6_1 | ($11_1 | ($9_1 | $2_1));
    $0_1 = $8_1 | $5_1 ? -1 : 0;
    $19_1 = $0_1 & $7_1;
    HEAP32[$1_1 >> 2] = $19_1;
    $16_1 = $0_1 & $6_1;
    HEAP32[$1_1 + 4 >> 2] = $16_1;
    $15_1 = $0_1 & $10_1;
    HEAP32[$4_1 >> 2] = $15_1;
    $20_1 = $0_1 & $11_1;
    HEAP32[$4_1 + 4 >> 2] = $20_1;
    $12_1 = $0_1 & $12_1;
    HEAP32[$3_1 >> 2] = $12_1;
    $10_1 = $0_1 & $9_1;
    HEAP32[$3_1 + 4 >> 2] = $10_1;
    $5_1 = !($5_1 | $8_1) | $0_1 & $13_1;
    HEAP32[$14_1 + 688 >> 2] = $5_1;
    $6_1 = $0_1 & $2_1;
    HEAP32[$14_1 + 692 >> 2] = $6_1;
    $68($39_1, 68);
    HEAP32[$46_1 >> 2] = 0;
    HEAP32[$46_1 + 4 >> 2] = 0;
    HEAP32[$45_1 >> 2] = 0;
    HEAP32[$45_1 + 4 >> 2] = 0;
    HEAP32[$14_1 + 488 >> 2] = 0;
    HEAP32[$14_1 + 492 >> 2] = 0;
    HEAP32[$14_1 + 480 >> 2] = 0;
    HEAP32[$14_1 + 484 >> 2] = 0;
    $48(655392, $18_1, $17_1);
    $0_1 = $12_1 | $15_1 | $19_1 | $5_1 | ($10_1 | $20_1 | $16_1 | $6_1) ? -1 : 0;
    $7_1 = $5_1 ^ -1;
    $2_1 = $7_1 - 801750718 | 0;
    $5_1 = $0_1;
    $11_1 = $6_1 ^ -1;
    $6_1 = $11_1 - (($7_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
    $0_1 = $0_1 & $6_1;
    $8_1 = $0_1;
    $9_1 = $2_1 & $5_1;
    HEAP32[163850] = $9_1;
    HEAP32[163851] = $0_1;
    $10_1 = $10_1 ^ -1;
    $0_1 = $10_1;
    $13_1 = $12_1 ^ -1;
    $12_1 = $13_1 + (($6_1 | 0) == ($11_1 | 0) & $2_1 >>> 0 < $7_1 >>> 0 | $6_1 >>> 0 < $11_1 >>> 0) | 0;
    $2_1 = $12_1 - 1354194885 | 0;
    $11_1 = $2_1 & $5_1;
    HEAP32[$3_1 >> 2] = $11_1;
    $0_1 = $12_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $7_1 = $0_1 - (($12_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
    $6_1 = $7_1 & $5_1;
    HEAP32[$3_1 + 4 >> 2] = $6_1;
    HEAP32[163852] = $11_1;
    HEAP32[163853] = $6_1;
    $6_1 = ($0_1 | 0) == ($7_1 | 0) & $2_1 >>> 0 < $12_1 >>> 0 | $0_1 >>> 0 > $7_1 >>> 0;
    $11_1 = $6_1 + (($0_1 | 0) == ($10_1 | 0) & $12_1 >>> 0 < $13_1 >>> 0 | $0_1 >>> 0 < $10_1 >>> 0) | 0;
    $13_1 = $15_1 ^ -1;
    $12_1 = $13_1 + $11_1 | 0;
    $10_1 = $20_1 ^ -1;
    $0_1 = $10_1 + ($6_1 >>> 0 > $11_1 >>> 0) | 0;
    $2_1 = $12_1 - 2 | 0;
    $11_1 = $2_1 & $5_1;
    HEAP32[$4_1 >> 2] = $11_1;
    $0_1 = $12_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $7_1 = $0_1 - ($12_1 >>> 0 < 2) | 0;
    $6_1 = $7_1 & $5_1;
    HEAP32[$4_1 + 4 >> 2] = $6_1;
    HEAP32[163854] = $11_1;
    HEAP32[163855] = $6_1;
    $6_1 = ($0_1 | 0) == ($7_1 | 0) & $2_1 >>> 0 < $12_1 >>> 0 | $0_1 >>> 0 > $7_1 >>> 0;
    $2_1 = $6_1 + (($0_1 | 0) == ($10_1 | 0) & $12_1 >>> 0 < $13_1 >>> 0 | $0_1 >>> 0 < $10_1 >>> 0) | 0;
    $0_1 = $2_1 >>> 0 < $6_1 >>> 0;
    $11_1 = $2_1 - $19_1 | 0;
    $6_1 = $11_1 - 2 & $5_1;
    HEAP32[$1_1 >> 2] = $6_1;
    $0_1 = ($0_1 - (($2_1 >>> 0 < $19_1 >>> 0) + $16_1 | 0) | 0) - ($11_1 >>> 0 < 2) & $5_1;
    HEAP32[$1_1 + 4 >> 2] = $0_1;
    HEAP32[163856] = $6_1;
    HEAP32[163857] = $0_1;
    HEAP32[$14_1 + 688 >> 2] = $9_1;
    HEAP32[$14_1 + 692 >> 2] = $8_1;
    $70(655432, $18_1, 128);
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    HEAP32[$4_1 >> 2] = 0;
    HEAP32[$4_1 + 4 >> 2] = 0;
    HEAP32[$3_1 >> 2] = 0;
    HEAP32[$3_1 + 4 >> 2] = 0;
    HEAP32[$14_1 + 688 >> 2] = 0;
    HEAP32[$14_1 + 692 >> 2] = 0;
    $68($18_1, 124);
   }
   global$0 = $14_1 + 720 | 0;
   HEAP8[690757] = 0;
   HEAP8[690758] = 0;
   HEAP8[690759] = 0;
   HEAP8[690760] = 0;
   HEAP8[690761] = 0;
   HEAP8[690762] = 0;
   HEAP8[690763] = 0;
   HEAP8[690764] = 0;
   HEAP8[690756] = 1;
   HEAP8[690765] = 0;
   HEAP8[690766] = 0;
   HEAP8[690767] = 0;
   HEAP8[690768] = 0;
   HEAP8[690769] = 0;
   HEAP8[690770] = 0;
   HEAP8[690771] = 0;
   HEAP8[690772] = 0;
   HEAP8[690773] = 0;
   HEAP8[690774] = 0;
   HEAP8[690775] = 0;
   HEAP8[690776] = 0;
   HEAP8[690777] = 0;
   HEAP8[690778] = 0;
   HEAP8[690779] = 0;
   HEAP8[690780] = 0;
   HEAP8[690780] = 0;
   HEAP8[690781] = 0;
   HEAP8[690782] = 0;
   HEAP8[690783] = 0;
   HEAP8[690784] = 0;
   HEAP8[690785] = 0;
   HEAP8[690786] = 0;
   HEAP8[690787] = 0;
   HEAP32[$33_1 + 4 >> 2] = 1;
   HEAP32[172762] = 655392;
  }
  global$0 = $33_1 + 32 | 0;
  return $47_1;
 }
 
 function $7() {
  $6();
 }
 
 function $8($0_1) {
  $0_1 = $0_1 | 0;
  var $1_1 = 0, $2_1 = 0;
  $1_1 = global$0 + -64 | 0;
  global$0 = $1_1;
  label$1 : {
   if (($0_1 | 0) != 32) {
    $2_1 = $1_1 + 56 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $2_1 = $1_1 + 48 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $2_1 = $1_1 + 40 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $2_1 = $1_1 + 32 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $2_1 = $1_1 + 24 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $2_1 = $1_1 + 16 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    $2_1 = $1_1 + 8 | 0;
    HEAP32[$2_1 >> 2] = 0;
    HEAP32[$2_1 + 4 >> 2] = 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $0_1 = $31(HEAP32[172688], $1_1, 690820, $0_1);
    break label$1;
   }
   $0_1 = $1_1 + 56 | 0;
   HEAP32[$0_1 >> 2] = 0;
   HEAP32[$0_1 + 4 >> 2] = 0;
   $0_1 = $1_1 + 48 | 0;
   HEAP32[$0_1 >> 2] = 0;
   HEAP32[$0_1 + 4 >> 2] = 0;
   $0_1 = $1_1 + 40 | 0;
   HEAP32[$0_1 >> 2] = 0;
   HEAP32[$0_1 + 4 >> 2] = 0;
   $0_1 = $1_1 + 32 | 0;
   HEAP32[$0_1 >> 2] = 0;
   HEAP32[$0_1 + 4 >> 2] = 0;
   $0_1 = $1_1 + 24 | 0;
   HEAP32[$0_1 >> 2] = 0;
   HEAP32[$0_1 + 4 >> 2] = 0;
   $0_1 = $1_1 + 16 | 0;
   HEAP32[$0_1 >> 2] = 0;
   HEAP32[$0_1 + 4 >> 2] = 0;
   $0_1 = $1_1 + 8 | 0;
   HEAP32[$0_1 >> 2] = 0;
   HEAP32[$0_1 + 4 >> 2] = 0;
   HEAP32[$1_1 >> 2] = 0;
   HEAP32[$1_1 + 4 >> 2] = 0;
   $0_1 = $57(HEAP32[172688], $1_1, 690820);
  }
  global$0 = $1_1 - -64 | 0;
  return ($0_1 | 0) == 1 | 0;
 }
 
 function $9($0_1, $1_1, $2_1) {
  $0_1 = $0_1 | 0;
  $1_1 = $1_1 | 0;
  $2_1 = $2_1 | 0;
  var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0;
  $5_1 = global$0 - 272 | 0;
  global$0 = $5_1;
  $3_1 = $5_1 + 200 | 0;
  $26_1 = $3_1 + 56 | 0;
  HEAP32[$26_1 >> 2] = 0;
  HEAP32[$26_1 + 4 >> 2] = 0;
  $9_1 = $3_1 + 48 | 0;
  HEAP32[$9_1 >> 2] = 0;
  HEAP32[$9_1 + 4 >> 2] = 0;
  $16_1 = $3_1 + 40 | 0;
  HEAP32[$16_1 >> 2] = 0;
  HEAP32[$16_1 + 4 >> 2] = 0;
  $18_1 = $3_1 + 32 | 0;
  HEAP32[$18_1 >> 2] = 0;
  HEAP32[$18_1 + 4 >> 2] = 0;
  $17_1 = $3_1 + 24 | 0;
  HEAP32[$17_1 >> 2] = 0;
  HEAP32[$17_1 + 4 >> 2] = 0;
  $19_1 = $3_1 + 16 | 0;
  HEAP32[$19_1 >> 2] = 0;
  HEAP32[$19_1 + 4 >> 2] = 0;
  $25_1 = $3_1 + 8 | 0;
  HEAP32[$25_1 >> 2] = 0;
  HEAP32[$25_1 + 4 >> 2] = 0;
  HEAP32[$5_1 + 200 >> 2] = 0;
  HEAP32[$5_1 + 204 >> 2] = 0;
  label$1 : {
   label$2 : {
    if (($31(HEAP32[172688], $3_1, 690820, $0_1) | 0) == 1) {
     $20_1 = $5_1 + 200 | 0;
     $14_1 = $20_1 + 15 | 0;
     $3_1 = $14_1;
     $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
     $10_1 = $5_1 - -64 | 0;
     $22_1 = $10_1 + 8 | 0;
     HEAP32[$22_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
     HEAP32[$22_1 + 4 >> 2] = $0_1;
     $13_1 = $20_1 + 23 | 0;
     $3_1 = $13_1;
     $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
     $23_1 = $10_1 + 16 | 0;
     HEAP32[$23_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
     HEAP32[$23_1 + 4 >> 2] = $0_1;
     $11_1 = $20_1 + 31 | 0;
     $3_1 = $11_1;
     $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
     $24_1 = $10_1 + 24 | 0;
     HEAP32[$24_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
     HEAP32[$24_1 + 4 >> 2] = $0_1;
     $12_1 = $20_1 + 39 | 0;
     $3_1 = $12_1;
     $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
     $27_1 = $10_1 + 32 | 0;
     HEAP32[$27_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
     HEAP32[$27_1 + 4 >> 2] = $0_1;
     $6_1 = $20_1 + 47 | 0;
     $3_1 = $6_1;
     $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
     $4_1 = $10_1 + 40 | 0;
     HEAP32[$4_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
     HEAP32[$4_1 + 4 >> 2] = $0_1;
     $3_1 = $20_1 + 55 | 0;
     $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
     $7_1 = $10_1 + 48 | 0;
     HEAP32[$7_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
     HEAP32[$7_1 + 4 >> 2] = $0_1;
     $8_1 = $10_1 + 56 | 0;
     $10_1 = $20_1 + 63 | 0;
     HEAP8[$8_1 | 0] = HEAPU8[$10_1 | 0];
     HEAP8[$5_1 + 2 | 0] = HEAPU8[$5_1 + 202 | 0];
     HEAP16[$5_1 >> 1] = HEAPU16[$5_1 + 200 >> 1];
     $0_1 = HEAPU8[$5_1 + 211 | 0] | HEAPU8[$5_1 + 212 | 0] << 8 | (HEAPU8[$5_1 + 213 | 0] << 16 | HEAPU8[$5_1 + 214 | 0] << 24);
     HEAP32[$5_1 + 64 >> 2] = HEAPU8[$5_1 + 207 | 0] | HEAPU8[$5_1 + 208 | 0] << 8 | (HEAPU8[$5_1 + 209 | 0] << 16 | HEAPU8[$5_1 + 210 | 0] << 24);
     HEAP32[$5_1 + 68 >> 2] = $0_1;
     $0_1 = HEAPU8[$5_1 + 203 | 0] | HEAPU8[$5_1 + 204 | 0] << 8 | (HEAPU8[$5_1 + 205 | 0] << 16 | HEAPU8[$5_1 + 206 | 0] << 24);
     HEAP8[$5_1 + 63 | 0] = HEAPU8[$8_1 | 0];
     $15_1 = HEAP32[$7_1 + 4 >> 2];
     $21_1 = $5_1 + 55 | 0;
     $8_1 = HEAP32[$7_1 >> 2];
     HEAP8[$21_1 | 0] = $8_1;
     HEAP8[$21_1 + 1 | 0] = $8_1 >>> 8;
     HEAP8[$21_1 + 2 | 0] = $8_1 >>> 16;
     HEAP8[$21_1 + 3 | 0] = $8_1 >>> 24;
     HEAP8[$21_1 + 4 | 0] = $15_1;
     HEAP8[$21_1 + 5 | 0] = $15_1 >>> 8;
     HEAP8[$21_1 + 6 | 0] = $15_1 >>> 16;
     HEAP8[$21_1 + 7 | 0] = $15_1 >>> 24;
     $7_1 = HEAP32[$4_1 + 4 >> 2];
     $15_1 = $5_1 + 47 | 0;
     $8_1 = HEAP32[$4_1 >> 2];
     HEAP8[$15_1 | 0] = $8_1;
     HEAP8[$15_1 + 1 | 0] = $8_1 >>> 8;
     HEAP8[$15_1 + 2 | 0] = $8_1 >>> 16;
     HEAP8[$15_1 + 3 | 0] = $8_1 >>> 24;
     HEAP8[$15_1 + 4 | 0] = $7_1;
     HEAP8[$15_1 + 5 | 0] = $7_1 >>> 8;
     HEAP8[$15_1 + 6 | 0] = $7_1 >>> 16;
     HEAP8[$15_1 + 7 | 0] = $7_1 >>> 24;
     $7_1 = HEAP32[$27_1 + 4 >> 2];
     $4_1 = $5_1 + 39 | 0;
     $8_1 = HEAP32[$27_1 >> 2];
     HEAP8[$4_1 | 0] = $8_1;
     HEAP8[$4_1 + 1 | 0] = $8_1 >>> 8;
     HEAP8[$4_1 + 2 | 0] = $8_1 >>> 16;
     HEAP8[$4_1 + 3 | 0] = $8_1 >>> 24;
     HEAP8[$4_1 + 4 | 0] = $7_1;
     HEAP8[$4_1 + 5 | 0] = $7_1 >>> 8;
     HEAP8[$4_1 + 6 | 0] = $7_1 >>> 16;
     HEAP8[$4_1 + 7 | 0] = $7_1 >>> 24;
     $7_1 = HEAP32[$24_1 + 4 >> 2];
     $4_1 = $5_1 + 31 | 0;
     $8_1 = HEAP32[$24_1 >> 2];
     HEAP8[$4_1 | 0] = $8_1;
     HEAP8[$4_1 + 1 | 0] = $8_1 >>> 8;
     HEAP8[$4_1 + 2 | 0] = $8_1 >>> 16;
     HEAP8[$4_1 + 3 | 0] = $8_1 >>> 24;
     HEAP8[$4_1 + 4 | 0] = $7_1;
     HEAP8[$4_1 + 5 | 0] = $7_1 >>> 8;
     HEAP8[$4_1 + 6 | 0] = $7_1 >>> 16;
     HEAP8[$4_1 + 7 | 0] = $7_1 >>> 24;
     $7_1 = HEAP32[$23_1 + 4 >> 2];
     $4_1 = $5_1 + 23 | 0;
     $8_1 = HEAP32[$23_1 >> 2];
     HEAP8[$4_1 | 0] = $8_1;
     HEAP8[$4_1 + 1 | 0] = $8_1 >>> 8;
     HEAP8[$4_1 + 2 | 0] = $8_1 >>> 16;
     HEAP8[$4_1 + 3 | 0] = $8_1 >>> 24;
     HEAP8[$4_1 + 4 | 0] = $7_1;
     HEAP8[$4_1 + 5 | 0] = $7_1 >>> 8;
     HEAP8[$4_1 + 6 | 0] = $7_1 >>> 16;
     HEAP8[$4_1 + 7 | 0] = $7_1 >>> 24;
     $7_1 = HEAP32[$22_1 + 4 >> 2];
     $4_1 = $5_1 + 15 | 0;
     $8_1 = HEAP32[$22_1 >> 2];
     HEAP8[$4_1 | 0] = $8_1;
     HEAP8[$4_1 + 1 | 0] = $8_1 >>> 8;
     HEAP8[$4_1 + 2 | 0] = $8_1 >>> 16;
     HEAP8[$4_1 + 3 | 0] = $8_1 >>> 24;
     HEAP8[$4_1 + 4 | 0] = $7_1;
     HEAP8[$4_1 + 5 | 0] = $7_1 >>> 8;
     HEAP8[$4_1 + 6 | 0] = $7_1 >>> 16;
     HEAP8[$4_1 + 7 | 0] = $7_1 >>> 24;
     HEAP8[$5_1 + 3 | 0] = $0_1;
     HEAP8[$5_1 + 4 | 0] = $0_1 >>> 8;
     HEAP8[$5_1 + 5 | 0] = $0_1 >>> 16;
     HEAP8[$5_1 + 6 | 0] = $0_1 >>> 24;
     $8_1 = HEAP32[$5_1 + 68 >> 2];
     $0_1 = HEAP32[$5_1 + 64 >> 2];
     HEAP8[$5_1 + 7 | 0] = $0_1;
     HEAP8[$5_1 + 8 | 0] = $0_1 >>> 8;
     HEAP8[$5_1 + 9 | 0] = $0_1 >>> 16;
     HEAP8[$5_1 + 10 | 0] = $0_1 >>> 24;
     HEAP8[$5_1 + 11 | 0] = $8_1;
     HEAP8[$5_1 + 12 | 0] = $8_1 >>> 8;
     HEAP8[$5_1 + 13 | 0] = $8_1 >>> 16;
     HEAP8[$5_1 + 14 | 0] = $8_1 >>> 24;
     HEAP32[$26_1 >> 2] = 0;
     HEAP32[$26_1 + 4 >> 2] = 0;
     HEAP32[$9_1 >> 2] = 0;
     HEAP32[$9_1 + 4 >> 2] = 0;
     HEAP32[$16_1 >> 2] = 0;
     HEAP32[$16_1 + 4 >> 2] = 0;
     HEAP32[$18_1 >> 2] = 0;
     HEAP32[$18_1 + 4 >> 2] = 0;
     HEAP32[$17_1 >> 2] = 0;
     HEAP32[$17_1 + 4 >> 2] = 0;
     HEAP32[$19_1 >> 2] = 0;
     HEAP32[$19_1 + 4 >> 2] = 0;
     HEAP32[$25_1 >> 2] = 0;
     HEAP32[$25_1 + 4 >> 2] = 0;
     HEAP32[$5_1 + 200 >> 2] = 0;
     HEAP32[$5_1 + 204 >> 2] = 0;
     $15_1 = 0;
     if (($31(HEAP32[172688], $20_1, 655584, $1_1) | 0) == 1) {
      $0_1 = HEAPU8[$14_1 + 4 | 0] | HEAPU8[$14_1 + 5 | 0] << 8 | (HEAPU8[$14_1 + 6 | 0] << 16 | HEAPU8[$14_1 + 7 | 0] << 24);
      $1_1 = $5_1 + 128 | 0;
      $8_1 = $1_1 + 8 | 0;
      HEAP32[$8_1 >> 2] = HEAPU8[$14_1 | 0] | HEAPU8[$14_1 + 1 | 0] << 8 | (HEAPU8[$14_1 + 2 | 0] << 16 | HEAPU8[$14_1 + 3 | 0] << 24);
      HEAP32[$8_1 + 4 >> 2] = $0_1;
      $0_1 = HEAPU8[$13_1 + 4 | 0] | HEAPU8[$13_1 + 5 | 0] << 8 | (HEAPU8[$13_1 + 6 | 0] << 16 | HEAPU8[$13_1 + 7 | 0] << 24);
      $14_1 = $1_1 + 16 | 0;
      HEAP32[$14_1 >> 2] = HEAPU8[$13_1 | 0] | HEAPU8[$13_1 + 1 | 0] << 8 | (HEAPU8[$13_1 + 2 | 0] << 16 | HEAPU8[$13_1 + 3 | 0] << 24);
      HEAP32[$14_1 + 4 >> 2] = $0_1;
      $0_1 = HEAPU8[$11_1 + 4 | 0] | HEAPU8[$11_1 + 5 | 0] << 8 | (HEAPU8[$11_1 + 6 | 0] << 16 | HEAPU8[$11_1 + 7 | 0] << 24);
      $13_1 = $1_1 + 24 | 0;
      HEAP32[$13_1 >> 2] = HEAPU8[$11_1 | 0] | HEAPU8[$11_1 + 1 | 0] << 8 | (HEAPU8[$11_1 + 2 | 0] << 16 | HEAPU8[$11_1 + 3 | 0] << 24);
      HEAP32[$13_1 + 4 >> 2] = $0_1;
      $0_1 = HEAPU8[$12_1 + 4 | 0] | HEAPU8[$12_1 + 5 | 0] << 8 | (HEAPU8[$12_1 + 6 | 0] << 16 | HEAPU8[$12_1 + 7 | 0] << 24);
      $11_1 = $1_1 + 32 | 0;
      HEAP32[$11_1 >> 2] = HEAPU8[$12_1 | 0] | HEAPU8[$12_1 + 1 | 0] << 8 | (HEAPU8[$12_1 + 2 | 0] << 16 | HEAPU8[$12_1 + 3 | 0] << 24);
      HEAP32[$11_1 + 4 >> 2] = $0_1;
      $0_1 = HEAPU8[$6_1 + 4 | 0] | HEAPU8[$6_1 + 5 | 0] << 8 | (HEAPU8[$6_1 + 6 | 0] << 16 | HEAPU8[$6_1 + 7 | 0] << 24);
      $12_1 = $1_1 + 40 | 0;
      HEAP32[$12_1 >> 2] = HEAPU8[$6_1 | 0] | HEAPU8[$6_1 + 1 | 0] << 8 | (HEAPU8[$6_1 + 2 | 0] << 16 | HEAPU8[$6_1 + 3 | 0] << 24);
      HEAP32[$12_1 + 4 >> 2] = $0_1;
      $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
      $6_1 = $1_1 + 48 | 0;
      HEAP32[$6_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
      HEAP32[$6_1 + 4 >> 2] = $0_1;
      $1_1 = $1_1 + 56 | 0;
      HEAP8[$1_1 | 0] = HEAPU8[$10_1 | 0];
      HEAP8[$5_1 + 66 | 0] = HEAPU8[$5_1 + 202 | 0];
      HEAP16[$5_1 + 64 >> 1] = HEAPU16[$5_1 + 200 >> 1];
      $0_1 = HEAPU8[$5_1 + 211 | 0] | HEAPU8[$5_1 + 212 | 0] << 8 | (HEAPU8[$5_1 + 213 | 0] << 16 | HEAPU8[$5_1 + 214 | 0] << 24);
      HEAP32[$5_1 + 128 >> 2] = HEAPU8[$5_1 + 207 | 0] | HEAPU8[$5_1 + 208 | 0] << 8 | (HEAPU8[$5_1 + 209 | 0] << 16 | HEAPU8[$5_1 + 210 | 0] << 24);
      HEAP32[$5_1 + 132 >> 2] = $0_1;
      $0_1 = HEAPU8[$5_1 + 203 | 0] | HEAPU8[$5_1 + 204 | 0] << 8 | (HEAPU8[$5_1 + 205 | 0] << 16 | HEAPU8[$5_1 + 206 | 0] << 24);
      $7_1 = $5_1 - -64 | 0;
      HEAP8[$7_1 + 63 | 0] = HEAPU8[$1_1 | 0];
      $3_1 = HEAP32[$6_1 + 4 >> 2];
      $10_1 = $7_1 + 55 | 0;
      $1_1 = HEAP32[$6_1 >> 2];
      HEAP8[$10_1 | 0] = $1_1;
      HEAP8[$10_1 + 1 | 0] = $1_1 >>> 8;
      HEAP8[$10_1 + 2 | 0] = $1_1 >>> 16;
      HEAP8[$10_1 + 3 | 0] = $1_1 >>> 24;
      HEAP8[$10_1 + 4 | 0] = $3_1;
      HEAP8[$10_1 + 5 | 0] = $3_1 >>> 8;
      HEAP8[$10_1 + 6 | 0] = $3_1 >>> 16;
      HEAP8[$10_1 + 7 | 0] = $3_1 >>> 24;
      $3_1 = HEAP32[$12_1 + 4 >> 2];
      $6_1 = $7_1 + 47 | 0;
      $1_1 = HEAP32[$12_1 >> 2];
      HEAP8[$6_1 | 0] = $1_1;
      HEAP8[$6_1 + 1 | 0] = $1_1 >>> 8;
      HEAP8[$6_1 + 2 | 0] = $1_1 >>> 16;
      HEAP8[$6_1 + 3 | 0] = $1_1 >>> 24;
      HEAP8[$6_1 + 4 | 0] = $3_1;
      HEAP8[$6_1 + 5 | 0] = $3_1 >>> 8;
      HEAP8[$6_1 + 6 | 0] = $3_1 >>> 16;
      HEAP8[$6_1 + 7 | 0] = $3_1 >>> 24;
      $3_1 = HEAP32[$11_1 + 4 >> 2];
      $6_1 = $7_1 + 39 | 0;
      $1_1 = HEAP32[$11_1 >> 2];
      HEAP8[$6_1 | 0] = $1_1;
      HEAP8[$6_1 + 1 | 0] = $1_1 >>> 8;
      HEAP8[$6_1 + 2 | 0] = $1_1 >>> 16;
      HEAP8[$6_1 + 3 | 0] = $1_1 >>> 24;
      HEAP8[$6_1 + 4 | 0] = $3_1;
      HEAP8[$6_1 + 5 | 0] = $3_1 >>> 8;
      HEAP8[$6_1 + 6 | 0] = $3_1 >>> 16;
      HEAP8[$6_1 + 7 | 0] = $3_1 >>> 24;
      $3_1 = HEAP32[$13_1 + 4 >> 2];
      $6_1 = $7_1 + 31 | 0;
      $1_1 = HEAP32[$13_1 >> 2];
      HEAP8[$6_1 | 0] = $1_1;
      HEAP8[$6_1 + 1 | 0] = $1_1 >>> 8;
      HEAP8[$6_1 + 2 | 0] = $1_1 >>> 16;
      HEAP8[$6_1 + 3 | 0] = $1_1 >>> 24;
      HEAP8[$6_1 + 4 | 0] = $3_1;
      HEAP8[$6_1 + 5 | 0] = $3_1 >>> 8;
      HEAP8[$6_1 + 6 | 0] = $3_1 >>> 16;
      HEAP8[$6_1 + 7 | 0] = $3_1 >>> 24;
      $3_1 = HEAP32[$14_1 + 4 >> 2];
      $6_1 = $7_1 + 23 | 0;
      $1_1 = HEAP32[$14_1 >> 2];
      HEAP8[$6_1 | 0] = $1_1;
      HEAP8[$6_1 + 1 | 0] = $1_1 >>> 8;
      HEAP8[$6_1 + 2 | 0] = $1_1 >>> 16;
      HEAP8[$6_1 + 3 | 0] = $1_1 >>> 24;
      HEAP8[$6_1 + 4 | 0] = $3_1;
      HEAP8[$6_1 + 5 | 0] = $3_1 >>> 8;
      HEAP8[$6_1 + 6 | 0] = $3_1 >>> 16;
      HEAP8[$6_1 + 7 | 0] = $3_1 >>> 24;
      $3_1 = HEAP32[$8_1 + 4 >> 2];
      $6_1 = $7_1 + 15 | 0;
      $1_1 = HEAP32[$8_1 >> 2];
      HEAP8[$6_1 | 0] = $1_1;
      HEAP8[$6_1 + 1 | 0] = $1_1 >>> 8;
      HEAP8[$6_1 + 2 | 0] = $1_1 >>> 16;
      HEAP8[$6_1 + 3 | 0] = $1_1 >>> 24;
      HEAP8[$6_1 + 4 | 0] = $3_1;
      HEAP8[$6_1 + 5 | 0] = $3_1 >>> 8;
      HEAP8[$6_1 + 6 | 0] = $3_1 >>> 16;
      HEAP8[$6_1 + 7 | 0] = $3_1 >>> 24;
      HEAP8[$5_1 + 67 | 0] = $0_1;
      HEAP8[$5_1 + 68 | 0] = $0_1 >>> 8;
      HEAP8[$5_1 + 69 | 0] = $0_1 >>> 16;
      HEAP8[$5_1 + 70 | 0] = $0_1 >>> 24;
      $1_1 = HEAP32[$5_1 + 132 >> 2];
      $0_1 = HEAP32[$5_1 + 128 >> 2];
      HEAP8[$5_1 + 71 | 0] = $0_1;
      HEAP8[$5_1 + 72 | 0] = $0_1 >>> 8;
      HEAP8[$5_1 + 73 | 0] = $0_1 >>> 16;
      HEAP8[$5_1 + 74 | 0] = $0_1 >>> 24;
      HEAP8[$5_1 + 75 | 0] = $1_1;
      HEAP8[$5_1 + 76 | 0] = $1_1 >>> 8;
      HEAP8[$5_1 + 77 | 0] = $1_1 >>> 16;
      HEAP8[$5_1 + 78 | 0] = $1_1 >>> 24;
      $9_1 = $5_1 + 200 | 0;
      $0_1 = $9_1 + 56 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $9_1 + 48 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $9_1 + 40 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $9_1 + 32 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $9_1 + 24 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $9_1 + 16 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $9_1 + 8 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      HEAP32[$5_1 + 200 >> 2] = 0;
      HEAP32[$5_1 + 204 >> 2] = 0;
      HEAP32[$5_1 + 196 >> 2] = $7_1;
      HEAP32[$5_1 + 192 >> 2] = $5_1;
      $16_1 = HEAP32[172688];
      $17_1 = $5_1 + 192 | 0;
      $19_1 = 2;
      $7_1 = global$0 - 224 | 0;
      global$0 = $7_1;
      label$5 : {
       if (!$9_1) {
        FUNCTION_TABLE[HEAP32[$16_1 + 168 >> 2]](689778, HEAP32[$16_1 + 172 >> 2]);
        $0_1 = 0;
        break label$5;
       }
       HEAP8[$9_1 | 0] = 0;
       HEAP8[$9_1 + 1 | 0] = 0;
       HEAP8[$9_1 + 2 | 0] = 0;
       HEAP8[$9_1 + 3 | 0] = 0;
       HEAP8[$9_1 + 4 | 0] = 0;
       HEAP8[$9_1 + 5 | 0] = 0;
       HEAP8[$9_1 + 6 | 0] = 0;
       HEAP8[$9_1 + 7 | 0] = 0;
       $0_1 = $9_1 + 56 | 0;
       HEAP8[$0_1 | 0] = 0;
       HEAP8[$0_1 + 1 | 0] = 0;
       HEAP8[$0_1 + 2 | 0] = 0;
       HEAP8[$0_1 + 3 | 0] = 0;
       HEAP8[$0_1 + 4 | 0] = 0;
       HEAP8[$0_1 + 5 | 0] = 0;
       HEAP8[$0_1 + 6 | 0] = 0;
       HEAP8[$0_1 + 7 | 0] = 0;
       $0_1 = $9_1 + 48 | 0;
       HEAP8[$0_1 | 0] = 0;
       HEAP8[$0_1 + 1 | 0] = 0;
       HEAP8[$0_1 + 2 | 0] = 0;
       HEAP8[$0_1 + 3 | 0] = 0;
       HEAP8[$0_1 + 4 | 0] = 0;
       HEAP8[$0_1 + 5 | 0] = 0;
       HEAP8[$0_1 + 6 | 0] = 0;
       HEAP8[$0_1 + 7 | 0] = 0;
       $0_1 = $9_1 + 40 | 0;
       HEAP8[$0_1 | 0] = 0;
       HEAP8[$0_1 + 1 | 0] = 0;
       HEAP8[$0_1 + 2 | 0] = 0;
       HEAP8[$0_1 + 3 | 0] = 0;
       HEAP8[$0_1 + 4 | 0] = 0;
       HEAP8[$0_1 + 5 | 0] = 0;
       HEAP8[$0_1 + 6 | 0] = 0;
       HEAP8[$0_1 + 7 | 0] = 0;
       $0_1 = $9_1 + 32 | 0;
       HEAP8[$0_1 | 0] = 0;
       HEAP8[$0_1 + 1 | 0] = 0;
       HEAP8[$0_1 + 2 | 0] = 0;
       HEAP8[$0_1 + 3 | 0] = 0;
       HEAP8[$0_1 + 4 | 0] = 0;
       HEAP8[$0_1 + 5 | 0] = 0;
       HEAP8[$0_1 + 6 | 0] = 0;
       HEAP8[$0_1 + 7 | 0] = 0;
       $0_1 = $9_1 + 24 | 0;
       HEAP8[$0_1 | 0] = 0;
       HEAP8[$0_1 + 1 | 0] = 0;
       HEAP8[$0_1 + 2 | 0] = 0;
       HEAP8[$0_1 + 3 | 0] = 0;
       HEAP8[$0_1 + 4 | 0] = 0;
       HEAP8[$0_1 + 5 | 0] = 0;
       HEAP8[$0_1 + 6 | 0] = 0;
       HEAP8[$0_1 + 7 | 0] = 0;
       $0_1 = $9_1 + 16 | 0;
       HEAP8[$0_1 | 0] = 0;
       HEAP8[$0_1 + 1 | 0] = 0;
       HEAP8[$0_1 + 2 | 0] = 0;
       HEAP8[$0_1 + 3 | 0] = 0;
       HEAP8[$0_1 + 4 | 0] = 0;
       HEAP8[$0_1 + 5 | 0] = 0;
       HEAP8[$0_1 + 6 | 0] = 0;
       HEAP8[$0_1 + 7 | 0] = 0;
       $0_1 = $9_1 + 8 | 0;
       HEAP8[$0_1 | 0] = 0;
       HEAP8[$0_1 + 1 | 0] = 0;
       HEAP8[$0_1 + 2 | 0] = 0;
       HEAP8[$0_1 + 3 | 0] = 0;
       HEAP8[$0_1 + 4 | 0] = 0;
       HEAP8[$0_1 + 5 | 0] = 0;
       HEAP8[$0_1 + 6 | 0] = 0;
       HEAP8[$0_1 + 7 | 0] = 0;
       if (!$17_1) {
        FUNCTION_TABLE[HEAP32[$16_1 + 168 >> 2]](689682, HEAP32[$16_1 + 172 >> 2]);
        $0_1 = 0;
        break label$5;
       }
       HEAP32[$7_1 + 216 >> 2] = 1;
       $68($7_1 + 96 | 0, 120);
       $25_1 = $16_1 + 172 | 0;
       while (1) {
        $4_1 = HEAP32[$17_1 >> 2];
        if (!$4_1) {
         FUNCTION_TABLE[HEAP32[$16_1 + 168 >> 2]](689809, HEAP32[$16_1 + 172 >> 2]);
         $0_1 = 0;
         break label$5;
        }
        HEAP32[$7_1 + 88 >> 2] = 0;
        $1_1 = HEAPU8[$4_1 + 60 | 0] | HEAPU8[$4_1 + 61 | 0] << 8 | (HEAPU8[$4_1 + 62 | 0] << 16 | HEAPU8[$4_1 + 63 | 0] << 24);
        $11_1 = $1_1 >>> 16 | 0;
        $0_1 = $7_1;
        $3_1 = HEAPU8[$4_1 + 56 | 0] | HEAPU8[$4_1 + 57 | 0] << 8 | (HEAPU8[$4_1 + 58 | 0] << 16 | HEAPU8[$4_1 + 59 | 0] << 24);
        HEAP32[$0_1 + 80 >> 2] = ($1_1 & 65535) << 16 | $3_1 >>> 16;
        HEAP32[$0_1 + 84 >> 2] = $11_1;
        $6_1 = HEAPU8[$4_1 + 36 | 0] | HEAPU8[$4_1 + 37 | 0] << 8 | (HEAPU8[$4_1 + 38 | 0] << 16 | HEAPU8[$4_1 + 39 | 0] << 24);
        HEAP32[$0_1 + 48 >> 2] = HEAPU8[$4_1 + 32 | 0] | HEAPU8[$4_1 + 33 | 0] << 8 | (HEAPU8[$4_1 + 34 | 0] << 16 | HEAPU8[$4_1 + 35 | 0] << 24);
        HEAP32[$0_1 + 52 >> 2] = $6_1 & 1048575;
        $11_1 = $3_1 << 4 & 1048560;
        $1_1 = HEAPU8[$4_1 + 52 | 0] | HEAPU8[$4_1 + 53 | 0] << 8 | (HEAPU8[$4_1 + 54 | 0] << 16 | HEAPU8[$4_1 + 55 | 0] << 24);
        $8_1 = $1_1 >>> 28 | 0;
        $3_1 = HEAPU8[$4_1 + 48 | 0] | HEAPU8[$4_1 + 49 | 0] << 8 | (HEAPU8[$4_1 + 50 | 0] << 16 | HEAPU8[$4_1 + 51 | 0] << 24);
        HEAP32[$0_1 + 72 >> 2] = ($1_1 & 268435455) << 4 | $3_1 >>> 28;
        HEAP32[$0_1 + 76 >> 2] = $8_1 | $11_1;
        $11_1 = $1_1 << 24 | $3_1 >>> 8;
        $13_1 = $3_1 << 24 & -16777216;
        $3_1 = HEAPU8[$4_1 + 40 | 0] | HEAPU8[$4_1 + 41 | 0] << 8 | (HEAPU8[$4_1 + 42 | 0] << 16 | HEAPU8[$4_1 + 43 | 0] << 24);
        $1_1 = HEAPU8[$4_1 + 44 | 0] | HEAPU8[$4_1 + 45 | 0] << 8 | (HEAPU8[$4_1 + 46 | 0] << 16 | HEAPU8[$4_1 + 47 | 0] << 24);
        HEAP32[$0_1 + 64 >> 2] = $1_1 >>> 8 | $13_1;
        HEAP32[$0_1 + 68 >> 2] = $11_1 & 1048575;
        $18_1 = $1_1 << 12 | $3_1 >>> 20;
        HEAP32[$0_1 + 56 >> 2] = $3_1 << 12 & -4096 | $6_1 >>> 20;
        HEAP32[$0_1 + 60 >> 2] = $18_1 & 1048575;
        $3_1 = HEAPU8[$4_1 + 12 | 0] | HEAPU8[$4_1 + 13 | 0] << 8 | (HEAPU8[$4_1 + 14 | 0] << 16 | HEAPU8[$4_1 + 15 | 0] << 24);
        $10_1 = $3_1;
        $1_1 = HEAPU8[$4_1 + 8 | 0] | HEAPU8[$4_1 + 9 | 0] << 8 | (HEAPU8[$4_1 + 10 | 0] << 16 | HEAPU8[$4_1 + 11 | 0] << 24);
        $18_1 = $3_1 << 12 | $1_1 >>> 20;
        $12_1 = $1_1 << 12 & -4096;
        $14_1 = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
        $1_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
        $3_1 = $1_1;
        $22_1 = $3_1 >>> 20 | $12_1;
        HEAP32[$0_1 + 16 >> 2] = $22_1;
        $23_1 = $18_1 & 1048575;
        HEAP32[$0_1 + 20 >> 2] = $23_1;
        HEAP32[$0_1 + 8 >> 2] = $14_1;
        $24_1 = $3_1 & 1048575;
        HEAP32[$0_1 + 12 >> 2] = $24_1;
        $1_1 = HEAPU8[$4_1 + 24 | 0] | HEAPU8[$4_1 + 25 | 0] << 8 | (HEAPU8[$4_1 + 26 | 0] << 16 | HEAPU8[$4_1 + 27 | 0] << 24);
        $13_1 = $1_1;
        $3_1 = HEAPU8[$4_1 + 28 | 0] | HEAPU8[$4_1 + 29 | 0] << 8 | (HEAPU8[$4_1 + 30 | 0] << 16 | HEAPU8[$4_1 + 31 | 0] << 24);
        $6_1 = ($3_1 & 65535) << 16 | $1_1 >>> 16;
        HEAP32[$0_1 + 40 >> 2] = $6_1;
        $12_1 = $3_1 >>> 16 | 0;
        HEAP32[$0_1 + 44 >> 2] = $12_1;
        $1_1 = HEAPU8[$4_1 + 16 | 0] | HEAPU8[$4_1 + 17 | 0] << 8 | (HEAPU8[$4_1 + 18 | 0] << 16 | HEAPU8[$4_1 + 19 | 0] << 24);
        $3_1 = HEAPU8[$4_1 + 20 | 0] | HEAPU8[$4_1 + 21 | 0] << 8 | (HEAPU8[$4_1 + 22 | 0] << 16 | HEAPU8[$4_1 + 23 | 0] << 24);
        $8_1 = $3_1 << 24 | $1_1 >>> 8;
        $4_1 = $1_1 << 24 & -16777216 | $10_1 >>> 8;
        HEAP32[$0_1 + 24 >> 2] = $4_1;
        $10_1 = $8_1 & 1048575;
        HEAP32[$0_1 + 28 >> 2] = $10_1;
        $11_1 = $13_1 << 4 & 1048560;
        $1_1 = ($3_1 & 268435455) << 4 | $1_1 >>> 28;
        HEAP32[$0_1 + 32 >> 2] = $1_1;
        $0_1 = $3_1 >>> 28 | $11_1;
        HEAP32[$7_1 + 36 >> 2] = $0_1;
        if (!($14_1 | $22_1 | $6_1 | $4_1 | $1_1 | ($23_1 | $24_1 | $12_1 | $10_1 | $0_1))) {
         FUNCTION_TABLE[HEAP32[$16_1 + 168 >> 2]](690116, HEAP32[$25_1 >> 2])
        }
        $17_1 = $17_1 + 4 | 0;
        $0_1 = $7_1 + 96 | 0;
        $53($0_1, $0_1, $7_1 + 8 | 0);
        $19_1 = $19_1 - 1 | 0;
        if ($19_1) {
         continue
        }
        break;
       };
       $0_1 = 0;
       if (HEAP32[$7_1 + 216 >> 2]) {
        break label$5
       }
       $0_1 = $7_1 + 8 | 0;
       $49($0_1, $7_1 + 96 | 0);
       $35($9_1, $0_1);
       $0_1 = 1;
      }
      global$0 = $7_1 + 224 | 0;
      if (!$0_1) {
       break label$1
      }
      HEAP32[$5_1 + 264 >> 2] = $2_1;
      $0_1 = $36(HEAP32[172688], $5_1 + 264 | 0, $5_1 + 200 | 0, ($2_1 | 0) == 33 ? 258 : 2);
      HEAP32[$5_1 + 268 >> 2] = $0_1;
      if (($0_1 | 0) != 1) {
       break label$2
      }
      $15_1 = 1;
      break label$1;
     }
     fimport$1(1);
     break label$1;
    }
    fimport$1(1);
    break label$1;
   }
   HEAP32[$5_1 + 136 >> 2] = 0;
   $5($5_1 + 128 | 0);
   wasm2js_trap();
  }
  global$0 = $5_1 + 272 | 0;
  return $15_1 | 0;
 }
 
 function $10($0_1, $1_1) {
  $0_1 = $0_1 | 0;
  $1_1 = $1_1 | 0;
  var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0;
  $6_1 = global$0 - 208 | 0;
  global$0 = $6_1;
  $2_1 = $6_1 + 136 | 0;
  $3_1 = $2_1 + 56 | 0;
  HEAP32[$3_1 >> 2] = 0;
  HEAP32[$3_1 + 4 >> 2] = 0;
  $3_1 = $2_1 + 48 | 0;
  HEAP32[$3_1 >> 2] = 0;
  HEAP32[$3_1 + 4 >> 2] = 0;
  $3_1 = $2_1 + 40 | 0;
  HEAP32[$3_1 >> 2] = 0;
  HEAP32[$3_1 + 4 >> 2] = 0;
  $3_1 = $2_1 + 32 | 0;
  HEAP32[$3_1 >> 2] = 0;
  HEAP32[$3_1 + 4 >> 2] = 0;
  $3_1 = $2_1 + 24 | 0;
  HEAP32[$3_1 >> 2] = 0;
  HEAP32[$3_1 + 4 >> 2] = 0;
  $3_1 = $2_1 + 16 | 0;
  HEAP32[$3_1 >> 2] = 0;
  HEAP32[$3_1 + 4 >> 2] = 0;
  $3_1 = $2_1 + 8 | 0;
  HEAP32[$3_1 >> 2] = 0;
  HEAP32[$3_1 + 4 >> 2] = 0;
  HEAP32[$6_1 + 136 >> 2] = 0;
  HEAP32[$6_1 + 140 >> 2] = 0;
  label$1 : {
   if (($31(HEAP32[172688], $2_1, 690820, $0_1) | 0) == 1) {
    $9_1 = $6_1 + 136 | 0;
    $2_1 = $9_1 + 15 | 0;
    $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $3_1 = $6_1 + 72 | 0;
    $13_1 = $3_1 + 8 | 0;
    HEAP32[$13_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP32[$13_1 + 4 >> 2] = $0_1;
    $2_1 = $9_1 + 23 | 0;
    $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $11_1 = $3_1 + 16 | 0;
    HEAP32[$11_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP32[$11_1 + 4 >> 2] = $0_1;
    $2_1 = $9_1 + 31 | 0;
    $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $12_1 = $3_1 + 24 | 0;
    HEAP32[$12_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP32[$12_1 + 4 >> 2] = $0_1;
    $2_1 = $9_1 + 39 | 0;
    $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $10_1 = $3_1 + 32 | 0;
    HEAP32[$10_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP32[$10_1 + 4 >> 2] = $0_1;
    $2_1 = $9_1 + 47 | 0;
    $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $7_1 = $3_1 + 40 | 0;
    HEAP32[$7_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP32[$7_1 + 4 >> 2] = $0_1;
    $8_1 = $9_1 + 55 | 0;
    $0_1 = HEAPU8[$8_1 + 4 | 0] | HEAPU8[$8_1 + 5 | 0] << 8 | (HEAPU8[$8_1 + 6 | 0] << 16 | HEAPU8[$8_1 + 7 | 0] << 24);
    $2_1 = $3_1 + 48 | 0;
    HEAP32[$2_1 >> 2] = HEAPU8[$8_1 | 0] | HEAPU8[$8_1 + 1 | 0] << 8 | (HEAPU8[$8_1 + 2 | 0] << 16 | HEAPU8[$8_1 + 3 | 0] << 24);
    HEAP32[$2_1 + 4 >> 2] = $0_1;
    $3_1 = $3_1 + 56 | 0;
    HEAP8[$3_1 | 0] = HEAPU8[$9_1 + 63 | 0];
    HEAP8[$6_1 + 10 | 0] = HEAPU8[$6_1 + 138 | 0];
    HEAP16[$6_1 + 8 >> 1] = HEAPU16[$6_1 + 136 >> 1];
    $0_1 = HEAPU8[$6_1 + 147 | 0] | HEAPU8[$6_1 + 148 | 0] << 8 | (HEAPU8[$6_1 + 149 | 0] << 16 | HEAPU8[$6_1 + 150 | 0] << 24);
    HEAP32[$6_1 + 72 >> 2] = HEAPU8[$6_1 + 143 | 0] | HEAPU8[$6_1 + 144 | 0] << 8 | (HEAPU8[$6_1 + 145 | 0] << 16 | HEAPU8[$6_1 + 146 | 0] << 24);
    HEAP32[$6_1 + 76 >> 2] = $0_1;
    $9_1 = HEAPU8[$6_1 + 139 | 0] | HEAPU8[$6_1 + 140 | 0] << 8 | (HEAPU8[$6_1 + 141 | 0] << 16 | HEAPU8[$6_1 + 142 | 0] << 24);
    $4_1 = $6_1 + 8 | 0;
    HEAP8[$4_1 + 63 | 0] = HEAPU8[$3_1 | 0];
    $3_1 = HEAP32[$2_1 + 4 >> 2];
    $8_1 = $4_1 + 55 | 0;
    $0_1 = HEAP32[$2_1 >> 2];
    HEAP8[$8_1 | 0] = $0_1;
    HEAP8[$8_1 + 1 | 0] = $0_1 >>> 8;
    HEAP8[$8_1 + 2 | 0] = $0_1 >>> 16;
    HEAP8[$8_1 + 3 | 0] = $0_1 >>> 24;
    HEAP8[$8_1 + 4 | 0] = $3_1;
    HEAP8[$8_1 + 5 | 0] = $3_1 >>> 8;
    HEAP8[$8_1 + 6 | 0] = $3_1 >>> 16;
    HEAP8[$8_1 + 7 | 0] = $3_1 >>> 24;
    $3_1 = HEAP32[$7_1 + 4 >> 2];
    $2_1 = $4_1 + 47 | 0;
    $0_1 = HEAP32[$7_1 >> 2];
    HEAP8[$2_1 | 0] = $0_1;
    HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
    HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
    HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
    HEAP8[$2_1 + 4 | 0] = $3_1;
    HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
    HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
    HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
    $3_1 = HEAP32[$10_1 + 4 >> 2];
    $2_1 = $4_1 + 39 | 0;
    $0_1 = HEAP32[$10_1 >> 2];
    HEAP8[$2_1 | 0] = $0_1;
    HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
    HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
    HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
    HEAP8[$2_1 + 4 | 0] = $3_1;
    HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
    HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
    HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
    $3_1 = HEAP32[$12_1 + 4 >> 2];
    $2_1 = $4_1 + 31 | 0;
    $0_1 = HEAP32[$12_1 >> 2];
    HEAP8[$2_1 | 0] = $0_1;
    HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
    HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
    HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
    HEAP8[$2_1 + 4 | 0] = $3_1;
    HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
    HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
    HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
    $3_1 = HEAP32[$11_1 + 4 >> 2];
    $2_1 = $4_1 + 23 | 0;
    $0_1 = HEAP32[$11_1 >> 2];
    HEAP8[$2_1 | 0] = $0_1;
    HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
    HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
    HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
    HEAP8[$2_1 + 4 | 0] = $3_1;
    HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
    HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
    HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
    $3_1 = HEAP32[$13_1 + 4 >> 2];
    $2_1 = $4_1 + 15 | 0;
    $0_1 = HEAP32[$13_1 >> 2];
    HEAP8[$2_1 | 0] = $0_1;
    HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
    HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
    HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
    HEAP8[$2_1 + 4 | 0] = $3_1;
    HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
    HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
    HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
    HEAP8[$6_1 + 11 | 0] = $9_1;
    HEAP8[$6_1 + 12 | 0] = $9_1 >>> 8;
    HEAP8[$6_1 + 13 | 0] = $9_1 >>> 16;
    HEAP8[$6_1 + 14 | 0] = $9_1 >>> 24;
    $3_1 = HEAP32[$6_1 + 76 >> 2];
    $0_1 = HEAP32[$6_1 + 72 >> 2];
    HEAP8[$6_1 + 15 | 0] = $0_1;
    HEAP8[$6_1 + 16 | 0] = $0_1 >>> 8;
    HEAP8[$6_1 + 17 | 0] = $0_1 >>> 16;
    HEAP8[$6_1 + 18 | 0] = $0_1 >>> 24;
    HEAP8[$6_1 + 19 | 0] = $3_1;
    HEAP8[$6_1 + 20 | 0] = $3_1 >>> 8;
    HEAP8[$6_1 + 21 | 0] = $3_1 >>> 16;
    HEAP8[$6_1 + 22 | 0] = $3_1 >>> 24;
    $14_1 = $6();
    $5_1 = global$0 - 288 | 0;
    global$0 = $5_1;
    label$3 : {
     if (!$4_1) {
      FUNCTION_TABLE[HEAP32[$14_1 + 168 >> 2]](689638, HEAP32[$14_1 + 172 >> 2]);
      break label$3;
     }
     $0_1 = HEAPU8[$4_1 + 60 | 0] | HEAPU8[$4_1 + 61 | 0] << 8 | (HEAPU8[$4_1 + 62 | 0] << 16 | HEAPU8[$4_1 + 63 | 0] << 24);
     $11_1 = $0_1 >>> 16 | 0;
     $7_1 = $5_1 + 72 | 0;
     $3_1 = HEAPU8[$4_1 + 56 | 0] | HEAPU8[$4_1 + 57 | 0] << 8 | (HEAPU8[$4_1 + 58 | 0] << 16 | HEAPU8[$4_1 + 59 | 0] << 24);
     HEAP32[$7_1 >> 2] = ($0_1 & 65535) << 16 | $3_1 >>> 16;
     HEAP32[$7_1 + 4 >> 2] = $11_1;
     $7_1 = $3_1 << 4 & 1048560;
     $0_1 = HEAPU8[$4_1 + 52 | 0] | HEAPU8[$4_1 + 53 | 0] << 8 | (HEAPU8[$4_1 + 54 | 0] << 16 | HEAPU8[$4_1 + 55 | 0] << 24);
     $8_1 = $0_1 >>> 28 | 0;
     $10_1 = $5_1 - -64 | 0;
     $3_1 = HEAPU8[$4_1 + 48 | 0] | HEAPU8[$4_1 + 49 | 0] << 8 | (HEAPU8[$4_1 + 50 | 0] << 16 | HEAPU8[$4_1 + 51 | 0] << 24);
     HEAP32[$10_1 >> 2] = ($0_1 & 268435455) << 4 | $3_1 >>> 28;
     HEAP32[$10_1 + 4 >> 2] = $7_1 | $8_1;
     $11_1 = $0_1 << 24 | $3_1 >>> 8;
     $10_1 = $3_1 << 24 & -16777216;
     $3_1 = HEAPU8[$4_1 + 40 | 0] | HEAPU8[$4_1 + 41 | 0] << 8 | (HEAPU8[$4_1 + 42 | 0] << 16 | HEAPU8[$4_1 + 43 | 0] << 24);
     $12_1 = $5_1 + 56 | 0;
     $0_1 = HEAPU8[$4_1 + 44 | 0] | HEAPU8[$4_1 + 45 | 0] << 8 | (HEAPU8[$4_1 + 46 | 0] << 16 | HEAPU8[$4_1 + 47 | 0] << 24);
     HEAP32[$12_1 >> 2] = $0_1 >>> 8 | $10_1;
     HEAP32[$12_1 + 4 >> 2] = $11_1 & 1048575;
     $11_1 = $0_1 << 12 | $3_1 >>> 20;
     $10_1 = $3_1 << 12 & -4096;
     $2_1 = HEAPU8[$4_1 + 32 | 0] | HEAPU8[$4_1 + 33 | 0] << 8 | (HEAPU8[$4_1 + 34 | 0] << 16 | HEAPU8[$4_1 + 35 | 0] << 24);
     $0_1 = HEAPU8[$4_1 + 36 | 0] | HEAPU8[$4_1 + 37 | 0] << 8 | (HEAPU8[$4_1 + 38 | 0] << 16 | HEAPU8[$4_1 + 39 | 0] << 24);
     $12_1 = $5_1 + 48 | 0;
     HEAP32[$12_1 >> 2] = $0_1 >>> 20 | $10_1;
     HEAP32[$12_1 + 4 >> 2] = $11_1 & 1048575;
     HEAP32[$5_1 + 80 >> 2] = 0;
     HEAP32[$5_1 + 40 >> 2] = $2_1;
     HEAP32[$5_1 + 44 >> 2] = $0_1 & 1048575;
     $2_1 = HEAPU8[$4_1 + 12 | 0] | HEAPU8[$4_1 + 13 | 0] << 8 | (HEAPU8[$4_1 + 14 | 0] << 16 | HEAPU8[$4_1 + 15 | 0] << 24);
     $9_1 = $2_1;
     $3_1 = HEAPU8[$4_1 + 8 | 0] | HEAPU8[$4_1 + 9 | 0] << 8 | (HEAPU8[$4_1 + 10 | 0] << 16 | HEAPU8[$4_1 + 11 | 0] << 24);
     $11_1 = $2_1 << 12 | $3_1 >>> 20;
     $10_1 = $3_1 << 12 & -4096;
     $13_1 = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
     $3_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
     $2_1 = $3_1;
     $0_1 = $5_1;
     $15_1 = $2_1 >>> 20 | $10_1;
     HEAP32[$0_1 + 8 >> 2] = $15_1;
     $16_1 = $11_1 & 1048575;
     HEAP32[$0_1 + 12 >> 2] = $16_1;
     HEAP32[$0_1 >> 2] = $13_1;
     $17_1 = $2_1 & 1048575;
     HEAP32[$0_1 + 4 >> 2] = $17_1;
     $3_1 = HEAPU8[$4_1 + 24 | 0] | HEAPU8[$4_1 + 25 | 0] << 8 | (HEAPU8[$4_1 + 26 | 0] << 16 | HEAPU8[$4_1 + 27 | 0] << 24);
     $11_1 = $3_1;
     $2_1 = HEAPU8[$4_1 + 28 | 0] | HEAPU8[$4_1 + 29 | 0] << 8 | (HEAPU8[$4_1 + 30 | 0] << 16 | HEAPU8[$4_1 + 31 | 0] << 24);
     $7_1 = ($2_1 & 65535) << 16 | $3_1 >>> 16;
     HEAP32[$0_1 + 32 >> 2] = $7_1;
     $10_1 = $2_1 >>> 16 | 0;
     HEAP32[$0_1 + 36 >> 2] = $10_1;
     $3_1 = HEAPU8[$4_1 + 16 | 0] | HEAPU8[$4_1 + 17 | 0] << 8 | (HEAPU8[$4_1 + 18 | 0] << 16 | HEAPU8[$4_1 + 19 | 0] << 24);
     $2_1 = HEAPU8[$4_1 + 20 | 0] | HEAPU8[$4_1 + 21 | 0] << 8 | (HEAPU8[$4_1 + 22 | 0] << 16 | HEAPU8[$4_1 + 23 | 0] << 24);
     $8_1 = $2_1 << 24 | $3_1 >>> 8;
     $18_1 = $3_1 << 24 & -16777216 | $9_1 >>> 8;
     HEAP32[$0_1 + 16 >> 2] = $18_1;
     $9_1 = $8_1 & 1048575;
     HEAP32[$0_1 + 20 >> 2] = $9_1;
     $12_1 = $11_1 << 4 & 1048560;
     $3_1 = ($2_1 & 268435455) << 4 | $3_1 >>> 28;
     HEAP32[$0_1 + 24 >> 2] = $3_1;
     $0_1 = $2_1 >>> 28 | $12_1;
     HEAP32[$5_1 + 28 >> 2] = $0_1;
     if (!($13_1 | $15_1 | $7_1 | $18_1 | $3_1 | ($16_1 | $17_1 | $10_1 | $9_1 | $0_1))) {
      FUNCTION_TABLE[HEAP32[$14_1 + 168 >> 2]](690116, HEAP32[$14_1 + 172 >> 2]);
      $0_1 = $4_1 + 56 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $4_1 + 48 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $4_1 + 40 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $4_1 + 32 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $4_1 + 24 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $4_1 + 16 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $4_1 + 8 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      HEAP8[$4_1 | 0] = 0;
      HEAP8[$4_1 + 1 | 0] = 0;
      HEAP8[$4_1 + 2 | 0] = 0;
      HEAP8[$4_1 + 3 | 0] = 0;
      HEAP8[$4_1 + 4 | 0] = 0;
      HEAP8[$4_1 + 5 | 0] = 0;
      HEAP8[$4_1 + 6 | 0] = 0;
      HEAP8[$4_1 + 7 | 0] = 0;
      break label$3;
     }
     HEAP8[$4_1 | 0] = 0;
     HEAP8[$4_1 + 1 | 0] = 0;
     HEAP8[$4_1 + 2 | 0] = 0;
     HEAP8[$4_1 + 3 | 0] = 0;
     HEAP8[$4_1 + 4 | 0] = 0;
     HEAP8[$4_1 + 5 | 0] = 0;
     HEAP8[$4_1 + 6 | 0] = 0;
     HEAP8[$4_1 + 7 | 0] = 0;
     $0_1 = $4_1 + 56 | 0;
     HEAP8[$0_1 | 0] = 0;
     HEAP8[$0_1 + 1 | 0] = 0;
     HEAP8[$0_1 + 2 | 0] = 0;
     HEAP8[$0_1 + 3 | 0] = 0;
     HEAP8[$0_1 + 4 | 0] = 0;
     HEAP8[$0_1 + 5 | 0] = 0;
     HEAP8[$0_1 + 6 | 0] = 0;
     HEAP8[$0_1 + 7 | 0] = 0;
     $0_1 = $4_1 + 48 | 0;
     HEAP8[$0_1 | 0] = 0;
     HEAP8[$0_1 + 1 | 0] = 0;
     HEAP8[$0_1 + 2 | 0] = 0;
     HEAP8[$0_1 + 3 | 0] = 0;
     HEAP8[$0_1 + 4 | 0] = 0;
     HEAP8[$0_1 + 5 | 0] = 0;
     HEAP8[$0_1 + 6 | 0] = 0;
     HEAP8[$0_1 + 7 | 0] = 0;
     $0_1 = $4_1 + 40 | 0;
     HEAP8[$0_1 | 0] = 0;
     HEAP8[$0_1 + 1 | 0] = 0;
     HEAP8[$0_1 + 2 | 0] = 0;
     HEAP8[$0_1 + 3 | 0] = 0;
     HEAP8[$0_1 + 4 | 0] = 0;
     HEAP8[$0_1 + 5 | 0] = 0;
     HEAP8[$0_1 + 6 | 0] = 0;
     HEAP8[$0_1 + 7 | 0] = 0;
     $0_1 = $4_1 + 32 | 0;
     HEAP8[$0_1 | 0] = 0;
     HEAP8[$0_1 + 1 | 0] = 0;
     HEAP8[$0_1 + 2 | 0] = 0;
     HEAP8[$0_1 + 3 | 0] = 0;
     HEAP8[$0_1 + 4 | 0] = 0;
     HEAP8[$0_1 + 5 | 0] = 0;
     HEAP8[$0_1 + 6 | 0] = 0;
     HEAP8[$0_1 + 7 | 0] = 0;
     $0_1 = $4_1 + 24 | 0;
     HEAP8[$0_1 | 0] = 0;
     HEAP8[$0_1 + 1 | 0] = 0;
     HEAP8[$0_1 + 2 | 0] = 0;
     HEAP8[$0_1 + 3 | 0] = 0;
     HEAP8[$0_1 + 4 | 0] = 0;
     HEAP8[$0_1 + 5 | 0] = 0;
     HEAP8[$0_1 + 6 | 0] = 0;
     HEAP8[$0_1 + 7 | 0] = 0;
     $0_1 = $4_1 + 16 | 0;
     HEAP8[$0_1 | 0] = 0;
     HEAP8[$0_1 + 1 | 0] = 0;
     HEAP8[$0_1 + 2 | 0] = 0;
     HEAP8[$0_1 + 3 | 0] = 0;
     HEAP8[$0_1 + 4 | 0] = 0;
     HEAP8[$0_1 + 5 | 0] = 0;
     HEAP8[$0_1 + 6 | 0] = 0;
     HEAP8[$0_1 + 7 | 0] = 0;
     $0_1 = $4_1 + 8 | 0;
     HEAP8[$0_1 | 0] = 0;
     HEAP8[$0_1 + 1 | 0] = 0;
     HEAP8[$0_1 + 2 | 0] = 0;
     HEAP8[$0_1 + 3 | 0] = 0;
     HEAP8[$0_1 + 4 | 0] = 0;
     HEAP8[$0_1 + 5 | 0] = 0;
     HEAP8[$0_1 + 6 | 0] = 0;
     HEAP8[$0_1 + 7 | 0] = 0;
     HEAP32[$5_1 + 92 >> 2] = 0;
     $38($5_1 + 96 | 0, 690949, $5_1 + 92 | 0);
     if (HEAP32[$5_1 + 92 >> 2]) {
      break label$3
     }
     $2_1 = $5_1 + 8 | 0;
     $3_1 = HEAP32[$2_1 + 4 >> 2];
     $7_1 = $5_1 + 160 | 0;
     $0_1 = $7_1 + 8 | 0;
     HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
     HEAP32[$0_1 + 4 >> 2] = $3_1;
     $2_1 = $5_1 + 16 | 0;
     $3_1 = HEAP32[$2_1 + 4 >> 2];
     $0_1 = $7_1 + 16 | 0;
     HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
     HEAP32[$0_1 + 4 >> 2] = $3_1;
     $2_1 = $5_1 + 24 | 0;
     $3_1 = HEAP32[$2_1 + 4 >> 2];
     $0_1 = $7_1 + 24 | 0;
     HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
     HEAP32[$0_1 + 4 >> 2] = $3_1;
     $2_1 = $5_1 + 32 | 0;
     $3_1 = HEAP32[$2_1 + 4 >> 2];
     $0_1 = $7_1 + 32 | 0;
     HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
     HEAP32[$0_1 + 4 >> 2] = $3_1;
     $2_1 = $5_1 + 48 | 0;
     $3_1 = HEAP32[$2_1 + 4 >> 2];
     $0_1 = $7_1 + 48 | 0;
     HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
     HEAP32[$0_1 + 4 >> 2] = $3_1;
     $2_1 = $5_1 + 56 | 0;
     $3_1 = HEAP32[$2_1 + 4 >> 2];
     $0_1 = $7_1 + 56 | 0;
     HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
     HEAP32[$0_1 + 4 >> 2] = $3_1;
     $2_1 = $5_1 - -64 | 0;
     $3_1 = HEAP32[$2_1 + 4 >> 2];
     $0_1 = $7_1 - -64 | 0;
     HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
     HEAP32[$0_1 + 4 >> 2] = $3_1;
     $2_1 = $5_1 + 72 | 0;
     $3_1 = HEAP32[$2_1 + 4 >> 2];
     $0_1 = $7_1 + 72 | 0;
     HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
     HEAP32[$0_1 + 4 >> 2] = $3_1;
     HEAP32[$5_1 + 280 >> 2] = 0;
     $0_1 = HEAP32[$5_1 + 4 >> 2];
     HEAP32[$5_1 + 160 >> 2] = HEAP32[$5_1 >> 2];
     HEAP32[$5_1 + 164 >> 2] = $0_1;
     $0_1 = HEAP32[$5_1 + 44 >> 2];
     HEAP32[$5_1 + 200 >> 2] = HEAP32[$5_1 + 40 >> 2];
     HEAP32[$5_1 + 204 >> 2] = $0_1;
     $0_1 = $5_1 + 248 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     $0_1 = $5_1 + 256 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     $0_1 = $5_1 + 264 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     $0_1 = $5_1 + 272 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     $3_1 = $5_1 + 128 | 0;
     $0_1 = $3_1 + 16 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     $0_1 = $3_1 + 24 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     HEAP32[$5_1 + 240 >> 2] = 1;
     HEAP32[$5_1 + 244 >> 2] = 0;
     HEAP32[$5_1 + 136 >> 2] = 0;
     HEAP32[$5_1 + 140 >> 2] = 0;
     HEAP32[$5_1 + 128 >> 2] = 1;
     HEAP32[$5_1 + 132 >> 2] = 0;
     $42($7_1, $7_1, $3_1, $5_1 + 96 | 0);
     if (HEAP32[$5_1 + 280 >> 2]) {
      break label$3
     }
     $49($5_1, $5_1 + 160 | 0);
     $35($4_1, $5_1);
     $19_1 = 1;
    }
    global$0 = $5_1 + 288 | 0;
    if (!$19_1) {
     break label$1
    }
    HEAP32[$6_1 + 204 >> 2] = $1_1;
    $0_1 = $36(HEAP32[172688], $6_1 + 204 | 0, $6_1 + 8 | 0, ($1_1 | 0) == 33 ? 258 : 2);
    HEAP32[$6_1 + 72 >> 2] = $0_1;
    $20_1 = 1;
    if (($0_1 | 0) == 1) {
     break label$1
    }
    HEAP32[$6_1 + 144 >> 2] = 0;
    $5($6_1 + 136 | 0);
    wasm2js_trap();
   }
   fimport$1(1);
  }
  global$0 = $6_1 + 208 | 0;
  return $20_1 | 0;
 }
 
 function $11() {
  var $0_1 = 0, $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0;
  $6_1 = global$0 - 208 | 0;
  global$0 = $6_1;
  $2_1 = $6_1 + 136 | 0;
  $16_1 = $2_1 + 56 | 0;
  HEAP32[$16_1 >> 2] = 0;
  HEAP32[$16_1 + 4 >> 2] = 0;
  $17_1 = $2_1 + 48 | 0;
  HEAP32[$17_1 >> 2] = 0;
  HEAP32[$17_1 + 4 >> 2] = 0;
  $12_1 = $2_1 + 40 | 0;
  HEAP32[$12_1 >> 2] = 0;
  HEAP32[$12_1 + 4 >> 2] = 0;
  $18_1 = $2_1 + 32 | 0;
  HEAP32[$18_1 >> 2] = 0;
  HEAP32[$18_1 + 4 >> 2] = 0;
  $5_1 = $2_1 + 24 | 0;
  HEAP32[$5_1 >> 2] = 0;
  HEAP32[$5_1 + 4 >> 2] = 0;
  $15_1 = $2_1 + 16 | 0;
  HEAP32[$15_1 >> 2] = 0;
  HEAP32[$15_1 + 4 >> 2] = 0;
  $14_1 = $2_1 + 8 | 0;
  HEAP32[$14_1 >> 2] = 0;
  HEAP32[$14_1 + 4 >> 2] = 0;
  HEAP32[$6_1 + 136 >> 2] = 0;
  HEAP32[$6_1 + 140 >> 2] = 0;
  label$1 : {
   label$2 : {
    if (($57(HEAP32[172688], $2_1, 690885) | 0) == 1) {
     $8_1 = $6_1 + 136 | 0;
     $1_1 = $8_1 + 15 | 0;
     $0_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
     $2_1 = $6_1 + 72 | 0;
     $19_1 = $2_1 + 8 | 0;
     HEAP32[$19_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
     HEAP32[$19_1 + 4 >> 2] = $0_1;
     $1_1 = $8_1 + 23 | 0;
     $0_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
     $10_1 = $2_1 + 16 | 0;
     HEAP32[$10_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
     HEAP32[$10_1 + 4 >> 2] = $0_1;
     $1_1 = $8_1 + 31 | 0;
     $0_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
     $11_1 = $2_1 + 24 | 0;
     HEAP32[$11_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
     HEAP32[$11_1 + 4 >> 2] = $0_1;
     $1_1 = $8_1 + 39 | 0;
     $0_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
     $9_1 = $2_1 + 32 | 0;
     HEAP32[$9_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
     HEAP32[$9_1 + 4 >> 2] = $0_1;
     $1_1 = $8_1 + 47 | 0;
     $0_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
     $4_1 = $2_1 + 40 | 0;
     HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
     HEAP32[$4_1 + 4 >> 2] = $0_1;
     $7_1 = $8_1 + 55 | 0;
     $0_1 = HEAPU8[$7_1 + 4 | 0] | HEAPU8[$7_1 + 5 | 0] << 8 | (HEAPU8[$7_1 + 6 | 0] << 16 | HEAPU8[$7_1 + 7 | 0] << 24);
     $1_1 = $2_1 + 48 | 0;
     HEAP32[$1_1 >> 2] = HEAPU8[$7_1 | 0] | HEAPU8[$7_1 + 1 | 0] << 8 | (HEAPU8[$7_1 + 2 | 0] << 16 | HEAPU8[$7_1 + 3 | 0] << 24);
     HEAP32[$1_1 + 4 >> 2] = $0_1;
     $2_1 = $2_1 + 56 | 0;
     HEAP8[$2_1 | 0] = HEAPU8[$8_1 + 63 | 0];
     HEAP8[$6_1 + 10 | 0] = HEAPU8[$6_1 + 138 | 0];
     HEAP16[$6_1 + 8 >> 1] = HEAPU16[$6_1 + 136 >> 1];
     $0_1 = HEAPU8[$6_1 + 147 | 0] | HEAPU8[$6_1 + 148 | 0] << 8 | (HEAPU8[$6_1 + 149 | 0] << 16 | HEAPU8[$6_1 + 150 | 0] << 24);
     HEAP32[$6_1 + 72 >> 2] = HEAPU8[$6_1 + 143 | 0] | HEAPU8[$6_1 + 144 | 0] << 8 | (HEAPU8[$6_1 + 145 | 0] << 16 | HEAPU8[$6_1 + 146 | 0] << 24);
     HEAP32[$6_1 + 76 >> 2] = $0_1;
     $0_1 = HEAPU8[$6_1 + 139 | 0] | HEAPU8[$6_1 + 140 | 0] << 8 | (HEAPU8[$6_1 + 141 | 0] << 16 | HEAPU8[$6_1 + 142 | 0] << 24);
     $3_1 = $6_1 + 8 | 0;
     HEAP8[$3_1 + 63 | 0] = HEAPU8[$2_1 | 0];
     $7_1 = HEAP32[$1_1 + 4 >> 2];
     $13_1 = $3_1 + 55 | 0;
     $2_1 = HEAP32[$1_1 >> 2];
     HEAP8[$13_1 | 0] = $2_1;
     HEAP8[$13_1 + 1 | 0] = $2_1 >>> 8;
     HEAP8[$13_1 + 2 | 0] = $2_1 >>> 16;
     HEAP8[$13_1 + 3 | 0] = $2_1 >>> 24;
     HEAP8[$13_1 + 4 | 0] = $7_1;
     HEAP8[$13_1 + 5 | 0] = $7_1 >>> 8;
     HEAP8[$13_1 + 6 | 0] = $7_1 >>> 16;
     HEAP8[$13_1 + 7 | 0] = $7_1 >>> 24;
     $1_1 = HEAP32[$4_1 + 4 >> 2];
     $7_1 = $3_1 + 47 | 0;
     $2_1 = HEAP32[$4_1 >> 2];
     HEAP8[$7_1 | 0] = $2_1;
     HEAP8[$7_1 + 1 | 0] = $2_1 >>> 8;
     HEAP8[$7_1 + 2 | 0] = $2_1 >>> 16;
     HEAP8[$7_1 + 3 | 0] = $2_1 >>> 24;
     HEAP8[$7_1 + 4 | 0] = $1_1;
     HEAP8[$7_1 + 5 | 0] = $1_1 >>> 8;
     HEAP8[$7_1 + 6 | 0] = $1_1 >>> 16;
     HEAP8[$7_1 + 7 | 0] = $1_1 >>> 24;
     $1_1 = HEAP32[$9_1 + 4 >> 2];
     $4_1 = $3_1 + 39 | 0;
     $2_1 = HEAP32[$9_1 >> 2];
     HEAP8[$4_1 | 0] = $2_1;
     HEAP8[$4_1 + 1 | 0] = $2_1 >>> 8;
     HEAP8[$4_1 + 2 | 0] = $2_1 >>> 16;
     HEAP8[$4_1 + 3 | 0] = $2_1 >>> 24;
     HEAP8[$4_1 + 4 | 0] = $1_1;
     HEAP8[$4_1 + 5 | 0] = $1_1 >>> 8;
     HEAP8[$4_1 + 6 | 0] = $1_1 >>> 16;
     HEAP8[$4_1 + 7 | 0] = $1_1 >>> 24;
     $1_1 = HEAP32[$11_1 + 4 >> 2];
     $4_1 = $3_1 + 31 | 0;
     $2_1 = HEAP32[$11_1 >> 2];
     HEAP8[$4_1 | 0] = $2_1;
     HEAP8[$4_1 + 1 | 0] = $2_1 >>> 8;
     HEAP8[$4_1 + 2 | 0] = $2_1 >>> 16;
     HEAP8[$4_1 + 3 | 0] = $2_1 >>> 24;
     HEAP8[$4_1 + 4 | 0] = $1_1;
     HEAP8[$4_1 + 5 | 0] = $1_1 >>> 8;
     HEAP8[$4_1 + 6 | 0] = $1_1 >>> 16;
     HEAP8[$4_1 + 7 | 0] = $1_1 >>> 24;
     $1_1 = HEAP32[$10_1 + 4 >> 2];
     $4_1 = $3_1 + 23 | 0;
     $2_1 = HEAP32[$10_1 >> 2];
     HEAP8[$4_1 | 0] = $2_1;
     HEAP8[$4_1 + 1 | 0] = $2_1 >>> 8;
     HEAP8[$4_1 + 2 | 0] = $2_1 >>> 16;
     HEAP8[$4_1 + 3 | 0] = $2_1 >>> 24;
     HEAP8[$4_1 + 4 | 0] = $1_1;
     HEAP8[$4_1 + 5 | 0] = $1_1 >>> 8;
     HEAP8[$4_1 + 6 | 0] = $1_1 >>> 16;
     HEAP8[$4_1 + 7 | 0] = $1_1 >>> 24;
     $1_1 = HEAP32[$19_1 + 4 >> 2];
     $4_1 = $3_1 + 15 | 0;
     $2_1 = HEAP32[$19_1 >> 2];
     HEAP8[$4_1 | 0] = $2_1;
     HEAP8[$4_1 + 1 | 0] = $2_1 >>> 8;
     HEAP8[$4_1 + 2 | 0] = $2_1 >>> 16;
     HEAP8[$4_1 + 3 | 0] = $2_1 >>> 24;
     HEAP8[$4_1 + 4 | 0] = $1_1;
     HEAP8[$4_1 + 5 | 0] = $1_1 >>> 8;
     HEAP8[$4_1 + 6 | 0] = $1_1 >>> 16;
     HEAP8[$4_1 + 7 | 0] = $1_1 >>> 24;
     HEAP8[$6_1 + 11 | 0] = $0_1;
     HEAP8[$6_1 + 12 | 0] = $0_1 >>> 8;
     HEAP8[$6_1 + 13 | 0] = $0_1 >>> 16;
     HEAP8[$6_1 + 14 | 0] = $0_1 >>> 24;
     $2_1 = HEAP32[$6_1 + 76 >> 2];
     $0_1 = HEAP32[$6_1 + 72 >> 2];
     HEAP8[$6_1 + 15 | 0] = $0_1;
     HEAP8[$6_1 + 16 | 0] = $0_1 >>> 8;
     HEAP8[$6_1 + 17 | 0] = $0_1 >>> 16;
     HEAP8[$6_1 + 18 | 0] = $0_1 >>> 24;
     HEAP8[$6_1 + 19 | 0] = $2_1;
     HEAP8[$6_1 + 20 | 0] = $2_1 >>> 8;
     HEAP8[$6_1 + 21 | 0] = $2_1 >>> 16;
     HEAP8[$6_1 + 22 | 0] = $2_1 >>> 24;
     HEAP32[$16_1 >> 2] = 0;
     HEAP32[$16_1 + 4 >> 2] = 0;
     HEAP32[$17_1 >> 2] = 0;
     HEAP32[$17_1 + 4 >> 2] = 0;
     HEAP32[$12_1 >> 2] = 0;
     HEAP32[$12_1 + 4 >> 2] = 0;
     HEAP32[$18_1 >> 2] = 0;
     HEAP32[$18_1 + 4 >> 2] = 0;
     HEAP32[$5_1 >> 2] = 0;
     HEAP32[$5_1 + 4 >> 2] = 0;
     HEAP32[$15_1 >> 2] = 0;
     HEAP32[$15_1 + 4 >> 2] = 0;
     HEAP32[$14_1 >> 2] = 0;
     HEAP32[$14_1 + 4 >> 2] = 0;
     HEAP32[$6_1 + 136 >> 2] = 0;
     HEAP32[$6_1 + 140 >> 2] = 0;
     $12_1 = $6();
     $13_1 = 0;
     $5_1 = global$0 - 288 | 0;
     global$0 = $5_1;
     label$4 : {
      if (!$8_1) {
       FUNCTION_TABLE[HEAP32[$12_1 + 168 >> 2]](689607, HEAP32[$12_1 + 172 >> 2]);
       break label$4;
      }
      HEAP8[$8_1 | 0] = 0;
      HEAP8[$8_1 + 1 | 0] = 0;
      HEAP8[$8_1 + 2 | 0] = 0;
      HEAP8[$8_1 + 3 | 0] = 0;
      HEAP8[$8_1 + 4 | 0] = 0;
      HEAP8[$8_1 + 5 | 0] = 0;
      HEAP8[$8_1 + 6 | 0] = 0;
      HEAP8[$8_1 + 7 | 0] = 0;
      $0_1 = $8_1 + 56 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $8_1 + 48 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $8_1 + 40 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $8_1 + 32 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $8_1 + 24 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $8_1 + 16 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $8_1 + 8 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      if (!$3_1) {
       FUNCTION_TABLE[HEAP32[$12_1 + 168 >> 2]](689629, HEAP32[$12_1 + 172 >> 2]);
       break label$4;
      }
      $0_1 = HEAPU8[$3_1 + 60 | 0] | HEAPU8[$3_1 + 61 | 0] << 8 | (HEAPU8[$3_1 + 62 | 0] << 16 | HEAPU8[$3_1 + 63 | 0] << 24);
      $10_1 = $0_1 >>> 16 | 0;
      $4_1 = $5_1 + 72 | 0;
      $2_1 = HEAPU8[$3_1 + 56 | 0] | HEAPU8[$3_1 + 57 | 0] << 8 | (HEAPU8[$3_1 + 58 | 0] << 16 | HEAPU8[$3_1 + 59 | 0] << 24);
      HEAP32[$4_1 >> 2] = ($0_1 & 65535) << 16 | $2_1 >>> 16;
      HEAP32[$4_1 + 4 >> 2] = $10_1;
      $4_1 = $2_1 << 4 & 1048560;
      $0_1 = HEAPU8[$3_1 + 52 | 0] | HEAPU8[$3_1 + 53 | 0] << 8 | (HEAPU8[$3_1 + 54 | 0] << 16 | HEAPU8[$3_1 + 55 | 0] << 24);
      $15_1 = $0_1 >>> 28 | 0;
      $9_1 = $5_1 - -64 | 0;
      $2_1 = HEAPU8[$3_1 + 48 | 0] | HEAPU8[$3_1 + 49 | 0] << 8 | (HEAPU8[$3_1 + 50 | 0] << 16 | HEAPU8[$3_1 + 51 | 0] << 24);
      HEAP32[$9_1 >> 2] = ($0_1 & 268435455) << 4 | $2_1 >>> 28;
      HEAP32[$9_1 + 4 >> 2] = $4_1 | $15_1;
      $10_1 = $0_1 << 24 | $2_1 >>> 8;
      $9_1 = $2_1 << 24 & -16777216;
      $2_1 = HEAPU8[$3_1 + 40 | 0] | HEAPU8[$3_1 + 41 | 0] << 8 | (HEAPU8[$3_1 + 42 | 0] << 16 | HEAPU8[$3_1 + 43 | 0] << 24);
      $11_1 = $5_1 + 56 | 0;
      $0_1 = HEAPU8[$3_1 + 44 | 0] | HEAPU8[$3_1 + 45 | 0] << 8 | (HEAPU8[$3_1 + 46 | 0] << 16 | HEAPU8[$3_1 + 47 | 0] << 24);
      HEAP32[$11_1 >> 2] = $0_1 >>> 8 | $9_1;
      HEAP32[$11_1 + 4 >> 2] = $10_1 & 1048575;
      $10_1 = $0_1 << 12 | $2_1 >>> 20;
      $9_1 = $2_1 << 12 & -4096;
      $1_1 = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
      $0_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
      $11_1 = $5_1 + 48 | 0;
      HEAP32[$11_1 >> 2] = $0_1 >>> 20 | $9_1;
      HEAP32[$11_1 + 4 >> 2] = $10_1 & 1048575;
      HEAP32[$5_1 + 80 >> 2] = 0;
      HEAP32[$5_1 + 40 >> 2] = $1_1;
      HEAP32[$5_1 + 44 >> 2] = $0_1 & 1048575;
      $1_1 = HEAPU8[$3_1 + 12 | 0] | HEAPU8[$3_1 + 13 | 0] << 8 | (HEAPU8[$3_1 + 14 | 0] << 16 | HEAPU8[$3_1 + 15 | 0] << 24);
      $14_1 = $1_1;
      $2_1 = HEAPU8[$3_1 + 8 | 0] | HEAPU8[$3_1 + 9 | 0] << 8 | (HEAPU8[$3_1 + 10 | 0] << 16 | HEAPU8[$3_1 + 11 | 0] << 24);
      $10_1 = $1_1 << 12 | $2_1 >>> 20;
      $9_1 = $2_1 << 12 & -4096;
      $19_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
      $2_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
      $1_1 = $2_1;
      $0_1 = $5_1;
      $7_1 = $1_1 >>> 20 | $9_1;
      HEAP32[$0_1 + 8 >> 2] = $7_1;
      $16_1 = $10_1 & 1048575;
      HEAP32[$0_1 + 12 >> 2] = $16_1;
      HEAP32[$0_1 >> 2] = $19_1;
      $17_1 = $1_1 & 1048575;
      HEAP32[$0_1 + 4 >> 2] = $17_1;
      $2_1 = HEAPU8[$3_1 + 24 | 0] | HEAPU8[$3_1 + 25 | 0] << 8 | (HEAPU8[$3_1 + 26 | 0] << 16 | HEAPU8[$3_1 + 27 | 0] << 24);
      $10_1 = $2_1;
      $1_1 = HEAPU8[$3_1 + 28 | 0] | HEAPU8[$3_1 + 29 | 0] << 8 | (HEAPU8[$3_1 + 30 | 0] << 16 | HEAPU8[$3_1 + 31 | 0] << 24);
      $4_1 = ($1_1 & 65535) << 16 | $2_1 >>> 16;
      HEAP32[$0_1 + 32 >> 2] = $4_1;
      $9_1 = $1_1 >>> 16 | 0;
      HEAP32[$0_1 + 36 >> 2] = $9_1;
      $2_1 = HEAPU8[$3_1 + 16 | 0] | HEAPU8[$3_1 + 17 | 0] << 8 | (HEAPU8[$3_1 + 18 | 0] << 16 | HEAPU8[$3_1 + 19 | 0] << 24);
      $1_1 = HEAPU8[$3_1 + 20 | 0] | HEAPU8[$3_1 + 21 | 0] << 8 | (HEAPU8[$3_1 + 22 | 0] << 16 | HEAPU8[$3_1 + 23 | 0] << 24);
      $15_1 = $1_1 << 24 | $2_1 >>> 8;
      $18_1 = $2_1 << 24 & -16777216 | $14_1 >>> 8;
      HEAP32[$0_1 + 16 >> 2] = $18_1;
      $14_1 = $15_1 & 1048575;
      HEAP32[$0_1 + 20 >> 2] = $14_1;
      $11_1 = $10_1 << 4 & 1048560;
      $2_1 = ($1_1 & 268435455) << 4 | $2_1 >>> 28;
      HEAP32[$0_1 + 24 >> 2] = $2_1;
      $0_1 = $1_1 >>> 28 | $11_1;
      HEAP32[$5_1 + 28 >> 2] = $0_1;
      if (!($7_1 | $19_1 | $4_1 | $18_1 | $2_1 | ($16_1 | $17_1 | $9_1 | $14_1 | $0_1))) {
       FUNCTION_TABLE[HEAP32[$12_1 + 168 >> 2]](690116, HEAP32[$12_1 + 172 >> 2]);
       break label$4;
      }
      HEAP32[$5_1 + 92 >> 2] = 0;
      $38($5_1 + 96 | 0, 690949, $5_1 + 92 | 0);
      if (HEAP32[$5_1 + 92 >> 2]) {
       break label$4
      }
      $1_1 = $5_1 + 8 | 0;
      $2_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $5_1 + 160 | 0;
      $0_1 = $4_1 + 8 | 0;
      HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$0_1 + 4 >> 2] = $2_1;
      $1_1 = $5_1 + 16 | 0;
      $2_1 = HEAP32[$1_1 + 4 >> 2];
      $0_1 = $4_1 + 16 | 0;
      HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$0_1 + 4 >> 2] = $2_1;
      $1_1 = $5_1 + 24 | 0;
      $2_1 = HEAP32[$1_1 + 4 >> 2];
      $0_1 = $4_1 + 24 | 0;
      HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$0_1 + 4 >> 2] = $2_1;
      $1_1 = $5_1 + 32 | 0;
      $2_1 = HEAP32[$1_1 + 4 >> 2];
      $0_1 = $4_1 + 32 | 0;
      HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$0_1 + 4 >> 2] = $2_1;
      $1_1 = $5_1 + 48 | 0;
      $2_1 = HEAP32[$1_1 + 4 >> 2];
      $0_1 = $4_1 + 48 | 0;
      HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$0_1 + 4 >> 2] = $2_1;
      $1_1 = $5_1 + 56 | 0;
      $2_1 = HEAP32[$1_1 + 4 >> 2];
      $0_1 = $4_1 + 56 | 0;
      HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$0_1 + 4 >> 2] = $2_1;
      $1_1 = $5_1 - -64 | 0;
      $2_1 = HEAP32[$1_1 + 4 >> 2];
      $0_1 = $4_1 - -64 | 0;
      HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$0_1 + 4 >> 2] = $2_1;
      $1_1 = $5_1 + 72 | 0;
      $2_1 = HEAP32[$1_1 + 4 >> 2];
      $0_1 = $4_1 + 72 | 0;
      HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$0_1 + 4 >> 2] = $2_1;
      HEAP32[$5_1 + 280 >> 2] = 0;
      $0_1 = HEAP32[$5_1 + 4 >> 2];
      HEAP32[$5_1 + 160 >> 2] = HEAP32[$5_1 >> 2];
      HEAP32[$5_1 + 164 >> 2] = $0_1;
      $0_1 = HEAP32[$5_1 + 44 >> 2];
      HEAP32[$5_1 + 200 >> 2] = HEAP32[$5_1 + 40 >> 2];
      HEAP32[$5_1 + 204 >> 2] = $0_1;
      $0_1 = $5_1 + 248 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $5_1 + 256 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $5_1 + 264 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $5_1 + 272 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $2_1 = $5_1 + 128 | 0;
      $0_1 = $2_1 + 16 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $2_1 + 24 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      HEAP32[$5_1 + 240 >> 2] = 1;
      HEAP32[$5_1 + 244 >> 2] = 0;
      HEAP32[$5_1 + 136 >> 2] = 0;
      HEAP32[$5_1 + 140 >> 2] = 0;
      HEAP32[$5_1 + 128 >> 2] = 1;
      HEAP32[$5_1 + 132 >> 2] = 0;
      $42($4_1, $4_1, $2_1, $5_1 + 96 | 0);
      if (HEAP32[$5_1 + 280 >> 2]) {
       break label$4
      }
      $49($5_1, $5_1 + 160 | 0);
      $35($8_1, $5_1);
      $13_1 = 1;
     }
     global$0 = $5_1 + 288 | 0;
     if ($13_1) {
      HEAP32[$6_1 + 132 >> 2] = 0;
      $0_1 = $59($6(), $6_1 + 8 | 0, $6_1 + 132 | 0, $6_1 + 136 | 0);
      HEAP32[$6_1 + 204 >> 2] = $0_1;
      if (($0_1 | 0) != 1) {
       break label$1
      }
      $0_1 = $58(HEAP32[172688], $6_1 + 8 | 0);
      HEAP32[$6_1 + 204 >> 2] = $0_1;
      if (($0_1 | 0) != 1) {
       break label$1
      }
      $0_1 = HEAP32[$6_1 + 132 >> 2];
      break label$2;
     }
     $0_1 = -1;
     break label$2;
    }
    fimport$1(1);
   }
   global$0 = $6_1 + 208 | 0;
   return $0_1 | 0;
  }
  HEAP32[$6_1 + 80 >> 2] = 0;
  $5($6_1 + 72 | 0);
  wasm2js_trap();
 }
 
 function $12($0_1) {
  $0_1 = $0_1 | 0;
  var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0;
  $3_1 = global$0 - 192 | 0;
  global$0 = $3_1;
  $2_1 = $3_1 + 128 | 0;
  $9_1 = $2_1 + 56 | 0;
  HEAP32[$9_1 >> 2] = 0;
  HEAP32[$9_1 + 4 >> 2] = 0;
  $10_1 = $2_1 + 48 | 0;
  HEAP32[$10_1 >> 2] = 0;
  HEAP32[$10_1 + 4 >> 2] = 0;
  $7_1 = $2_1 + 40 | 0;
  HEAP32[$7_1 >> 2] = 0;
  HEAP32[$7_1 + 4 >> 2] = 0;
  $13_1 = $2_1 + 32 | 0;
  HEAP32[$13_1 >> 2] = 0;
  HEAP32[$13_1 + 4 >> 2] = 0;
  $18_1 = $2_1 + 24 | 0;
  HEAP32[$18_1 >> 2] = 0;
  HEAP32[$18_1 + 4 >> 2] = 0;
  $19_1 = $2_1 + 16 | 0;
  HEAP32[$19_1 >> 2] = 0;
  HEAP32[$19_1 + 4 >> 2] = 0;
  $17_1 = $2_1 + 8 | 0;
  HEAP32[$17_1 >> 2] = 0;
  HEAP32[$17_1 + 4 >> 2] = 0;
  HEAP32[$3_1 + 128 >> 2] = 0;
  HEAP32[$3_1 + 132 >> 2] = 0;
  label$1 : {
   if (($57(HEAP32[172688], $2_1, 690885) | 0) == 1) {
    $2_1 = $3_1 + 128 | 0;
    $1_1 = $2_1 + 15 | 0;
    $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
    $5_1 = $3_1 - -64 | 0;
    $11_1 = $5_1 + 8 | 0;
    HEAP32[$11_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
    HEAP32[$11_1 + 4 >> 2] = $4_1;
    $1_1 = $2_1 + 23 | 0;
    $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
    $14_1 = $5_1 + 16 | 0;
    HEAP32[$14_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
    HEAP32[$14_1 + 4 >> 2] = $4_1;
    $1_1 = $2_1 + 31 | 0;
    $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
    $12_1 = $5_1 + 24 | 0;
    HEAP32[$12_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
    HEAP32[$12_1 + 4 >> 2] = $4_1;
    $1_1 = $2_1 + 39 | 0;
    $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
    $15_1 = $5_1 + 32 | 0;
    HEAP32[$15_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
    HEAP32[$15_1 + 4 >> 2] = $4_1;
    $1_1 = $2_1 + 47 | 0;
    $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
    $16_1 = $5_1 + 40 | 0;
    HEAP32[$16_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
    HEAP32[$16_1 + 4 >> 2] = $4_1;
    $1_1 = $2_1 + 55 | 0;
    $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
    $8_1 = $5_1 + 48 | 0;
    HEAP32[$8_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
    HEAP32[$8_1 + 4 >> 2] = $4_1;
    $1_1 = $5_1 + 56 | 0;
    HEAP8[$1_1 | 0] = HEAPU8[$2_1 + 63 | 0];
    HEAP8[$3_1 + 2 | 0] = HEAPU8[$3_1 + 130 | 0];
    HEAP16[$3_1 >> 1] = HEAPU16[$3_1 + 128 >> 1];
    $5_1 = HEAPU8[$3_1 + 139 | 0] | HEAPU8[$3_1 + 140 | 0] << 8 | (HEAPU8[$3_1 + 141 | 0] << 16 | HEAPU8[$3_1 + 142 | 0] << 24);
    HEAP32[$3_1 + 64 >> 2] = HEAPU8[$3_1 + 135 | 0] | HEAPU8[$3_1 + 136 | 0] << 8 | (HEAPU8[$3_1 + 137 | 0] << 16 | HEAPU8[$3_1 + 138 | 0] << 24);
    HEAP32[$3_1 + 68 >> 2] = $5_1;
    $5_1 = HEAPU8[$3_1 + 131 | 0] | HEAPU8[$3_1 + 132 | 0] << 8 | (HEAPU8[$3_1 + 133 | 0] << 16 | HEAPU8[$3_1 + 134 | 0] << 24);
    HEAP8[$3_1 + 63 | 0] = HEAPU8[$1_1 | 0];
    $4_1 = HEAP32[$8_1 + 4 >> 2];
    $1_1 = $3_1 + 55 | 0;
    $8_1 = HEAP32[$8_1 >> 2];
    HEAP8[$1_1 | 0] = $8_1;
    HEAP8[$1_1 + 1 | 0] = $8_1 >>> 8;
    HEAP8[$1_1 + 2 | 0] = $8_1 >>> 16;
    HEAP8[$1_1 + 3 | 0] = $8_1 >>> 24;
    HEAP8[$1_1 + 4 | 0] = $4_1;
    HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$16_1 + 4 >> 2];
    $1_1 = $3_1 + 47 | 0;
    $16_1 = HEAP32[$16_1 >> 2];
    HEAP8[$1_1 | 0] = $16_1;
    HEAP8[$1_1 + 1 | 0] = $16_1 >>> 8;
    HEAP8[$1_1 + 2 | 0] = $16_1 >>> 16;
    HEAP8[$1_1 + 3 | 0] = $16_1 >>> 24;
    HEAP8[$1_1 + 4 | 0] = $4_1;
    HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$15_1 + 4 >> 2];
    $1_1 = $3_1 + 39 | 0;
    $15_1 = HEAP32[$15_1 >> 2];
    HEAP8[$1_1 | 0] = $15_1;
    HEAP8[$1_1 + 1 | 0] = $15_1 >>> 8;
    HEAP8[$1_1 + 2 | 0] = $15_1 >>> 16;
    HEAP8[$1_1 + 3 | 0] = $15_1 >>> 24;
    HEAP8[$1_1 + 4 | 0] = $4_1;
    HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$12_1 + 4 >> 2];
    $1_1 = $3_1 + 31 | 0;
    $12_1 = HEAP32[$12_1 >> 2];
    HEAP8[$1_1 | 0] = $12_1;
    HEAP8[$1_1 + 1 | 0] = $12_1 >>> 8;
    HEAP8[$1_1 + 2 | 0] = $12_1 >>> 16;
    HEAP8[$1_1 + 3 | 0] = $12_1 >>> 24;
    HEAP8[$1_1 + 4 | 0] = $4_1;
    HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$14_1 + 4 >> 2];
    $1_1 = $3_1 + 23 | 0;
    $14_1 = HEAP32[$14_1 >> 2];
    HEAP8[$1_1 | 0] = $14_1;
    HEAP8[$1_1 + 1 | 0] = $14_1 >>> 8;
    HEAP8[$1_1 + 2 | 0] = $14_1 >>> 16;
    HEAP8[$1_1 + 3 | 0] = $14_1 >>> 24;
    HEAP8[$1_1 + 4 | 0] = $4_1;
    HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$11_1 + 4 >> 2];
    $1_1 = $3_1 + 15 | 0;
    $11_1 = HEAP32[$11_1 >> 2];
    HEAP8[$1_1 | 0] = $11_1;
    HEAP8[$1_1 + 1 | 0] = $11_1 >>> 8;
    HEAP8[$1_1 + 2 | 0] = $11_1 >>> 16;
    HEAP8[$1_1 + 3 | 0] = $11_1 >>> 24;
    HEAP8[$1_1 + 4 | 0] = $4_1;
    HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
    HEAP8[$3_1 + 3 | 0] = $5_1;
    HEAP8[$3_1 + 4 | 0] = $5_1 >>> 8;
    HEAP8[$3_1 + 5 | 0] = $5_1 >>> 16;
    HEAP8[$3_1 + 6 | 0] = $5_1 >>> 24;
    $1_1 = HEAP32[$3_1 + 68 >> 2];
    $5_1 = HEAP32[$3_1 + 64 >> 2];
    HEAP8[$3_1 + 7 | 0] = $5_1;
    HEAP8[$3_1 + 8 | 0] = $5_1 >>> 8;
    HEAP8[$3_1 + 9 | 0] = $5_1 >>> 16;
    HEAP8[$3_1 + 10 | 0] = $5_1 >>> 24;
    HEAP8[$3_1 + 11 | 0] = $1_1;
    HEAP8[$3_1 + 12 | 0] = $1_1 >>> 8;
    HEAP8[$3_1 + 13 | 0] = $1_1 >>> 16;
    HEAP8[$3_1 + 14 | 0] = $1_1 >>> 24;
    HEAP32[$9_1 >> 2] = 0;
    HEAP32[$9_1 + 4 >> 2] = 0;
    HEAP32[$10_1 >> 2] = 0;
    HEAP32[$10_1 + 4 >> 2] = 0;
    HEAP32[$7_1 >> 2] = 0;
    HEAP32[$7_1 + 4 >> 2] = 0;
    HEAP32[$13_1 >> 2] = 0;
    HEAP32[$13_1 + 4 >> 2] = 0;
    HEAP32[$18_1 >> 2] = 0;
    HEAP32[$18_1 + 4 >> 2] = 0;
    HEAP32[$19_1 >> 2] = 0;
    HEAP32[$19_1 + 4 >> 2] = 0;
    HEAP32[$17_1 >> 2] = 0;
    HEAP32[$17_1 + 4 >> 2] = 0;
    HEAP32[$3_1 + 128 >> 2] = 0;
    HEAP32[$3_1 + 132 >> 2] = 0;
    if (($57(HEAP32[172688], $2_1, 690917) | 0) == 1) {
     $17_1 = $6();
     $6_1 = global$0 - 288 | 0;
     global$0 = $6_1;
     label$4 : {
      if (!$3_1) {
       FUNCTION_TABLE[HEAP32[$17_1 + 168 >> 2]](689629, HEAP32[$17_1 + 172 >> 2]);
       break label$4;
      }
      $5_1 = HEAPU8[$3_1 + 60 | 0] | HEAPU8[$3_1 + 61 | 0] << 8 | (HEAPU8[$3_1 + 62 | 0] << 16 | HEAPU8[$3_1 + 63 | 0] << 24);
      $2_1 = $5_1 >>> 16 | 0;
      $4_1 = $6_1 + 72 | 0;
      $1_1 = HEAPU8[$3_1 + 56 | 0] | HEAPU8[$3_1 + 57 | 0] << 8 | (HEAPU8[$3_1 + 58 | 0] << 16 | HEAPU8[$3_1 + 59 | 0] << 24);
      HEAP32[$4_1 >> 2] = ($5_1 & 65535) << 16 | $1_1 >>> 16;
      HEAP32[$4_1 + 4 >> 2] = $2_1;
      $9_1 = $1_1 << 4 & 1048560;
      $5_1 = HEAPU8[$3_1 + 52 | 0] | HEAPU8[$3_1 + 53 | 0] << 8 | (HEAPU8[$3_1 + 54 | 0] << 16 | HEAPU8[$3_1 + 55 | 0] << 24);
      $2_1 = $5_1 >>> 28 | 0;
      $4_1 = $6_1 - -64 | 0;
      $1_1 = HEAPU8[$3_1 + 48 | 0] | HEAPU8[$3_1 + 49 | 0] << 8 | (HEAPU8[$3_1 + 50 | 0] << 16 | HEAPU8[$3_1 + 51 | 0] << 24);
      HEAP32[$4_1 >> 2] = ($5_1 & 268435455) << 4 | $1_1 >>> 28;
      HEAP32[$4_1 + 4 >> 2] = $2_1 | $9_1;
      $2_1 = $5_1 << 24 | $1_1 >>> 8;
      $9_1 = $1_1 << 24 & -16777216;
      $1_1 = HEAPU8[$3_1 + 40 | 0] | HEAPU8[$3_1 + 41 | 0] << 8 | (HEAPU8[$3_1 + 42 | 0] << 16 | HEAPU8[$3_1 + 43 | 0] << 24);
      $4_1 = $6_1 + 56 | 0;
      $5_1 = HEAPU8[$3_1 + 44 | 0] | HEAPU8[$3_1 + 45 | 0] << 8 | (HEAPU8[$3_1 + 46 | 0] << 16 | HEAPU8[$3_1 + 47 | 0] << 24);
      HEAP32[$4_1 >> 2] = $5_1 >>> 8 | $9_1;
      HEAP32[$4_1 + 4 >> 2] = $2_1 & 1048575;
      $5_1 = ($5_1 << 12 | $1_1 >>> 20) & 1048575;
      $9_1 = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
      $4_1 = $6_1 + 48 | 0;
      $10_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
      HEAP32[$4_1 >> 2] = $1_1 << 12 & -4096 | $10_1 >>> 20;
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      HEAP32[$6_1 + 40 >> 2] = $9_1;
      HEAP32[$6_1 + 44 >> 2] = $10_1 & 1048575;
      $2_1 = HEAPU8[$3_1 + 12 | 0] | HEAPU8[$3_1 + 13 | 0] << 8 | (HEAPU8[$3_1 + 14 | 0] << 16 | HEAPU8[$3_1 + 15 | 0] << 24);
      $4_1 = $2_1;
      $5_1 = HEAPU8[$3_1 + 8 | 0] | HEAPU8[$3_1 + 9 | 0] << 8 | (HEAPU8[$3_1 + 10 | 0] << 16 | HEAPU8[$3_1 + 11 | 0] << 24);
      $2_1 = $2_1 << 12 | $5_1 >>> 20;
      $9_1 = $5_1 << 12 & -4096;
      $5_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
      $1_1 = $6_1;
      $7_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
      $11_1 = $7_1 >>> 20 | $9_1;
      HEAP32[$1_1 + 8 >> 2] = $11_1;
      $14_1 = $2_1 & 1048575;
      HEAP32[$1_1 + 12 >> 2] = $14_1;
      $9_1 = $5_1;
      HEAP32[$1_1 >> 2] = $5_1;
      $12_1 = $7_1 & 1048575;
      HEAP32[$1_1 + 4 >> 2] = $12_1;
      $5_1 = HEAPU8[$3_1 + 28 | 0] | HEAPU8[$3_1 + 29 | 0] << 8 | (HEAPU8[$3_1 + 30 | 0] << 16 | HEAPU8[$3_1 + 31 | 0] << 24);
      $2_1 = $5_1 >>> 16 | 0;
      $10_1 = HEAPU8[$3_1 + 24 | 0] | HEAPU8[$3_1 + 25 | 0] << 8 | (HEAPU8[$3_1 + 26 | 0] << 16 | HEAPU8[$3_1 + 27 | 0] << 24);
      $18_1 = ($5_1 & 65535) << 16 | $10_1 >>> 16;
      HEAP32[$1_1 + 32 >> 2] = $18_1;
      $13_1 = $2_1;
      HEAP32[$1_1 + 36 >> 2] = $2_1;
      $2_1 = HEAPU8[$3_1 + 20 | 0] | HEAPU8[$3_1 + 21 | 0] << 8 | (HEAPU8[$3_1 + 22 | 0] << 16 | HEAPU8[$3_1 + 23 | 0] << 24);
      $5_1 = HEAPU8[$3_1 + 16 | 0] | HEAPU8[$3_1 + 17 | 0] << 8 | (HEAPU8[$3_1 + 18 | 0] << 16 | HEAPU8[$3_1 + 19 | 0] << 24);
      $16_1 = ($2_1 << 24 | $5_1 >>> 8) & 1048575;
      $4_1 = $5_1 << 24 & -16777216 | $4_1 >>> 8;
      HEAP32[$1_1 + 16 >> 2] = $4_1;
      $15_1 = $16_1;
      HEAP32[$1_1 + 20 >> 2] = $15_1;
      $10_1 = $10_1 << 4 & 1048560;
      $1_1 = $2_1;
      $2_1 = $1_1 >>> 28 | 0;
      $1_1 = ($1_1 & 268435455) << 4 | $5_1 >>> 28;
      HEAP32[$6_1 + 24 >> 2] = $1_1;
      $2_1 = $2_1 | $10_1;
      HEAP32[$6_1 + 28 >> 2] = $2_1;
      if (!($9_1 | $11_1 | $18_1 | $4_1 | $1_1 | ($14_1 | $12_1 | $13_1 | $15_1 | $2_1))) {
       FUNCTION_TABLE[HEAP32[$17_1 + 168 >> 2]](690116, HEAP32[$17_1 + 172 >> 2]);
       break label$4;
      }
      HEAP32[$6_1 + 92 >> 2] = 0;
      $38($6_1 + 96 | 0, 690949, $6_1 + 92 | 0);
      if (HEAP32[$6_1 + 92 >> 2]) {
       break label$4
      }
      $1_1 = $6_1 + 8 | 0;
      $5_1 = HEAP32[$1_1 + 4 >> 2];
      $2_1 = $6_1 + 160 | 0;
      $4_1 = $2_1 + 8 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $1_1 = $6_1 + 16 | 0;
      $5_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $2_1 + 16 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $1_1 = $6_1 + 24 | 0;
      $5_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $2_1 + 24 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $1_1 = $6_1 + 32 | 0;
      $5_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $2_1 + 32 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $1_1 = $6_1 + 48 | 0;
      $5_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $2_1 + 48 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $1_1 = $6_1 + 56 | 0;
      $5_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $2_1 + 56 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $1_1 = $6_1 - -64 | 0;
      $5_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $2_1 - -64 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $1_1 = $6_1 + 72 | 0;
      $5_1 = HEAP32[$1_1 + 4 >> 2];
      $4_1 = $2_1 + 72 | 0;
      HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      HEAP32[$6_1 + 280 >> 2] = 0;
      $1_1 = HEAP32[$6_1 + 4 >> 2];
      HEAP32[$6_1 + 160 >> 2] = HEAP32[$6_1 >> 2];
      HEAP32[$6_1 + 164 >> 2] = $1_1;
      $1_1 = HEAP32[$6_1 + 44 >> 2];
      HEAP32[$6_1 + 200 >> 2] = HEAP32[$6_1 + 40 >> 2];
      HEAP32[$6_1 + 204 >> 2] = $1_1;
      $1_1 = $6_1 + 248 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $6_1 + 256 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $6_1 + 264 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $6_1 + 272 | 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
      $1_1 = $6_1 + 128 | 0;
      $5_1 = $1_1 + 16 | 0;
      HEAP32[$5_1 >> 2] = 0;
      HEAP32[$5_1 + 4 >> 2] = 0;
      $5_1 = $1_1 + 24 | 0;
      HEAP32[$5_1 >> 2] = 0;
      HEAP32[$5_1 + 4 >> 2] = 0;
      HEAP32[$6_1 + 240 >> 2] = 1;
      HEAP32[$6_1 + 244 >> 2] = 0;
      HEAP32[$6_1 + 136 >> 2] = 0;
      HEAP32[$6_1 + 140 >> 2] = 0;
      HEAP32[$6_1 + 128 >> 2] = 1;
      HEAP32[$6_1 + 132 >> 2] = 0;
      $42($2_1, $2_1, $1_1, $6_1 + 96 | 0);
      if (HEAP32[$6_1 + 280 >> 2]) {
       break label$4
      }
      $49($6_1, $6_1 + 160 | 0);
      $5_1 = HEAP32[$6_1 + 8 >> 2];
      $4_1 = HEAP32[$6_1 + 12 >> 2];
      $9_1 = HEAP32[$6_1 + 4 >> 2];
      $7_1 = HEAP32[$6_1 + 32 >> 2];
      $10_1 = HEAP32[$6_1 + 36 >> 2];
      $18_1 = $10_1;
      $2_1 = HEAP32[$6_1 >> 2];
      $1_1 = __wasm_i64_mul($10_1 >>> 16 | 0, 0, 977, 1);
      $15_1 = $2_1 + $1_1 | 0;
      $2_1 = $9_1 + i64toi32_i32$HIGH_BITS | 0;
      $13_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $4_1;
      $1_1 = $13_1 >>> 20 | 0;
      $4_1 = $1_1;
      $1_1 = $1_1 + $5_1 | 0;
      $4_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $17_1 = $4_1 & 1048575;
      $19_1 = HEAP32[$6_1 + 24 >> 2];
      $11_1 = HEAP32[$6_1 + 28 >> 2];
      $2_1 = HEAP32[$6_1 + 20 >> 2];
      $5_1 = $4_1 >>> 20 | 0;
      $10_1 = $5_1 + HEAP32[$6_1 + 16 >> 2] | 0;
      $9_1 = $5_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $11_1;
      $5_1 = $9_1 >>> 20 | 0;
      $8_1 = $5_1;
      $5_1 = $5_1 + $19_1 | 0;
      $2_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $11_1 = $2_1 & 1048575;
      $9_1 = $9_1 & 1048575;
      $19_1 = ($1_1 & $10_1 & $5_1) == -1 & ($4_1 & $9_1 & $2_1) == 1048575;
      $4_1 = $2_1;
      $2_1 = $18_1 & 65535;
      $4_1 = $4_1 >>> 20 | 0;
      $12_1 = $4_1 + $7_1 | 0;
      $2_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $4_1 = $2_1;
      $14_1 = $13_1 & 1048575;
      if ($19_1 & (($12_1 | 0) == -1 & ($2_1 | 0) == 65535) & (($14_1 | 0) == 1048574 & $15_1 >>> 0 > 4294966318 | $14_1 >>> 0 > 1048574) | $2_1 >>> 16) {
       $2_1 = $14_1 + 1 | 0;
       $15_1 = $15_1 + 977 | 0;
       $2_1 = $15_1 >>> 0 < 977 ? $2_1 + 1 | 0 : $2_1;
       $14_1 = $2_1 & 1048575;
       $7_1 = $2_1;
       $2_1 = $17_1;
       $7_1 = $7_1 >>> 20 | 0;
       $1_1 = $1_1 + $7_1 | 0;
       $2_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
       $17_1 = $2_1 & 1048575;
       $7_1 = $2_1;
       $2_1 = $9_1;
       $7_1 = $7_1 >>> 20 | 0;
       $10_1 = $7_1 + $10_1 | 0;
       $2_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
       $9_1 = $2_1 & 1048575;
       $7_1 = $2_1;
       $2_1 = $11_1;
       $7_1 = $7_1 >>> 20 | 0;
       $5_1 = $5_1 + $7_1 | 0;
       $2_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
       $11_1 = $2_1 & 1048575;
       $7_1 = $2_1;
       $2_1 = $4_1;
       $4_1 = $12_1;
       $12_1 = ($7_1 >>> 20 | 0) + $12_1 | 0;
       $4_1 = ($4_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) & 65535;
      }
      HEAP32[$6_1 + 32 >> 2] = $12_1;
      HEAP32[$6_1 + 36 >> 2] = $4_1;
      HEAP32[$6_1 + 24 >> 2] = $5_1;
      HEAP32[$6_1 + 28 >> 2] = $11_1;
      HEAP32[$6_1 + 16 >> 2] = $10_1;
      HEAP32[$6_1 + 20 >> 2] = $9_1;
      HEAP32[$6_1 + 8 >> 2] = $1_1;
      HEAP32[$6_1 + 12 >> 2] = $17_1;
      HEAP32[$6_1 >> 2] = $15_1;
      HEAP32[$6_1 + 4 >> 2] = $14_1;
      $18_1 = HEAP32[$6_1 + 48 >> 2];
      $19_1 = HEAP32[$6_1 + 52 >> 2];
      $8_1 = HEAP32[$6_1 + 44 >> 2];
      $7_1 = HEAP32[$6_1 + 72 >> 2];
      $16_1 = HEAP32[$6_1 + 76 >> 2];
      $23_1 = $16_1;
      $2_1 = HEAP32[$6_1 + 40 >> 2];
      $13_1 = __wasm_i64_mul($16_1 >>> 16 | 0, 0, 977, 1);
      $16_1 = $2_1 + $13_1 | 0;
      $2_1 = $8_1 + i64toi32_i32$HIGH_BITS | 0;
      $21_1 = $13_1 >>> 0 > $16_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $19_1;
      $13_1 = $21_1 >>> 20 | 0;
      $18_1 = $13_1 + $18_1 | 0;
      $8_1 = $13_1 >>> 0 > $18_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $24_1 = $8_1 & 1048575;
      $22_1 = $7_1;
      $25_1 = $23_1 & 65535;
      $13_1 = HEAP32[$6_1 + 64 >> 2];
      $20_1 = HEAP32[$6_1 + 68 >> 2];
      $2_1 = HEAP32[$6_1 + 60 >> 2];
      $7_1 = $8_1 >>> 20 | 0;
      $19_1 = $7_1 + HEAP32[$6_1 + 56 >> 2] | 0;
      $23_1 = $7_1 >>> 0 > $19_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $20_1;
      $7_1 = $23_1 >>> 20 | 0;
      $20_1 = $7_1;
      $7_1 = $7_1 + $13_1 | 0;
      $13_1 = $20_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $2_1 = $25_1;
      $20_1 = $13_1 >>> 20 | 0;
      $25_1 = $20_1;
      $20_1 = $22_1 + $20_1 | 0;
      $2_1 = $25_1 >>> 0 > $20_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      $22_1 = $23_1 & 1048575;
      $21_1 = $21_1 & 1048575;
      if (($19_1 & $18_1 & $7_1) == -1 & ($8_1 & $22_1 & $13_1) == 1048575 & (($20_1 | 0) == -1 & ($2_1 | 0) == 65535) & (($21_1 | 0) == 1048574 & $16_1 >>> 0 > 4294966318 | $21_1 >>> 0 > 1048574) | $2_1 >>> 16) {
       $2_1 = $21_1 + 1 | 0;
       $16_1 = $16_1 + 977 | 0;
       $2_1 = $16_1 >>> 0 < 977 ? $2_1 + 1 | 0 : $2_1;
       $21_1 = $2_1 & 1048575;
       $8_1 = $2_1;
       $2_1 = $24_1;
       $8_1 = $8_1 >>> 20 | 0;
       $18_1 = $8_1 + $18_1 | 0;
       $2_1 = $8_1 >>> 0 > $18_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
       $24_1 = $2_1 & 1048575;
       $8_1 = $2_1;
       $2_1 = $22_1;
       $8_1 = $8_1 >>> 20 | 0;
       $19_1 = $8_1 + $19_1 | 0;
       $2_1 = $8_1 >>> 0 > $19_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
       $22_1 = $2_1 & 1048575;
       $8_1 = $2_1;
       $2_1 = $13_1;
       $8_1 = $8_1 >>> 20 | 0;
       $7_1 = $7_1 + $8_1 | 0;
       $13_1 = $8_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
      }
      HEAP32[$6_1 + 56 >> 2] = $19_1;
      HEAP32[$6_1 + 60 >> 2] = $22_1;
      HEAP32[$6_1 + 48 >> 2] = $18_1;
      HEAP32[$6_1 + 52 >> 2] = $24_1;
      HEAP32[$6_1 + 40 >> 2] = $16_1;
      HEAP32[$6_1 + 44 >> 2] = $21_1;
      HEAP32[$6_1 + 64 >> 2] = $7_1;
      HEAP32[$6_1 + 68 >> 2] = $13_1 & 1048575;
      if (HEAPU8[690917] != ($4_1 >>> 8 & 255)) {
       break label$4
      }
      if (HEAPU8[690918] != ($4_1 & 255)) {
       break label$4
      }
      if (HEAPU8[690919] != ((($4_1 & 16777215) << 8 | $12_1 >>> 24) & 255)) {
       break label$4
      }
      if (HEAPU8[690920] != ((($4_1 & 65535) << 16 | $12_1 >>> 16) & 255)) {
       break label$4
      }
      if (HEAPU8[690921] != ((($4_1 & 255) << 24 | $12_1 >>> 8) & 255)) {
       break label$4
      }
      if (HEAPU8[690922] != ($12_1 & 255)) {
       break label$4
      }
      if (HEAPU8[690923] != ($11_1 >>> 12 | 0)) {
       break label$4
      }
      if (HEAPU8[690924] != ($11_1 >>> 4 & 255)) {
       break label$4
      }
      if (HEAPU8[690925] != ((($11_1 & 268435455) << 4 | $5_1 >>> 28) & 255)) {
       break label$4
      }
      if (HEAPU8[690926] != ((($11_1 & 1048575) << 12 | $5_1 >>> 20) & 255)) {
       break label$4
      }
      if (HEAPU8[690927] != ((($11_1 & 4095) << 20 | $5_1 >>> 12) & 255)) {
       break label$4
      }
      if (HEAPU8[690928] != ((($11_1 & 15) << 28 | $5_1 >>> 4) & 255)) {
       break label$4
      }
      if (HEAPU8[690929] != (($5_1 << 4 | $9_1 >>> 16) & 255)) {
       break label$4
      }
      $2_1 = $9_1;
      if (HEAPU8[690930] != ($2_1 >>> 8 & 255)) {
       break label$4
      }
      if (HEAPU8[690931] != ($2_1 & 255)) {
       break label$4
      }
      if (HEAPU8[690932] != ((($9_1 & 16777215) << 8 | $10_1 >>> 24) & 255)) {
       break label$4
      }
      if (HEAPU8[690933] != ((($9_1 & 65535) << 16 | $10_1 >>> 16) & 255)) {
       break label$4
      }
      if (HEAPU8[690934] != ((($9_1 & 255) << 24 | $10_1 >>> 8) & 255)) {
       break label$4
      }
      if (HEAPU8[690935] != ($10_1 & 255)) {
       break label$4
      }
      if (HEAPU8[690936] != ($17_1 >>> 12 | 0)) {
       break label$4
      }
      if (HEAPU8[690937] != ($17_1 >>> 4 & 255)) {
       break label$4
      }
      if (HEAPU8[690938] != ((($17_1 & 268435455) << 4 | $1_1 >>> 28) & 255)) {
       break label$4
      }
      if (HEAPU8[690939] != ((($17_1 & 1048575) << 12 | $1_1 >>> 20) & 255)) {
       break label$4
      }
      if (HEAPU8[690940] != ((($17_1 & 4095) << 20 | $1_1 >>> 12) & 255)) {
       break label$4
      }
      if (HEAPU8[690941] != ((($17_1 & 15) << 28 | $1_1 >>> 4) & 255)) {
       break label$4
      }
      if (HEAPU8[690942] != (($1_1 << 4 | $14_1 >>> 16) & 255)) {
       break label$4
      }
      $2_1 = $14_1;
      if (HEAPU8[690943] != ($2_1 >>> 8 & 255)) {
       break label$4
      }
      if (HEAPU8[690944] != ($2_1 & 255)) {
       break label$4
      }
      if (HEAPU8[690945] != ((($14_1 & 16777215) << 8 | $15_1 >>> 24) & 255)) {
       break label$4
      }
      if (HEAPU8[690946] != ((($14_1 & 65535) << 16 | $15_1 >>> 16) & 255)) {
       break label$4
      }
      if (HEAPU8[690947] != ((($14_1 & 255) << 24 | $15_1 >>> 8) & 255)) {
       break label$4
      }
      if (HEAPU8[690948] != ($15_1 & 255)) {
       break label$4
      }
      $26_1 = ($16_1 & 1) == ($0_1 | 0);
     }
     global$0 = $6_1 + 288 | 0;
     break label$1;
    }
    fimport$1(1);
    break label$1;
   }
   fimport$1(1);
  }
  global$0 = $3_1 + 192 | 0;
  return $26_1 | 0;
 }
 
 function $13($0_1, $1_1) {
  $0_1 = $0_1 | 0;
  $1_1 = $1_1 | 0;
  var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0;
  $3_1 = global$0 - 208 | 0;
  global$0 = $3_1;
  $2_1 = $3_1 + 136 | 0;
  $5_1 = $2_1 + 56 | 0;
  HEAP32[$5_1 >> 2] = 0;
  HEAP32[$5_1 + 4 >> 2] = 0;
  $5_1 = $2_1 + 48 | 0;
  HEAP32[$5_1 >> 2] = 0;
  HEAP32[$5_1 + 4 >> 2] = 0;
  $5_1 = $2_1 + 40 | 0;
  HEAP32[$5_1 >> 2] = 0;
  HEAP32[$5_1 + 4 >> 2] = 0;
  $5_1 = $2_1 + 32 | 0;
  HEAP32[$5_1 >> 2] = 0;
  HEAP32[$5_1 + 4 >> 2] = 0;
  $5_1 = $2_1 + 24 | 0;
  HEAP32[$5_1 >> 2] = 0;
  HEAP32[$5_1 + 4 >> 2] = 0;
  $5_1 = $2_1 + 16 | 0;
  HEAP32[$5_1 >> 2] = 0;
  HEAP32[$5_1 + 4 >> 2] = 0;
  $5_1 = $2_1 + 8 | 0;
  HEAP32[$5_1 >> 2] = 0;
  HEAP32[$5_1 + 4 >> 2] = 0;
  HEAP32[$3_1 + 136 >> 2] = 0;
  HEAP32[$3_1 + 140 >> 2] = 0;
  label$1 : {
   if (($31(HEAP32[172688], $2_1, 690820, $0_1) | 0) == 1) {
    $2_1 = $3_1 + 136 | 0;
    $0_1 = $2_1 + 15 | 0;
    $4_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $5_1 = $3_1 + 72 | 0;
    $6_1 = $5_1 + 8 | 0;
    HEAP32[$6_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP32[$6_1 + 4 >> 2] = $4_1;
    $0_1 = $2_1 + 23 | 0;
    $4_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $7_1 = $5_1 + 16 | 0;
    HEAP32[$7_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP32[$7_1 + 4 >> 2] = $4_1;
    $0_1 = $2_1 + 31 | 0;
    $4_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $8_1 = $5_1 + 24 | 0;
    HEAP32[$8_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP32[$8_1 + 4 >> 2] = $4_1;
    $0_1 = $2_1 + 39 | 0;
    $4_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $9_1 = $5_1 + 32 | 0;
    HEAP32[$9_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP32[$9_1 + 4 >> 2] = $4_1;
    $0_1 = $2_1 + 47 | 0;
    $4_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $10_1 = $5_1 + 40 | 0;
    HEAP32[$10_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP32[$10_1 + 4 >> 2] = $4_1;
    $0_1 = $2_1 + 55 | 0;
    $4_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $11_1 = $5_1 + 48 | 0;
    HEAP32[$11_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP32[$11_1 + 4 >> 2] = $4_1;
    $4_1 = $5_1 + 56 | 0;
    HEAP8[$4_1 | 0] = HEAPU8[$2_1 + 63 | 0];
    HEAP8[$3_1 + 10 | 0] = HEAPU8[$3_1 + 138 | 0];
    HEAP16[$3_1 + 8 >> 1] = HEAPU16[$3_1 + 136 >> 1];
    $0_1 = HEAPU8[$3_1 + 147 | 0] | HEAPU8[$3_1 + 148 | 0] << 8 | (HEAPU8[$3_1 + 149 | 0] << 16 | HEAPU8[$3_1 + 150 | 0] << 24);
    HEAP32[$3_1 + 72 >> 2] = HEAPU8[$3_1 + 143 | 0] | HEAPU8[$3_1 + 144 | 0] << 8 | (HEAPU8[$3_1 + 145 | 0] << 16 | HEAPU8[$3_1 + 146 | 0] << 24);
    HEAP32[$3_1 + 76 >> 2] = $0_1;
    $5_1 = HEAPU8[$3_1 + 139 | 0] | HEAPU8[$3_1 + 140 | 0] << 8 | (HEAPU8[$3_1 + 141 | 0] << 16 | HEAPU8[$3_1 + 142 | 0] << 24);
    $0_1 = $3_1 + 8 | 0;
    HEAP8[$0_1 + 63 | 0] = HEAPU8[$4_1 | 0];
    $4_1 = HEAP32[$11_1 + 4 >> 2];
    $2_1 = $0_1 + 55 | 0;
    $11_1 = HEAP32[$11_1 >> 2];
    HEAP8[$2_1 | 0] = $11_1;
    HEAP8[$2_1 + 1 | 0] = $11_1 >>> 8;
    HEAP8[$2_1 + 2 | 0] = $11_1 >>> 16;
    HEAP8[$2_1 + 3 | 0] = $11_1 >>> 24;
    HEAP8[$2_1 + 4 | 0] = $4_1;
    HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$10_1 + 4 >> 2];
    $2_1 = $0_1 + 47 | 0;
    $10_1 = HEAP32[$10_1 >> 2];
    HEAP8[$2_1 | 0] = $10_1;
    HEAP8[$2_1 + 1 | 0] = $10_1 >>> 8;
    HEAP8[$2_1 + 2 | 0] = $10_1 >>> 16;
    HEAP8[$2_1 + 3 | 0] = $10_1 >>> 24;
    HEAP8[$2_1 + 4 | 0] = $4_1;
    HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$9_1 + 4 >> 2];
    $2_1 = $0_1 + 39 | 0;
    $9_1 = HEAP32[$9_1 >> 2];
    HEAP8[$2_1 | 0] = $9_1;
    HEAP8[$2_1 + 1 | 0] = $9_1 >>> 8;
    HEAP8[$2_1 + 2 | 0] = $9_1 >>> 16;
    HEAP8[$2_1 + 3 | 0] = $9_1 >>> 24;
    HEAP8[$2_1 + 4 | 0] = $4_1;
    HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$8_1 + 4 >> 2];
    $2_1 = $0_1 + 31 | 0;
    $8_1 = HEAP32[$8_1 >> 2];
    HEAP8[$2_1 | 0] = $8_1;
    HEAP8[$2_1 + 1 | 0] = $8_1 >>> 8;
    HEAP8[$2_1 + 2 | 0] = $8_1 >>> 16;
    HEAP8[$2_1 + 3 | 0] = $8_1 >>> 24;
    HEAP8[$2_1 + 4 | 0] = $4_1;
    HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$7_1 + 4 >> 2];
    $2_1 = $0_1 + 23 | 0;
    $7_1 = HEAP32[$7_1 >> 2];
    HEAP8[$2_1 | 0] = $7_1;
    HEAP8[$2_1 + 1 | 0] = $7_1 >>> 8;
    HEAP8[$2_1 + 2 | 0] = $7_1 >>> 16;
    HEAP8[$2_1 + 3 | 0] = $7_1 >>> 24;
    HEAP8[$2_1 + 4 | 0] = $4_1;
    HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$6_1 + 4 >> 2];
    $2_1 = $0_1 + 15 | 0;
    $6_1 = HEAP32[$6_1 >> 2];
    HEAP8[$2_1 | 0] = $6_1;
    HEAP8[$2_1 + 1 | 0] = $6_1 >>> 8;
    HEAP8[$2_1 + 2 | 0] = $6_1 >>> 16;
    HEAP8[$2_1 + 3 | 0] = $6_1 >>> 24;
    HEAP8[$2_1 + 4 | 0] = $4_1;
    HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
    HEAP8[$3_1 + 11 | 0] = $5_1;
    HEAP8[$3_1 + 12 | 0] = $5_1 >>> 8;
    HEAP8[$3_1 + 13 | 0] = $5_1 >>> 16;
    HEAP8[$3_1 + 14 | 0] = $5_1 >>> 24;
    $2_1 = HEAP32[$3_1 + 76 >> 2];
    $5_1 = HEAP32[$3_1 + 72 >> 2];
    HEAP8[$3_1 + 15 | 0] = $5_1;
    HEAP8[$3_1 + 16 | 0] = $5_1 >>> 8;
    HEAP8[$3_1 + 17 | 0] = $5_1 >>> 16;
    HEAP8[$3_1 + 18 | 0] = $5_1 >>> 24;
    HEAP8[$3_1 + 19 | 0] = $2_1;
    HEAP8[$3_1 + 20 | 0] = $2_1 >>> 8;
    HEAP8[$3_1 + 21 | 0] = $2_1 >>> 16;
    HEAP8[$3_1 + 22 | 0] = $2_1 >>> 24;
    HEAP32[$3_1 + 204 >> 2] = $1_1;
    $0_1 = $36(HEAP32[172688], $3_1 + 204 | 0, $0_1, ($1_1 | 0) == 33 ? 258 : 2);
    HEAP32[$3_1 + 72 >> 2] = $0_1;
    if (($0_1 | 0) == 1) {
     break label$1
    }
    HEAP32[$3_1 + 144 >> 2] = 0;
    $5($3_1 + 136 | 0);
    wasm2js_trap();
   }
   fimport$1(1);
  }
  global$0 = $3_1 + 208 | 0;
 }
 
 function $14($0_1) {
  $0_1 = $0_1 | 0;
  var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0;
  $2_1 = global$0 - 96 | 0;
  global$0 = $2_1;
  $1_1 = $2_1 + 56 | 0;
  HEAP32[$1_1 >> 2] = 0;
  HEAP32[$1_1 + 4 >> 2] = 0;
  $1_1 = $2_1 + 48 | 0;
  HEAP32[$1_1 >> 2] = 0;
  HEAP32[$1_1 + 4 >> 2] = 0;
  $1_1 = $2_1 + 40 | 0;
  HEAP32[$1_1 >> 2] = 0;
  HEAP32[$1_1 + 4 >> 2] = 0;
  $1_1 = $2_1 + 32 | 0;
  HEAP32[$1_1 >> 2] = 0;
  HEAP32[$1_1 + 4 >> 2] = 0;
  $1_1 = $2_1 + 24 | 0;
  HEAP32[$1_1 >> 2] = 0;
  HEAP32[$1_1 + 4 >> 2] = 0;
  $1_1 = $2_1 + 16 | 0;
  HEAP32[$1_1 >> 2] = 0;
  HEAP32[$1_1 + 4 >> 2] = 0;
  $1_1 = $2_1 + 8 | 0;
  HEAP32[$1_1 >> 2] = 0;
  HEAP32[$1_1 + 4 >> 2] = 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  $4_1 = $6();
  $3_1 = global$0 - 256 | 0;
  global$0 = $3_1;
  label$1 : {
   if (!$2_1) {
    FUNCTION_TABLE[HEAP32[$4_1 + 168 >> 2]](689638, HEAP32[$4_1 + 172 >> 2]);
    $1_1 = 0;
    break label$1;
   }
   HEAP8[$2_1 | 0] = 0;
   HEAP8[$2_1 + 1 | 0] = 0;
   HEAP8[$2_1 + 2 | 0] = 0;
   HEAP8[$2_1 + 3 | 0] = 0;
   HEAP8[$2_1 + 4 | 0] = 0;
   HEAP8[$2_1 + 5 | 0] = 0;
   HEAP8[$2_1 + 6 | 0] = 0;
   HEAP8[$2_1 + 7 | 0] = 0;
   $1_1 = $2_1 + 56 | 0;
   HEAP8[$1_1 | 0] = 0;
   HEAP8[$1_1 + 1 | 0] = 0;
   HEAP8[$1_1 + 2 | 0] = 0;
   HEAP8[$1_1 + 3 | 0] = 0;
   HEAP8[$1_1 + 4 | 0] = 0;
   HEAP8[$1_1 + 5 | 0] = 0;
   HEAP8[$1_1 + 6 | 0] = 0;
   HEAP8[$1_1 + 7 | 0] = 0;
   $1_1 = $2_1 + 48 | 0;
   HEAP8[$1_1 | 0] = 0;
   HEAP8[$1_1 + 1 | 0] = 0;
   HEAP8[$1_1 + 2 | 0] = 0;
   HEAP8[$1_1 + 3 | 0] = 0;
   HEAP8[$1_1 + 4 | 0] = 0;
   HEAP8[$1_1 + 5 | 0] = 0;
   HEAP8[$1_1 + 6 | 0] = 0;
   HEAP8[$1_1 + 7 | 0] = 0;
   $1_1 = $2_1 + 40 | 0;
   HEAP8[$1_1 | 0] = 0;
   HEAP8[$1_1 + 1 | 0] = 0;
   HEAP8[$1_1 + 2 | 0] = 0;
   HEAP8[$1_1 + 3 | 0] = 0;
   HEAP8[$1_1 + 4 | 0] = 0;
   HEAP8[$1_1 + 5 | 0] = 0;
   HEAP8[$1_1 + 6 | 0] = 0;
   HEAP8[$1_1 + 7 | 0] = 0;
   $1_1 = $2_1 + 32 | 0;
   HEAP8[$1_1 | 0] = 0;
   HEAP8[$1_1 + 1 | 0] = 0;
   HEAP8[$1_1 + 2 | 0] = 0;
   HEAP8[$1_1 + 3 | 0] = 0;
   HEAP8[$1_1 + 4 | 0] = 0;
   HEAP8[$1_1 + 5 | 0] = 0;
   HEAP8[$1_1 + 6 | 0] = 0;
   HEAP8[$1_1 + 7 | 0] = 0;
   $1_1 = $2_1 + 24 | 0;
   HEAP8[$1_1 | 0] = 0;
   HEAP8[$1_1 + 1 | 0] = 0;
   HEAP8[$1_1 + 2 | 0] = 0;
   HEAP8[$1_1 + 3 | 0] = 0;
   HEAP8[$1_1 + 4 | 0] = 0;
   HEAP8[$1_1 + 5 | 0] = 0;
   HEAP8[$1_1 + 6 | 0] = 0;
   HEAP8[$1_1 + 7 | 0] = 0;
   $1_1 = $2_1 + 16 | 0;
   HEAP8[$1_1 | 0] = 0;
   HEAP8[$1_1 + 1 | 0] = 0;
   HEAP8[$1_1 + 2 | 0] = 0;
   HEAP8[$1_1 + 3 | 0] = 0;
   HEAP8[$1_1 + 4 | 0] = 0;
   HEAP8[$1_1 + 5 | 0] = 0;
   HEAP8[$1_1 + 6 | 0] = 0;
   HEAP8[$1_1 + 7 | 0] = 0;
   $1_1 = $2_1 + 8 | 0;
   HEAP8[$1_1 | 0] = 0;
   HEAP8[$1_1 + 1 | 0] = 0;
   HEAP8[$1_1 + 2 | 0] = 0;
   HEAP8[$1_1 + 3 | 0] = 0;
   HEAP8[$1_1 + 4 | 0] = 0;
   HEAP8[$1_1 + 5 | 0] = 0;
   HEAP8[$1_1 + 6 | 0] = 0;
   HEAP8[$1_1 + 7 | 0] = 0;
   if (!HEAP32[$4_1 >> 2]) {
    FUNCTION_TABLE[HEAP32[$4_1 + 168 >> 2]](690045, HEAP32[$4_1 + 172 >> 2]);
    $1_1 = 0;
    break label$1;
   }
   $8_1 = $3_1 + 8 | 0;
   $6_1 = $3_1 + 128 | 0;
   $38($8_1, 690788, $6_1);
   $9_1 = HEAP32[$3_1 + 32 >> 2];
   $10_1 = HEAP32[$3_1 + 24 >> 2];
   $5_1 = HEAP32[$3_1 + 16 >> 2];
   $11_1 = HEAP32[$3_1 + 8 >> 2];
   $12_1 = HEAP32[$3_1 + 36 >> 2];
   $13_1 = HEAP32[$3_1 + 28 >> 2];
   $14_1 = HEAP32[$3_1 + 20 >> 2];
   $15_1 = HEAP32[$3_1 + 12 >> 2];
   $7_1 = HEAP32[$3_1 + 128 >> 2] | !($9_1 | ($10_1 | ($5_1 | $11_1)) | ($12_1 | ($13_1 | ($14_1 | $15_1))));
   $1_1 = $7_1 ? 0 : -1;
   HEAP32[$3_1 + 32 >> 2] = $1_1 & $9_1;
   HEAP32[$3_1 + 36 >> 2] = $1_1 & $12_1;
   HEAP32[$3_1 + 24 >> 2] = $1_1 & $10_1;
   HEAP32[$3_1 + 28 >> 2] = $1_1 & $13_1;
   HEAP32[$3_1 + 16 >> 2] = $1_1 & $5_1;
   HEAP32[$3_1 + 20 >> 2] = $1_1 & $14_1;
   $5_1 = ($7_1 | 0) != 0;
   HEAP32[$3_1 + 8 >> 2] = $5_1 | $1_1 & $11_1;
   HEAP32[$3_1 + 12 >> 2] = $1_1 & $15_1;
   $48($4_1, $6_1, $8_1);
   $1_1 = $3_1 + 40 | 0;
   $49($1_1, $6_1);
   $35($2_1, $1_1);
   HEAP32[$3_1 + 128 >> 2] = $5_1;
   $1_1 = HEAP32[$3_1 + 128 >> 2] - 1 | 0;
   HEAP8[$2_1 | 0] = $1_1 & HEAPU8[$2_1 | 0];
   HEAP8[$2_1 + 1 | 0] = HEAPU8[$2_1 + 1 | 0] & $1_1;
   HEAP8[$2_1 + 2 | 0] = HEAPU8[$2_1 + 2 | 0] & $1_1;
   HEAP8[$2_1 + 3 | 0] = HEAPU8[$2_1 + 3 | 0] & $1_1;
   HEAP8[$2_1 + 4 | 0] = HEAPU8[$2_1 + 4 | 0] & $1_1;
   HEAP8[$2_1 + 5 | 0] = HEAPU8[$2_1 + 5 | 0] & $1_1;
   HEAP8[$2_1 + 6 | 0] = HEAPU8[$2_1 + 6 | 0] & $1_1;
   HEAP8[$2_1 + 7 | 0] = HEAPU8[$2_1 + 7 | 0] & $1_1;
   HEAP8[$2_1 + 8 | 0] = HEAPU8[$2_1 + 8 | 0] & $1_1;
   HEAP8[$2_1 + 9 | 0] = HEAPU8[$2_1 + 9 | 0] & $1_1;
   HEAP8[$2_1 + 10 | 0] = HEAPU8[$2_1 + 10 | 0] & $1_1;
   HEAP8[$2_1 + 11 | 0] = HEAPU8[$2_1 + 11 | 0] & $1_1;
   HEAP8[$2_1 + 12 | 0] = HEAPU8[$2_1 + 12 | 0] & $1_1;
   HEAP8[$2_1 + 13 | 0] = HEAPU8[$2_1 + 13 | 0] & $1_1;
   HEAP8[$2_1 + 14 | 0] = HEAPU8[$2_1 + 14 | 0] & $1_1;
   HEAP8[$2_1 + 15 | 0] = HEAPU8[$2_1 + 15 | 0] & $1_1;
   HEAP8[$2_1 + 16 | 0] = HEAPU8[$2_1 + 16 | 0] & $1_1;
   HEAP8[$2_1 + 17 | 0] = HEAPU8[$2_1 + 17 | 0] & $1_1;
   HEAP8[$2_1 + 18 | 0] = HEAPU8[$2_1 + 18 | 0] & $1_1;
   HEAP8[$2_1 + 19 | 0] = HEAPU8[$2_1 + 19 | 0] & $1_1;
   HEAP8[$2_1 + 20 | 0] = HEAPU8[$2_1 + 20 | 0] & $1_1;
   HEAP8[$2_1 + 21 | 0] = HEAPU8[$2_1 + 21 | 0] & $1_1;
   HEAP8[$2_1 + 22 | 0] = HEAPU8[$2_1 + 22 | 0] & $1_1;
   HEAP8[$2_1 + 23 | 0] = HEAPU8[$2_1 + 23 | 0] & $1_1;
   HEAP8[$2_1 + 24 | 0] = HEAPU8[$2_1 + 24 | 0] & $1_1;
   HEAP8[$2_1 + 25 | 0] = HEAPU8[$2_1 + 25 | 0] & $1_1;
   HEAP8[$2_1 + 26 | 0] = HEAPU8[$2_1 + 26 | 0] & $1_1;
   HEAP8[$2_1 + 27 | 0] = HEAPU8[$2_1 + 27 | 0] & $1_1;
   HEAP8[$2_1 + 28 | 0] = HEAPU8[$2_1 + 28 | 0] & $1_1;
   HEAP8[$2_1 + 29 | 0] = HEAPU8[$2_1 + 29 | 0] & $1_1;
   HEAP8[$2_1 + 30 | 0] = HEAPU8[$2_1 + 30 | 0] & $1_1;
   HEAP8[$2_1 + 31 | 0] = HEAPU8[$2_1 + 31 | 0] & $1_1;
   HEAP8[$2_1 + 32 | 0] = HEAPU8[$2_1 + 32 | 0] & $1_1;
   HEAP8[$2_1 + 33 | 0] = HEAPU8[$2_1 + 33 | 0] & $1_1;
   HEAP8[$2_1 + 34 | 0] = HEAPU8[$2_1 + 34 | 0] & $1_1;
   HEAP8[$2_1 + 35 | 0] = HEAPU8[$2_1 + 35 | 0] & $1_1;
   HEAP8[$2_1 + 36 | 0] = HEAPU8[$2_1 + 36 | 0] & $1_1;
   HEAP8[$2_1 + 37 | 0] = HEAPU8[$2_1 + 37 | 0] & $1_1;
   HEAP8[$2_1 + 38 | 0] = HEAPU8[$2_1 + 38 | 0] & $1_1;
   HEAP8[$2_1 + 39 | 0] = HEAPU8[$2_1 + 39 | 0] & $1_1;
   HEAP8[$2_1 + 40 | 0] = HEAPU8[$2_1 + 40 | 0] & $1_1;
   HEAP8[$2_1 + 41 | 0] = HEAPU8[$2_1 + 41 | 0] & $1_1;
   HEAP8[$2_1 + 42 | 0] = HEAPU8[$2_1 + 42 | 0] & $1_1;
   HEAP8[$2_1 + 43 | 0] = HEAPU8[$2_1 + 43 | 0] & $1_1;
   HEAP8[$2_1 + 44 | 0] = HEAPU8[$2_1 + 44 | 0] & $1_1;
   HEAP8[$2_1 + 45 | 0] = HEAPU8[$2_1 + 45 | 0] & $1_1;
   HEAP8[$2_1 + 46 | 0] = HEAPU8[$2_1 + 46 | 0] & $1_1;
   HEAP8[$2_1 + 47 | 0] = HEAPU8[$2_1 + 47 | 0] & $1_1;
   HEAP8[$2_1 + 48 | 0] = HEAPU8[$2_1 + 48 | 0] & $1_1;
   HEAP8[$2_1 + 49 | 0] = HEAPU8[$2_1 + 49 | 0] & $1_1;
   HEAP8[$2_1 + 50 | 0] = HEAPU8[$2_1 + 50 | 0] & $1_1;
   HEAP8[$2_1 + 51 | 0] = HEAPU8[$2_1 + 51 | 0] & $1_1;
   HEAP8[$2_1 + 52 | 0] = HEAPU8[$2_1 + 52 | 0] & $1_1;
   HEAP8[$2_1 + 53 | 0] = HEAPU8[$2_1 + 53 | 0] & $1_1;
   HEAP8[$2_1 + 54 | 0] = HEAPU8[$2_1 + 54 | 0] & $1_1;
   HEAP8[$2_1 + 55 | 0] = HEAPU8[$2_1 + 55 | 0] & $1_1;
   HEAP8[$2_1 + 56 | 0] = HEAPU8[$2_1 + 56 | 0] & $1_1;
   HEAP8[$2_1 + 57 | 0] = HEAPU8[$2_1 + 57 | 0] & $1_1;
   HEAP8[$2_1 + 58 | 0] = HEAPU8[$2_1 + 58 | 0] & $1_1;
   HEAP8[$2_1 + 59 | 0] = HEAPU8[$2_1 + 59 | 0] & $1_1;
   HEAP8[$2_1 + 60 | 0] = HEAPU8[$2_1 + 60 | 0] & $1_1;
   HEAP8[$2_1 + 61 | 0] = HEAPU8[$2_1 + 61 | 0] & $1_1;
   HEAP8[$2_1 + 62 | 0] = HEAPU8[$2_1 + 62 | 0] & $1_1;
   HEAP8[$2_1 + 63 | 0] = HEAPU8[$2_1 + 63 | 0] & $1_1;
   $1_1 = !$7_1;
  }
  global$0 = $3_1 + 256 | 0;
  label$4 : {
   if ($1_1) {
    HEAP32[$2_1 + 64 >> 2] = $0_1;
    $0_1 = $36(HEAP32[172688], $2_1 - -64 | 0, $2_1, ($0_1 | 0) == 33 ? 258 : 2);
    HEAP32[$2_1 + 68 >> 2] = $0_1;
    if (($0_1 | 0) != 1) {
     break label$4
    }
    $16_1 = 1;
   }
   global$0 = $2_1 + 96 | 0;
   return $16_1 | 0;
  }
  HEAP32[$2_1 + 80 >> 2] = 0;
  $5($2_1 + 72 | 0);
  wasm2js_trap();
 }
 
 function $15() {
  var $0_1 = 0, $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0;
  $3_1 = global$0 - 304 | 0;
  global$0 = $3_1;
  $2_1 = $3_1 + 200 | 0;
  $68($2_1, 96);
  label$1 : {
   label$2 : {
    label$3 : {
     if (($60($6(), $2_1) | 0) == 1) {
      HEAP8[$3_1 + 10 | 0] = HEAPU8[$3_1 + 202 | 0];
      HEAP16[$3_1 + 8 >> 1] = HEAPU16[$3_1 + 200 >> 1];
      $2_1 = HEAPU8[$3_1 + 203 | 0] | HEAPU8[$3_1 + 204 | 0] << 8 | (HEAPU8[$3_1 + 205 | 0] << 16 | HEAPU8[$3_1 + 206 | 0] << 24);
      $0_1 = $3_1 + 104 | 0;
      $5_1 = $3_1 + 200 | 0;
      $70($0_1, $5_1 | 7, 89);
      $1_1 = $3_1 + 8 | 0;
      $70($1_1 | 7, $0_1, 89);
      HEAP8[$3_1 + 11 | 0] = $2_1;
      HEAP8[$3_1 + 12 | 0] = $2_1 >>> 8;
      HEAP8[$3_1 + 13 | 0] = $2_1 >>> 16;
      HEAP8[$3_1 + 14 | 0] = $2_1 >>> 24;
      $2_1 = $3_1 + 256 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $3_1 + 248 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $3_1 + 240 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $3_1 + 232 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $3_1 + 224 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $3_1 + 216 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $3_1 + 208 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      HEAP32[$3_1 + 200 >> 2] = 0;
      HEAP32[$3_1 + 204 >> 2] = 0;
      HEAP32[$3_1 + 196 >> 2] = 0;
      $10_1 = $6();
      $15_1 = $3_1 + 196 | 0;
      $2_1 = global$0 - 96 | 0;
      global$0 = $2_1;
      label$5 : {
       if (!$5_1) {
        FUNCTION_TABLE[HEAP32[$10_1 + 168 >> 2]](689638, HEAP32[$10_1 + 172 >> 2]);
        $0_1 = 0;
        break label$5;
       }
       HEAP8[$5_1 | 0] = 0;
       HEAP8[$5_1 + 1 | 0] = 0;
       HEAP8[$5_1 + 2 | 0] = 0;
       HEAP8[$5_1 + 3 | 0] = 0;
       HEAP8[$5_1 + 4 | 0] = 0;
       HEAP8[$5_1 + 5 | 0] = 0;
       HEAP8[$5_1 + 6 | 0] = 0;
       HEAP8[$5_1 + 7 | 0] = 0;
       $0_1 = $5_1 + 56 | 0;
       HEAP8[$0_1 | 0] = 0;
       HEAP8[$0_1 + 1 | 0] = 0;
       HEAP8[$0_1 + 2 | 0] = 0;
       HEAP8[$0_1 + 3 | 0] = 0;
       HEAP8[$0_1 + 4 | 0] = 0;
       HEAP8[$0_1 + 5 | 0] = 0;
       HEAP8[$0_1 + 6 | 0] = 0;
       HEAP8[$0_1 + 7 | 0] = 0;
       $0_1 = $5_1 + 48 | 0;
       HEAP8[$0_1 | 0] = 0;
       HEAP8[$0_1 + 1 | 0] = 0;
       HEAP8[$0_1 + 2 | 0] = 0;
       HEAP8[$0_1 + 3 | 0] = 0;
       HEAP8[$0_1 + 4 | 0] = 0;
       HEAP8[$0_1 + 5 | 0] = 0;
       HEAP8[$0_1 + 6 | 0] = 0;
       HEAP8[$0_1 + 7 | 0] = 0;
       $0_1 = $5_1 + 40 | 0;
       HEAP8[$0_1 | 0] = 0;
       HEAP8[$0_1 + 1 | 0] = 0;
       HEAP8[$0_1 + 2 | 0] = 0;
       HEAP8[$0_1 + 3 | 0] = 0;
       HEAP8[$0_1 + 4 | 0] = 0;
       HEAP8[$0_1 + 5 | 0] = 0;
       HEAP8[$0_1 + 6 | 0] = 0;
       HEAP8[$0_1 + 7 | 0] = 0;
       $0_1 = $5_1 + 32 | 0;
       HEAP8[$0_1 | 0] = 0;
       HEAP8[$0_1 + 1 | 0] = 0;
       HEAP8[$0_1 + 2 | 0] = 0;
       HEAP8[$0_1 + 3 | 0] = 0;
       HEAP8[$0_1 + 4 | 0] = 0;
       HEAP8[$0_1 + 5 | 0] = 0;
       HEAP8[$0_1 + 6 | 0] = 0;
       HEAP8[$0_1 + 7 | 0] = 0;
       $0_1 = $5_1 + 24 | 0;
       HEAP8[$0_1 | 0] = 0;
       HEAP8[$0_1 + 1 | 0] = 0;
       HEAP8[$0_1 + 2 | 0] = 0;
       HEAP8[$0_1 + 3 | 0] = 0;
       HEAP8[$0_1 + 4 | 0] = 0;
       HEAP8[$0_1 + 5 | 0] = 0;
       HEAP8[$0_1 + 6 | 0] = 0;
       HEAP8[$0_1 + 7 | 0] = 0;
       $0_1 = $5_1 + 16 | 0;
       HEAP8[$0_1 | 0] = 0;
       HEAP8[$0_1 + 1 | 0] = 0;
       HEAP8[$0_1 + 2 | 0] = 0;
       HEAP8[$0_1 + 3 | 0] = 0;
       HEAP8[$0_1 + 4 | 0] = 0;
       HEAP8[$0_1 + 5 | 0] = 0;
       HEAP8[$0_1 + 6 | 0] = 0;
       HEAP8[$0_1 + 7 | 0] = 0;
       $0_1 = $5_1 + 8 | 0;
       HEAP8[$0_1 | 0] = 0;
       HEAP8[$0_1 + 1 | 0] = 0;
       HEAP8[$0_1 + 2 | 0] = 0;
       HEAP8[$0_1 + 3 | 0] = 0;
       HEAP8[$0_1 + 4 | 0] = 0;
       HEAP8[$0_1 + 5 | 0] = 0;
       HEAP8[$0_1 + 6 | 0] = 0;
       HEAP8[$0_1 + 7 | 0] = 0;
       if (!$1_1) {
        FUNCTION_TABLE[HEAP32[$10_1 + 168 >> 2]](689700, HEAP32[$10_1 + 172 >> 2]);
        $0_1 = 0;
        break label$5;
       }
       $11_1 = HEAPU8[$1_1 + 92 | 0] | HEAPU8[$1_1 + 93 | 0] << 8 | (HEAPU8[$1_1 + 94 | 0] << 16 | HEAPU8[$1_1 + 95 | 0] << 24);
       $0_1 = $11_1 >>> 16 | 0;
       $6_1 = $2_1 + 80 | 0;
       $7_1 = HEAPU8[$1_1 + 88 | 0] | HEAPU8[$1_1 + 89 | 0] << 8 | (HEAPU8[$1_1 + 90 | 0] << 16 | HEAPU8[$1_1 + 91 | 0] << 24);
       $11_1 = ($11_1 & 65535) << 16 | $7_1 >>> 16;
       HEAP32[$6_1 >> 2] = $11_1;
       $24_1 = $0_1;
       HEAP32[$6_1 + 4 >> 2] = $0_1;
       $9_1 = $7_1 << 4 & 1048560;
       $4_1 = HEAPU8[$1_1 + 84 | 0] | HEAPU8[$1_1 + 85 | 0] << 8 | (HEAPU8[$1_1 + 86 | 0] << 16 | HEAPU8[$1_1 + 87 | 0] << 24);
       $0_1 = $4_1 >>> 28 | 0;
       $6_1 = $2_1 + 72 | 0;
       $7_1 = HEAPU8[$1_1 + 80 | 0] | HEAPU8[$1_1 + 81 | 0] << 8 | (HEAPU8[$1_1 + 82 | 0] << 16 | HEAPU8[$1_1 + 83 | 0] << 24);
       $12_1 = ($4_1 & 268435455) << 4 | $7_1 >>> 28;
       HEAP32[$6_1 >> 2] = $12_1;
       $16_1 = $0_1 | $9_1;
       HEAP32[$6_1 + 4 >> 2] = $16_1;
       $0_1 = $4_1 << 24 | $7_1 >>> 8;
       $8_1 = $7_1 << 24 & -16777216;
       $7_1 = HEAPU8[$1_1 + 72 | 0] | HEAPU8[$1_1 + 73 | 0] << 8 | (HEAPU8[$1_1 + 74 | 0] << 16 | HEAPU8[$1_1 + 75 | 0] << 24);
       $9_1 = $2_1 + 8 | 0;
       $6_1 = $9_1 + 56 | 0;
       $4_1 = HEAPU8[$1_1 + 76 | 0] | HEAPU8[$1_1 + 77 | 0] << 8 | (HEAPU8[$1_1 + 78 | 0] << 16 | HEAPU8[$1_1 + 79 | 0] << 24);
       $13_1 = $4_1 >>> 8 | $8_1;
       HEAP32[$6_1 >> 2] = $13_1;
       $17_1 = $0_1 & 1048575;
       HEAP32[$6_1 + 4 >> 2] = $17_1;
       $0_1 = $7_1;
       $4_1 = $4_1 << 12 | $0_1 >>> 20;
       $7_1 = HEAPU8[$1_1 + 64 | 0] | HEAPU8[$1_1 + 65 | 0] << 8 | (HEAPU8[$1_1 + 66 | 0] << 16 | HEAPU8[$1_1 + 67 | 0] << 24);
       $6_1 = $9_1 + 48 | 0;
       $8_1 = HEAPU8[$1_1 + 68 | 0] | HEAPU8[$1_1 + 69 | 0] << 8 | (HEAPU8[$1_1 + 70 | 0] << 16 | HEAPU8[$1_1 + 71 | 0] << 24);
       $14_1 = $0_1 << 12 & -4096 | $8_1 >>> 20;
       HEAP32[$6_1 >> 2] = $14_1;
       $18_1 = $4_1 & 1048575;
       HEAP32[$6_1 + 4 >> 2] = $18_1;
       HEAP32[$2_1 + 88 >> 2] = 0;
       HEAP32[$2_1 + 48 >> 2] = $7_1;
       $19_1 = $8_1 & 1048575;
       HEAP32[$2_1 + 52 >> 2] = $19_1;
       $0_1 = HEAPU8[$1_1 + 44 | 0] | HEAPU8[$1_1 + 45 | 0] << 8 | (HEAPU8[$1_1 + 46 | 0] << 16 | HEAPU8[$1_1 + 47 | 0] << 24);
       $6_1 = $0_1;
       $4_1 = HEAPU8[$1_1 + 40 | 0] | HEAPU8[$1_1 + 41 | 0] << 8 | (HEAPU8[$1_1 + 42 | 0] << 16 | HEAPU8[$1_1 + 43 | 0] << 24);
       $8_1 = ($0_1 << 12 | $4_1 >>> 20) & 1048575;
       $0_1 = HEAPU8[$1_1 + 32 | 0] | HEAPU8[$1_1 + 33 | 0] << 8 | (HEAPU8[$1_1 + 34 | 0] << 16 | HEAPU8[$1_1 + 35 | 0] << 24);
       $9_1 = $4_1 << 12 & -4096;
       $4_1 = HEAPU8[$1_1 + 36 | 0] | HEAPU8[$1_1 + 37 | 0] << 8 | (HEAPU8[$1_1 + 38 | 0] << 16 | HEAPU8[$1_1 + 39 | 0] << 24);
       $20_1 = $9_1 | $4_1 >>> 20;
       HEAP32[$2_1 + 16 >> 2] = $20_1;
       $25_1 = $8_1;
       HEAP32[$2_1 + 20 >> 2] = $8_1;
       $9_1 = $0_1;
       HEAP32[$2_1 + 8 >> 2] = $0_1;
       $21_1 = $4_1 & 1048575;
       HEAP32[$2_1 + 12 >> 2] = $21_1;
       $4_1 = HEAPU8[$1_1 + 60 | 0] | HEAPU8[$1_1 + 61 | 0] << 8 | (HEAPU8[$1_1 + 62 | 0] << 16 | HEAPU8[$1_1 + 63 | 0] << 24);
       $0_1 = $4_1 >>> 16 | 0;
       $8_1 = HEAPU8[$1_1 + 56 | 0] | HEAPU8[$1_1 + 57 | 0] << 8 | (HEAPU8[$1_1 + 58 | 0] << 16 | HEAPU8[$1_1 + 59 | 0] << 24);
       $22_1 = ($4_1 & 65535) << 16 | $8_1 >>> 16;
       HEAP32[$2_1 + 40 >> 2] = $22_1;
       $26_1 = $0_1;
       HEAP32[$2_1 + 44 >> 2] = $0_1;
       $4_1 = HEAPU8[$1_1 + 48 | 0] | HEAPU8[$1_1 + 49 | 0] << 8 | (HEAPU8[$1_1 + 50 | 0] << 16 | HEAPU8[$1_1 + 51 | 0] << 24);
       $0_1 = HEAPU8[$1_1 + 52 | 0] | HEAPU8[$1_1 + 53 | 0] << 8 | (HEAPU8[$1_1 + 54 | 0] << 16 | HEAPU8[$1_1 + 55 | 0] << 24);
       $1_1 = $0_1;
       $23_1 = ($0_1 << 24 | $4_1 >>> 8) & 1048575;
       $6_1 = $4_1 << 24 & -16777216 | $6_1 >>> 8;
       HEAP32[$2_1 + 24 >> 2] = $6_1;
       HEAP32[$2_1 + 28 >> 2] = $23_1;
       $8_1 = $8_1 << 4 & 1048560;
       $0_1 = $0_1 >>> 28 | 0;
       $4_1 = ($1_1 & 268435455) << 4 | $4_1 >>> 28;
       HEAP32[$2_1 + 32 >> 2] = $4_1;
       $0_1 = $0_1 | $8_1;
       HEAP32[$2_1 + 36 >> 2] = $0_1;
       if (!($9_1 | $20_1 | $22_1 | $6_1 | $4_1 | ($25_1 | $21_1 | $26_1 | $23_1 | $0_1))) {
        FUNCTION_TABLE[HEAP32[$10_1 + 168 >> 2]](690116, HEAP32[$10_1 + 172 >> 2]);
        $0_1 = 0;
        break label$5;
       }
       if ($7_1 & 1) {
        HEAP32[$2_1 + 80 >> 2] = -4 - $11_1;
        HEAP32[$2_1 + 84 >> 2] = 262143 - (($11_1 >>> 0 > 4294967292) + $24_1 | 0);
        HEAP32[$2_1 + 72 >> 2] = -4 - $12_1;
        HEAP32[$2_1 + 76 >> 2] = 4194303 - (($12_1 >>> 0 > 4294967292) + $16_1 | 0);
        HEAP32[$2_1 + 64 >> 2] = -4 - $13_1;
        HEAP32[$2_1 + 68 >> 2] = 4194303 - (($13_1 >>> 0 > 4294967292) + $17_1 | 0);
        HEAP32[$2_1 + 56 >> 2] = -4 - $14_1;
        HEAP32[$2_1 + 60 >> 2] = 4194303 - (($14_1 >>> 0 > 4294967292) + $18_1 | 0);
        HEAP32[$2_1 + 48 >> 2] = -3908 - $7_1;
        HEAP32[$2_1 + 52 >> 2] = 4194299 - (($7_1 >>> 0 > 4294963388) + $19_1 | 0);
        $27_1 = 1;
       }
       if ($15_1) {
        HEAP32[$15_1 >> 2] = $27_1
       }
       $35($5_1, $2_1 + 8 | 0);
       $0_1 = 1;
      }
      global$0 = $2_1 + 96 | 0;
      HEAP32[$3_1 + 300 >> 2] = $0_1;
      if (($0_1 | 0) == 1) {
       break label$3
      }
      break label$1;
     }
     fimport$1(0);
     break label$2;
    }
    $2_1 = $58(HEAP32[172688], $3_1 + 200 | 0);
    HEAP32[$3_1 + 300 >> 2] = $2_1;
    $0_1 = 1;
    if (($2_1 | 0) == 1) {
     break label$2
    }
    break label$1;
   }
   global$0 = $3_1 + 304 | 0;
   return $0_1 | 0;
  }
  HEAP32[$3_1 + 112 >> 2] = 0;
  $5($3_1 + 104 | 0);
  wasm2js_trap();
 }
 
 function $16($0_1) {
  $0_1 = $0_1 | 0;
  var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0;
  $3_1 = global$0 - 272 | 0;
  global$0 = $3_1;
  $1_1 = $3_1 + 8 | 0;
  $4_1 = $1_1 + 56 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $2_1 = $1_1 + 48 | 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  $5_1 = $1_1 + 40 | 0;
  HEAP32[$5_1 >> 2] = 0;
  HEAP32[$5_1 + 4 >> 2] = 0;
  $6_1 = $1_1 + 32 | 0;
  HEAP32[$6_1 >> 2] = 0;
  HEAP32[$6_1 + 4 >> 2] = 0;
  $7_1 = $1_1 + 24 | 0;
  HEAP32[$7_1 >> 2] = 0;
  HEAP32[$7_1 + 4 >> 2] = 0;
  $8_1 = $1_1 + 16 | 0;
  HEAP32[$8_1 >> 2] = 0;
  HEAP32[$8_1 + 4 >> 2] = 0;
  $9_1 = $1_1 + 8 | 0;
  HEAP32[$9_1 >> 2] = 0;
  HEAP32[$9_1 + 4 >> 2] = 0;
  HEAP32[$3_1 + 8 >> 2] = 0;
  HEAP32[$3_1 + 12 >> 2] = 0;
  HEAP32[$3_1 + 76 >> 2] = 0;
  $1_1 = $3_1 + 208 | 0;
  $10_1 = $1_1 + 56 | 0;
  HEAP32[$10_1 >> 2] = 0;
  HEAP32[$10_1 + 4 >> 2] = 0;
  $11_1 = $1_1 + 48 | 0;
  HEAP32[$11_1 >> 2] = 0;
  HEAP32[$11_1 + 4 >> 2] = 0;
  $12_1 = $1_1 + 40 | 0;
  HEAP32[$12_1 >> 2] = 0;
  HEAP32[$12_1 + 4 >> 2] = 0;
  $13_1 = $1_1 + 32 | 0;
  HEAP32[$13_1 >> 2] = 0;
  HEAP32[$13_1 + 4 >> 2] = 0;
  $14_1 = $1_1 + 24 | 0;
  HEAP32[$14_1 >> 2] = 0;
  HEAP32[$14_1 + 4 >> 2] = 0;
  $15_1 = $1_1 + 16 | 0;
  HEAP32[$15_1 >> 2] = 0;
  HEAP32[$15_1 + 4 >> 2] = 0;
  $16_1 = $1_1 + 8 | 0;
  HEAP32[$16_1 >> 2] = 0;
  HEAP32[$16_1 + 4 >> 2] = 0;
  HEAP32[$3_1 + 208 >> 2] = 0;
  HEAP32[$3_1 + 212 >> 2] = 0;
  folding_inner0 : {
   label$3 : {
    if (($31(HEAP32[172688], $1_1, 690820, $0_1) | 0) == 1) {
     $1_1 = $3_1 + 208 | 0;
     $0_1 = $1_1 + 15 | 0;
     $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
     $4_1 = $3_1 + 144 | 0;
     $5_1 = $4_1 + 8 | 0;
     HEAP32[$5_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
     HEAP32[$5_1 + 4 >> 2] = $2_1;
     $0_1 = $1_1 + 23 | 0;
     $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
     $6_1 = $4_1 + 16 | 0;
     HEAP32[$6_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
     HEAP32[$6_1 + 4 >> 2] = $2_1;
     $0_1 = $1_1 + 31 | 0;
     $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
     $7_1 = $4_1 + 24 | 0;
     HEAP32[$7_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
     HEAP32[$7_1 + 4 >> 2] = $2_1;
     $0_1 = $1_1 + 39 | 0;
     $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
     $8_1 = $4_1 + 32 | 0;
     HEAP32[$8_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
     HEAP32[$8_1 + 4 >> 2] = $2_1;
     $0_1 = $1_1 + 47 | 0;
     $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
     $9_1 = $4_1 + 40 | 0;
     HEAP32[$9_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
     HEAP32[$9_1 + 4 >> 2] = $2_1;
     $0_1 = $1_1 + 55 | 0;
     $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
     $10_1 = $4_1 + 48 | 0;
     HEAP32[$10_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
     HEAP32[$10_1 + 4 >> 2] = $2_1;
     $2_1 = $4_1 + 56 | 0;
     HEAP8[$2_1 | 0] = HEAPU8[$1_1 + 63 | 0];
     HEAP8[$3_1 + 82 | 0] = HEAPU8[$3_1 + 210 | 0];
     HEAP16[$3_1 + 80 >> 1] = HEAPU16[$3_1 + 208 >> 1];
     $0_1 = HEAPU8[$3_1 + 219 | 0] | HEAPU8[$3_1 + 220 | 0] << 8 | (HEAPU8[$3_1 + 221 | 0] << 16 | HEAPU8[$3_1 + 222 | 0] << 24);
     HEAP32[$3_1 + 144 >> 2] = HEAPU8[$3_1 + 215 | 0] | HEAPU8[$3_1 + 216 | 0] << 8 | (HEAPU8[$3_1 + 217 | 0] << 16 | HEAPU8[$3_1 + 218 | 0] << 24);
     HEAP32[$3_1 + 148 >> 2] = $0_1;
     $4_1 = HEAPU8[$3_1 + 211 | 0] | HEAPU8[$3_1 + 212 | 0] << 8 | (HEAPU8[$3_1 + 213 | 0] << 16 | HEAPU8[$3_1 + 214 | 0] << 24);
     $0_1 = $3_1 + 80 | 0;
     HEAP8[$0_1 + 63 | 0] = HEAPU8[$2_1 | 0];
     $2_1 = HEAP32[$10_1 + 4 >> 2];
     $1_1 = $0_1 + 55 | 0;
     $10_1 = HEAP32[$10_1 >> 2];
     HEAP8[$1_1 | 0] = $10_1;
     HEAP8[$1_1 + 1 | 0] = $10_1 >>> 8;
     HEAP8[$1_1 + 2 | 0] = $10_1 >>> 16;
     HEAP8[$1_1 + 3 | 0] = $10_1 >>> 24;
     HEAP8[$1_1 + 4 | 0] = $2_1;
     HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
     HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
     HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
     $2_1 = HEAP32[$9_1 + 4 >> 2];
     $1_1 = $0_1 + 47 | 0;
     $9_1 = HEAP32[$9_1 >> 2];
     HEAP8[$1_1 | 0] = $9_1;
     HEAP8[$1_1 + 1 | 0] = $9_1 >>> 8;
     HEAP8[$1_1 + 2 | 0] = $9_1 >>> 16;
     HEAP8[$1_1 + 3 | 0] = $9_1 >>> 24;
     HEAP8[$1_1 + 4 | 0] = $2_1;
     HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
     HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
     HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
     $2_1 = HEAP32[$8_1 + 4 >> 2];
     $1_1 = $0_1 + 39 | 0;
     $8_1 = HEAP32[$8_1 >> 2];
     HEAP8[$1_1 | 0] = $8_1;
     HEAP8[$1_1 + 1 | 0] = $8_1 >>> 8;
     HEAP8[$1_1 + 2 | 0] = $8_1 >>> 16;
     HEAP8[$1_1 + 3 | 0] = $8_1 >>> 24;
     HEAP8[$1_1 + 4 | 0] = $2_1;
     HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
     HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
     HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
     $2_1 = HEAP32[$7_1 + 4 >> 2];
     $1_1 = $0_1 + 31 | 0;
     $7_1 = HEAP32[$7_1 >> 2];
     HEAP8[$1_1 | 0] = $7_1;
     HEAP8[$1_1 + 1 | 0] = $7_1 >>> 8;
     HEAP8[$1_1 + 2 | 0] = $7_1 >>> 16;
     HEAP8[$1_1 + 3 | 0] = $7_1 >>> 24;
     HEAP8[$1_1 + 4 | 0] = $2_1;
     HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
     HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
     HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
     $2_1 = HEAP32[$6_1 + 4 >> 2];
     $1_1 = $0_1 + 23 | 0;
     $6_1 = HEAP32[$6_1 >> 2];
     HEAP8[$1_1 | 0] = $6_1;
     HEAP8[$1_1 + 1 | 0] = $6_1 >>> 8;
     HEAP8[$1_1 + 2 | 0] = $6_1 >>> 16;
     HEAP8[$1_1 + 3 | 0] = $6_1 >>> 24;
     HEAP8[$1_1 + 4 | 0] = $2_1;
     HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
     HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
     HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
     $2_1 = HEAP32[$5_1 + 4 >> 2];
     $1_1 = $0_1 + 15 | 0;
     $5_1 = HEAP32[$5_1 >> 2];
     HEAP8[$1_1 | 0] = $5_1;
     HEAP8[$1_1 + 1 | 0] = $5_1 >>> 8;
     HEAP8[$1_1 + 2 | 0] = $5_1 >>> 16;
     HEAP8[$1_1 + 3 | 0] = $5_1 >>> 24;
     HEAP8[$1_1 + 4 | 0] = $2_1;
     HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
     HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
     HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
     HEAP8[$3_1 + 83 | 0] = $4_1;
     HEAP8[$3_1 + 84 | 0] = $4_1 >>> 8;
     HEAP8[$3_1 + 85 | 0] = $4_1 >>> 16;
     HEAP8[$3_1 + 86 | 0] = $4_1 >>> 24;
     $1_1 = HEAP32[$3_1 + 148 >> 2];
     $4_1 = HEAP32[$3_1 + 144 >> 2];
     HEAP8[$3_1 + 87 | 0] = $4_1;
     HEAP8[$3_1 + 88 | 0] = $4_1 >>> 8;
     HEAP8[$3_1 + 89 | 0] = $4_1 >>> 16;
     HEAP8[$3_1 + 90 | 0] = $4_1 >>> 24;
     HEAP8[$3_1 + 91 | 0] = $1_1;
     HEAP8[$3_1 + 92 | 0] = $1_1 >>> 8;
     HEAP8[$3_1 + 93 | 0] = $1_1 >>> 16;
     HEAP8[$3_1 + 94 | 0] = $1_1 >>> 24;
     $0_1 = $59($6(), $3_1 + 8 | 0, $3_1 + 76 | 0, $0_1);
     HEAP32[$3_1 + 144 >> 2] = $0_1;
     if (($0_1 | 0) != 1) {
      break folding_inner0
     }
     $0_1 = $3_1 + 8 | 0;
     $4_1 = $0_1 + 8 | 0;
     $2_1 = HEAP32[$4_1 + 4 >> 2];
     $1_1 = $3_1 + 208 | 0;
     $5_1 = $1_1 + 8 | 0;
     HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
     HEAP32[$5_1 + 4 >> 2] = $2_1;
     $4_1 = $0_1 + 16 | 0;
     $2_1 = HEAP32[$4_1 + 4 >> 2];
     $5_1 = $1_1 + 16 | 0;
     HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
     HEAP32[$5_1 + 4 >> 2] = $2_1;
     $4_1 = $0_1 + 24 | 0;
     $2_1 = HEAP32[$4_1 + 4 >> 2];
     $5_1 = $1_1 + 24 | 0;
     HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
     HEAP32[$5_1 + 4 >> 2] = $2_1;
     $4_1 = $0_1 + 32 | 0;
     $2_1 = HEAP32[$4_1 + 4 >> 2];
     $5_1 = $1_1 + 32 | 0;
     HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
     HEAP32[$5_1 + 4 >> 2] = $2_1;
     $4_1 = $0_1 + 40 | 0;
     $2_1 = HEAP32[$4_1 + 4 >> 2];
     $5_1 = $1_1 + 40 | 0;
     HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
     HEAP32[$5_1 + 4 >> 2] = $2_1;
     $4_1 = $0_1 + 48 | 0;
     $2_1 = HEAP32[$4_1 + 4 >> 2];
     $5_1 = $1_1 + 48 | 0;
     HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
     HEAP32[$5_1 + 4 >> 2] = $2_1;
     $0_1 = $0_1 + 56 | 0;
     $4_1 = HEAP32[$0_1 + 4 >> 2];
     $1_1 = $1_1 + 56 | 0;
     HEAP32[$1_1 >> 2] = HEAP32[$0_1 >> 2];
     HEAP32[$1_1 + 4 >> 2] = $4_1;
     break label$3;
    }
    fimport$1(1);
    $0_1 = HEAP32[$4_1 + 4 >> 2];
    HEAP32[$10_1 >> 2] = HEAP32[$4_1 >> 2];
    HEAP32[$10_1 + 4 >> 2] = $0_1;
    $0_1 = HEAP32[$2_1 + 4 >> 2];
    HEAP32[$11_1 >> 2] = HEAP32[$2_1 >> 2];
    HEAP32[$11_1 + 4 >> 2] = $0_1;
    $0_1 = HEAP32[$5_1 + 4 >> 2];
    HEAP32[$12_1 >> 2] = HEAP32[$5_1 >> 2];
    HEAP32[$12_1 + 4 >> 2] = $0_1;
    $0_1 = HEAP32[$6_1 + 4 >> 2];
    HEAP32[$13_1 >> 2] = HEAP32[$6_1 >> 2];
    HEAP32[$13_1 + 4 >> 2] = $0_1;
    $0_1 = HEAP32[$7_1 + 4 >> 2];
    HEAP32[$14_1 >> 2] = HEAP32[$7_1 >> 2];
    HEAP32[$14_1 + 4 >> 2] = $0_1;
    $0_1 = HEAP32[$8_1 + 4 >> 2];
    HEAP32[$15_1 >> 2] = HEAP32[$8_1 >> 2];
    HEAP32[$15_1 + 4 >> 2] = $0_1;
    $0_1 = HEAP32[$9_1 + 4 >> 2];
    HEAP32[$16_1 >> 2] = HEAP32[$9_1 >> 2];
    HEAP32[$16_1 + 4 >> 2] = $0_1;
   }
   $0_1 = HEAP32[$3_1 + 12 >> 2];
   HEAP32[$3_1 + 208 >> 2] = HEAP32[$3_1 + 8 >> 2];
   HEAP32[$3_1 + 212 >> 2] = $0_1;
   $1_1 = $3_1 + 208 | 0;
   $4_1 = $1_1 + 56 | 0;
   $2_1 = HEAP32[$4_1 + 4 >> 2];
   $0_1 = $3_1 + 80 | 0;
   $5_1 = $0_1 + 56 | 0;
   HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
   HEAP32[$5_1 + 4 >> 2] = $2_1;
   $4_1 = $1_1 + 48 | 0;
   $2_1 = HEAP32[$4_1 + 4 >> 2];
   $5_1 = $0_1 + 48 | 0;
   HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
   HEAP32[$5_1 + 4 >> 2] = $2_1;
   $4_1 = $1_1 + 40 | 0;
   $2_1 = HEAP32[$4_1 + 4 >> 2];
   $5_1 = $0_1 + 40 | 0;
   HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
   HEAP32[$5_1 + 4 >> 2] = $2_1;
   $4_1 = $1_1 + 32 | 0;
   $2_1 = HEAP32[$4_1 + 4 >> 2];
   $5_1 = $0_1 + 32 | 0;
   HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
   HEAP32[$5_1 + 4 >> 2] = $2_1;
   $4_1 = $1_1 + 24 | 0;
   $2_1 = HEAP32[$4_1 + 4 >> 2];
   $5_1 = $0_1 + 24 | 0;
   HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
   HEAP32[$5_1 + 4 >> 2] = $2_1;
   $4_1 = $1_1 + 16 | 0;
   $2_1 = HEAP32[$4_1 + 4 >> 2];
   $5_1 = $0_1 + 16 | 0;
   HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
   HEAP32[$5_1 + 4 >> 2] = $2_1;
   $1_1 = $1_1 + 8 | 0;
   $4_1 = HEAP32[$1_1 + 4 >> 2];
   $2_1 = $0_1 + 8 | 0;
   HEAP32[$2_1 >> 2] = HEAP32[$1_1 >> 2];
   HEAP32[$2_1 + 4 >> 2] = $4_1;
   $1_1 = HEAP32[$3_1 + 212 >> 2];
   HEAP32[$3_1 + 80 >> 2] = HEAP32[$3_1 + 208 >> 2];
   HEAP32[$3_1 + 84 >> 2] = $1_1;
   $0_1 = $58(HEAP32[172688], $0_1);
   HEAP32[$3_1 + 8 >> 2] = $0_1;
   if (($0_1 | 0) != 1) {
    break folding_inner0
   }
   global$0 = $3_1 + 272 | 0;
   return 1;
  }
  HEAP32[$3_1 + 216 >> 2] = 0;
  $5($3_1 + 208 | 0);
  wasm2js_trap();
 }
 
 function $17($0_1, $1_1) {
  $0_1 = $0_1 | 0;
  $1_1 = $1_1 | 0;
  var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0;
  $5_1 = global$0 - 208 | 0;
  global$0 = $5_1;
  $2_1 = $5_1 + 136 | 0;
  $4_1 = $2_1 + 56 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $4_1 = $2_1 + 48 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $4_1 = $2_1 + 40 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $4_1 = $2_1 + 32 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $4_1 = $2_1 + 24 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $4_1 = $2_1 + 16 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $4_1 = $2_1 + 8 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  HEAP32[$5_1 + 136 >> 2] = 0;
  HEAP32[$5_1 + 140 >> 2] = 0;
  label$1 : {
   if (($31(HEAP32[172688], $2_1, 690820, $0_1) | 0) == 1) {
    $10_1 = $5_1 + 136 | 0;
    $2_1 = $10_1 + 15 | 0;
    $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $4_1 = $5_1 + 72 | 0;
    $13_1 = $4_1 + 8 | 0;
    HEAP32[$13_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP32[$13_1 + 4 >> 2] = $0_1;
    $2_1 = $10_1 + 23 | 0;
    $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $12_1 = $4_1 + 16 | 0;
    HEAP32[$12_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP32[$12_1 + 4 >> 2] = $0_1;
    $2_1 = $10_1 + 31 | 0;
    $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $9_1 = $4_1 + 24 | 0;
    HEAP32[$9_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP32[$9_1 + 4 >> 2] = $0_1;
    $2_1 = $10_1 + 39 | 0;
    $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $7_1 = $4_1 + 32 | 0;
    HEAP32[$7_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP32[$7_1 + 4 >> 2] = $0_1;
    $2_1 = $10_1 + 47 | 0;
    $0_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $11_1 = $4_1 + 40 | 0;
    HEAP32[$11_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP32[$11_1 + 4 >> 2] = $0_1;
    $8_1 = $10_1 + 55 | 0;
    $0_1 = HEAPU8[$8_1 + 4 | 0] | HEAPU8[$8_1 + 5 | 0] << 8 | (HEAPU8[$8_1 + 6 | 0] << 16 | HEAPU8[$8_1 + 7 | 0] << 24);
    $2_1 = $4_1 + 48 | 0;
    HEAP32[$2_1 >> 2] = HEAPU8[$8_1 | 0] | HEAPU8[$8_1 + 1 | 0] << 8 | (HEAPU8[$8_1 + 2 | 0] << 16 | HEAPU8[$8_1 + 3 | 0] << 24);
    HEAP32[$2_1 + 4 >> 2] = $0_1;
    $4_1 = $4_1 + 56 | 0;
    HEAP8[$4_1 | 0] = HEAPU8[$10_1 + 63 | 0];
    HEAP8[$5_1 + 10 | 0] = HEAPU8[$5_1 + 138 | 0];
    HEAP16[$5_1 + 8 >> 1] = HEAPU16[$5_1 + 136 >> 1];
    $0_1 = HEAPU8[$5_1 + 147 | 0] | HEAPU8[$5_1 + 148 | 0] << 8 | (HEAPU8[$5_1 + 149 | 0] << 16 | HEAPU8[$5_1 + 150 | 0] << 24);
    HEAP32[$5_1 + 72 >> 2] = HEAPU8[$5_1 + 143 | 0] | HEAPU8[$5_1 + 144 | 0] << 8 | (HEAPU8[$5_1 + 145 | 0] << 16 | HEAPU8[$5_1 + 146 | 0] << 24);
    HEAP32[$5_1 + 76 >> 2] = $0_1;
    $10_1 = HEAPU8[$5_1 + 139 | 0] | HEAPU8[$5_1 + 140 | 0] << 8 | (HEAPU8[$5_1 + 141 | 0] << 16 | HEAPU8[$5_1 + 142 | 0] << 24);
    $3_1 = $5_1 + 8 | 0;
    HEAP8[$3_1 + 63 | 0] = HEAPU8[$4_1 | 0];
    $4_1 = HEAP32[$2_1 + 4 >> 2];
    $8_1 = $3_1 + 55 | 0;
    $0_1 = HEAP32[$2_1 >> 2];
    HEAP8[$8_1 | 0] = $0_1;
    HEAP8[$8_1 + 1 | 0] = $0_1 >>> 8;
    HEAP8[$8_1 + 2 | 0] = $0_1 >>> 16;
    HEAP8[$8_1 + 3 | 0] = $0_1 >>> 24;
    HEAP8[$8_1 + 4 | 0] = $4_1;
    HEAP8[$8_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$8_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$8_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$11_1 + 4 >> 2];
    $2_1 = $3_1 + 47 | 0;
    $0_1 = HEAP32[$11_1 >> 2];
    HEAP8[$2_1 | 0] = $0_1;
    HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
    HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
    HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
    HEAP8[$2_1 + 4 | 0] = $4_1;
    HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$7_1 + 4 >> 2];
    $2_1 = $3_1 + 39 | 0;
    $0_1 = HEAP32[$7_1 >> 2];
    HEAP8[$2_1 | 0] = $0_1;
    HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
    HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
    HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
    HEAP8[$2_1 + 4 | 0] = $4_1;
    HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$9_1 + 4 >> 2];
    $2_1 = $3_1 + 31 | 0;
    $0_1 = HEAP32[$9_1 >> 2];
    HEAP8[$2_1 | 0] = $0_1;
    HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
    HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
    HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
    HEAP8[$2_1 + 4 | 0] = $4_1;
    HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$12_1 + 4 >> 2];
    $2_1 = $3_1 + 23 | 0;
    $0_1 = HEAP32[$12_1 >> 2];
    HEAP8[$2_1 | 0] = $0_1;
    HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
    HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
    HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
    HEAP8[$2_1 + 4 | 0] = $4_1;
    HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$13_1 + 4 >> 2];
    $2_1 = $3_1 + 15 | 0;
    $0_1 = HEAP32[$13_1 >> 2];
    HEAP8[$2_1 | 0] = $0_1;
    HEAP8[$2_1 + 1 | 0] = $0_1 >>> 8;
    HEAP8[$2_1 + 2 | 0] = $0_1 >>> 16;
    HEAP8[$2_1 + 3 | 0] = $0_1 >>> 24;
    HEAP8[$2_1 + 4 | 0] = $4_1;
    HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
    HEAP8[$5_1 + 11 | 0] = $10_1;
    HEAP8[$5_1 + 12 | 0] = $10_1 >>> 8;
    HEAP8[$5_1 + 13 | 0] = $10_1 >>> 16;
    HEAP8[$5_1 + 14 | 0] = $10_1 >>> 24;
    $4_1 = HEAP32[$5_1 + 76 >> 2];
    $0_1 = HEAP32[$5_1 + 72 >> 2];
    HEAP8[$5_1 + 15 | 0] = $0_1;
    HEAP8[$5_1 + 16 | 0] = $0_1 >>> 8;
    HEAP8[$5_1 + 17 | 0] = $0_1 >>> 16;
    HEAP8[$5_1 + 18 | 0] = $0_1 >>> 24;
    HEAP8[$5_1 + 19 | 0] = $4_1;
    HEAP8[$5_1 + 20 | 0] = $4_1 >>> 8;
    HEAP8[$5_1 + 21 | 0] = $4_1 >>> 16;
    HEAP8[$5_1 + 22 | 0] = $4_1 >>> 24;
    $14_1 = $6();
    $6_1 = global$0 - 288 | 0;
    global$0 = $6_1;
    HEAP32[$6_1 + 4 >> 2] = 0;
    label$3 : {
     if (!$3_1) {
      FUNCTION_TABLE[HEAP32[$14_1 + 168 >> 2]](689638, HEAP32[$14_1 + 172 >> 2]);
      break label$3;
     }
     $38($6_1 + 8 | 0, 690949, $6_1 + 4 | 0);
     if (HEAP32[$6_1 + 4 >> 2]) {
      HEAP8[$3_1 | 0] = 0;
      HEAP8[$3_1 + 1 | 0] = 0;
      HEAP8[$3_1 + 2 | 0] = 0;
      HEAP8[$3_1 + 3 | 0] = 0;
      HEAP8[$3_1 + 4 | 0] = 0;
      HEAP8[$3_1 + 5 | 0] = 0;
      HEAP8[$3_1 + 6 | 0] = 0;
      HEAP8[$3_1 + 7 | 0] = 0;
      $0_1 = $3_1 + 56 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $3_1 + 48 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $3_1 + 40 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $3_1 + 32 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $3_1 + 24 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $3_1 + 16 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $3_1 + 8 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      break label$3;
     }
     $0_1 = HEAPU8[$3_1 + 60 | 0] | HEAPU8[$3_1 + 61 | 0] << 8 | (HEAPU8[$3_1 + 62 | 0] << 16 | HEAPU8[$3_1 + 63 | 0] << 24);
     $8_1 = $0_1 >>> 16 | 0;
     $11_1 = $6_1 + 112 | 0;
     $4_1 = HEAPU8[$3_1 + 56 | 0] | HEAPU8[$3_1 + 57 | 0] << 8 | (HEAPU8[$3_1 + 58 | 0] << 16 | HEAPU8[$3_1 + 59 | 0] << 24);
     HEAP32[$11_1 >> 2] = ($0_1 & 65535) << 16 | $4_1 >>> 16;
     HEAP32[$11_1 + 4 >> 2] = $8_1;
     $11_1 = $4_1 << 4 & 1048560;
     $0_1 = HEAPU8[$3_1 + 52 | 0] | HEAPU8[$3_1 + 53 | 0] << 8 | (HEAPU8[$3_1 + 54 | 0] << 16 | HEAPU8[$3_1 + 55 | 0] << 24);
     $8_1 = $0_1 >>> 28 | 0;
     $7_1 = $6_1 + 104 | 0;
     $4_1 = HEAPU8[$3_1 + 48 | 0] | HEAPU8[$3_1 + 49 | 0] << 8 | (HEAPU8[$3_1 + 50 | 0] << 16 | HEAPU8[$3_1 + 51 | 0] << 24);
     HEAP32[$7_1 >> 2] = ($0_1 & 268435455) << 4 | $4_1 >>> 28;
     HEAP32[$7_1 + 4 >> 2] = $8_1 | $11_1;
     $8_1 = $0_1 << 24 | $4_1 >>> 8;
     $7_1 = $4_1 << 24 & -16777216;
     $4_1 = HEAPU8[$3_1 + 40 | 0] | HEAPU8[$3_1 + 41 | 0] << 8 | (HEAPU8[$3_1 + 42 | 0] << 16 | HEAPU8[$3_1 + 43 | 0] << 24);
     $9_1 = $6_1 + 40 | 0;
     $12_1 = $9_1 + 56 | 0;
     $0_1 = HEAPU8[$3_1 + 44 | 0] | HEAPU8[$3_1 + 45 | 0] << 8 | (HEAPU8[$3_1 + 46 | 0] << 16 | HEAPU8[$3_1 + 47 | 0] << 24);
     HEAP32[$12_1 >> 2] = $0_1 >>> 8 | $7_1;
     HEAP32[$12_1 + 4 >> 2] = $8_1 & 1048575;
     $12_1 = $0_1 << 12 | $4_1 >>> 20;
     $7_1 = $4_1 << 12 & -4096;
     $2_1 = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
     $0_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
     $9_1 = $9_1 + 48 | 0;
     HEAP32[$9_1 >> 2] = $0_1 >>> 20 | $7_1;
     HEAP32[$9_1 + 4 >> 2] = $12_1 & 1048575;
     HEAP32[$6_1 + 120 >> 2] = 0;
     HEAP32[$6_1 + 80 >> 2] = $2_1;
     HEAP32[$6_1 + 84 >> 2] = $0_1 & 1048575;
     $2_1 = HEAPU8[$3_1 + 12 | 0] | HEAPU8[$3_1 + 13 | 0] << 8 | (HEAPU8[$3_1 + 14 | 0] << 16 | HEAPU8[$3_1 + 15 | 0] << 24);
     $10_1 = $2_1;
     $4_1 = HEAPU8[$3_1 + 8 | 0] | HEAPU8[$3_1 + 9 | 0] << 8 | (HEAPU8[$3_1 + 10 | 0] << 16 | HEAPU8[$3_1 + 11 | 0] << 24);
     $8_1 = $2_1 << 12 | $4_1 >>> 20;
     $7_1 = $4_1 << 12 & -4096;
     $13_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
     $4_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
     $2_1 = $4_1;
     $0_1 = $6_1;
     $15_1 = $2_1 >>> 20 | $7_1;
     HEAP32[$0_1 + 48 >> 2] = $15_1;
     $16_1 = $8_1 & 1048575;
     HEAP32[$0_1 + 52 >> 2] = $16_1;
     HEAP32[$0_1 + 40 >> 2] = $13_1;
     $17_1 = $2_1 & 1048575;
     HEAP32[$0_1 + 44 >> 2] = $17_1;
     $4_1 = HEAPU8[$3_1 + 24 | 0] | HEAPU8[$3_1 + 25 | 0] << 8 | (HEAPU8[$3_1 + 26 | 0] << 16 | HEAPU8[$3_1 + 27 | 0] << 24);
     $12_1 = $4_1;
     $2_1 = HEAPU8[$3_1 + 28 | 0] | HEAPU8[$3_1 + 29 | 0] << 8 | (HEAPU8[$3_1 + 30 | 0] << 16 | HEAPU8[$3_1 + 31 | 0] << 24);
     $11_1 = ($2_1 & 65535) << 16 | $4_1 >>> 16;
     HEAP32[$0_1 + 72 >> 2] = $11_1;
     $7_1 = $2_1 >>> 16 | 0;
     HEAP32[$0_1 + 76 >> 2] = $7_1;
     $4_1 = HEAPU8[$3_1 + 16 | 0] | HEAPU8[$3_1 + 17 | 0] << 8 | (HEAPU8[$3_1 + 18 | 0] << 16 | HEAPU8[$3_1 + 19 | 0] << 24);
     $2_1 = HEAPU8[$3_1 + 20 | 0] | HEAPU8[$3_1 + 21 | 0] << 8 | (HEAPU8[$3_1 + 22 | 0] << 16 | HEAPU8[$3_1 + 23 | 0] << 24);
     $8_1 = $2_1 << 24 | $4_1 >>> 8;
     $18_1 = $4_1 << 24 & -16777216 | $10_1 >>> 8;
     HEAP32[$0_1 + 56 >> 2] = $18_1;
     $10_1 = $8_1 & 1048575;
     HEAP32[$0_1 + 60 >> 2] = $10_1;
     $9_1 = $12_1 << 4 & 1048560;
     $4_1 = ($2_1 & 268435455) << 4 | $4_1 >>> 28;
     HEAP32[$0_1 + 64 >> 2] = $4_1;
     $0_1 = $2_1 >>> 28 | $9_1;
     HEAP32[$6_1 + 68 >> 2] = $0_1;
     if (!($13_1 | $15_1 | $11_1 | $18_1 | $4_1 | ($16_1 | $17_1 | $7_1 | $10_1 | $0_1))) {
      FUNCTION_TABLE[HEAP32[$14_1 + 168 >> 2]](690116, HEAP32[$14_1 + 172 >> 2]);
      $0_1 = $3_1 + 56 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $3_1 + 48 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $3_1 + 40 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $3_1 + 32 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $3_1 + 24 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $3_1 + 16 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      $0_1 = $3_1 + 8 | 0;
      HEAP8[$0_1 | 0] = 0;
      HEAP8[$0_1 + 1 | 0] = 0;
      HEAP8[$0_1 + 2 | 0] = 0;
      HEAP8[$0_1 + 3 | 0] = 0;
      HEAP8[$0_1 + 4 | 0] = 0;
      HEAP8[$0_1 + 5 | 0] = 0;
      HEAP8[$0_1 + 6 | 0] = 0;
      HEAP8[$0_1 + 7 | 0] = 0;
      HEAP8[$3_1 | 0] = 0;
      HEAP8[$3_1 + 1 | 0] = 0;
      HEAP8[$3_1 + 2 | 0] = 0;
      HEAP8[$3_1 + 3 | 0] = 0;
      HEAP8[$3_1 + 4 | 0] = 0;
      HEAP8[$3_1 + 5 | 0] = 0;
      HEAP8[$3_1 + 6 | 0] = 0;
      HEAP8[$3_1 + 7 | 0] = 0;
      break label$3;
     }
     HEAP8[$3_1 | 0] = 0;
     HEAP8[$3_1 + 1 | 0] = 0;
     HEAP8[$3_1 + 2 | 0] = 0;
     HEAP8[$3_1 + 3 | 0] = 0;
     HEAP8[$3_1 + 4 | 0] = 0;
     HEAP8[$3_1 + 5 | 0] = 0;
     HEAP8[$3_1 + 6 | 0] = 0;
     HEAP8[$3_1 + 7 | 0] = 0;
     $0_1 = $3_1 + 56 | 0;
     HEAP8[$0_1 | 0] = 0;
     HEAP8[$0_1 + 1 | 0] = 0;
     HEAP8[$0_1 + 2 | 0] = 0;
     HEAP8[$0_1 + 3 | 0] = 0;
     HEAP8[$0_1 + 4 | 0] = 0;
     HEAP8[$0_1 + 5 | 0] = 0;
     HEAP8[$0_1 + 6 | 0] = 0;
     HEAP8[$0_1 + 7 | 0] = 0;
     $0_1 = $3_1 + 48 | 0;
     HEAP8[$0_1 | 0] = 0;
     HEAP8[$0_1 + 1 | 0] = 0;
     HEAP8[$0_1 + 2 | 0] = 0;
     HEAP8[$0_1 + 3 | 0] = 0;
     HEAP8[$0_1 + 4 | 0] = 0;
     HEAP8[$0_1 + 5 | 0] = 0;
     HEAP8[$0_1 + 6 | 0] = 0;
     HEAP8[$0_1 + 7 | 0] = 0;
     $0_1 = $3_1 + 40 | 0;
     HEAP8[$0_1 | 0] = 0;
     HEAP8[$0_1 + 1 | 0] = 0;
     HEAP8[$0_1 + 2 | 0] = 0;
     HEAP8[$0_1 + 3 | 0] = 0;
     HEAP8[$0_1 + 4 | 0] = 0;
     HEAP8[$0_1 + 5 | 0] = 0;
     HEAP8[$0_1 + 6 | 0] = 0;
     HEAP8[$0_1 + 7 | 0] = 0;
     $0_1 = $3_1 + 32 | 0;
     HEAP8[$0_1 | 0] = 0;
     HEAP8[$0_1 + 1 | 0] = 0;
     HEAP8[$0_1 + 2 | 0] = 0;
     HEAP8[$0_1 + 3 | 0] = 0;
     HEAP8[$0_1 + 4 | 0] = 0;
     HEAP8[$0_1 + 5 | 0] = 0;
     HEAP8[$0_1 + 6 | 0] = 0;
     HEAP8[$0_1 + 7 | 0] = 0;
     $0_1 = $3_1 + 24 | 0;
     HEAP8[$0_1 | 0] = 0;
     HEAP8[$0_1 + 1 | 0] = 0;
     HEAP8[$0_1 + 2 | 0] = 0;
     HEAP8[$0_1 + 3 | 0] = 0;
     HEAP8[$0_1 + 4 | 0] = 0;
     HEAP8[$0_1 + 5 | 0] = 0;
     HEAP8[$0_1 + 6 | 0] = 0;
     HEAP8[$0_1 + 7 | 0] = 0;
     $0_1 = $3_1 + 16 | 0;
     HEAP8[$0_1 | 0] = 0;
     HEAP8[$0_1 + 1 | 0] = 0;
     HEAP8[$0_1 + 2 | 0] = 0;
     HEAP8[$0_1 + 3 | 0] = 0;
     HEAP8[$0_1 + 4 | 0] = 0;
     HEAP8[$0_1 + 5 | 0] = 0;
     HEAP8[$0_1 + 6 | 0] = 0;
     HEAP8[$0_1 + 7 | 0] = 0;
     $0_1 = $3_1 + 8 | 0;
     HEAP8[$0_1 | 0] = 0;
     HEAP8[$0_1 + 1 | 0] = 0;
     HEAP8[$0_1 + 2 | 0] = 0;
     HEAP8[$0_1 + 3 | 0] = 0;
     HEAP8[$0_1 + 4 | 0] = 0;
     HEAP8[$0_1 + 5 | 0] = 0;
     HEAP8[$0_1 + 6 | 0] = 0;
     HEAP8[$0_1 + 7 | 0] = 0;
     if (!(HEAP32[$6_1 + 32 >> 2] | (HEAP32[$6_1 + 24 >> 2] | (HEAP32[$6_1 + 16 >> 2] | HEAP32[$6_1 + 8 >> 2])) | (HEAP32[$6_1 + 36 >> 2] | (HEAP32[$6_1 + 28 >> 2] | (HEAP32[$6_1 + 20 >> 2] | HEAP32[$6_1 + 12 >> 2]))))) {
      break label$3
     }
     $11_1 = $6_1 + 256 | 0;
     $0_1 = $11_1 + 24 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     $0_1 = $11_1 + 16 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     $0_1 = $11_1 + 8 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     $7_1 = $6_1 + 40 | 0;
     $2_1 = $7_1 + 8 | 0;
     $4_1 = HEAP32[$2_1 + 4 >> 2];
     $9_1 = $6_1 + 128 | 0;
     $0_1 = $9_1 + 8 | 0;
     HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
     HEAP32[$0_1 + 4 >> 2] = $4_1;
     $2_1 = $7_1 + 16 | 0;
     $4_1 = HEAP32[$2_1 + 4 >> 2];
     $0_1 = $9_1 + 16 | 0;
     HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
     HEAP32[$0_1 + 4 >> 2] = $4_1;
     $2_1 = $7_1 + 24 | 0;
     $4_1 = HEAP32[$2_1 + 4 >> 2];
     $0_1 = $9_1 + 24 | 0;
     HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
     HEAP32[$0_1 + 4 >> 2] = $4_1;
     $2_1 = $7_1 + 32 | 0;
     $4_1 = HEAP32[$2_1 + 4 >> 2];
     $0_1 = $9_1 + 32 | 0;
     HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
     HEAP32[$0_1 + 4 >> 2] = $4_1;
     $2_1 = $7_1 + 48 | 0;
     $4_1 = HEAP32[$2_1 + 4 >> 2];
     $0_1 = $9_1 + 48 | 0;
     HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
     HEAP32[$0_1 + 4 >> 2] = $4_1;
     $2_1 = $7_1 + 56 | 0;
     $4_1 = HEAP32[$2_1 + 4 >> 2];
     $0_1 = $9_1 + 56 | 0;
     HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
     HEAP32[$0_1 + 4 >> 2] = $4_1;
     $2_1 = $7_1 - -64 | 0;
     $4_1 = HEAP32[$2_1 + 4 >> 2];
     $0_1 = $9_1 - -64 | 0;
     HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
     HEAP32[$0_1 + 4 >> 2] = $4_1;
     $2_1 = $7_1 + 72 | 0;
     $4_1 = HEAP32[$2_1 + 4 >> 2];
     $0_1 = $9_1 + 72 | 0;
     HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
     HEAP32[$0_1 + 4 >> 2] = $4_1;
     HEAP32[$6_1 + 256 >> 2] = 0;
     HEAP32[$6_1 + 260 >> 2] = 0;
     HEAP32[$6_1 + 248 >> 2] = 0;
     $0_1 = HEAP32[$6_1 + 44 >> 2];
     HEAP32[$6_1 + 128 >> 2] = HEAP32[$6_1 + 40 >> 2];
     HEAP32[$6_1 + 132 >> 2] = $0_1;
     $0_1 = HEAP32[$6_1 + 84 >> 2];
     HEAP32[$6_1 + 168 >> 2] = HEAP32[$6_1 + 80 >> 2];
     HEAP32[$6_1 + 172 >> 2] = $0_1;
     $0_1 = $6_1 + 240 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     $0_1 = $6_1 + 232 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     $0_1 = $6_1 + 224 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     $0_1 = $6_1 + 216 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     HEAP32[$6_1 + 208 >> 2] = 1;
     HEAP32[$6_1 + 212 >> 2] = 0;
     $42($9_1, $9_1, $6_1 + 8 | 0, $11_1);
     $49($7_1, $9_1);
     $35($3_1, $7_1);
     $19_1 = 1;
    }
    global$0 = $6_1 + 288 | 0;
    if (!$19_1) {
     break label$1
    }
    HEAP32[$5_1 + 204 >> 2] = $1_1;
    $0_1 = $36(HEAP32[172688], $5_1 + 204 | 0, $5_1 + 8 | 0, ($1_1 | 0) == 33 ? 258 : 2);
    HEAP32[$5_1 + 72 >> 2] = $0_1;
    $20_1 = 1;
    if (($0_1 | 0) == 1) {
     break label$1
    }
    HEAP32[$5_1 + 144 >> 2] = 0;
    $5($5_1 + 136 | 0);
    wasm2js_trap();
   }
   fimport$1(1);
  }
  global$0 = $5_1 + 208 | 0;
  return $20_1 | 0;
 }
 
 function $18() {
  return ($52() | 0) == 1 | 0;
 }
 
 function $19() {
  var $0_1 = 0, $1_1 = 0;
  $0_1 = global$0 - 32 | 0;
  global$0 = $0_1;
  $1_1 = $51(HEAP32[172688], 690949);
  HEAP32[$0_1 + 4 >> 2] = $1_1;
  if (($1_1 | 0) == 1) {
   $1_1 = $52();
   global$0 = $0_1 + 32 | 0;
   return ($1_1 | 0) == 1 | 0;
  }
  HEAP32[$0_1 + 16 >> 2] = 0;
  $5($0_1 + 8 | 0);
  wasm2js_trap();
 }
 
 function $20() {
  var $0_1 = 0, $1_1 = 0;
  $0_1 = global$0 - 32 | 0;
  global$0 = $0_1;
  $1_1 = $51(HEAP32[172688], 690788);
  HEAP32[$0_1 + 4 >> 2] = $1_1;
  if (($1_1 | 0) == 1) {
   global$0 = $0_1 + 32 | 0;
   return;
  }
  HEAP32[$0_1 + 16 >> 2] = 0;
  $5($0_1 + 8 | 0);
  wasm2js_trap();
 }
 
 function $21($0_1) {
  $0_1 = $0_1 | 0;
  var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0;
  $3_1 = global$0 - 96 | 0;
  global$0 = $3_1;
  $1_1 = $3_1 + 56 | 0;
  HEAP32[$1_1 >> 2] = 0;
  HEAP32[$1_1 + 4 >> 2] = 0;
  $1_1 = $3_1 + 48 | 0;
  HEAP32[$1_1 >> 2] = 0;
  HEAP32[$1_1 + 4 >> 2] = 0;
  $1_1 = $3_1 + 40 | 0;
  HEAP32[$1_1 >> 2] = 0;
  HEAP32[$1_1 + 4 >> 2] = 0;
  $1_1 = $3_1 + 32 | 0;
  HEAP32[$1_1 >> 2] = 0;
  HEAP32[$1_1 + 4 >> 2] = 0;
  $1_1 = $3_1 + 24 | 0;
  HEAP32[$1_1 >> 2] = 0;
  HEAP32[$1_1 + 4 >> 2] = 0;
  $1_1 = $3_1 + 16 | 0;
  HEAP32[$1_1 >> 2] = 0;
  HEAP32[$1_1 + 4 >> 2] = 0;
  $1_1 = $3_1 + 8 | 0;
  HEAP32[$1_1 >> 2] = 0;
  HEAP32[$1_1 + 4 >> 2] = 0;
  HEAP32[$3_1 >> 2] = 0;
  HEAP32[$3_1 + 4 >> 2] = 0;
  $2_1 = $6();
  $5_1 = HEAP32[172560];
  $0_1 = $0_1 ? 655681 : 0;
  $1_1 = global$0 + -64 | 0;
  global$0 = $1_1;
  label$1 : {
   if (!HEAP32[$2_1 >> 2]) {
    FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](690045, HEAP32[$2_1 + 172 >> 2]);
    $0_1 = 0;
    break label$1;
   }
   if (!$3_1) {
    FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689760, HEAP32[$2_1 + 172 >> 2]);
    $0_1 = 0;
    break label$1;
   }
   $4_1 = $1_1 + 32 | 0;
   $0_1 = $47($2_1, $4_1, $1_1, 0, $5_1, $0_1);
   $6_1 = $4_1 + 24 | 0;
   $5_1 = HEAP32[$6_1 + 4 >> 2];
   $2_1 = $3_1 + 24 | 0;
   $6_1 = HEAP32[$6_1 >> 2];
   HEAP8[$2_1 | 0] = $6_1;
   HEAP8[$2_1 + 1 | 0] = $6_1 >>> 8;
   HEAP8[$2_1 + 2 | 0] = $6_1 >>> 16;
   HEAP8[$2_1 + 3 | 0] = $6_1 >>> 24;
   HEAP8[$2_1 + 4 | 0] = $5_1;
   HEAP8[$2_1 + 5 | 0] = $5_1 >>> 8;
   HEAP8[$2_1 + 6 | 0] = $5_1 >>> 16;
   HEAP8[$2_1 + 7 | 0] = $5_1 >>> 24;
   $6_1 = $4_1 + 16 | 0;
   $5_1 = HEAP32[$6_1 + 4 >> 2];
   $2_1 = $3_1 + 16 | 0;
   $6_1 = HEAP32[$6_1 >> 2];
   HEAP8[$2_1 | 0] = $6_1;
   HEAP8[$2_1 + 1 | 0] = $6_1 >>> 8;
   HEAP8[$2_1 + 2 | 0] = $6_1 >>> 16;
   HEAP8[$2_1 + 3 | 0] = $6_1 >>> 24;
   HEAP8[$2_1 + 4 | 0] = $5_1;
   HEAP8[$2_1 + 5 | 0] = $5_1 >>> 8;
   HEAP8[$2_1 + 6 | 0] = $5_1 >>> 16;
   HEAP8[$2_1 + 7 | 0] = $5_1 >>> 24;
   $4_1 = $4_1 + 8 | 0;
   $5_1 = HEAP32[$4_1 + 4 >> 2];
   $2_1 = $3_1 + 8 | 0;
   $4_1 = HEAP32[$4_1 >> 2];
   HEAP8[$2_1 | 0] = $4_1;
   HEAP8[$2_1 + 1 | 0] = $4_1 >>> 8;
   HEAP8[$2_1 + 2 | 0] = $4_1 >>> 16;
   HEAP8[$2_1 + 3 | 0] = $4_1 >>> 24;
   HEAP8[$2_1 + 4 | 0] = $5_1;
   HEAP8[$2_1 + 5 | 0] = $5_1 >>> 8;
   HEAP8[$2_1 + 6 | 0] = $5_1 >>> 16;
   HEAP8[$2_1 + 7 | 0] = $5_1 >>> 24;
   $2_1 = HEAP32[$1_1 + 36 >> 2];
   $5_1 = HEAP32[$1_1 + 32 >> 2];
   HEAP8[$3_1 | 0] = $5_1;
   HEAP8[$3_1 + 1 | 0] = $5_1 >>> 8;
   HEAP8[$3_1 + 2 | 0] = $5_1 >>> 16;
   HEAP8[$3_1 + 3 | 0] = $5_1 >>> 24;
   HEAP8[$3_1 + 4 | 0] = $2_1;
   HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
   HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
   HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
   $2_1 = HEAP32[$1_1 + 4 >> 2];
   $5_1 = HEAP32[$1_1 >> 2];
   HEAP8[$3_1 + 32 | 0] = $5_1;
   HEAP8[$3_1 + 33 | 0] = $5_1 >>> 8;
   HEAP8[$3_1 + 34 | 0] = $5_1 >>> 16;
   HEAP8[$3_1 + 35 | 0] = $5_1 >>> 24;
   HEAP8[$3_1 + 36 | 0] = $2_1;
   HEAP8[$3_1 + 37 | 0] = $2_1 >>> 8;
   HEAP8[$3_1 + 38 | 0] = $2_1 >>> 16;
   HEAP8[$3_1 + 39 | 0] = $2_1 >>> 24;
   $4_1 = $1_1 + 8 | 0;
   $5_1 = HEAP32[$4_1 + 4 >> 2];
   $2_1 = $3_1 + 40 | 0;
   $4_1 = HEAP32[$4_1 >> 2];
   HEAP8[$2_1 | 0] = $4_1;
   HEAP8[$2_1 + 1 | 0] = $4_1 >>> 8;
   HEAP8[$2_1 + 2 | 0] = $4_1 >>> 16;
   HEAP8[$2_1 + 3 | 0] = $4_1 >>> 24;
   HEAP8[$2_1 + 4 | 0] = $5_1;
   HEAP8[$2_1 + 5 | 0] = $5_1 >>> 8;
   HEAP8[$2_1 + 6 | 0] = $5_1 >>> 16;
   HEAP8[$2_1 + 7 | 0] = $5_1 >>> 24;
   $4_1 = $1_1 + 16 | 0;
   $5_1 = HEAP32[$4_1 + 4 >> 2];
   $2_1 = $3_1 + 48 | 0;
   $4_1 = HEAP32[$4_1 >> 2];
   HEAP8[$2_1 | 0] = $4_1;
   HEAP8[$2_1 + 1 | 0] = $4_1 >>> 8;
   HEAP8[$2_1 + 2 | 0] = $4_1 >>> 16;
   HEAP8[$2_1 + 3 | 0] = $4_1 >>> 24;
   HEAP8[$2_1 + 4 | 0] = $5_1;
   HEAP8[$2_1 + 5 | 0] = $5_1 >>> 8;
   HEAP8[$2_1 + 6 | 0] = $5_1 >>> 16;
   HEAP8[$2_1 + 7 | 0] = $5_1 >>> 24;
   $4_1 = $1_1 + 24 | 0;
   $5_1 = HEAP32[$4_1 + 4 >> 2];
   $2_1 = $3_1 + 56 | 0;
   $4_1 = HEAP32[$4_1 >> 2];
   HEAP8[$2_1 | 0] = $4_1;
   HEAP8[$2_1 + 1 | 0] = $4_1 >>> 8;
   HEAP8[$2_1 + 2 | 0] = $4_1 >>> 16;
   HEAP8[$2_1 + 3 | 0] = $4_1 >>> 24;
   HEAP8[$2_1 + 4 | 0] = $5_1;
   HEAP8[$2_1 + 5 | 0] = $5_1 >>> 8;
   HEAP8[$2_1 + 6 | 0] = $5_1 >>> 16;
   HEAP8[$2_1 + 7 | 0] = $5_1 >>> 24;
  }
  global$0 = $1_1 - -64 | 0;
  HEAP32[$3_1 + 68 >> 2] = $0_1;
  label$4 : {
   label$5 : {
    if (($0_1 | 0) == 1) {
     $1_1 = HEAP32[172688];
     $0_1 = global$0 + -64 | 0;
     global$0 = $0_1;
     label$7 : {
      if (!$3_1) {
       FUNCTION_TABLE[HEAP32[$1_1 + 168 >> 2]](689748, HEAP32[$1_1 + 172 >> 2]);
       $1_1 = 0;
       break label$7;
      }
      $1_1 = $3_1 + 24 | 0;
      $5_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
      $2_1 = $0_1 + 32 | 0;
      $4_1 = $2_1 + 24 | 0;
      HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $1_1 = $3_1 + 16 | 0;
      $5_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
      $4_1 = $2_1 + 16 | 0;
      HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $1_1 = $3_1 + 8 | 0;
      $5_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
      $4_1 = $2_1 + 8 | 0;
      HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $1_1 = $3_1 + 40 | 0;
      $5_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
      $4_1 = $0_1 + 8 | 0;
      HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $1_1 = $3_1 + 48 | 0;
      $5_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
      $4_1 = $0_1 + 16 | 0;
      HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $1_1 = $3_1 + 56 | 0;
      $5_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
      $4_1 = $0_1 + 24 | 0;
      HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
      HEAP32[$4_1 + 4 >> 2] = $5_1;
      $1_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
      HEAP32[$0_1 + 32 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
      HEAP32[$0_1 + 36 >> 2] = $1_1;
      $1_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
      HEAP32[$0_1 >> 2] = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
      HEAP32[$0_1 + 4 >> 2] = $1_1;
      $39(690981, $2_1);
      $39(691013, $0_1);
      $1_1 = 1;
     }
     global$0 = $0_1 - -64 | 0;
     HEAP32[$3_1 + 68 >> 2] = $1_1;
     if (($1_1 | 0) == 1) {
      break label$5
     }
     break label$4;
    }
    break label$4;
   }
   global$0 = $3_1 + 96 | 0;
   return;
  }
  HEAP32[$3_1 + 80 >> 2] = 0;
  $5($3_1 + 72 | 0);
  wasm2js_trap();
 }
 
 function $22($0_1) {
  $0_1 = $0_1 | 0;
  var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0;
  $8_1 = global$0 - 112 | 0;
  global$0 = $8_1;
  $5_1 = $8_1 + 16 | 0;
  $68($5_1, 65);
  $1_1 = $6();
  $3_1 = HEAP32[172560];
  $0_1 = $0_1 ? 655681 : 0;
  $2_1 = global$0 - 80 | 0;
  global$0 = $2_1;
  label$1 : {
   if (!HEAP32[$1_1 >> 2]) {
    FUNCTION_TABLE[HEAP32[$1_1 + 168 >> 2]](690045, HEAP32[$1_1 + 172 >> 2]);
    $0_1 = 0;
    break label$1;
   }
   if (!$5_1) {
    FUNCTION_TABLE[HEAP32[$1_1 + 168 >> 2]](689760, HEAP32[$1_1 + 172 >> 2]);
    $0_1 = 0;
    break label$1;
   }
   $4_1 = $2_1 + 48 | 0;
   $7_1 = $2_1 + 16 | 0;
   $0_1 = $47($1_1, $4_1, $7_1, $2_1 + 12 | 0, $3_1, $0_1);
   $1_1 = HEAP32[$2_1 + 52 >> 2];
   $3_1 = HEAP32[$2_1 + 48 >> 2];
   HEAP8[$5_1 | 0] = $3_1;
   HEAP8[$5_1 + 1 | 0] = $3_1 >>> 8;
   HEAP8[$5_1 + 2 | 0] = $3_1 >>> 16;
   HEAP8[$5_1 + 3 | 0] = $3_1 >>> 24;
   HEAP8[$5_1 + 4 | 0] = $1_1;
   HEAP8[$5_1 + 5 | 0] = $1_1 >>> 8;
   HEAP8[$5_1 + 6 | 0] = $1_1 >>> 16;
   HEAP8[$5_1 + 7 | 0] = $1_1 >>> 24;
   $6_1 = $4_1 + 8 | 0;
   $3_1 = HEAP32[$6_1 + 4 >> 2];
   $1_1 = $5_1 + 8 | 0;
   $6_1 = HEAP32[$6_1 >> 2];
   HEAP8[$1_1 | 0] = $6_1;
   HEAP8[$1_1 + 1 | 0] = $6_1 >>> 8;
   HEAP8[$1_1 + 2 | 0] = $6_1 >>> 16;
   HEAP8[$1_1 + 3 | 0] = $6_1 >>> 24;
   HEAP8[$1_1 + 4 | 0] = $3_1;
   HEAP8[$1_1 + 5 | 0] = $3_1 >>> 8;
   HEAP8[$1_1 + 6 | 0] = $3_1 >>> 16;
   HEAP8[$1_1 + 7 | 0] = $3_1 >>> 24;
   $6_1 = $4_1 + 16 | 0;
   $3_1 = HEAP32[$6_1 + 4 >> 2];
   $1_1 = $5_1 + 16 | 0;
   $6_1 = HEAP32[$6_1 >> 2];
   HEAP8[$1_1 | 0] = $6_1;
   HEAP8[$1_1 + 1 | 0] = $6_1 >>> 8;
   HEAP8[$1_1 + 2 | 0] = $6_1 >>> 16;
   HEAP8[$1_1 + 3 | 0] = $6_1 >>> 24;
   HEAP8[$1_1 + 4 | 0] = $3_1;
   HEAP8[$1_1 + 5 | 0] = $3_1 >>> 8;
   HEAP8[$1_1 + 6 | 0] = $3_1 >>> 16;
   HEAP8[$1_1 + 7 | 0] = $3_1 >>> 24;
   $4_1 = $4_1 + 24 | 0;
   $3_1 = HEAP32[$4_1 + 4 >> 2];
   $1_1 = $5_1 + 24 | 0;
   $4_1 = HEAP32[$4_1 >> 2];
   HEAP8[$1_1 | 0] = $4_1;
   HEAP8[$1_1 + 1 | 0] = $4_1 >>> 8;
   HEAP8[$1_1 + 2 | 0] = $4_1 >>> 16;
   HEAP8[$1_1 + 3 | 0] = $4_1 >>> 24;
   HEAP8[$1_1 + 4 | 0] = $3_1;
   HEAP8[$1_1 + 5 | 0] = $3_1 >>> 8;
   HEAP8[$1_1 + 6 | 0] = $3_1 >>> 16;
   HEAP8[$1_1 + 7 | 0] = $3_1 >>> 24;
   $1_1 = HEAP32[$2_1 + 20 >> 2];
   $3_1 = HEAP32[$2_1 + 16 >> 2];
   HEAP8[$5_1 + 32 | 0] = $3_1;
   HEAP8[$5_1 + 33 | 0] = $3_1 >>> 8;
   HEAP8[$5_1 + 34 | 0] = $3_1 >>> 16;
   HEAP8[$5_1 + 35 | 0] = $3_1 >>> 24;
   HEAP8[$5_1 + 36 | 0] = $1_1;
   HEAP8[$5_1 + 37 | 0] = $1_1 >>> 8;
   HEAP8[$5_1 + 38 | 0] = $1_1 >>> 16;
   HEAP8[$5_1 + 39 | 0] = $1_1 >>> 24;
   $4_1 = $7_1 + 8 | 0;
   $3_1 = HEAP32[$4_1 + 4 >> 2];
   $1_1 = $5_1 + 40 | 0;
   $4_1 = HEAP32[$4_1 >> 2];
   HEAP8[$1_1 | 0] = $4_1;
   HEAP8[$1_1 + 1 | 0] = $4_1 >>> 8;
   HEAP8[$1_1 + 2 | 0] = $4_1 >>> 16;
   HEAP8[$1_1 + 3 | 0] = $4_1 >>> 24;
   HEAP8[$1_1 + 4 | 0] = $3_1;
   HEAP8[$1_1 + 5 | 0] = $3_1 >>> 8;
   HEAP8[$1_1 + 6 | 0] = $3_1 >>> 16;
   HEAP8[$1_1 + 7 | 0] = $3_1 >>> 24;
   $4_1 = $7_1 + 16 | 0;
   $3_1 = HEAP32[$4_1 + 4 >> 2];
   $1_1 = $5_1 + 48 | 0;
   $4_1 = HEAP32[$4_1 >> 2];
   HEAP8[$1_1 | 0] = $4_1;
   HEAP8[$1_1 + 1 | 0] = $4_1 >>> 8;
   HEAP8[$1_1 + 2 | 0] = $4_1 >>> 16;
   HEAP8[$1_1 + 3 | 0] = $4_1 >>> 24;
   HEAP8[$1_1 + 4 | 0] = $3_1;
   HEAP8[$1_1 + 5 | 0] = $3_1 >>> 8;
   HEAP8[$1_1 + 6 | 0] = $3_1 >>> 16;
   HEAP8[$1_1 + 7 | 0] = $3_1 >>> 24;
   $4_1 = $7_1 + 24 | 0;
   $3_1 = HEAP32[$4_1 + 4 >> 2];
   $1_1 = $5_1 + 56 | 0;
   $4_1 = HEAP32[$4_1 >> 2];
   HEAP8[$1_1 | 0] = $4_1;
   HEAP8[$1_1 + 1 | 0] = $4_1 >>> 8;
   HEAP8[$1_1 + 2 | 0] = $4_1 >>> 16;
   HEAP8[$1_1 + 3 | 0] = $4_1 >>> 24;
   HEAP8[$1_1 + 4 | 0] = $3_1;
   HEAP8[$1_1 + 5 | 0] = $3_1 >>> 8;
   HEAP8[$1_1 + 6 | 0] = $3_1 >>> 16;
   HEAP8[$1_1 + 7 | 0] = $3_1 >>> 24;
   HEAP8[$5_1 + 64 | 0] = HEAP32[$2_1 + 12 >> 2];
  }
  global$0 = $2_1 + 80 | 0;
  HEAP32[$8_1 + 84 >> 2] = $0_1;
  if (($0_1 | 0) == 1) {
   HEAP32[$8_1 + 12 >> 2] = 0;
   $2_1 = HEAP32[172688];
   $3_1 = $8_1 + 12 | 0;
   $5_1 = global$0 + -64 | 0;
   global$0 = $5_1;
   $0_1 = $8_1 + 16 | 0;
   label$5 : {
    if (!$0_1) {
     FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689748, HEAP32[$2_1 + 172 >> 2]);
     break label$5;
    }
    if (!$3_1) {
     FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689795, HEAP32[$2_1 + 172 >> 2]);
     break label$5;
    }
    $2_1 = $0_1 + 24 | 0;
    $4_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $1_1 = $5_1 + 32 | 0;
    $7_1 = $1_1 + 24 | 0;
    HEAP32[$7_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP32[$7_1 + 4 >> 2] = $4_1;
    $2_1 = $0_1 + 16 | 0;
    $4_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $7_1 = $1_1 + 16 | 0;
    HEAP32[$7_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP32[$7_1 + 4 >> 2] = $4_1;
    $2_1 = $0_1 + 8 | 0;
    $4_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $7_1 = $1_1 + 8 | 0;
    HEAP32[$7_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    HEAP32[$7_1 + 4 >> 2] = $4_1;
    $2_1 = $0_1 + 56 | 0;
    $4_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    $7_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $2_1 = $0_1 + 48 | 0;
    $6_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    $9_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $2_1 = $0_1 + 40 | 0;
    $10_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
    $2_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
    $11_1 = HEAPU8[$0_1 + 32 | 0] | HEAPU8[$0_1 + 33 | 0] << 8 | (HEAPU8[$0_1 + 34 | 0] << 16 | HEAPU8[$0_1 + 35 | 0] << 24);
    $12_1 = HEAPU8[$0_1 + 36 | 0] | HEAPU8[$0_1 + 37 | 0] << 8 | (HEAPU8[$0_1 + 38 | 0] << 16 | HEAPU8[$0_1 + 39 | 0] << 24);
    $13_1 = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    $14_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    HEAP32[$3_1 >> 2] = HEAPU8[$0_1 + 64 | 0];
    $0_1 = $5_1 + 8 | 0;
    HEAP32[$0_1 >> 2] = $10_1;
    HEAP32[$0_1 + 4 >> 2] = $2_1;
    $0_1 = $5_1 + 16 | 0;
    HEAP32[$0_1 >> 2] = $6_1;
    HEAP32[$0_1 + 4 >> 2] = $9_1;
    $0_1 = $5_1 + 24 | 0;
    HEAP32[$0_1 >> 2] = $4_1;
    HEAP32[$0_1 + 4 >> 2] = $7_1;
    HEAP32[$5_1 + 32 >> 2] = $13_1;
    HEAP32[$5_1 + 36 >> 2] = $14_1;
    HEAP32[$5_1 >> 2] = $11_1;
    HEAP32[$5_1 + 4 >> 2] = $12_1;
    $39(690981, $1_1);
    $39(691013, $5_1);
   }
   global$0 = $5_1 - -64 | 0;
   global$0 = $8_1 + 112 | 0;
   return HEAP32[$8_1 + 12 >> 2];
  }
  HEAP32[$8_1 + 96 >> 2] = 0;
  $5($8_1 + 88 | 0);
  wasm2js_trap();
 }
 
 function $23($0_1) {
  $0_1 = $0_1 | 0;
  var $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0;
  $2_1 = global$0 - 128 | 0;
  global$0 = $2_1;
  $7_1 = $68($2_1, 96);
  $2_1 = $60($6(), $7_1);
  HEAP32[$7_1 + 100 >> 2] = $2_1;
  label$1 : {
   label$2 : {
    if (($2_1 | 0) == 1) {
     $15_1 = $6();
     $26_1 = $0_1 ? 655681 : 0;
     $1_1 = global$0 - 640 | 0;
     global$0 = $1_1;
     $0_1 = $1_1 + 88 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     $0_1 = $1_1 + 80 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     HEAP32[$1_1 + 72 >> 2] = 0;
     HEAP32[$1_1 + 76 >> 2] = 0;
     HEAP32[$1_1 + 64 >> 2] = 0;
     HEAP32[$1_1 + 68 >> 2] = 0;
     label$4 : {
      if (!HEAP32[$15_1 >> 2]) {
       FUNCTION_TABLE[HEAP32[$15_1 + 168 >> 2]](690045, HEAP32[$15_1 + 172 >> 2]);
       break label$4;
      }
      if (!$7_1) {
       FUNCTION_TABLE[HEAP32[$15_1 + 168 >> 2]](689700, HEAP32[$15_1 + 172 >> 2]);
       break label$4;
      }
      $17_1 = $1_1 + 472 | 0;
      $23_1 = global$0 - 16 | 0;
      global$0 = $23_1;
      $18_1 = HEAPU8[$7_1 + 40 | 0] | HEAPU8[$7_1 + 41 | 0] << 8 | (HEAPU8[$7_1 + 42 | 0] << 16 | HEAPU8[$7_1 + 43 | 0] << 24);
      $6_1 = HEAPU8[$7_1 + 44 | 0] | HEAPU8[$7_1 + 45 | 0] << 8 | (HEAPU8[$7_1 + 46 | 0] << 16 | HEAPU8[$7_1 + 47 | 0] << 24);
      $10_1 = HEAPU8[$7_1 + 48 | 0] | HEAPU8[$7_1 + 49 | 0] << 8 | (HEAPU8[$7_1 + 50 | 0] << 16 | HEAPU8[$7_1 + 51 | 0] << 24);
      $5_1 = HEAPU8[$7_1 + 52 | 0] | HEAPU8[$7_1 + 53 | 0] << 8 | (HEAPU8[$7_1 + 54 | 0] << 16 | HEAPU8[$7_1 + 55 | 0] << 24);
      $19_1 = HEAPU8[$7_1 + 72 | 0] | HEAPU8[$7_1 + 73 | 0] << 8 | (HEAPU8[$7_1 + 74 | 0] << 16 | HEAPU8[$7_1 + 75 | 0] << 24);
      $12_1 = HEAPU8[$7_1 + 76 | 0] | HEAPU8[$7_1 + 77 | 0] << 8 | (HEAPU8[$7_1 + 78 | 0] << 16 | HEAPU8[$7_1 + 79 | 0] << 24);
      $8_1 = HEAPU8[$7_1 + 80 | 0] | HEAPU8[$7_1 + 81 | 0] << 8 | (HEAPU8[$7_1 + 82 | 0] << 16 | HEAPU8[$7_1 + 83 | 0] << 24);
      $3_1 = HEAPU8[$7_1 + 84 | 0] | HEAPU8[$7_1 + 85 | 0] << 8 | (HEAPU8[$7_1 + 86 | 0] << 16 | HEAPU8[$7_1 + 87 | 0] << 24);
      $16_1 = HEAPU8[$7_1 + 32 | 0] | HEAPU8[$7_1 + 33 | 0] << 8 | (HEAPU8[$7_1 + 34 | 0] << 16 | HEAPU8[$7_1 + 35 | 0] << 24);
      $13_1 = HEAPU8[$7_1 + 36 | 0] | HEAPU8[$7_1 + 37 | 0] << 8 | (HEAPU8[$7_1 + 38 | 0] << 16 | HEAPU8[$7_1 + 39 | 0] << 24);
      $11_1 = HEAPU8[$7_1 + 56 | 0] | HEAPU8[$7_1 + 57 | 0] << 8 | (HEAPU8[$7_1 + 58 | 0] << 16 | HEAPU8[$7_1 + 59 | 0] << 24);
      $4_1 = HEAPU8[$7_1 + 60 | 0] | HEAPU8[$7_1 + 61 | 0] << 8 | (HEAPU8[$7_1 + 62 | 0] << 16 | HEAPU8[$7_1 + 63 | 0] << 24);
      $22_1 = HEAPU8[$7_1 + 64 | 0] | HEAPU8[$7_1 + 65 | 0] << 8 | (HEAPU8[$7_1 + 66 | 0] << 16 | HEAPU8[$7_1 + 67 | 0] << 24);
      $14_1 = HEAPU8[$7_1 + 68 | 0] | HEAPU8[$7_1 + 69 | 0] << 8 | (HEAPU8[$7_1 + 70 | 0] << 16 | HEAPU8[$7_1 + 71 | 0] << 24);
      $9_1 = HEAPU8[$7_1 + 88 | 0] | HEAPU8[$7_1 + 89 | 0] << 8 | (HEAPU8[$7_1 + 90 | 0] << 16 | HEAPU8[$7_1 + 91 | 0] << 24);
      $20_1 = HEAPU8[$7_1 + 92 | 0] | HEAPU8[$7_1 + 93 | 0] << 8 | (HEAPU8[$7_1 + 94 | 0] << 16 | HEAPU8[$7_1 + 95 | 0] << 24);
      $2_1 = $1_1 + 192 | 0;
      HEAP32[$2_1 + 80 >> 2] = 0;
      $21_1 = $2_1 + 72 | 0;
      HEAP32[$21_1 >> 2] = ($20_1 & 65535) << 16 | $9_1 >>> 16;
      HEAP32[$21_1 + 4 >> 2] = $20_1 >>> 16;
      HEAP32[$2_1 + 40 >> 2] = $22_1;
      HEAP32[$2_1 + 44 >> 2] = $14_1 & 1048575;
      $21_1 = ($4_1 & 65535) << 16 | $11_1 >>> 16;
      HEAP32[$2_1 + 32 >> 2] = $21_1;
      $22_1 = $4_1 >>> 16 | 0;
      HEAP32[$2_1 + 36 >> 2] = $22_1;
      HEAP32[$2_1 >> 2] = $16_1;
      $20_1 = $13_1 & 1048575;
      HEAP32[$2_1 + 4 >> 2] = $20_1;
      $24_1 = $2_1 - -64 | 0;
      HEAP32[$24_1 >> 2] = ($3_1 & 268435455) << 4 | $8_1 >>> 28;
      HEAP32[$24_1 + 4 >> 2] = $9_1 << 4 & 1048560 | $3_1 >>> 28;
      $0_1 = $3_1 << 24 | $8_1 >>> 8;
      $9_1 = $2_1 + 56 | 0;
      $3_1 = $12_1;
      HEAP32[$9_1 >> 2] = $8_1 << 24 & -16777216 | $3_1 >>> 8;
      HEAP32[$9_1 + 4 >> 2] = $0_1 & 1048575;
      $0_1 = $3_1 << 12;
      $3_1 = $19_1;
      $8_1 = ($0_1 | $3_1 >>> 20) & 1048575;
      $12_1 = $2_1 + 48 | 0;
      HEAP32[$12_1 >> 2] = $3_1 << 12 & -4096 | $14_1 >>> 20;
      HEAP32[$12_1 + 4 >> 2] = $8_1;
      $3_1 = $11_1 << 4 & 1048560;
      $4_1 = $5_1;
      $0_1 = $4_1 >>> 28 | 0;
      $5_1 = ($4_1 & 268435455) << 4 | $10_1 >>> 28;
      HEAP32[$2_1 + 24 >> 2] = $5_1;
      $3_1 = $0_1 | $3_1;
      HEAP32[$2_1 + 28 >> 2] = $3_1;
      $0_1 = $4_1 << 24 | $10_1 >>> 8;
      $4_1 = $6_1;
      $6_1 = $10_1 << 24 & -16777216 | $4_1 >>> 8;
      HEAP32[$2_1 + 16 >> 2] = $6_1;
      $10_1 = $0_1 & 1048575;
      HEAP32[$2_1 + 20 >> 2] = $10_1;
      $0_1 = $4_1 << 12;
      $4_1 = $18_1;
      $12_1 = ($0_1 | $4_1 >>> 20) & 1048575;
      $4_1 = $4_1 << 12 & -4096 | $13_1 >>> 20;
      HEAP32[$2_1 + 8 >> 2] = $4_1;
      $0_1 = $12_1;
      HEAP32[$2_1 + 12 >> 2] = $0_1;
      label$7 : {
       label$8 : {
        if (!($4_1 | $16_1 | $21_1 | $6_1 | $5_1 | ($0_1 | $20_1 | $22_1 | $10_1 | $3_1))) {
         FUNCTION_TABLE[HEAP32[$15_1 + 168 >> 2]](690116, HEAP32[$15_1 + 172 >> 2]);
         $70($2_1, 690376, 88);
         if ($17_1) {
          break label$8
         }
         break label$7;
        }
        $25_1 = 1;
        if (!$17_1) {
         break label$7
        }
        $38($17_1, $7_1, $23_1 + 12 | 0);
        if (!(HEAP32[$23_1 + 12 >> 2] | !(HEAP32[$17_1 + 24 >> 2] | (HEAP32[$17_1 + 16 >> 2] | (HEAP32[$17_1 + 8 >> 2] | HEAP32[$17_1 >> 2])) | (HEAP32[$17_1 + 28 >> 2] | (HEAP32[$17_1 + 20 >> 2] | (HEAP32[$17_1 + 12 >> 2] | HEAP32[$17_1 + 4 >> 2])))))) {
         break label$7
        }
        FUNCTION_TABLE[HEAP32[$15_1 + 168 >> 2]](689400, HEAP32[$15_1 + 172 >> 2]);
        $70($2_1, 690376, 88);
       }
       $25_1 = 0;
       $0_1 = HEAP32[172569];
       $2_1 = $17_1 + 24 | 0;
       HEAP32[$2_1 >> 2] = HEAP32[172568];
       HEAP32[$2_1 + 4 >> 2] = $0_1;
       $0_1 = HEAP32[172567];
       $2_1 = $17_1 + 16 | 0;
       HEAP32[$2_1 >> 2] = HEAP32[172566];
       HEAP32[$2_1 + 4 >> 2] = $0_1;
       $0_1 = HEAP32[172565];
       $2_1 = $17_1 + 8 | 0;
       HEAP32[$2_1 >> 2] = HEAP32[172564];
       HEAP32[$2_1 + 4 >> 2] = $0_1;
       $0_1 = HEAP32[172563];
       HEAP32[$17_1 >> 2] = HEAP32[172562];
       HEAP32[$17_1 + 4 >> 2] = $0_1;
      }
      global$0 = $23_1 + 16 | 0;
      label$10 : {
       if (!(HEAP8[$1_1 + 232 | 0] & 1)) {
        $18_1 = HEAP32[$1_1 + 472 >> 2];
        $12_1 = HEAP32[$1_1 + 476 >> 2];
        $8_1 = HEAP32[$1_1 + 480 >> 2];
        $2_1 = HEAP32[$1_1 + 484 >> 2];
        $3_1 = HEAP32[$1_1 + 488 >> 2];
        $5_1 = HEAP32[$1_1 + 492 >> 2];
        $19_1 = HEAP32[$1_1 + 496 >> 2];
        $10_1 = HEAP32[$1_1 + 500 >> 2];
        break label$10;
       }
       $13_1 = HEAP32[$1_1 + 496 >> 2];
       $14_1 = HEAP32[$1_1 + 488 >> 2];
       $3_1 = HEAP32[$1_1 + 480 >> 2];
       $0_1 = HEAP32[$1_1 + 472 >> 2];
       $16_1 = HEAP32[$1_1 + 500 >> 2];
       $19_1 = HEAP32[$1_1 + 492 >> 2];
       $5_1 = HEAP32[$1_1 + 484 >> 2];
       $2_1 = HEAP32[$1_1 + 476 >> 2];
       $6_1 = $13_1 | ($14_1 | ($3_1 | $0_1)) | ($16_1 | ($19_1 | ($5_1 | $2_1))) ? -1 : 0;
       $0_1 = $0_1 ^ -1;
       $10_1 = $0_1 - 801750718 | 0;
       $18_1 = $6_1 & $10_1;
       HEAP32[$1_1 + 472 >> 2] = $18_1;
       $2_1 = $2_1 ^ -1;
       $4_1 = $2_1 - (($0_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
       $12_1 = $4_1 & $6_1;
       HEAP32[$1_1 + 476 >> 2] = $12_1;
       $0_1 = ($2_1 | 0) == ($4_1 | 0) & $0_1 >>> 0 > $10_1 >>> 0 | $2_1 >>> 0 > $4_1 >>> 0;
       $10_1 = $3_1 ^ -1;
       $3_1 = $0_1 + $10_1 | 0;
       $5_1 = $5_1 ^ -1;
       $0_1 = $5_1;
       $9_1 = $3_1 - 1354194885 | 0;
       $8_1 = $9_1 & $6_1;
       HEAP32[$1_1 + 480 >> 2] = $8_1;
       $0_1 = $3_1 >>> 0 < $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
       $11_1 = $0_1 - (($3_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
       $2_1 = $11_1 & $6_1;
       HEAP32[$1_1 + 484 >> 2] = $2_1;
       $4_1 = ($0_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 < $10_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
       $10_1 = ($0_1 | 0) == ($11_1 | 0) & $3_1 >>> 0 > $9_1 >>> 0 | $0_1 >>> 0 > $11_1 >>> 0;
       $3_1 = $4_1 + $10_1 | 0;
       $0_1 = $3_1 >>> 0 < $10_1 >>> 0;
       $11_1 = $14_1 ^ -1;
       $10_1 = $11_1 + $3_1 | 0;
       $14_1 = $19_1 ^ -1;
       $0_1 = $14_1 + $0_1 | 0;
       $9_1 = $10_1 - 2 | 0;
       $3_1 = $9_1 & $6_1;
       HEAP32[$1_1 + 488 >> 2] = $3_1;
       $0_1 = $10_1 >>> 0 < $11_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
       $19_1 = $0_1 - ($10_1 >>> 0 < 2) | 0;
       $5_1 = $19_1 & $6_1;
       HEAP32[$1_1 + 492 >> 2] = $5_1;
       $4_1 = ($0_1 | 0) == ($14_1 | 0) & $10_1 >>> 0 < $11_1 >>> 0 | $0_1 >>> 0 < $14_1 >>> 0;
       $10_1 = ($0_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $0_1 >>> 0 > $19_1 >>> 0;
       $4_1 = $4_1 + $10_1 | 0;
       $0_1 = $4_1 >>> 0 < $10_1 >>> 0;
       $10_1 = $4_1 - $13_1 | 0;
       $19_1 = $10_1 - 2 & $6_1;
       HEAP32[$1_1 + 496 >> 2] = $19_1;
       $10_1 = ($0_1 - (($4_1 >>> 0 < $13_1 >>> 0) + $16_1 | 0) | 0) - ($10_1 >>> 0 < 2) & $6_1;
       HEAP32[$1_1 + 500 >> 2] = $10_1;
      }
      HEAP8[$1_1 + 31 | 0] = $18_1;
      HEAP8[$1_1 + 30 | 0] = ($12_1 & 255) << 24 | $18_1 >>> 8;
      HEAP8[$1_1 + 29 | 0] = ($12_1 & 65535) << 16 | $18_1 >>> 16;
      HEAP8[$1_1 + 28 | 0] = ($12_1 & 16777215) << 8 | $18_1 >>> 24;
      HEAP8[$1_1 + 27 | 0] = $12_1;
      HEAP8[$1_1 + 26 | 0] = $12_1 >>> 8;
      HEAP8[$1_1 + 25 | 0] = $12_1 >>> 16;
      HEAP8[$1_1 + 24 | 0] = $12_1 >>> 24;
      HEAP8[$1_1 + 23 | 0] = $8_1;
      HEAP8[$1_1 + 22 | 0] = ($2_1 & 255) << 24 | $8_1 >>> 8;
      HEAP8[$1_1 + 21 | 0] = ($2_1 & 65535) << 16 | $8_1 >>> 16;
      HEAP8[$1_1 + 20 | 0] = ($2_1 & 16777215) << 8 | $8_1 >>> 24;
      HEAP8[$1_1 + 19 | 0] = $2_1;
      HEAP8[$1_1 + 18 | 0] = $2_1 >>> 8;
      HEAP8[$1_1 + 17 | 0] = $2_1 >>> 16;
      HEAP8[$1_1 + 16 | 0] = $2_1 >>> 24;
      HEAP8[$1_1 + 15 | 0] = $3_1;
      HEAP8[$1_1 + 14 | 0] = ($5_1 & 255) << 24 | $3_1 >>> 8;
      HEAP8[$1_1 + 13 | 0] = ($5_1 & 65535) << 16 | $3_1 >>> 16;
      HEAP8[$1_1 + 12 | 0] = ($5_1 & 16777215) << 8 | $3_1 >>> 24;
      HEAP8[$1_1 + 11 | 0] = $5_1;
      HEAP8[$1_1 + 10 | 0] = $5_1 >>> 8;
      HEAP8[$1_1 + 9 | 0] = $5_1 >>> 16;
      HEAP8[$1_1 + 8 | 0] = $5_1 >>> 24;
      HEAP8[$1_1 + 7 | 0] = $19_1;
      HEAP8[$1_1 + 6 | 0] = ($10_1 & 255) << 24 | $19_1 >>> 8;
      HEAP8[$1_1 + 5 | 0] = ($10_1 & 65535) << 16 | $19_1 >>> 16;
      HEAP8[$1_1 + 4 | 0] = ($10_1 & 16777215) << 8 | $19_1 >>> 24;
      HEAP8[$1_1 + 3 | 0] = $10_1;
      HEAP8[$1_1 + 2 | 0] = $10_1 >>> 8;
      HEAP8[$1_1 + 1 | 0] = $10_1 >>> 16;
      HEAP8[$1_1 | 0] = $10_1 >>> 24;
      $2_1 = HEAP32[$1_1 + 228 >> 2];
      $4_1 = HEAP32[$1_1 + 224 >> 2];
      HEAP8[$1_1 + 37 | 0] = $4_1;
      $0_1 = HEAP32[$1_1 + 212 >> 2];
      $3_1 = HEAP32[$1_1 + 208 >> 2];
      HEAP8[$1_1 + 50 | 0] = $3_1;
      HEAP8[$1_1 + 36 | 0] = ($2_1 & 255) << 24 | $4_1 >>> 8;
      HEAP8[$1_1 + 35 | 0] = ($2_1 & 65535) << 16 | $4_1 >>> 16;
      HEAP8[$1_1 + 34 | 0] = ($2_1 & 16777215) << 8 | $4_1 >>> 24;
      HEAP8[$1_1 + 33 | 0] = $2_1;
      HEAP8[$1_1 + 32 | 0] = $2_1 >>> 8;
      $2_1 = HEAP32[$1_1 + 220 >> 2];
      $4_1 = HEAP32[$1_1 + 216 >> 2];
      HEAP8[$1_1 + 43 | 0] = ($2_1 & 15) << 28 | $4_1 >>> 4;
      HEAP8[$1_1 + 42 | 0] = ($2_1 & 4095) << 20 | $4_1 >>> 12;
      HEAP8[$1_1 + 41 | 0] = ($2_1 & 1048575) << 12 | $4_1 >>> 20;
      HEAP8[$1_1 + 40 | 0] = ($2_1 & 268435455) << 4 | $4_1 >>> 28;
      HEAP8[$1_1 + 39 | 0] = $2_1 >>> 4;
      HEAP8[$1_1 + 38 | 0] = $2_1 >>> 12;
      HEAP8[$1_1 + 49 | 0] = ($0_1 & 255) << 24 | $3_1 >>> 8;
      HEAP8[$1_1 + 48 | 0] = ($0_1 & 65535) << 16 | $3_1 >>> 16;
      HEAP8[$1_1 + 47 | 0] = ($0_1 & 16777215) << 8 | $3_1 >>> 24;
      HEAP8[$1_1 + 46 | 0] = $0_1;
      HEAP8[$1_1 + 45 | 0] = $0_1 >>> 8;
      HEAP8[$1_1 + 44 | 0] = $0_1 >>> 16 & 15 | $4_1 << 4;
      $0_1 = HEAP32[$1_1 + 196 >> 2];
      $3_1 = HEAP32[$1_1 + 192 >> 2];
      HEAP8[$1_1 + 63 | 0] = $3_1;
      $2_1 = HEAP32[$1_1 + 204 >> 2];
      $4_1 = HEAP32[$1_1 + 200 >> 2];
      HEAP8[$1_1 + 56 | 0] = ($2_1 & 15) << 28 | $4_1 >>> 4;
      HEAP8[$1_1 + 55 | 0] = ($2_1 & 4095) << 20 | $4_1 >>> 12;
      HEAP8[$1_1 + 54 | 0] = ($2_1 & 1048575) << 12 | $4_1 >>> 20;
      HEAP8[$1_1 + 53 | 0] = ($2_1 & 268435455) << 4 | $4_1 >>> 28;
      HEAP8[$1_1 + 52 | 0] = $2_1 >>> 4;
      HEAP8[$1_1 + 51 | 0] = $2_1 >>> 12;
      HEAP8[$1_1 + 62 | 0] = ($0_1 & 255) << 24 | $3_1 >>> 8;
      HEAP8[$1_1 + 61 | 0] = ($0_1 & 65535) << 16 | $3_1 >>> 16;
      HEAP8[$1_1 + 60 | 0] = ($0_1 & 16777215) << 8 | $3_1 >>> 24;
      HEAP8[$1_1 + 59 | 0] = $0_1;
      HEAP8[$1_1 + 58 | 0] = $0_1 >>> 8;
      HEAP8[$1_1 + 57 | 0] = $0_1 >>> 16 & 15 | $4_1 << 4;
      $0_1 = $1_1 - -64 | 0;
      $2_1 = $61($0_1, 655649, 32, $1_1, $1_1 + 32 | 0, 690736, 13, $26_1);
      $4_1 = $1_1 + 408 | 0;
      $38($4_1, $0_1, 0);
      $0_1 = $25_1 & ($2_1 | 0) != 0;
      $2_1 = HEAP32[$1_1 + 432 >> 2];
      $5_1 = HEAP32[$1_1 + 424 >> 2];
      $3_1 = HEAP32[$1_1 + 416 >> 2];
      $6_1 = HEAP32[$1_1 + 408 >> 2];
      $10_1 = HEAP32[$1_1 + 436 >> 2];
      $13_1 = HEAP32[$1_1 + 428 >> 2];
      $12_1 = HEAP32[$1_1 + 420 >> 2];
      $8_1 = HEAP32[$1_1 + 412 >> 2];
      $24_1 = $0_1 & ($2_1 | ($5_1 | ($3_1 | $6_1)) | ($10_1 | ($13_1 | ($12_1 | $8_1)))) != 0;
      $23_1 = !$24_1;
      $0_1 = $23_1 - 1 | 0;
      $19_1 = $0_1 & $2_1;
      HEAP32[$1_1 + 432 >> 2] = $19_1;
      $2_1 = 0 - !$23_1 | 0;
      $10_1 = $2_1 & $10_1;
      HEAP32[$1_1 + 436 >> 2] = $10_1;
      $20_1 = $0_1 & $5_1;
      HEAP32[$1_1 + 424 >> 2] = $20_1;
      $22_1 = $2_1 & $13_1;
      HEAP32[$1_1 + 428 >> 2] = $22_1;
      $21_1 = $0_1 & $3_1;
      HEAP32[$1_1 + 416 >> 2] = $21_1;
      $17_1 = $2_1 & $12_1;
      HEAP32[$1_1 + 420 >> 2] = $17_1;
      $18_1 = $0_1 & $6_1 | $23_1;
      HEAP32[$1_1 + 408 >> 2] = $18_1;
      $12_1 = $2_1 & $8_1;
      HEAP32[$1_1 + 412 >> 2] = $12_1;
      $0_1 = $1_1 + 280 | 0;
      $48($15_1, $0_1, $4_1);
      $49($1_1 + 104 | 0, $0_1);
      $0_1 = $1_1 + 152 | 0;
      $4_1 = HEAP32[$0_1 >> 2];
      $6_1 = HEAP32[$0_1 + 4 >> 2];
      $5_1 = HEAP32[$1_1 + 148 >> 2];
      $0_1 = $1_1 + 176 | 0;
      $8_1 = HEAP32[$0_1 >> 2];
      $3_1 = HEAP32[$0_1 + 4 >> 2];
      $14_1 = $3_1;
      $0_1 = HEAP32[$1_1 + 144 >> 2];
      $2_1 = __wasm_i64_mul($3_1 >>> 16 | 0, 0, 977, 1);
      $3_1 = $0_1 + $2_1 | 0;
      $0_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
      $9_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $6_1;
      $2_1 = $9_1 >>> 20 | 0;
      $5_1 = $2_1;
      $2_1 = $2_1 + $4_1 | 0;
      $5_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $13_1 = $5_1 & 1048575;
      $0_1 = $1_1 + 168 | 0;
      $16_1 = HEAP32[$0_1 >> 2];
      $15_1 = HEAP32[$0_1 + 4 >> 2];
      $0_1 = $1_1 + 160 | 0;
      $6_1 = HEAP32[$0_1 >> 2];
      $0_1 = HEAP32[$0_1 + 4 >> 2];
      $4_1 = $5_1 >>> 20 | 0;
      $11_1 = $4_1;
      $4_1 = $4_1 + $6_1 | 0;
      $11_1 = $11_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $15_1;
      $6_1 = $11_1 >>> 20 | 0;
      $15_1 = $6_1;
      $6_1 = $6_1 + $16_1 | 0;
      $0_1 = $15_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $16_1 = $0_1 & 1048575;
      $11_1 = $11_1 & 1048575;
      $15_1 = ($2_1 & $4_1 & $6_1) == -1 & ($5_1 & $11_1 & $0_1) == 1048575;
      $5_1 = $0_1;
      $0_1 = $14_1 & 65535;
      $5_1 = $5_1 >>> 20 | 0;
      $14_1 = $5_1 + $8_1 | 0;
      $0_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $8_1 = $0_1;
      $5_1 = $9_1 & 1048575;
      if ($15_1 & (($14_1 | 0) == -1 & ($0_1 | 0) == 65535) & (($5_1 | 0) == 1048574 & $3_1 >>> 0 > 4294966318 | $5_1 >>> 0 > 1048574) | $0_1 >>> 16) {
       $0_1 = $5_1 + 1 | 0;
       $3_1 = $3_1 + 977 | 0;
       $0_1 = $3_1 >>> 0 < 977 ? $0_1 + 1 | 0 : $0_1;
       $5_1 = $0_1 & 1048575;
       $9_1 = $0_1;
       $0_1 = $13_1;
       $9_1 = $9_1 >>> 20 | 0;
       $2_1 = $2_1 + $9_1 | 0;
       $0_1 = $9_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
       $13_1 = $0_1 & 1048575;
       $9_1 = $0_1;
       $0_1 = $11_1;
       $9_1 = $9_1 >>> 20 | 0;
       $4_1 = $4_1 + $9_1 | 0;
       $0_1 = $9_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
       $11_1 = $0_1 & 1048575;
       $9_1 = $0_1;
       $0_1 = $16_1;
       $9_1 = $9_1 >>> 20 | 0;
       $6_1 = $6_1 + $9_1 | 0;
       $0_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
       $16_1 = $0_1 & 1048575;
       $9_1 = $0_1;
       $0_1 = $8_1;
       $8_1 = $14_1;
       $14_1 = ($9_1 >>> 20 | 0) + $14_1 | 0;
       $8_1 = ($8_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) & 65535;
      }
      HEAP32[$1_1 + 176 >> 2] = $14_1;
      HEAP32[$1_1 + 180 >> 2] = $8_1;
      HEAP32[$1_1 + 168 >> 2] = $6_1;
      HEAP32[$1_1 + 172 >> 2] = $16_1;
      HEAP32[$1_1 + 160 >> 2] = $4_1;
      HEAP32[$1_1 + 164 >> 2] = $11_1;
      HEAP32[$1_1 + 152 >> 2] = $2_1;
      HEAP32[$1_1 + 156 >> 2] = $13_1;
      HEAP32[$1_1 + 144 >> 2] = $3_1;
      HEAP32[$1_1 + 148 >> 2] = $5_1;
      if ($3_1 & 1) {
       $4_1 = $18_1 | $21_1 | $20_1 | $19_1 | ($12_1 | $17_1 | $22_1 | $10_1) ? -1 : 0;
       $0_1 = $18_1 ^ -1;
       $6_1 = $0_1 - 801750718 | 0;
       $18_1 = $4_1 & $6_1;
       HEAP32[$1_1 + 408 >> 2] = $18_1;
       $2_1 = $12_1 ^ -1;
       $3_1 = $2_1 - (($0_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
       $12_1 = $3_1 & $4_1;
       HEAP32[$1_1 + 412 >> 2] = $12_1;
       $0_1 = ($2_1 | 0) == ($3_1 | 0) & $0_1 >>> 0 > $6_1 >>> 0 | $2_1 >>> 0 > $3_1 >>> 0;
       $6_1 = $21_1 ^ -1;
       $3_1 = $0_1 + $6_1 | 0;
       $5_1 = $17_1 ^ -1;
       $0_1 = $5_1;
       $13_1 = $3_1 - 1354194885 | 0;
       $21_1 = $13_1 & $4_1;
       HEAP32[$1_1 + 416 >> 2] = $21_1;
       $0_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
       $8_1 = $0_1 - (($3_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
       $17_1 = $8_1 & $4_1;
       HEAP32[$1_1 + 420 >> 2] = $17_1;
       $2_1 = ($0_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
       $6_1 = ($0_1 | 0) == ($8_1 | 0) & $3_1 >>> 0 > $13_1 >>> 0 | $0_1 >>> 0 > $8_1 >>> 0;
       $3_1 = $2_1 + $6_1 | 0;
       $5_1 = $22_1 ^ -1;
       $0_1 = $5_1 + ($3_1 >>> 0 < $6_1 >>> 0) | 0;
       $6_1 = $20_1 ^ -1;
       $3_1 = $6_1 + $3_1 | 0;
       $13_1 = $3_1 - 2 | 0;
       $20_1 = $13_1 & $4_1;
       HEAP32[$1_1 + 424 >> 2] = $20_1;
       $0_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
       $8_1 = $0_1 - ($3_1 >>> 0 < 2) | 0;
       $22_1 = $8_1 & $4_1;
       HEAP32[$1_1 + 428 >> 2] = $22_1;
       $2_1 = ($0_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
       $3_1 = ($0_1 | 0) == ($8_1 | 0) & $3_1 >>> 0 > $13_1 >>> 0 | $0_1 >>> 0 > $8_1 >>> 0;
       $2_1 = $2_1 + $3_1 | 0;
       $0_1 = $2_1 >>> 0 < $3_1 >>> 0;
       $3_1 = $2_1 - $19_1 | 0;
       $6_1 = $3_1 - 2 | 0;
       $10_1 = ($0_1 - (($2_1 >>> 0 < $19_1 >>> 0) + $10_1 | 0) | 0) - ($3_1 >>> 0 < 2) & $4_1;
       $19_1 = $4_1 & $6_1;
       HEAP32[$1_1 + 432 >> 2] = $19_1;
       HEAP32[$1_1 + 436 >> 2] = $10_1;
      }
      $4_1 = HEAP32[$1_1 + 112 >> 2];
      $3_1 = HEAP32[$1_1 + 116 >> 2];
      $5_1 = HEAP32[$1_1 + 108 >> 2];
      $14_1 = HEAP32[$1_1 + 136 >> 2];
      $6_1 = HEAP32[$1_1 + 140 >> 2];
      $9_1 = $6_1;
      $0_1 = HEAP32[$1_1 + 104 >> 2];
      $2_1 = __wasm_i64_mul($6_1 >>> 16 | 0, 0, 977, 1);
      $6_1 = $0_1 + $2_1 | 0;
      $0_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
      $16_1 = $2_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $3_1;
      $2_1 = $16_1 >>> 20 | 0;
      $3_1 = $2_1 + $4_1 | 0;
      $8_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $5_1 = $8_1 & 1048575;
      $13_1 = HEAP32[$1_1 + 128 >> 2];
      $15_1 = HEAP32[$1_1 + 132 >> 2];
      $0_1 = HEAP32[$1_1 + 124 >> 2];
      $2_1 = $8_1 >>> 20 | 0;
      $4_1 = $2_1 + HEAP32[$1_1 + 120 >> 2] | 0;
      $11_1 = $2_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $15_1;
      $2_1 = $11_1 >>> 20 | 0;
      $15_1 = $2_1;
      $2_1 = $2_1 + $13_1 | 0;
      $0_1 = $15_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $13_1 = $0_1 & 1048575;
      $11_1 = $11_1 & 1048575;
      $15_1 = ($3_1 & $4_1 & $2_1) == -1 & ($8_1 & $11_1 & $0_1) == 1048575;
      $8_1 = $0_1;
      $0_1 = $9_1 & 65535;
      $8_1 = $8_1 >>> 20 | 0;
      $14_1 = $8_1 + $14_1 | 0;
      $0_1 = $8_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $8_1 = $0_1;
      $16_1 = $16_1 & 1048575;
      if ($15_1 & (($14_1 | 0) == -1 & ($0_1 | 0) == 65535) & (($16_1 | 0) == 1048574 & $6_1 >>> 0 > 4294966318 | $16_1 >>> 0 > 1048574) | $0_1 >>> 16) {
       $0_1 = $16_1 + 1 | 0;
       $6_1 = $6_1 + 977 | 0;
       $0_1 = $6_1 >>> 0 < 977 ? $0_1 + 1 | 0 : $0_1;
       $16_1 = $0_1 & 1048575;
       $9_1 = $0_1;
       $0_1 = $5_1;
       $9_1 = $9_1 >>> 20 | 0;
       $3_1 = $3_1 + $9_1 | 0;
       $0_1 = $9_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
       $5_1 = $0_1 & 1048575;
       $9_1 = $0_1;
       $0_1 = $11_1;
       $9_1 = $9_1 >>> 20 | 0;
       $4_1 = $4_1 + $9_1 | 0;
       $0_1 = $9_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
       $11_1 = $0_1 & 1048575;
       $9_1 = $0_1;
       $0_1 = $13_1;
       $9_1 = $9_1 >>> 20 | 0;
       $2_1 = $2_1 + $9_1 | 0;
       $0_1 = $9_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
       $13_1 = $0_1 & 1048575;
       $9_1 = $0_1;
       $0_1 = $8_1;
       $8_1 = $14_1;
       $14_1 = ($9_1 >>> 20 | 0) + $14_1 | 0;
       $8_1 = ($8_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) & 65535;
      }
      HEAP32[$1_1 + 136 >> 2] = $14_1;
      HEAP32[$1_1 + 140 >> 2] = $8_1;
      HEAP32[$1_1 + 128 >> 2] = $2_1;
      HEAP32[$1_1 + 132 >> 2] = $13_1;
      HEAP32[$1_1 + 120 >> 2] = $4_1;
      HEAP32[$1_1 + 124 >> 2] = $11_1;
      HEAP32[$1_1 + 112 >> 2] = $3_1;
      HEAP32[$1_1 + 116 >> 2] = $5_1;
      HEAP32[$1_1 + 104 >> 2] = $6_1;
      HEAP32[$1_1 + 108 >> 2] = $16_1;
      $37(690981, $1_1 + 104 | 0);
      HEAP32[$1_1 + 600 >> 2] = 64;
      HEAP32[$1_1 + 604 >> 2] = 0;
      HEAP32[$1_1 + 528 >> 2] = -1862921884;
      HEAP32[$1_1 + 532 >> 2] = 870954602;
      HEAP32[$1_1 + 520 >> 2] = -1748470448;
      HEAP32[$1_1 + 524 >> 2] = 3983205;
      HEAP32[$1_1 + 512 >> 2] = 292000018;
      HEAP32[$1_1 + 516 >> 2] = -782074353;
      HEAP32[$1_1 + 504 >> 2] = -1662207471;
      HEAP32[$1_1 + 508 >> 2] = 596792193;
      $0_1 = $1_1 + 504 | 0;
      $29($0_1, 690981, 32);
      $29($0_1, $1_1 + 32 | 0, 32);
      $29($0_1, 655649, 32);
      $2_1 = $0_1;
      $0_1 = $1_1 + 608 | 0;
      $30($2_1, $0_1);
      $9_1 = $1_1 + 440 | 0;
      $38($9_1, $0_1, 0);
      $15_1 = $1_1 + 472 | 0;
      $41($9_1, $9_1, $15_1);
      $2_1 = HEAP32[$1_1 + 440 >> 2];
      $8_1 = $2_1 + $18_1 | 0;
      $0_1 = $12_1 + HEAP32[$1_1 + 444 >> 2] | 0;
      $5_1 = $2_1 >>> 0 > $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $3_1 = ($12_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $18_1 >>> 0 | $5_1 >>> 0 < $12_1 >>> 0;
      $2_1 = HEAP32[$1_1 + 448 >> 2];
      $4_1 = $3_1 + $2_1 | 0;
      $0_1 = HEAP32[$1_1 + 452 >> 2];
      $2_1 = $2_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $2_1 + $17_1 | 0;
      $3_1 = !$2_1 & $3_1 >>> 0 > $4_1 >>> 0;
      $12_1 = $4_1 + $21_1 | 0;
      $6_1 = $12_1 >>> 0 < $21_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $4_1 = ($2_1 | 0) == ($6_1 | 0) & $4_1 >>> 0 > $12_1 >>> 0 | $2_1 >>> 0 > $6_1 >>> 0;
      $2_1 = $3_1 + $4_1 | 0;
      $0_1 = $2_1 >>> 0 < $4_1 >>> 0;
      $11_1 = $2_1;
      $2_1 = HEAP32[$1_1 + 456 >> 2];
      $4_1 = $11_1 + $2_1 | 0;
      $3_1 = $0_1;
      $0_1 = $0_1 + HEAP32[$1_1 + 460 >> 2] | 0;
      $2_1 = $2_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $2_1 + $22_1 | 0;
      $13_1 = $4_1;
      $14_1 = $4_1 + $20_1 | 0;
      $0_1 = $14_1 >>> 0 < $20_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $18_1 = $10_1;
      $11_1 = ($2_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 < $11_1 >>> 0 | $2_1 >>> 0 < $3_1 >>> 0;
      $4_1 = $0_1;
      $10_1 = $14_1;
      $3_1 = ($2_1 | 0) == ($0_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $0_1 >>> 0 < $2_1 >>> 0;
      $2_1 = $11_1 + $3_1 | 0;
      $0_1 = $2_1 >>> 0 < $3_1 >>> 0;
      $16_1 = $2_1;
      $3_1 = HEAP32[$1_1 + 464 >> 2];
      $2_1 = $2_1 + $3_1 | 0;
      $13_1 = $0_1;
      $0_1 = $0_1 + HEAP32[$1_1 + 468 >> 2] | 0;
      $3_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $3_1 + $18_1 | 0;
      $11_1 = $2_1;
      $2_1 = $2_1 + $19_1 | 0;
      $18_1 = $11_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $14_1 = $2_1;
      $16_1 = (($3_1 | 0) == ($18_1 | 0) & $11_1 >>> 0 > $2_1 >>> 0 | $3_1 >>> 0 > $18_1 >>> 0) + (($3_1 | 0) == ($13_1 | 0) & $11_1 >>> 0 < $16_1 >>> 0 | $3_1 >>> 0 < $13_1 >>> 0) | 0;
      $3_1 = ($4_1 | 0) == -1;
      $13_1 = $3_1 & $10_1 >>> 0 < 4294967294 | ($4_1 | 0) != -1 | ($2_1 & $18_1) != -1;
      $0_1 = ($6_1 | 0) == -1162945306;
      $11_1 = ($13_1 | ($0_1 & $12_1 >>> 0 < 2940772411 | $6_1 >>> 0 < 3132021990)) ^ -1;
      $13_1 = $16_1 + ($11_1 & (($5_1 | 0) == -1076732276 & $8_1 >>> 0 > 3493216576 | $5_1 >>> 0 > 3218235020) | ($11_1 & ($0_1 & $12_1 >>> 0 > 2940772411 | $6_1 >>> 0 > 3132021990) | ($10_1 | 0) == -1 & $3_1 & ($13_1 ^ -1))) | 0;
      $3_1 = __wasm_i64_mul($13_1, 0, 801750719, 1076732275);
      $11_1 = $3_1 + $8_1 | 0;
      $0_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
      HEAP32[$1_1 + 440 >> 2] = $11_1;
      $0_1 = $3_1 >>> 0 > $11_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      HEAP32[$1_1 + 444 >> 2] = $0_1;
      $8_1 = ($0_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 > $11_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
      $5_1 = __wasm_i64_mul($13_1, 0, 1354194884, 1162945305);
      $2_1 = $5_1 + $12_1 | 0;
      $0_1 = $6_1 + i64toi32_i32$HIGH_BITS | 0;
      $0_1 = $2_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $5_1 = $2_1;
      $2_1 = $0_1;
      $8_1 = $5_1 + $8_1 | 0;
      $0_1 = $8_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      HEAP32[$1_1 + 448 >> 2] = $8_1;
      HEAP32[$1_1 + 452 >> 2] = $0_1;
      $3_1 = ($2_1 | 0) == ($6_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $2_1 >>> 0 < $6_1 >>> 0;
      $6_1 = ($0_1 | 0) == ($2_1 | 0) & $5_1 >>> 0 > $8_1 >>> 0 | $0_1 >>> 0 < $2_1 >>> 0;
      $2_1 = $3_1 + $6_1 | 0;
      $5_1 = $2_1;
      $6_1 = $2_1 >>> 0 < $6_1 >>> 0;
      $0_1 = $4_1;
      $12_1 = $10_1 + $13_1 | 0;
      $2_1 = $12_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $0_1 = $2_1 + $6_1 | 0;
      $6_1 = $12_1;
      $5_1 = $5_1 + $6_1 | 0;
      $0_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      HEAP32[$1_1 + 456 >> 2] = $5_1;
      HEAP32[$1_1 + 460 >> 2] = $0_1;
      $3_1 = ($2_1 | 0) == ($4_1 | 0) & $6_1 >>> 0 < $10_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
      $4_1 = ($0_1 | 0) == ($2_1 | 0) & $5_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 < $2_1 >>> 0;
      $2_1 = $3_1 + $4_1 | 0;
      $0_1 = $18_1 + ($2_1 >>> 0 < $4_1 >>> 0) | 0;
      $2_1 = $2_1 + $14_1 | 0;
      $0_1 = $2_1 >>> 0 < $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      HEAP32[$1_1 + 464 >> 2] = $2_1;
      HEAP32[$1_1 + 468 >> 2] = $0_1;
      $39(691013, $9_1);
      HEAP32[$1_1 + 504 >> 2] = $23_1;
      $0_1 = HEAP32[$1_1 + 504 >> 2] - 1 | 0;
      HEAP8[690981] = $0_1 & HEAPU8[690981];
      HEAP8[690982] = HEAPU8[690982] & $0_1;
      HEAP8[690983] = HEAPU8[690983] & $0_1;
      HEAP8[690984] = HEAPU8[690984] & $0_1;
      HEAP8[690985] = HEAPU8[690985] & $0_1;
      HEAP8[690986] = HEAPU8[690986] & $0_1;
      HEAP8[690987] = HEAPU8[690987] & $0_1;
      HEAP8[690988] = HEAPU8[690988] & $0_1;
      HEAP8[690989] = HEAPU8[690989] & $0_1;
      HEAP8[690990] = HEAPU8[690990] & $0_1;
      HEAP8[690991] = HEAPU8[690991] & $0_1;
      HEAP8[690992] = HEAPU8[690992] & $0_1;
      HEAP8[690993] = HEAPU8[690993] & $0_1;
      HEAP8[690994] = HEAPU8[690994] & $0_1;
      HEAP8[690995] = HEAPU8[690995] & $0_1;
      HEAP8[690996] = HEAPU8[690996] & $0_1;
      HEAP8[690997] = HEAPU8[690997] & $0_1;
      HEAP8[690998] = HEAPU8[690998] & $0_1;
      HEAP8[690999] = HEAPU8[690999] & $0_1;
      HEAP8[691e3] = HEAPU8[691e3] & $0_1;
      HEAP8[691001] = HEAPU8[691001] & $0_1;
      HEAP8[691002] = HEAPU8[691002] & $0_1;
      HEAP8[691003] = HEAPU8[691003] & $0_1;
      HEAP8[691004] = HEAPU8[691004] & $0_1;
      HEAP8[691005] = HEAPU8[691005] & $0_1;
      HEAP8[691006] = HEAPU8[691006] & $0_1;
      HEAP8[691007] = HEAPU8[691007] & $0_1;
      HEAP8[691008] = HEAPU8[691008] & $0_1;
      HEAP8[691009] = HEAPU8[691009] & $0_1;
      HEAP8[691010] = HEAPU8[691010] & $0_1;
      HEAP8[691011] = HEAPU8[691011] & $0_1;
      HEAP8[691012] = HEAPU8[691012] & $0_1;
      HEAP8[691013] = HEAPU8[691013] & $0_1;
      HEAP8[691014] = HEAPU8[691014] & $0_1;
      HEAP8[691015] = HEAPU8[691015] & $0_1;
      HEAP8[691016] = HEAPU8[691016] & $0_1;
      HEAP8[691017] = HEAPU8[691017] & $0_1;
      HEAP8[691018] = HEAPU8[691018] & $0_1;
      HEAP8[691019] = HEAPU8[691019] & $0_1;
      HEAP8[691020] = HEAPU8[691020] & $0_1;
      HEAP8[691021] = HEAPU8[691021] & $0_1;
      HEAP8[691022] = HEAPU8[691022] & $0_1;
      HEAP8[691023] = HEAPU8[691023] & $0_1;
      HEAP8[691024] = HEAPU8[691024] & $0_1;
      HEAP8[691025] = HEAPU8[691025] & $0_1;
      HEAP8[691026] = HEAPU8[691026] & $0_1;
      HEAP8[691027] = HEAPU8[691027] & $0_1;
      HEAP8[691028] = HEAPU8[691028] & $0_1;
      HEAP8[691029] = HEAPU8[691029] & $0_1;
      HEAP8[691030] = HEAPU8[691030] & $0_1;
      HEAP8[691031] = HEAPU8[691031] & $0_1;
      HEAP8[691032] = HEAPU8[691032] & $0_1;
      HEAP8[691033] = HEAPU8[691033] & $0_1;
      HEAP8[691034] = HEAPU8[691034] & $0_1;
      HEAP8[691035] = HEAPU8[691035] & $0_1;
      HEAP8[691036] = HEAPU8[691036] & $0_1;
      HEAP8[691037] = HEAPU8[691037] & $0_1;
      HEAP8[691038] = HEAPU8[691038] & $0_1;
      HEAP8[691039] = HEAPU8[691039] & $0_1;
      HEAP8[691040] = HEAPU8[691040] & $0_1;
      HEAP8[691041] = HEAPU8[691041] & $0_1;
      HEAP8[691042] = HEAPU8[691042] & $0_1;
      HEAP8[691043] = HEAPU8[691043] & $0_1;
      HEAP8[691044] = HEAPU8[691044] & $0_1;
      $0_1 = $1_1 + 408 | 0;
      $2_1 = $0_1 + 24 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $2_1 = $0_1 + 16 | 0;
      HEAP32[$2_1 >> 2] = 0;
      HEAP32[$2_1 + 4 >> 2] = 0;
      $0_1 = $0_1 + 8 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      HEAP32[$1_1 + 408 >> 2] = 0;
      HEAP32[$1_1 + 412 >> 2] = 0;
      $0_1 = $15_1 + 24 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $15_1 + 16 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $15_1 + 8 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      HEAP32[$1_1 + 472 >> 2] = 0;
      HEAP32[$1_1 + 476 >> 2] = 0;
      $0_1 = $1_1 + 24 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $1_1 + 16 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      HEAP32[$1_1 + 8 >> 2] = 0;
      HEAP32[$1_1 + 12 >> 2] = 0;
      HEAP32[$1_1 >> 2] = 0;
      HEAP32[$1_1 + 4 >> 2] = 0;
     }
     global$0 = $1_1 + 640 | 0;
     HEAP32[$7_1 + 100 >> 2] = $24_1;
     if ($24_1) {
      break label$2
     }
     break label$1;
    }
    break label$1;
   }
   global$0 = $7_1 + 128 | 0;
   return;
  }
  HEAP32[$7_1 + 112 >> 2] = 0;
  $5($7_1 + 104 | 0);
  wasm2js_trap();
 }
 
 function $24($0_1, $1_1) {
  $0_1 = $0_1 | 0;
  $1_1 = $1_1 | 0;
  var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0;
  $5_1 = global$0 - 192 | 0;
  global$0 = $5_1;
  $4_1 = $5_1 + 128 | 0;
  $6_1 = $4_1 + 56 | 0;
  HEAP32[$6_1 >> 2] = 0;
  HEAP32[$6_1 + 4 >> 2] = 0;
  $7_1 = $4_1 + 48 | 0;
  HEAP32[$7_1 >> 2] = 0;
  HEAP32[$7_1 + 4 >> 2] = 0;
  $8_1 = $4_1 + 40 | 0;
  HEAP32[$8_1 >> 2] = 0;
  HEAP32[$8_1 + 4 >> 2] = 0;
  $12_1 = $4_1 + 32 | 0;
  HEAP32[$12_1 >> 2] = 0;
  HEAP32[$12_1 + 4 >> 2] = 0;
  $9_1 = $4_1 + 24 | 0;
  HEAP32[$9_1 >> 2] = 0;
  HEAP32[$9_1 + 4 >> 2] = 0;
  $11_1 = $4_1 + 16 | 0;
  HEAP32[$11_1 >> 2] = 0;
  HEAP32[$11_1 + 4 >> 2] = 0;
  $17_1 = $4_1 + 8 | 0;
  HEAP32[$17_1 >> 2] = 0;
  HEAP32[$17_1 + 4 >> 2] = 0;
  HEAP32[$5_1 + 128 >> 2] = 0;
  HEAP32[$5_1 + 132 >> 2] = 0;
  label$1 : {
   if (($31(HEAP32[172688], $4_1, 690820, $0_1) | 0) == 1) {
    $4_1 = $5_1 + 128 | 0;
    $0_1 = $4_1 + 15 | 0;
    $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $3_1 = $5_1 - -64 | 0;
    $10_1 = $3_1 + 8 | 0;
    HEAP32[$10_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP32[$10_1 + 4 >> 2] = $2_1;
    $0_1 = $4_1 + 23 | 0;
    $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $14_1 = $3_1 + 16 | 0;
    HEAP32[$14_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP32[$14_1 + 4 >> 2] = $2_1;
    $0_1 = $4_1 + 31 | 0;
    $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $16_1 = $3_1 + 24 | 0;
    HEAP32[$16_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP32[$16_1 + 4 >> 2] = $2_1;
    $0_1 = $4_1 + 39 | 0;
    $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $15_1 = $3_1 + 32 | 0;
    HEAP32[$15_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP32[$15_1 + 4 >> 2] = $2_1;
    $0_1 = $4_1 + 47 | 0;
    $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $13_1 = $3_1 + 40 | 0;
    HEAP32[$13_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP32[$13_1 + 4 >> 2] = $2_1;
    $0_1 = $4_1 + 55 | 0;
    $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $18_1 = $3_1 + 48 | 0;
    HEAP32[$18_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP32[$18_1 + 4 >> 2] = $2_1;
    $3_1 = $3_1 + 56 | 0;
    HEAP8[$3_1 | 0] = HEAPU8[$4_1 + 63 | 0];
    HEAP8[$5_1 + 2 | 0] = HEAPU8[$5_1 + 130 | 0];
    HEAP16[$5_1 >> 1] = HEAPU16[$5_1 + 128 >> 1];
    $0_1 = HEAPU8[$5_1 + 139 | 0] | HEAPU8[$5_1 + 140 | 0] << 8 | (HEAPU8[$5_1 + 141 | 0] << 16 | HEAPU8[$5_1 + 142 | 0] << 24);
    HEAP32[$5_1 + 64 >> 2] = HEAPU8[$5_1 + 135 | 0] | HEAPU8[$5_1 + 136 | 0] << 8 | (HEAPU8[$5_1 + 137 | 0] << 16 | HEAPU8[$5_1 + 138 | 0] << 24);
    HEAP32[$5_1 + 68 >> 2] = $0_1;
    $0_1 = HEAPU8[$5_1 + 131 | 0] | HEAPU8[$5_1 + 132 | 0] << 8 | (HEAPU8[$5_1 + 133 | 0] << 16 | HEAPU8[$5_1 + 134 | 0] << 24);
    HEAP8[$5_1 + 63 | 0] = HEAPU8[$3_1 | 0];
    $2_1 = HEAP32[$18_1 + 4 >> 2];
    $3_1 = $5_1 + 55 | 0;
    $18_1 = HEAP32[$18_1 >> 2];
    HEAP8[$3_1 | 0] = $18_1;
    HEAP8[$3_1 + 1 | 0] = $18_1 >>> 8;
    HEAP8[$3_1 + 2 | 0] = $18_1 >>> 16;
    HEAP8[$3_1 + 3 | 0] = $18_1 >>> 24;
    HEAP8[$3_1 + 4 | 0] = $2_1;
    HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
    HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
    HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
    $2_1 = HEAP32[$13_1 + 4 >> 2];
    $3_1 = $5_1 + 47 | 0;
    $13_1 = HEAP32[$13_1 >> 2];
    HEAP8[$3_1 | 0] = $13_1;
    HEAP8[$3_1 + 1 | 0] = $13_1 >>> 8;
    HEAP8[$3_1 + 2 | 0] = $13_1 >>> 16;
    HEAP8[$3_1 + 3 | 0] = $13_1 >>> 24;
    HEAP8[$3_1 + 4 | 0] = $2_1;
    HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
    HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
    HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
    $2_1 = HEAP32[$15_1 + 4 >> 2];
    $3_1 = $5_1 + 39 | 0;
    $15_1 = HEAP32[$15_1 >> 2];
    HEAP8[$3_1 | 0] = $15_1;
    HEAP8[$3_1 + 1 | 0] = $15_1 >>> 8;
    HEAP8[$3_1 + 2 | 0] = $15_1 >>> 16;
    HEAP8[$3_1 + 3 | 0] = $15_1 >>> 24;
    HEAP8[$3_1 + 4 | 0] = $2_1;
    HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
    HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
    HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
    $2_1 = HEAP32[$16_1 + 4 >> 2];
    $3_1 = $5_1 + 31 | 0;
    $16_1 = HEAP32[$16_1 >> 2];
    HEAP8[$3_1 | 0] = $16_1;
    HEAP8[$3_1 + 1 | 0] = $16_1 >>> 8;
    HEAP8[$3_1 + 2 | 0] = $16_1 >>> 16;
    HEAP8[$3_1 + 3 | 0] = $16_1 >>> 24;
    HEAP8[$3_1 + 4 | 0] = $2_1;
    HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
    HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
    HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
    $2_1 = HEAP32[$14_1 + 4 >> 2];
    $3_1 = $5_1 + 23 | 0;
    $14_1 = HEAP32[$14_1 >> 2];
    HEAP8[$3_1 | 0] = $14_1;
    HEAP8[$3_1 + 1 | 0] = $14_1 >>> 8;
    HEAP8[$3_1 + 2 | 0] = $14_1 >>> 16;
    HEAP8[$3_1 + 3 | 0] = $14_1 >>> 24;
    HEAP8[$3_1 + 4 | 0] = $2_1;
    HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
    HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
    HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
    $2_1 = HEAP32[$10_1 + 4 >> 2];
    $3_1 = $5_1 + 15 | 0;
    $10_1 = HEAP32[$10_1 >> 2];
    HEAP8[$3_1 | 0] = $10_1;
    HEAP8[$3_1 + 1 | 0] = $10_1 >>> 8;
    HEAP8[$3_1 + 2 | 0] = $10_1 >>> 16;
    HEAP8[$3_1 + 3 | 0] = $10_1 >>> 24;
    HEAP8[$3_1 + 4 | 0] = $2_1;
    HEAP8[$3_1 + 5 | 0] = $2_1 >>> 8;
    HEAP8[$3_1 + 6 | 0] = $2_1 >>> 16;
    HEAP8[$3_1 + 7 | 0] = $2_1 >>> 24;
    HEAP8[$5_1 + 3 | 0] = $0_1;
    HEAP8[$5_1 + 4 | 0] = $0_1 >>> 8;
    HEAP8[$5_1 + 5 | 0] = $0_1 >>> 16;
    HEAP8[$5_1 + 6 | 0] = $0_1 >>> 24;
    $0_1 = HEAP32[$5_1 + 68 >> 2];
    $3_1 = HEAP32[$5_1 + 64 >> 2];
    HEAP8[$5_1 + 7 | 0] = $3_1;
    HEAP8[$5_1 + 8 | 0] = $3_1 >>> 8;
    HEAP8[$5_1 + 9 | 0] = $3_1 >>> 16;
    HEAP8[$5_1 + 10 | 0] = $3_1 >>> 24;
    HEAP8[$5_1 + 11 | 0] = $0_1;
    HEAP8[$5_1 + 12 | 0] = $0_1 >>> 8;
    HEAP8[$5_1 + 13 | 0] = $0_1 >>> 16;
    HEAP8[$5_1 + 14 | 0] = $0_1 >>> 24;
    HEAP32[$6_1 >> 2] = 0;
    HEAP32[$6_1 + 4 >> 2] = 0;
    HEAP32[$7_1 >> 2] = 0;
    HEAP32[$7_1 + 4 >> 2] = 0;
    HEAP32[$8_1 >> 2] = 0;
    HEAP32[$8_1 + 4 >> 2] = 0;
    HEAP32[$12_1 >> 2] = 0;
    HEAP32[$12_1 + 4 >> 2] = 0;
    HEAP32[$9_1 >> 2] = 0;
    HEAP32[$9_1 + 4 >> 2] = 0;
    HEAP32[$11_1 >> 2] = 0;
    HEAP32[$11_1 + 4 >> 2] = 0;
    HEAP32[$17_1 >> 2] = 0;
    HEAP32[$17_1 + 4 >> 2] = 0;
    HEAP32[$5_1 + 128 >> 2] = 0;
    HEAP32[$5_1 + 132 >> 2] = 0;
    $3_1 = 0;
    $6_1 = HEAP32[172688];
    $2_1 = 0;
    $0_1 = global$0 - 80 | 0;
    global$0 = $0_1;
    HEAP32[$0_1 + 12 >> 2] = 0;
    label$3 : {
     if (!$4_1) {
      FUNCTION_TABLE[HEAP32[$6_1 + 168 >> 2]](689748, HEAP32[$6_1 + 172 >> 2]);
      break label$3;
     }
     $2_1 = $0_1 + 12 | 0;
     $38($0_1 + 48 | 0, 690981, $2_1);
     $6_1 = HEAP32[$0_1 + 12 >> 2];
     $38($0_1 + 16 | 0, 691013, $2_1);
     if (!($6_1 | HEAP32[$0_1 + 12 >> 2])) {
      $2_1 = HEAP32[$0_1 + 52 >> 2];
      $6_1 = HEAP32[$0_1 + 48 >> 2];
      HEAP8[$4_1 | 0] = $6_1;
      HEAP8[$4_1 + 1 | 0] = $6_1 >>> 8;
      HEAP8[$4_1 + 2 | 0] = $6_1 >>> 16;
      HEAP8[$4_1 + 3 | 0] = $6_1 >>> 24;
      HEAP8[$4_1 + 4 | 0] = $2_1;
      HEAP8[$4_1 + 5 | 0] = $2_1 >>> 8;
      HEAP8[$4_1 + 6 | 0] = $2_1 >>> 16;
      HEAP8[$4_1 + 7 | 0] = $2_1 >>> 24;
      $2_1 = HEAP32[$0_1 + 20 >> 2];
      $6_1 = HEAP32[$0_1 + 16 >> 2];
      HEAP8[$4_1 + 32 | 0] = $6_1;
      HEAP8[$4_1 + 33 | 0] = $6_1 >>> 8;
      HEAP8[$4_1 + 34 | 0] = $6_1 >>> 16;
      HEAP8[$4_1 + 35 | 0] = $6_1 >>> 24;
      HEAP8[$4_1 + 36 | 0] = $2_1;
      HEAP8[$4_1 + 37 | 0] = $2_1 >>> 8;
      HEAP8[$4_1 + 38 | 0] = $2_1 >>> 16;
      HEAP8[$4_1 + 39 | 0] = $2_1 >>> 24;
      $8_1 = $0_1 + 48 | 0;
      $7_1 = $8_1 + 24 | 0;
      $6_1 = HEAP32[$7_1 + 4 >> 2];
      $2_1 = $4_1 + 24 | 0;
      $7_1 = HEAP32[$7_1 >> 2];
      HEAP8[$2_1 | 0] = $7_1;
      HEAP8[$2_1 + 1 | 0] = $7_1 >>> 8;
      HEAP8[$2_1 + 2 | 0] = $7_1 >>> 16;
      HEAP8[$2_1 + 3 | 0] = $7_1 >>> 24;
      HEAP8[$2_1 + 4 | 0] = $6_1;
      HEAP8[$2_1 + 5 | 0] = $6_1 >>> 8;
      HEAP8[$2_1 + 6 | 0] = $6_1 >>> 16;
      HEAP8[$2_1 + 7 | 0] = $6_1 >>> 24;
      $7_1 = $8_1 + 16 | 0;
      $6_1 = HEAP32[$7_1 + 4 >> 2];
      $2_1 = $4_1 + 16 | 0;
      $7_1 = HEAP32[$7_1 >> 2];
      HEAP8[$2_1 | 0] = $7_1;
      HEAP8[$2_1 + 1 | 0] = $7_1 >>> 8;
      HEAP8[$2_1 + 2 | 0] = $7_1 >>> 16;
      HEAP8[$2_1 + 3 | 0] = $7_1 >>> 24;
      HEAP8[$2_1 + 4 | 0] = $6_1;
      HEAP8[$2_1 + 5 | 0] = $6_1 >>> 8;
      HEAP8[$2_1 + 6 | 0] = $6_1 >>> 16;
      HEAP8[$2_1 + 7 | 0] = $6_1 >>> 24;
      $7_1 = $8_1 + 8 | 0;
      $6_1 = HEAP32[$7_1 + 4 >> 2];
      $2_1 = $4_1 + 8 | 0;
      $7_1 = HEAP32[$7_1 >> 2];
      HEAP8[$2_1 | 0] = $7_1;
      HEAP8[$2_1 + 1 | 0] = $7_1 >>> 8;
      HEAP8[$2_1 + 2 | 0] = $7_1 >>> 16;
      HEAP8[$2_1 + 3 | 0] = $7_1 >>> 24;
      HEAP8[$2_1 + 4 | 0] = $6_1;
      HEAP8[$2_1 + 5 | 0] = $6_1 >>> 8;
      HEAP8[$2_1 + 6 | 0] = $6_1 >>> 16;
      HEAP8[$2_1 + 7 | 0] = $6_1 >>> 24;
      $8_1 = $0_1 + 16 | 0;
      $7_1 = $8_1 + 8 | 0;
      $6_1 = HEAP32[$7_1 + 4 >> 2];
      $2_1 = $4_1 + 40 | 0;
      $7_1 = HEAP32[$7_1 >> 2];
      HEAP8[$2_1 | 0] = $7_1;
      HEAP8[$2_1 + 1 | 0] = $7_1 >>> 8;
      HEAP8[$2_1 + 2 | 0] = $7_1 >>> 16;
      HEAP8[$2_1 + 3 | 0] = $7_1 >>> 24;
      HEAP8[$2_1 + 4 | 0] = $6_1;
      HEAP8[$2_1 + 5 | 0] = $6_1 >>> 8;
      HEAP8[$2_1 + 6 | 0] = $6_1 >>> 16;
      HEAP8[$2_1 + 7 | 0] = $6_1 >>> 24;
      $7_1 = $8_1 + 16 | 0;
      $6_1 = HEAP32[$7_1 + 4 >> 2];
      $2_1 = $4_1 + 48 | 0;
      $7_1 = HEAP32[$7_1 >> 2];
      HEAP8[$2_1 | 0] = $7_1;
      HEAP8[$2_1 + 1 | 0] = $7_1 >>> 8;
      HEAP8[$2_1 + 2 | 0] = $7_1 >>> 16;
      HEAP8[$2_1 + 3 | 0] = $7_1 >>> 24;
      HEAP8[$2_1 + 4 | 0] = $6_1;
      HEAP8[$2_1 + 5 | 0] = $6_1 >>> 8;
      HEAP8[$2_1 + 6 | 0] = $6_1 >>> 16;
      HEAP8[$2_1 + 7 | 0] = $6_1 >>> 24;
      $6_1 = $8_1 + 24 | 0;
      $2_1 = HEAP32[$6_1 + 4 >> 2];
      $4_1 = $4_1 + 56 | 0;
      $6_1 = HEAP32[$6_1 >> 2];
      HEAP8[$4_1 | 0] = $6_1;
      HEAP8[$4_1 + 1 | 0] = $6_1 >>> 8;
      HEAP8[$4_1 + 2 | 0] = $6_1 >>> 16;
      HEAP8[$4_1 + 3 | 0] = $6_1 >>> 24;
      HEAP8[$4_1 + 4 | 0] = $2_1;
      HEAP8[$4_1 + 5 | 0] = $2_1 >>> 8;
      HEAP8[$4_1 + 6 | 0] = $2_1 >>> 16;
      HEAP8[$4_1 + 7 | 0] = $2_1 >>> 24;
      $2_1 = 1;
      break label$3;
     }
     HEAP8[$4_1 | 0] = 0;
     HEAP8[$4_1 + 1 | 0] = 0;
     HEAP8[$4_1 + 2 | 0] = 0;
     HEAP8[$4_1 + 3 | 0] = 0;
     HEAP8[$4_1 + 4 | 0] = 0;
     HEAP8[$4_1 + 5 | 0] = 0;
     HEAP8[$4_1 + 6 | 0] = 0;
     HEAP8[$4_1 + 7 | 0] = 0;
     $2_1 = $4_1 + 56 | 0;
     HEAP8[$2_1 | 0] = 0;
     HEAP8[$2_1 + 1 | 0] = 0;
     HEAP8[$2_1 + 2 | 0] = 0;
     HEAP8[$2_1 + 3 | 0] = 0;
     HEAP8[$2_1 + 4 | 0] = 0;
     HEAP8[$2_1 + 5 | 0] = 0;
     HEAP8[$2_1 + 6 | 0] = 0;
     HEAP8[$2_1 + 7 | 0] = 0;
     $2_1 = $4_1 + 48 | 0;
     HEAP8[$2_1 | 0] = 0;
     HEAP8[$2_1 + 1 | 0] = 0;
     HEAP8[$2_1 + 2 | 0] = 0;
     HEAP8[$2_1 + 3 | 0] = 0;
     HEAP8[$2_1 + 4 | 0] = 0;
     HEAP8[$2_1 + 5 | 0] = 0;
     HEAP8[$2_1 + 6 | 0] = 0;
     HEAP8[$2_1 + 7 | 0] = 0;
     $2_1 = $4_1 + 40 | 0;
     HEAP8[$2_1 | 0] = 0;
     HEAP8[$2_1 + 1 | 0] = 0;
     HEAP8[$2_1 + 2 | 0] = 0;
     HEAP8[$2_1 + 3 | 0] = 0;
     HEAP8[$2_1 + 4 | 0] = 0;
     HEAP8[$2_1 + 5 | 0] = 0;
     HEAP8[$2_1 + 6 | 0] = 0;
     HEAP8[$2_1 + 7 | 0] = 0;
     $2_1 = $4_1 + 32 | 0;
     HEAP8[$2_1 | 0] = 0;
     HEAP8[$2_1 + 1 | 0] = 0;
     HEAP8[$2_1 + 2 | 0] = 0;
     HEAP8[$2_1 + 3 | 0] = 0;
     HEAP8[$2_1 + 4 | 0] = 0;
     HEAP8[$2_1 + 5 | 0] = 0;
     HEAP8[$2_1 + 6 | 0] = 0;
     HEAP8[$2_1 + 7 | 0] = 0;
     $2_1 = $4_1 + 24 | 0;
     HEAP8[$2_1 | 0] = 0;
     HEAP8[$2_1 + 1 | 0] = 0;
     HEAP8[$2_1 + 2 | 0] = 0;
     HEAP8[$2_1 + 3 | 0] = 0;
     HEAP8[$2_1 + 4 | 0] = 0;
     HEAP8[$2_1 + 5 | 0] = 0;
     HEAP8[$2_1 + 6 | 0] = 0;
     HEAP8[$2_1 + 7 | 0] = 0;
     $2_1 = $4_1 + 16 | 0;
     HEAP8[$2_1 | 0] = 0;
     HEAP8[$2_1 + 1 | 0] = 0;
     HEAP8[$2_1 + 2 | 0] = 0;
     HEAP8[$2_1 + 3 | 0] = 0;
     HEAP8[$2_1 + 4 | 0] = 0;
     HEAP8[$2_1 + 5 | 0] = 0;
     HEAP8[$2_1 + 6 | 0] = 0;
     HEAP8[$2_1 + 7 | 0] = 0;
     $4_1 = $4_1 + 8 | 0;
     HEAP8[$4_1 | 0] = 0;
     HEAP8[$4_1 + 1 | 0] = 0;
     HEAP8[$4_1 + 2 | 0] = 0;
     HEAP8[$4_1 + 3 | 0] = 0;
     HEAP8[$4_1 + 4 | 0] = 0;
     HEAP8[$4_1 + 5 | 0] = 0;
     HEAP8[$4_1 + 6 | 0] = 0;
     HEAP8[$4_1 + 7 | 0] = 0;
     $2_1 = 0;
    }
    global$0 = $0_1 + 80 | 0;
    if (!$2_1) {
     fimport$1(4);
     break label$1;
    }
    if (!$1_1) {
     label$8 : {
      $0_1 = HEAP32[172688];
      $2_1 = $5_1 + 128 | 0;
      if (!$2_1) {
       FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689716, HEAP32[$0_1 + 172 >> 2]);
       break label$8;
      }
      $1_1 = HEAPU8[$2_1 + 60 | 0] | HEAPU8[$2_1 + 61 | 0] << 8 | (HEAPU8[$2_1 + 62 | 0] << 16 | HEAPU8[$2_1 + 63 | 0] << 24);
      $12_1 = $1_1;
      $1_1 = $1_1 >>> 31 | 0;
      $3_1 = $1_1 ^ -1;
      $9_1 = HEAPU8[$2_1 + 44 | 0] | HEAPU8[$2_1 + 45 | 0] << 8 | (HEAPU8[$2_1 + 46 | 0] << 16 | HEAPU8[$2_1 + 47 | 0] << 24);
      $4_1 = ($9_1 | 0) == 1566010995;
      $11_1 = HEAPU8[$2_1 + 40 | 0] | HEAPU8[$2_1 + 41 | 0] << 8 | (HEAPU8[$2_1 + 42 | 0] << 16 | HEAPU8[$2_1 + 43 | 0] << 24);
      $10_1 = HEAPU8[$2_1 + 48 | 0] | HEAPU8[$2_1 + 49 | 0] << 8 | (HEAPU8[$2_1 + 50 | 0] << 16 | HEAPU8[$2_1 + 51 | 0] << 24);
      $14_1 = HEAPU8[$2_1 + 52 | 0] | HEAPU8[$2_1 + 53 | 0] << 8 | (HEAPU8[$2_1 + 54 | 0] << 16 | HEAPU8[$2_1 + 55 | 0] << 24);
      $0_1 = HEAPU8[$2_1 + 56 | 0] | HEAPU8[$2_1 + 57 | 0] << 8 | (HEAPU8[$2_1 + 58 | 0] << 16 | HEAPU8[$2_1 + 59 | 0] << 24);
      $3_1 = ($3_1 & ($4_1 & $11_1 >>> 0 < 1470386205 | $9_1 >>> 0 < 1566010995) | ($3_1 & ($10_1 & $14_1) != -1 | (($12_1 | 0) == 2147483647 & ($0_1 | 0) != -1 | $12_1 >>> 0 < 2147483647))) ^ -1;
      $17_1 = HEAPU8[$2_1 + 36 | 0] | HEAPU8[$2_1 + 37 | 0] << 8 | (HEAPU8[$2_1 + 38 | 0] << 16 | HEAPU8[$2_1 + 39 | 0] << 24);
      $16_1 = HEAPU8[$2_1 + 32 | 0] | HEAPU8[$2_1 + 33 | 0] << 8 | (HEAPU8[$2_1 + 34 | 0] << 16 | HEAPU8[$2_1 + 35 | 0] << 24);
      $1_1 = $3_1 & (($17_1 | 0) == -538366138 & $16_1 >>> 0 > 1746608288 | $17_1 >>> 0 > 3756601158) | ($3_1 & ($4_1 & $11_1 >>> 0 > 1470386205 | $9_1 >>> 0 > 1566010995) | $1_1);
      if ($2_1) {
       if ($1_1) {
        $1_1 = $16_1 ^ -1;
        $4_1 = $1_1 - 801750718 | 0;
        $13_1 = $4_1;
        $3_1 = $17_1 ^ -1;
        $7_1 = $3_1 - (($1_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
        $4_1 = ($3_1 | 0) == ($7_1 | 0) & $1_1 >>> 0 > $4_1 >>> 0 | $3_1 >>> 0 > $7_1 >>> 0;
        $15_1 = $11_1 ^ -1;
        $1_1 = $4_1 + $15_1 | 0;
        $3_1 = $9_1 ^ -1;
        $6_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $4_1 = $1_1 - 1354194885 | 0;
        $18_1 = $4_1;
        $19_1 = $10_1 ^ -1;
        $3_1 = ($3_1 | 0) == ($6_1 | 0) & $1_1 >>> 0 < $15_1 >>> 0 | $3_1 >>> 0 > $6_1 >>> 0;
        $15_1 = $6_1 - (($1_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
        $4_1 = ($15_1 | 0) == ($6_1 | 0) & $1_1 >>> 0 > $4_1 >>> 0 | $6_1 >>> 0 > $15_1 >>> 0;
        $1_1 = $3_1 + $4_1 | 0;
        $8_1 = $14_1 ^ -1;
        $3_1 = $8_1 + ($1_1 >>> 0 < $4_1 >>> 0) | 0;
        $4_1 = $1_1 + $19_1 | 0;
        $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
        $6_1 = $4_1 - 2 | 0;
        $20_1 = $6_1;
        $1_1 = $11_1 | $16_1 | $10_1 | $0_1 | ($9_1 | $17_1 | $14_1 | $12_1) ? -1 : 0;
        $14_1 = ($3_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 < $19_1 >>> 0 | $3_1 >>> 0 < $8_1 >>> 0;
        $8_1 = $3_1 - ($4_1 >>> 0 < 2) | 0;
        $3_1 = ($8_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 > $6_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
        $4_1 = $14_1 + $3_1 | 0;
        $6_1 = $3_1 >>> 0 > $4_1 >>> 0;
        $3_1 = $0_1;
        $9_1 = $4_1 - $3_1 | 0;
        $0_1 = $9_1 - 2 & $1_1;
        $12_1 = $1_1 & ($6_1 - (($3_1 >>> 0 > $4_1 >>> 0) + $12_1 | 0) | 0) - ($9_1 >>> 0 < 2);
        $3_1 = $1_1;
        $10_1 = $3_1 & $20_1;
        $14_1 = $3_1 & $8_1;
        $16_1 = $3_1 & $13_1;
        $17_1 = $3_1 & $7_1;
        $11_1 = $3_1 & $18_1;
        $9_1 = $3_1 & $15_1;
       }
       $6_1 = $2_1 + 8 | 0;
       $15_1 = HEAPU8[$6_1 | 0] | HEAPU8[$6_1 + 1 | 0] << 8 | (HEAPU8[$6_1 + 2 | 0] << 16 | HEAPU8[$6_1 + 3 | 0] << 24);
       $3_1 = HEAPU8[$6_1 + 4 | 0] | HEAPU8[$6_1 + 5 | 0] << 8 | (HEAPU8[$6_1 + 6 | 0] << 16 | HEAPU8[$6_1 + 7 | 0] << 24);
       $7_1 = $2_1 + 16 | 0;
       $13_1 = HEAPU8[$7_1 | 0] | HEAPU8[$7_1 + 1 | 0] << 8 | (HEAPU8[$7_1 + 2 | 0] << 16 | HEAPU8[$7_1 + 3 | 0] << 24);
       $1_1 = HEAPU8[$7_1 + 4 | 0] | HEAPU8[$7_1 + 5 | 0] << 8 | (HEAPU8[$7_1 + 6 | 0] << 16 | HEAPU8[$7_1 + 7 | 0] << 24);
       $18_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
       $4_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
       $8_1 = $2_1 + 24 | 0;
       $19_1 = HEAPU8[$8_1 + 4 | 0] | HEAPU8[$8_1 + 5 | 0] << 8 | (HEAPU8[$8_1 + 6 | 0] << 16 | HEAPU8[$8_1 + 7 | 0] << 24);
       $20_1 = HEAPU8[$8_1 | 0] | HEAPU8[$8_1 + 1 | 0] << 8 | (HEAPU8[$8_1 + 2 | 0] << 16 | HEAPU8[$8_1 + 3 | 0] << 24);
       HEAP8[$8_1 | 0] = $20_1;
       HEAP8[$8_1 + 1 | 0] = $20_1 >>> 8;
       HEAP8[$8_1 + 2 | 0] = $20_1 >>> 16;
       HEAP8[$8_1 + 3 | 0] = $20_1 >>> 24;
       HEAP8[$8_1 + 4 | 0] = $19_1;
       HEAP8[$8_1 + 5 | 0] = $19_1 >>> 8;
       HEAP8[$8_1 + 6 | 0] = $19_1 >>> 16;
       HEAP8[$8_1 + 7 | 0] = $19_1 >>> 24;
       HEAP8[$7_1 | 0] = $13_1;
       HEAP8[$7_1 + 1 | 0] = $13_1 >>> 8;
       HEAP8[$7_1 + 2 | 0] = $13_1 >>> 16;
       HEAP8[$7_1 + 3 | 0] = $13_1 >>> 24;
       HEAP8[$7_1 + 4 | 0] = $1_1;
       HEAP8[$7_1 + 5 | 0] = $1_1 >>> 8;
       HEAP8[$7_1 + 6 | 0] = $1_1 >>> 16;
       HEAP8[$7_1 + 7 | 0] = $1_1 >>> 24;
       HEAP8[$6_1 | 0] = $15_1;
       HEAP8[$6_1 + 1 | 0] = $15_1 >>> 8;
       HEAP8[$6_1 + 2 | 0] = $15_1 >>> 16;
       HEAP8[$6_1 + 3 | 0] = $15_1 >>> 24;
       HEAP8[$6_1 + 4 | 0] = $3_1;
       HEAP8[$6_1 + 5 | 0] = $3_1 >>> 8;
       HEAP8[$6_1 + 6 | 0] = $3_1 >>> 16;
       HEAP8[$6_1 + 7 | 0] = $3_1 >>> 24;
       HEAP8[$2_1 | 0] = $18_1;
       HEAP8[$2_1 + 1 | 0] = $18_1 >>> 8;
       HEAP8[$2_1 + 2 | 0] = $18_1 >>> 16;
       HEAP8[$2_1 + 3 | 0] = $18_1 >>> 24;
       HEAP8[$2_1 + 4 | 0] = $4_1;
       HEAP8[$2_1 + 5 | 0] = $4_1 >>> 8;
       HEAP8[$2_1 + 6 | 0] = $4_1 >>> 16;
       HEAP8[$2_1 + 7 | 0] = $4_1 >>> 24;
       HEAP8[$2_1 + 56 | 0] = $0_1;
       HEAP8[$2_1 + 57 | 0] = $0_1 >>> 8;
       HEAP8[$2_1 + 58 | 0] = $0_1 >>> 16;
       HEAP8[$2_1 + 59 | 0] = $0_1 >>> 24;
       HEAP8[$2_1 + 60 | 0] = $12_1;
       HEAP8[$2_1 + 61 | 0] = $12_1 >>> 8;
       HEAP8[$2_1 + 62 | 0] = $12_1 >>> 16;
       HEAP8[$2_1 + 63 | 0] = $12_1 >>> 24;
       HEAP8[$2_1 + 48 | 0] = $10_1;
       HEAP8[$2_1 + 49 | 0] = $10_1 >>> 8;
       HEAP8[$2_1 + 50 | 0] = $10_1 >>> 16;
       HEAP8[$2_1 + 51 | 0] = $10_1 >>> 24;
       HEAP8[$2_1 + 52 | 0] = $14_1;
       HEAP8[$2_1 + 53 | 0] = $14_1 >>> 8;
       HEAP8[$2_1 + 54 | 0] = $14_1 >>> 16;
       HEAP8[$2_1 + 55 | 0] = $14_1 >>> 24;
       HEAP8[$2_1 + 40 | 0] = $11_1;
       HEAP8[$2_1 + 41 | 0] = $11_1 >>> 8;
       HEAP8[$2_1 + 42 | 0] = $11_1 >>> 16;
       HEAP8[$2_1 + 43 | 0] = $11_1 >>> 24;
       HEAP8[$2_1 + 44 | 0] = $9_1;
       HEAP8[$2_1 + 45 | 0] = $9_1 >>> 8;
       HEAP8[$2_1 + 46 | 0] = $9_1 >>> 16;
       HEAP8[$2_1 + 47 | 0] = $9_1 >>> 24;
       HEAP8[$2_1 + 32 | 0] = $16_1;
       HEAP8[$2_1 + 33 | 0] = $16_1 >>> 8;
       HEAP8[$2_1 + 34 | 0] = $16_1 >>> 16;
       HEAP8[$2_1 + 35 | 0] = $16_1 >>> 24;
       HEAP8[$2_1 + 36 | 0] = $17_1;
       HEAP8[$2_1 + 37 | 0] = $17_1 >>> 8;
       HEAP8[$2_1 + 38 | 0] = $17_1 >>> 16;
       HEAP8[$2_1 + 39 | 0] = $17_1 >>> 24;
      }
     }
    }
    $13_1 = $6();
    $0_1 = 0;
    $1_1 = global$0 - 464 | 0;
    global$0 = $1_1;
    $3_1 = $5_1 + 128 | 0;
    label$12 : {
     if (!$3_1) {
      FUNCTION_TABLE[HEAP32[$13_1 + 168 >> 2]](689748, HEAP32[$13_1 + 172 >> 2]);
      break label$12;
     }
     if (!$5_1) {
      FUNCTION_TABLE[HEAP32[$13_1 + 168 >> 2]](689638, HEAP32[$13_1 + 172 >> 2]);
      break label$12;
     }
     $38($1_1 + 8 | 0, 655649, 0);
     $4_1 = $3_1 + 24 | 0;
     $6_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
     $2_1 = $1_1 + 40 | 0;
     $7_1 = $2_1 + 24 | 0;
     HEAP32[$7_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
     HEAP32[$7_1 + 4 >> 2] = $6_1;
     $4_1 = $3_1 + 16 | 0;
     $6_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
     $7_1 = $2_1 + 16 | 0;
     HEAP32[$7_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
     HEAP32[$7_1 + 4 >> 2] = $6_1;
     $4_1 = $3_1 + 8 | 0;
     $6_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
     $2_1 = $2_1 + 8 | 0;
     HEAP32[$2_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
     HEAP32[$2_1 + 4 >> 2] = $6_1;
     $4_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
     HEAP32[$1_1 + 40 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
     HEAP32[$1_1 + 44 >> 2] = $4_1;
     $6_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
     $21_1 = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
     $4_1 = HEAPU8[$3_1 + 60 | 0] | HEAPU8[$3_1 + 61 | 0] << 8 | (HEAPU8[$3_1 + 62 | 0] << 16 | HEAPU8[$3_1 + 63 | 0] << 24);
     $8_1 = $4_1 >>> 31 | 0;
     $10_1 = $8_1 ^ -1;
     $2_1 = HEAPU8[$3_1 + 44 | 0] | HEAPU8[$3_1 + 45 | 0] << 8 | (HEAPU8[$3_1 + 46 | 0] << 16 | HEAPU8[$3_1 + 47 | 0] << 24);
     $11_1 = ($2_1 | 0) == 1566010995;
     $7_1 = HEAPU8[$3_1 + 40 | 0] | HEAPU8[$3_1 + 41 | 0] << 8 | (HEAPU8[$3_1 + 42 | 0] << 16 | HEAPU8[$3_1 + 43 | 0] << 24);
     $17_1 = HEAPU8[$3_1 + 48 | 0] | HEAPU8[$3_1 + 49 | 0] << 8 | (HEAPU8[$3_1 + 50 | 0] << 16 | HEAPU8[$3_1 + 51 | 0] << 24);
     $9_1 = HEAPU8[$3_1 + 52 | 0] | HEAPU8[$3_1 + 53 | 0] << 8 | (HEAPU8[$3_1 + 54 | 0] << 16 | HEAPU8[$3_1 + 55 | 0] << 24);
     $12_1 = HEAPU8[$3_1 + 56 | 0] | HEAPU8[$3_1 + 57 | 0] << 8 | (HEAPU8[$3_1 + 58 | 0] << 16 | HEAPU8[$3_1 + 59 | 0] << 24);
     $3_1 = ($10_1 & ($11_1 & $7_1 >>> 0 < 1470386205 | $2_1 >>> 0 < 1566010995) | ($10_1 & ($17_1 & $9_1) != -1 | (($4_1 | 0) == 2147483647 & ($12_1 | 0) != -1 | $4_1 >>> 0 < 2147483647))) ^ -1;
     if ((($6_1 | 0) == -538366138 & $21_1 >>> 0 > 1746608288 | $6_1 >>> 0 > 3756601158) & $3_1 | ($3_1 & ($11_1 & $7_1 >>> 0 > 1470386205 | $2_1 >>> 0 > 1566010995) | $8_1)) {
      break label$12
     }
     $3_1 = HEAPU8[$5_1 + 12 | 0] | HEAPU8[$5_1 + 13 | 0] << 8 | (HEAPU8[$5_1 + 14 | 0] << 16 | HEAPU8[$5_1 + 15 | 0] << 24);
     $11_1 = $3_1;
     $8_1 = HEAPU8[$5_1 + 8 | 0] | HEAPU8[$5_1 + 9 | 0] << 8 | (HEAPU8[$5_1 + 10 | 0] << 16 | HEAPU8[$5_1 + 11 | 0] << 24);
     $10_1 = ($3_1 << 12 | $8_1 >>> 20) & 1048575;
     $14_1 = HEAPU8[$5_1 + 4 | 0] | HEAPU8[$5_1 + 5 | 0] << 8 | (HEAPU8[$5_1 + 6 | 0] << 16 | HEAPU8[$5_1 + 7 | 0] << 24);
     $18_1 = $14_1;
     $22_1 = $8_1 << 12 & -4096 | $14_1 >>> 20;
     $23_1 = $10_1;
     $8_1 = HEAPU8[$5_1 + 16 | 0] | HEAPU8[$5_1 + 17 | 0] << 8 | (HEAPU8[$5_1 + 18 | 0] << 16 | HEAPU8[$5_1 + 19 | 0] << 24);
     $19_1 = $8_1;
     $3_1 = HEAPU8[$5_1 + 20 | 0] | HEAPU8[$5_1 + 21 | 0] << 8 | (HEAPU8[$5_1 + 22 | 0] << 16 | HEAPU8[$5_1 + 23 | 0] << 24);
     $15_1 = $3_1;
     $10_1 = ($3_1 << 24 | $8_1 >>> 8) & 1048575;
     $24_1 = $8_1 << 24 & -16777216 | $11_1 >>> 8;
     $25_1 = $10_1;
     $11_1 = HEAPU8[$5_1 + 28 | 0] | HEAPU8[$5_1 + 29 | 0] << 8 | (HEAPU8[$5_1 + 30 | 0] << 16 | HEAPU8[$5_1 + 31 | 0] << 24);
     $3_1 = $11_1 >>> 16 | 0;
     $8_1 = HEAPU8[$5_1 + 24 | 0] | HEAPU8[$5_1 + 25 | 0] << 8 | (HEAPU8[$5_1 + 26 | 0] << 16 | HEAPU8[$5_1 + 27 | 0] << 24);
     $10_1 = ($11_1 & 65535) << 16 | $8_1 >>> 16;
     $14_1 = $3_1;
     $11_1 = $8_1 << 4 & 1048560;
     $8_1 = $15_1;
     $3_1 = $8_1 >>> 28 | 0;
     $26_1 = ($8_1 & 268435455) << 4 | $19_1 >>> 28;
     $27_1 = HEAPU8[$5_1 | 0] | HEAPU8[$5_1 + 1 | 0] << 8 | (HEAPU8[$5_1 + 2 | 0] << 16 | HEAPU8[$5_1 + 3 | 0] << 24);
     $28_1 = $3_1 | $11_1;
     $29_1 = $18_1 & 1048575;
     if (!($26_1 | ($24_1 | ($10_1 | ($22_1 | $27_1))) | ($28_1 | ($25_1 | ($14_1 | ($23_1 | $29_1)))))) {
      FUNCTION_TABLE[HEAP32[$13_1 + 168 >> 2]](690116, HEAP32[$13_1 + 172 >> 2]);
      break label$12;
     }
     $11_1 = HEAP32[$1_1 + 64 >> 2];
     $16_1 = HEAP32[$1_1 + 56 >> 2];
     $30_1 = HEAP32[$1_1 + 48 >> 2];
     $31_1 = HEAP32[$1_1 + 40 >> 2];
     $8_1 = HEAP32[$1_1 + 68 >> 2];
     $18_1 = HEAP32[$1_1 + 60 >> 2];
     $15_1 = HEAP32[$1_1 + 52 >> 2];
     $13_1 = HEAP32[$1_1 + 44 >> 2];
     if (!($11_1 | ($16_1 | ($30_1 | $31_1)) | ($8_1 | ($18_1 | ($15_1 | $13_1))))) {
      break label$12
     }
     if (!($7_1 | $21_1 | $17_1 | $12_1 | ($2_1 | $6_1 | $9_1 | $4_1))) {
      break label$12
     }
     $19_1 = HEAPU8[$5_1 + 48 | 0] | HEAPU8[$5_1 + 49 | 0] << 8 | (HEAPU8[$5_1 + 50 | 0] << 16 | HEAPU8[$5_1 + 51 | 0] << 24);
     $20_1 = HEAPU8[$5_1 + 52 | 0] | HEAPU8[$5_1 + 53 | 0] << 8 | (HEAPU8[$5_1 + 54 | 0] << 16 | HEAPU8[$5_1 + 55 | 0] << 24);
     $32_1 = HEAPU8[$5_1 + 56 | 0] | HEAPU8[$5_1 + 57 | 0] << 8 | (HEAPU8[$5_1 + 58 | 0] << 16 | HEAPU8[$5_1 + 59 | 0] << 24);
     $34_1 = HEAPU8[$5_1 + 60 | 0] | HEAPU8[$5_1 + 61 | 0] << 8 | (HEAPU8[$5_1 + 62 | 0] << 16 | HEAPU8[$5_1 + 63 | 0] << 24);
     $35_1 = HEAPU8[$5_1 + 40 | 0] | HEAPU8[$5_1 + 41 | 0] << 8 | (HEAPU8[$5_1 + 42 | 0] << 16 | HEAPU8[$5_1 + 43 | 0] << 24);
     $36_1 = HEAPU8[$5_1 + 44 | 0] | HEAPU8[$5_1 + 45 | 0] << 8 | (HEAPU8[$5_1 + 46 | 0] << 16 | HEAPU8[$5_1 + 47 | 0] << 24);
     $37_1 = HEAPU8[$5_1 + 32 | 0] | HEAPU8[$5_1 + 33 | 0] << 8 | (HEAPU8[$5_1 + 34 | 0] << 16 | HEAPU8[$5_1 + 35 | 0] << 24);
     $33_1 = HEAPU8[$5_1 + 36 | 0] | HEAPU8[$5_1 + 37 | 0] << 8 | (HEAPU8[$5_1 + 38 | 0] << 16 | HEAPU8[$5_1 + 39 | 0] << 24);
     HEAP32[$1_1 + 232 >> 2] = $4_1 >>> 24;
     HEAP32[$1_1 + 236 >> 2] = 0;
     HEAP32[$1_1 + 200 >> 2] = $21_1;
     HEAP32[$1_1 + 204 >> 2] = $6_1 & 1073741823;
     $3_1 = $4_1 << 6 | $12_1 >>> 26;
     $4_1 = $9_1;
     HEAP32[$1_1 + 224 >> 2] = $12_1 << 6 | $4_1 >>> 26;
     HEAP32[$1_1 + 228 >> 2] = $3_1 & 1073741823;
     $3_1 = $4_1 << 4 | $17_1 >>> 28;
     HEAP32[$1_1 + 216 >> 2] = $17_1 << 4 | $2_1 >>> 28;
     HEAP32[$1_1 + 220 >> 2] = $3_1 & 1073741823;
     $2_1 = $2_1 << 2 | $7_1 >>> 30;
     HEAP32[$1_1 + 208 >> 2] = $7_1 << 2 | $6_1 >>> 30;
     HEAP32[$1_1 + 212 >> 2] = $2_1 & 1073741823;
     $12_1 = $1_1 + 200 | 0;
     $40($12_1, 690320);
     $2_1 = HEAP32[$1_1 + 232 >> 2] << 24;
     $7_1 = HEAP32[$1_1 + 228 >> 2];
     $3_1 = $7_1 >>> 6 | 0;
     $6_1 = HEAP32[$1_1 + 224 >> 2];
     HEAP32[$1_1 + 456 >> 2] = ($7_1 & 63) << 26 | $6_1 >>> 6;
     HEAP32[$1_1 + 460 >> 2] = $2_1 | $3_1;
     $2_1 = $6_1 << 26;
     $7_1 = HEAP32[$1_1 + 220 >> 2];
     $3_1 = $7_1 >>> 4 | 0;
     $6_1 = HEAP32[$1_1 + 216 >> 2];
     HEAP32[$1_1 + 448 >> 2] = ($7_1 & 15) << 28 | $6_1 >>> 4;
     HEAP32[$1_1 + 452 >> 2] = $2_1 | $3_1;
     $2_1 = $6_1 << 28;
     $7_1 = HEAP32[$1_1 + 212 >> 2];
     $3_1 = $7_1 >>> 2 | 0;
     $6_1 = HEAP32[$1_1 + 208 >> 2];
     HEAP32[$1_1 + 440 >> 2] = ($7_1 & 3) << 30 | $6_1 >>> 2;
     HEAP32[$1_1 + 444 >> 2] = $2_1 | $3_1;
     $2_1 = HEAP32[$1_1 + 204 >> 2];
     $3_1 = $6_1 << 30;
     HEAP32[$1_1 + 432 >> 2] = HEAP32[$1_1 + 200 >> 2];
     HEAP32[$1_1 + 436 >> 2] = $2_1 | $3_1;
     $6_1 = $1_1 + 400 | 0;
     $3_1 = $1_1 + 432 | 0;
     $41($6_1, $3_1, $1_1 + 8 | 0);
     $7_1 = $1_1 + 368 | 0;
     $41($7_1, $3_1, $1_1 + 40 | 0);
     $3_1 = $1_1 + 288 | 0;
     HEAP32[$3_1 >> 2] = 0;
     HEAP32[$3_1 + 4 >> 2] = 0;
     $4_1 = $34_1;
     $3_1 = $4_1 >>> 16 | 0;
     $2_1 = $1_1 + 272 | 0;
     HEAP32[$2_1 >> 2] = ($4_1 & 65535) << 16 | $32_1 >>> 16;
     HEAP32[$2_1 + 4 >> 2] = $3_1;
     $9_1 = $32_1 << 4 & 1048560;
     $4_1 = $20_1;
     $3_1 = $4_1 >>> 28 | 0;
     $2_1 = $1_1 + 264 | 0;
     HEAP32[$2_1 >> 2] = ($4_1 & 268435455) << 4 | $19_1 >>> 28;
     HEAP32[$2_1 + 4 >> 2] = $3_1 | $9_1;
     $3_1 = $4_1 << 24 | $19_1 >>> 8;
     $2_1 = $1_1 + 256 | 0;
     $4_1 = $36_1;
     HEAP32[$2_1 >> 2] = $19_1 << 24 & -16777216 | $4_1 >>> 8;
     HEAP32[$2_1 + 4 >> 2] = $3_1 & 1048575;
     $3_1 = $4_1 << 12;
     $4_1 = $35_1;
     $9_1 = ($3_1 | $4_1 >>> 20) & 1048575;
     $2_1 = $1_1 + 248 | 0;
     HEAP32[$2_1 >> 2] = $4_1 << 12 & -4096 | $33_1 >>> 20;
     HEAP32[$2_1 + 4 >> 2] = $9_1;
     $3_1 = $1_1 + 296 | 0;
     HEAP32[$3_1 >> 2] = 0;
     HEAP32[$3_1 + 4 >> 2] = 0;
     $3_1 = $1_1 + 304 | 0;
     HEAP32[$3_1 >> 2] = 0;
     HEAP32[$3_1 + 4 >> 2] = 0;
     $3_1 = $1_1 + 312 | 0;
     HEAP32[$3_1 >> 2] = 0;
     HEAP32[$3_1 + 4 >> 2] = 0;
     HEAP32[$1_1 + 280 >> 2] = 1;
     HEAP32[$1_1 + 284 >> 2] = 0;
     HEAP32[$1_1 + 240 >> 2] = $37_1;
     HEAP32[$1_1 + 244 >> 2] = $33_1 & 1048575;
     HEAP32[$1_1 + 232 >> 2] = $10_1;
     HEAP32[$1_1 + 236 >> 2] = $14_1;
     HEAP32[$1_1 + 224 >> 2] = $26_1;
     HEAP32[$1_1 + 228 >> 2] = $28_1;
     HEAP32[$1_1 + 216 >> 2] = $24_1;
     HEAP32[$1_1 + 220 >> 2] = $25_1;
     HEAP32[$1_1 + 208 >> 2] = $22_1;
     HEAP32[$1_1 + 212 >> 2] = $23_1;
     HEAP32[$1_1 + 200 >> 2] = $27_1;
     HEAP32[$1_1 + 204 >> 2] = $29_1;
     HEAP32[$1_1 + 320 >> 2] = 0;
     $42($1_1 + 72 | 0, $12_1, $7_1, $6_1);
     if (HEAP32[$1_1 + 192 >> 2]) {
      break label$12
     }
     $0_1 = $8_1;
     $3_1 = $0_1 >>> 16 | 0;
     HEAP32[$1_1 + 360 >> 2] = ($0_1 & 65535) << 16 | $11_1 >>> 16;
     HEAP32[$1_1 + 364 >> 2] = $3_1;
     $4_1 = $31_1;
     HEAP32[$1_1 + 328 >> 2] = $4_1;
     $8_1 = $13_1 & 1048575;
     HEAP32[$1_1 + 332 >> 2] = $8_1;
     $2_1 = $0_1;
     $0_1 = $18_1;
     $3_1 = $11_1 << 4 & 1048560 | $0_1 >>> 28;
     $17_1 = $3_1;
     $10_1 = ($0_1 & 268435455) << 4 | $16_1 >>> 28;
     HEAP32[$1_1 + 352 >> 2] = $10_1;
     HEAP32[$1_1 + 356 >> 2] = $3_1;
     $3_1 = $0_1 << 24 | $16_1 >>> 8;
     $0_1 = $15_1;
     $12_1 = $16_1 << 24 & -16777216 | $0_1 >>> 8;
     HEAP32[$1_1 + 344 >> 2] = $12_1;
     $6_1 = $3_1 & 1048575;
     HEAP32[$1_1 + 348 >> 2] = $6_1;
     $3_1 = $0_1 << 12;
     $0_1 = $30_1;
     $7_1 = ($3_1 | $0_1 >>> 20) & 1048575;
     $9_1 = $0_1 << 12 & -4096 | $13_1 >>> 20;
     HEAP32[$1_1 + 336 >> 2] = $9_1;
     HEAP32[$1_1 + 340 >> 2] = $7_1;
     $0_1 = 1;
     if ($43($1_1 + 328 | 0, $1_1 + 72 | 0)) {
      break label$12
     }
     if ($2_1 | !$2_1 & $11_1 >>> 0 > 65535) {
      $0_1 = 0;
      break label$12;
     }
     if ($10_1 | $17_1) {
      $0_1 = 0;
      break label$12;
     }
     if ($6_1 | !$6_1 & $12_1 >>> 0 > 21319971) {
      $0_1 = 0;
      break label$12;
     }
     label$19 : {
      if ($6_1 | ($12_1 | 0) != 21319971) {
       break label$19
      }
      if (($7_1 | 0) == 103691 & $9_1 >>> 0 > 1979466754 | $7_1 >>> 0 > 103691) {
       $0_1 = 0;
       break label$12;
      }
      if (($9_1 | 0) != 1979466754 | ($7_1 | 0) != 103691) {
       break label$19
      }
      $0_1 = 0;
      if (($8_1 | 0) == 893298 & $4_1 >>> 0 > 801749741 | $8_1 >>> 0 > 893298) {
       break label$12
      }
     }
     HEAP32[$1_1 + 360 >> 2] = -1;
     HEAP32[$1_1 + 364 >> 2] = 65535;
     HEAP32[$1_1 + 352 >> 2] = -1;
     HEAP32[$1_1 + 356 >> 2] = 1048575;
     $3_1 = $6_1 + 1048575 | 0;
     $0_1 = $12_1 - 21319972 | 0;
     $3_1 = $0_1 >>> 0 < 4273647324 ? $3_1 + 1 | 0 : $3_1;
     HEAP32[$1_1 + 344 >> 2] = $0_1;
     HEAP32[$1_1 + 348 >> 2] = $3_1;
     $3_1 = $7_1 + 944884 | 0;
     $2_1 = $9_1 - 1979466755 | 0;
     $3_1 = $2_1 >>> 0 < 2315500541 ? $3_1 + 1 | 0 : $3_1;
     HEAP32[$1_1 + 336 >> 2] = $2_1;
     HEAP32[$1_1 + 340 >> 2] = $3_1;
     $6_1 = $8_1 + 155276 | 0;
     $0_1 = $4_1 - 801750719 | 0;
     $6_1 = $0_1 >>> 0 < 3493216577 ? $6_1 + 1 | 0 : $6_1;
     HEAP32[$1_1 + 328 >> 2] = $0_1;
     HEAP32[$1_1 + 332 >> 2] = $6_1;
     $0_1 = ($43($1_1 + 328 | 0, $1_1 + 72 | 0) | 0) != 0;
    }
    global$0 = $1_1 + 464 | 0;
    $3_1 = $0_1;
    break label$1;
   }
   fimport$1(1);
  }
  global$0 = $5_1 + 192 | 0;
  return $3_1 | 0;
 }
 
 function $25($0_1, $1_1) {
  $0_1 = $0_1 | 0;
  $1_1 = $1_1 | 0;
  var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0;
  $10_1 = global$0 - 176 | 0;
  global$0 = $10_1;
  $7_1 = $10_1 + 8 | 0;
  $68($7_1, 65);
  $2_1 = HEAP32[172688];
  $5_1 = global$0 - 80 | 0;
  global$0 = $5_1;
  HEAP32[$5_1 + 12 >> 2] = 0;
  label$1 : {
   if (!$7_1) {
    FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689748, HEAP32[$2_1 + 172 >> 2]);
    break label$1;
   }
   if ($1_1 >>> 0 >= 4) {
    FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689986, HEAP32[$2_1 + 172 >> 2]);
    break label$1;
   }
   $2_1 = $5_1 + 12 | 0;
   $38($5_1 + 48 | 0, 690981, $2_1);
   $3_1 = HEAP32[$5_1 + 12 >> 2];
   $38($5_1 + 16 | 0, 691013, $2_1);
   if (!($3_1 | HEAP32[$5_1 + 12 >> 2])) {
    $2_1 = HEAP32[$5_1 + 52 >> 2];
    $3_1 = HEAP32[$5_1 + 48 >> 2];
    HEAP8[$7_1 | 0] = $3_1;
    HEAP8[$7_1 + 1 | 0] = $3_1 >>> 8;
    HEAP8[$7_1 + 2 | 0] = $3_1 >>> 16;
    HEAP8[$7_1 + 3 | 0] = $3_1 >>> 24;
    HEAP8[$7_1 + 4 | 0] = $2_1;
    HEAP8[$7_1 + 5 | 0] = $2_1 >>> 8;
    HEAP8[$7_1 + 6 | 0] = $2_1 >>> 16;
    HEAP8[$7_1 + 7 | 0] = $2_1 >>> 24;
    $2_1 = HEAP32[$5_1 + 20 >> 2];
    $3_1 = HEAP32[$5_1 + 16 >> 2];
    HEAP8[$7_1 + 32 | 0] = $3_1;
    HEAP8[$7_1 + 33 | 0] = $3_1 >>> 8;
    HEAP8[$7_1 + 34 | 0] = $3_1 >>> 16;
    HEAP8[$7_1 + 35 | 0] = $3_1 >>> 24;
    HEAP8[$7_1 + 36 | 0] = $2_1;
    HEAP8[$7_1 + 37 | 0] = $2_1 >>> 8;
    HEAP8[$7_1 + 38 | 0] = $2_1 >>> 16;
    HEAP8[$7_1 + 39 | 0] = $2_1 >>> 24;
    HEAP8[$7_1 + 64 | 0] = $1_1;
    $3_1 = $5_1 + 48 | 0;
    $1_1 = $3_1 + 24 | 0;
    $2_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $7_1 + 24 | 0;
    $1_1 = HEAP32[$1_1 >> 2];
    HEAP8[$4_1 | 0] = $1_1;
    HEAP8[$4_1 + 1 | 0] = $1_1 >>> 8;
    HEAP8[$4_1 + 2 | 0] = $1_1 >>> 16;
    HEAP8[$4_1 + 3 | 0] = $1_1 >>> 24;
    HEAP8[$4_1 + 4 | 0] = $2_1;
    HEAP8[$4_1 + 5 | 0] = $2_1 >>> 8;
    HEAP8[$4_1 + 6 | 0] = $2_1 >>> 16;
    HEAP8[$4_1 + 7 | 0] = $2_1 >>> 24;
    $1_1 = $3_1 + 16 | 0;
    $2_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $7_1 + 16 | 0;
    $1_1 = HEAP32[$1_1 >> 2];
    HEAP8[$4_1 | 0] = $1_1;
    HEAP8[$4_1 + 1 | 0] = $1_1 >>> 8;
    HEAP8[$4_1 + 2 | 0] = $1_1 >>> 16;
    HEAP8[$4_1 + 3 | 0] = $1_1 >>> 24;
    HEAP8[$4_1 + 4 | 0] = $2_1;
    HEAP8[$4_1 + 5 | 0] = $2_1 >>> 8;
    HEAP8[$4_1 + 6 | 0] = $2_1 >>> 16;
    HEAP8[$4_1 + 7 | 0] = $2_1 >>> 24;
    $1_1 = $3_1 + 8 | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $2_1 = $7_1 + 8 | 0;
    $1_1 = HEAP32[$1_1 >> 2];
    HEAP8[$2_1 | 0] = $1_1;
    HEAP8[$2_1 + 1 | 0] = $1_1 >>> 8;
    HEAP8[$2_1 + 2 | 0] = $1_1 >>> 16;
    HEAP8[$2_1 + 3 | 0] = $1_1 >>> 24;
    HEAP8[$2_1 + 4 | 0] = $3_1;
    HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
    HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
    HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
    $3_1 = $5_1 + 16 | 0;
    $1_1 = $3_1 + 8 | 0;
    $2_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $7_1 + 40 | 0;
    $1_1 = HEAP32[$1_1 >> 2];
    HEAP8[$4_1 | 0] = $1_1;
    HEAP8[$4_1 + 1 | 0] = $1_1 >>> 8;
    HEAP8[$4_1 + 2 | 0] = $1_1 >>> 16;
    HEAP8[$4_1 + 3 | 0] = $1_1 >>> 24;
    HEAP8[$4_1 + 4 | 0] = $2_1;
    HEAP8[$4_1 + 5 | 0] = $2_1 >>> 8;
    HEAP8[$4_1 + 6 | 0] = $2_1 >>> 16;
    HEAP8[$4_1 + 7 | 0] = $2_1 >>> 24;
    $1_1 = $3_1 + 16 | 0;
    $2_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $7_1 + 48 | 0;
    $1_1 = HEAP32[$1_1 >> 2];
    HEAP8[$4_1 | 0] = $1_1;
    HEAP8[$4_1 + 1 | 0] = $1_1 >>> 8;
    HEAP8[$4_1 + 2 | 0] = $1_1 >>> 16;
    HEAP8[$4_1 + 3 | 0] = $1_1 >>> 24;
    HEAP8[$4_1 + 4 | 0] = $2_1;
    HEAP8[$4_1 + 5 | 0] = $2_1 >>> 8;
    HEAP8[$4_1 + 6 | 0] = $2_1 >>> 16;
    HEAP8[$4_1 + 7 | 0] = $2_1 >>> 24;
    $1_1 = $3_1 + 24 | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $2_1 = $7_1 + 56 | 0;
    $1_1 = HEAP32[$1_1 >> 2];
    HEAP8[$2_1 | 0] = $1_1;
    HEAP8[$2_1 + 1 | 0] = $1_1 >>> 8;
    HEAP8[$2_1 + 2 | 0] = $1_1 >>> 16;
    HEAP8[$2_1 + 3 | 0] = $1_1 >>> 24;
    HEAP8[$2_1 + 4 | 0] = $3_1;
    HEAP8[$2_1 + 5 | 0] = $3_1 >>> 8;
    HEAP8[$2_1 + 6 | 0] = $3_1 >>> 16;
    HEAP8[$2_1 + 7 | 0] = $3_1 >>> 24;
    $3_1 = 1;
    break label$1;
   }
   $3_1 = 0;
   $68($7_1, 65);
  }
  global$0 = $5_1 + 80 | 0;
  label$5 : {
   label$6 : {
    if (!$3_1) {
     fimport$1(4);
     break label$6;
    }
    $1_1 = $10_1 + 136 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $10_1 + 128 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $10_1 + 120 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $10_1 + 112 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $10_1 + 104 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $10_1 + 96 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $10_1 + 88 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    HEAP32[$10_1 + 80 >> 2] = 0;
    HEAP32[$10_1 + 84 >> 2] = 0;
    $2_1 = $6();
    $12_1 = $10_1 + 80 | 0;
    $3_1 = global$0 - 640 | 0;
    global$0 = $3_1;
    $1_1 = $10_1 + 8 | 0;
    label$8 : {
     label$9 : {
      if (!$1_1) {
       FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689760, HEAP32[$2_1 + 172 >> 2]);
       break label$9;
      }
      if (!$12_1) {
       FUNCTION_TABLE[HEAP32[$2_1 + 168 >> 2]](689638, HEAP32[$2_1 + 172 >> 2]);
       break label$9;
      }
      $5_1 = $1_1 + 40 | 0;
      $4_1 = HEAPU8[$5_1 + 4 | 0] | HEAPU8[$5_1 + 5 | 0] << 8 | (HEAPU8[$5_1 + 6 | 0] << 16 | HEAPU8[$5_1 + 7 | 0] << 24);
      $2_1 = $3_1 + 48 | 0;
      HEAP32[$2_1 >> 2] = HEAPU8[$5_1 | 0] | HEAPU8[$5_1 + 1 | 0] << 8 | (HEAPU8[$5_1 + 2 | 0] << 16 | HEAPU8[$5_1 + 3 | 0] << 24);
      HEAP32[$2_1 + 4 >> 2] = $4_1;
      $5_1 = $1_1 + 48 | 0;
      $4_1 = HEAPU8[$5_1 + 4 | 0] | HEAPU8[$5_1 + 5 | 0] << 8 | (HEAPU8[$5_1 + 6 | 0] << 16 | HEAPU8[$5_1 + 7 | 0] << 24);
      $2_1 = $3_1 + 56 | 0;
      HEAP32[$2_1 >> 2] = HEAPU8[$5_1 | 0] | HEAPU8[$5_1 + 1 | 0] << 8 | (HEAPU8[$5_1 + 2 | 0] << 16 | HEAPU8[$5_1 + 3 | 0] << 24);
      HEAP32[$2_1 + 4 >> 2] = $4_1;
      $5_1 = $1_1 + 56 | 0;
      $4_1 = HEAPU8[$5_1 + 4 | 0] | HEAPU8[$5_1 + 5 | 0] << 8 | (HEAPU8[$5_1 + 6 | 0] << 16 | HEAPU8[$5_1 + 7 | 0] << 24);
      $2_1 = $3_1 - -64 | 0;
      HEAP32[$2_1 >> 2] = HEAPU8[$5_1 | 0] | HEAPU8[$5_1 + 1 | 0] << 8 | (HEAPU8[$5_1 + 2 | 0] << 16 | HEAPU8[$5_1 + 3 | 0] << 24);
      HEAP32[$2_1 + 4 >> 2] = $4_1;
      $2_1 = HEAPU8[$1_1 + 36 | 0] | HEAPU8[$1_1 + 37 | 0] << 8 | (HEAPU8[$1_1 + 38 | 0] << 16 | HEAPU8[$1_1 + 39 | 0] << 24);
      HEAP32[$3_1 + 40 >> 2] = HEAPU8[$1_1 + 32 | 0] | HEAPU8[$1_1 + 33 | 0] << 8 | (HEAPU8[$1_1 + 34 | 0] << 16 | HEAPU8[$1_1 + 35 | 0] << 24);
      HEAP32[$3_1 + 44 >> 2] = $2_1;
      $17_1 = HEAPU8[$1_1 + 64 | 0];
      $11_1 = HEAPU8[$1_1 + 24 | 0] | HEAPU8[$1_1 + 25 | 0] << 8 | (HEAPU8[$1_1 + 26 | 0] << 16 | HEAPU8[$1_1 + 27 | 0] << 24);
      $2_1 = HEAPU8[$1_1 + 28 | 0] | HEAPU8[$1_1 + 29 | 0] << 8 | (HEAPU8[$1_1 + 30 | 0] << 16 | HEAPU8[$1_1 + 31 | 0] << 24);
      $14_1 = HEAPU8[$1_1 + 16 | 0] | HEAPU8[$1_1 + 17 | 0] << 8 | (HEAPU8[$1_1 + 18 | 0] << 16 | HEAPU8[$1_1 + 19 | 0] << 24);
      $7_1 = HEAPU8[$1_1 + 20 | 0] | HEAPU8[$1_1 + 21 | 0] << 8 | (HEAPU8[$1_1 + 22 | 0] << 16 | HEAPU8[$1_1 + 23 | 0] << 24);
      $18_1 = HEAPU8[$1_1 + 8 | 0] | HEAPU8[$1_1 + 9 | 0] << 8 | (HEAPU8[$1_1 + 10 | 0] << 16 | HEAPU8[$1_1 + 11 | 0] << 24);
      $5_1 = HEAPU8[$1_1 + 12 | 0] | HEAPU8[$1_1 + 13 | 0] << 8 | (HEAPU8[$1_1 + 14 | 0] << 16 | HEAPU8[$1_1 + 15 | 0] << 24);
      $19_1 = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
      $4_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
      $38($3_1 + 8 | 0, 655649, 0);
      label$12 : {
       if (!($11_1 | ($14_1 | ($18_1 | $19_1)) | ($2_1 | ($7_1 | ($4_1 | $5_1))))) {
        break label$12
       }
       if (!(HEAP32[$3_1 + 64 >> 2] | (HEAP32[$3_1 + 56 >> 2] | (HEAP32[$3_1 + 48 >> 2] | HEAP32[$3_1 + 40 >> 2])) | (HEAP32[$3_1 + 68 >> 2] | (HEAP32[$3_1 + 60 >> 2] | (HEAP32[$3_1 + 52 >> 2] | HEAP32[$3_1 + 44 >> 2]))))) {
        break label$12
       }
       $1_1 = $3_1;
       HEAP32[$1_1 + 632 >> 2] = ($2_1 & 65535) << 16 | $11_1 >>> 16;
       HEAP32[$1_1 + 636 >> 2] = $2_1 >>> 16;
       HEAP32[$1_1 + 600 >> 2] = $19_1;
       $23_1 = $4_1 & 1048575;
       HEAP32[$1_1 + 604 >> 2] = $23_1;
       $15_1 = $11_1 << 4;
       $9_1 = $15_1 & 1044480;
       $6_1 = $9_1 | ($15_1 & 4080 | $7_1 >>> 28);
       $24_1 = $6_1;
       $21_1 = ($7_1 & 268435455) << 4 | $14_1 >>> 28;
       HEAP32[$1_1 + 624 >> 2] = $21_1;
       HEAP32[$1_1 + 628 >> 2] = $6_1;
       $15_1 = $7_1 << 24 | $14_1 >>> 8;
       $20_1 = $15_1 & 983040;
       $16_1 = $15_1 & 65280;
       $13_1 = $14_1 << 24 & -16777216 | $5_1 >>> 8;
       HEAP32[$1_1 + 616 >> 2] = $13_1;
       $22_1 = $20_1 | ($16_1 | $15_1 & 255);
       HEAP32[$1_1 + 620 >> 2] = $22_1;
       $6_1 = $5_1 << 12 | $18_1 >>> 20;
       $20_1 = $6_1 & 1044480;
       $16_1 = $6_1 & 4080;
       $1_1 = $18_1 << 12;
       $15_1 = $1_1 & -268435456;
       $9_1 = $6_1 & 15;
       $8_1 = $1_1 & 267386880;
       $8_1 = $15_1 | ($8_1 | ($1_1 & 1044480 | $4_1 >>> 20));
       HEAP32[$3_1 + 608 >> 2] = $8_1;
       $9_1 = $20_1 | ($9_1 | $16_1);
       HEAP32[$3_1 + 612 >> 2] = $9_1;
       if ($17_1 & 2) {
        if ($2_1 | !$2_1 & $11_1 >>> 0 > 65535) {
         break label$12
        }
        if ($24_1 | $21_1) {
         break label$12
        }
        if ($22_1 | !$22_1 & $13_1 >>> 0 > 21319971) {
         break label$12
        }
        label$14 : {
         if ($22_1 | ($13_1 | 0) != 21319971) {
          break label$14
         }
         if (($9_1 | 0) == 103691 & $8_1 >>> 0 > 1979466754 | $9_1 >>> 0 > 103691) {
          break label$12
         }
         if (($8_1 | 0) != 1979466754 | ($9_1 | 0) != 103691) {
          break label$14
         }
         if (($23_1 | 0) == 893298 & $19_1 >>> 0 > 801749741 | $23_1 >>> 0 > 893298) {
          break label$12
         }
        }
        HEAP32[$3_1 + 632 >> 2] = -1;
        HEAP32[$3_1 + 636 >> 2] = 65535;
        HEAP32[$3_1 + 624 >> 2] = -1;
        HEAP32[$3_1 + 628 >> 2] = 1048575;
        $6_1 = $22_1 + 1048575 | 0;
        $1_1 = $13_1 - 21319972 | 0;
        $6_1 = $1_1 >>> 0 < 4273647324 ? $6_1 + 1 | 0 : $6_1;
        HEAP32[$3_1 + 616 >> 2] = $1_1;
        HEAP32[$3_1 + 620 >> 2] = $6_1;
        $1_1 = $9_1 + 944884 | 0;
        $8_1 = $8_1 - 1979466755 | 0;
        $1_1 = $8_1 >>> 0 < 2315500541 ? $1_1 + 1 | 0 : $1_1;
        HEAP32[$3_1 + 608 >> 2] = $8_1;
        HEAP32[$3_1 + 612 >> 2] = $1_1;
        $6_1 = $23_1 + 155276 | 0;
        $1_1 = $19_1 - 801750719 | 0;
        $6_1 = $1_1 >>> 0 < 3493216577 ? $6_1 + 1 | 0 : $6_1;
        HEAP32[$3_1 + 600 >> 2] = $1_1;
        HEAP32[$3_1 + 604 >> 2] = $6_1;
       }
       if (!$33($3_1 + 512 | 0, $3_1 + 600 | 0, $17_1 & 1)) {
        break label$12
       }
       $9_1 = $3_1 + 512 | 0;
       $8_1 = $9_1 + 8 | 0;
       $6_1 = HEAP32[$8_1 + 4 >> 2];
       $13_1 = $3_1 + 384 | 0;
       $1_1 = $13_1 + 8 | 0;
       HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
       HEAP32[$1_1 + 4 >> 2] = $6_1;
       $8_1 = $9_1 + 16 | 0;
       $6_1 = HEAP32[$8_1 + 4 >> 2];
       $1_1 = $13_1 + 16 | 0;
       HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
       HEAP32[$1_1 + 4 >> 2] = $6_1;
       $8_1 = $9_1 + 24 | 0;
       $6_1 = HEAP32[$8_1 + 4 >> 2];
       $1_1 = $13_1 + 24 | 0;
       HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
       HEAP32[$1_1 + 4 >> 2] = $6_1;
       $8_1 = $9_1 + 32 | 0;
       $6_1 = HEAP32[$8_1 + 4 >> 2];
       $1_1 = $13_1 + 32 | 0;
       HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
       HEAP32[$1_1 + 4 >> 2] = $6_1;
       $8_1 = $9_1 + 48 | 0;
       $6_1 = HEAP32[$8_1 + 4 >> 2];
       $1_1 = $13_1 + 48 | 0;
       HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
       HEAP32[$1_1 + 4 >> 2] = $6_1;
       $8_1 = $9_1 + 56 | 0;
       $6_1 = HEAP32[$8_1 + 4 >> 2];
       $1_1 = $13_1 + 56 | 0;
       HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
       HEAP32[$1_1 + 4 >> 2] = $6_1;
       $8_1 = $9_1 - -64 | 0;
       $6_1 = HEAP32[$8_1 + 4 >> 2];
       $1_1 = $13_1 - -64 | 0;
       HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
       HEAP32[$1_1 + 4 >> 2] = $6_1;
       $8_1 = $9_1 + 72 | 0;
       $6_1 = HEAP32[$8_1 + 4 >> 2];
       $1_1 = $13_1 + 72 | 0;
       HEAP32[$1_1 >> 2] = HEAP32[$8_1 >> 2];
       HEAP32[$1_1 + 4 >> 2] = $6_1;
       HEAP32[$3_1 + 504 >> 2] = HEAP32[$3_1 + 592 >> 2];
       $1_1 = HEAP32[$3_1 + 516 >> 2];
       HEAP32[$3_1 + 384 >> 2] = HEAP32[$3_1 + 512 >> 2];
       HEAP32[$3_1 + 388 >> 2] = $1_1;
       $1_1 = HEAP32[$3_1 + 556 >> 2];
       HEAP32[$3_1 + 424 >> 2] = HEAP32[$3_1 + 552 >> 2];
       HEAP32[$3_1 + 428 >> 2] = $1_1;
       $1_1 = $3_1 + 472 | 0;
       HEAP32[$1_1 >> 2] = 0;
       HEAP32[$1_1 + 4 >> 2] = 0;
       $1_1 = $3_1 + 480 | 0;
       HEAP32[$1_1 >> 2] = 0;
       HEAP32[$1_1 + 4 >> 2] = 0;
       $1_1 = $3_1 + 488 | 0;
       HEAP32[$1_1 >> 2] = 0;
       HEAP32[$1_1 + 4 >> 2] = 0;
       $1_1 = $3_1 + 496 | 0;
       HEAP32[$1_1 >> 2] = 0;
       HEAP32[$1_1 + 4 >> 2] = 0;
       HEAP32[$3_1 + 464 >> 2] = 1;
       HEAP32[$3_1 + 468 >> 2] = 0;
       HEAP32[$3_1 + 104 >> 2] = $2_1 >>> 24;
       HEAP32[$3_1 + 108 >> 2] = 0;
       $2_1 = $2_1 << 6 | $11_1 >>> 26;
       $1_1 = $7_1;
       HEAP32[$3_1 + 96 >> 2] = $11_1 << 6 | $1_1 >>> 26;
       HEAP32[$3_1 + 100 >> 2] = $2_1 & 1073741823;
       $7_1 = $1_1 << 4 | $14_1 >>> 28;
       $2_1 = $3_1;
       $1_1 = $5_1;
       HEAP32[$2_1 + 88 >> 2] = $14_1 << 4 | $1_1 >>> 28;
       HEAP32[$2_1 + 92 >> 2] = $7_1 & 1073741823;
       HEAP32[$2_1 + 80 >> 2] = $18_1 << 2 | $4_1 >>> 30;
       HEAP32[$2_1 + 84 >> 2] = ($1_1 << 2 | $18_1 >>> 30) & 1073741823;
       HEAP32[$2_1 + 72 >> 2] = $19_1;
       HEAP32[$2_1 + 76 >> 2] = $4_1 & 1073741823;
       $15_1 = $2_1 + 72 | 0;
       $40($15_1, 690320);
       $7_1 = HEAP32[$2_1 + 104 >> 2] << 24;
       $4_1 = HEAP32[$2_1 + 100 >> 2];
       $1_1 = $4_1 >>> 6 | 0;
       $5_1 = HEAP32[$2_1 + 96 >> 2];
       HEAP32[$2_1 + 376 >> 2] = ($4_1 & 63) << 26 | $5_1 >>> 6;
       HEAP32[$2_1 + 380 >> 2] = $1_1 | $7_1;
       $5_1 = $5_1 << 26;
       $1_1 = HEAP32[$2_1 + 92 >> 2];
       $6_1 = $1_1 >>> 4 | 0;
       $4_1 = HEAP32[$2_1 + 88 >> 2];
       HEAP32[$2_1 + 368 >> 2] = ($1_1 & 15) << 28 | $4_1 >>> 4;
       HEAP32[$2_1 + 372 >> 2] = $6_1 | $5_1;
       $7_1 = $4_1 << 28;
       $4_1 = HEAP32[$2_1 + 84 >> 2];
       $1_1 = $4_1 >>> 2 | 0;
       $5_1 = HEAP32[$2_1 + 80 >> 2];
       HEAP32[$2_1 + 360 >> 2] = ($4_1 & 3) << 30 | $5_1 >>> 2;
       HEAP32[$2_1 + 364 >> 2] = $1_1 | $7_1;
       $7_1 = HEAP32[$2_1 + 76 >> 2];
       $6_1 = $5_1 << 30;
       HEAP32[$2_1 + 352 >> 2] = HEAP32[$2_1 + 72 >> 2];
       HEAP32[$2_1 + 356 >> 2] = $6_1 | $7_1;
       $9_1 = $2_1 + 320 | 0;
       $8_1 = $2_1 + 352 | 0;
       $41($9_1, $8_1, $2_1 + 8 | 0);
       $21_1 = HEAP32[$2_1 + 344 >> 2];
       $19_1 = HEAP32[$2_1 + 336 >> 2];
       $11_1 = HEAP32[$2_1 + 328 >> 2];
       $4_1 = HEAP32[$2_1 + 320 >> 2];
       $18_1 = HEAP32[$2_1 + 348 >> 2];
       $14_1 = HEAP32[$2_1 + 340 >> 2];
       $6_1 = HEAP32[$2_1 + 332 >> 2];
       $7_1 = HEAP32[$2_1 + 324 >> 2];
       $1_1 = $21_1 | ($19_1 | ($11_1 | $4_1)) | ($18_1 | ($14_1 | ($6_1 | $7_1))) ? -1 : 0;
       $16_1 = $4_1 ^ -1;
       $5_1 = $16_1 - 801750718 | 0;
       HEAP32[$2_1 + 320 >> 2] = $1_1 & $5_1;
       $4_1 = $1_1;
       $7_1 = $7_1 ^ -1;
       $1_1 = $7_1 - (($16_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
       HEAP32[$2_1 + 324 >> 2] = $4_1 & $1_1;
       $1_1 = ($1_1 | 0) == ($7_1 | 0) & $5_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 < $7_1 >>> 0;
       $11_1 = $11_1 ^ -1;
       $17_1 = $1_1 + $11_1 | 0;
       $20_1 = $6_1 ^ -1;
       $6_1 = $20_1;
       $6_1 = $1_1 >>> 0 > $17_1 >>> 0 ? $6_1 + 1 | 0 : $6_1;
       $1_1 = $17_1 - 1354194885 | 0;
       HEAP32[$2_1 + 328 >> 2] = $1_1 & $4_1;
       $16_1 = $6_1 - (($17_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
       HEAP32[$2_1 + 332 >> 2] = $16_1 & $4_1;
       $7_1 = $19_1 ^ -1;
       $1_1 = ($6_1 | 0) == ($16_1 | 0) & $1_1 >>> 0 < $17_1 >>> 0 | $6_1 >>> 0 > $16_1 >>> 0;
       $11_1 = $1_1 + (($6_1 | 0) == ($20_1 | 0) & $11_1 >>> 0 > $17_1 >>> 0 | $6_1 >>> 0 < $20_1 >>> 0) | 0;
       $14_1 = $14_1 ^ -1;
       $1_1 = $14_1 + ($1_1 >>> 0 > $11_1 >>> 0) | 0;
       $6_1 = $7_1 + $11_1 | 0;
       $1_1 = $6_1 >>> 0 < $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
       $5_1 = $6_1 - 2 | 0;
       HEAP32[$2_1 + 336 >> 2] = $5_1 & $4_1;
       $11_1 = $1_1 - ($6_1 >>> 0 < 2) | 0;
       HEAP32[$2_1 + 340 >> 2] = $11_1 & $4_1;
       $24_1 = ($1_1 | 0) == ($14_1 | 0) & $6_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
       $1_1 = ($1_1 | 0) == ($11_1 | 0) & $6_1 >>> 0 > $5_1 >>> 0 | $1_1 >>> 0 > $11_1 >>> 0;
       $2_1 = $24_1 + $1_1 | 0;
       $6_1 = $1_1 >>> 0 > $2_1 >>> 0;
       $1_1 = $2_1 - $21_1 | 0;
       HEAP32[$3_1 + 344 >> 2] = $1_1 - 2 & $4_1;
       HEAP32[$3_1 + 348 >> 2] = ($6_1 - (($2_1 >>> 0 < $21_1 >>> 0) + $18_1 | 0) | 0) - ($1_1 >>> 0 < 2) & $4_1;
       $2_1 = $3_1 + 288 | 0;
       $41($2_1, $8_1, $3_1 + 40 | 0);
       $1_1 = $3_1 + 160 | 0;
       $42($1_1, $13_1, $2_1, $9_1);
       $56($15_1, $1_1);
       if (HEAP32[$3_1 + 280 >> 2]) {
        break label$12
       }
       $35($12_1, $3_1 + 72 | 0);
       $1_1 = 1;
       break label$8;
      }
      HEAP8[$12_1 | 0] = 0;
      HEAP8[$12_1 + 1 | 0] = 0;
      HEAP8[$12_1 + 2 | 0] = 0;
      HEAP8[$12_1 + 3 | 0] = 0;
      HEAP8[$12_1 + 4 | 0] = 0;
      HEAP8[$12_1 + 5 | 0] = 0;
      HEAP8[$12_1 + 6 | 0] = 0;
      HEAP8[$12_1 + 7 | 0] = 0;
      $1_1 = $12_1 + 56 | 0;
      HEAP8[$1_1 | 0] = 0;
      HEAP8[$1_1 + 1 | 0] = 0;
      HEAP8[$1_1 + 2 | 0] = 0;
      HEAP8[$1_1 + 3 | 0] = 0;
      HEAP8[$1_1 + 4 | 0] = 0;
      HEAP8[$1_1 + 5 | 0] = 0;
      HEAP8[$1_1 + 6 | 0] = 0;
      HEAP8[$1_1 + 7 | 0] = 0;
      $1_1 = $12_1 + 48 | 0;
      HEAP8[$1_1 | 0] = 0;
      HEAP8[$1_1 + 1 | 0] = 0;
      HEAP8[$1_1 + 2 | 0] = 0;
      HEAP8[$1_1 + 3 | 0] = 0;
      HEAP8[$1_1 + 4 | 0] = 0;
      HEAP8[$1_1 + 5 | 0] = 0;
      HEAP8[$1_1 + 6 | 0] = 0;
      HEAP8[$1_1 + 7 | 0] = 0;
      $1_1 = $12_1 + 40 | 0;
      HEAP8[$1_1 | 0] = 0;
      HEAP8[$1_1 + 1 | 0] = 0;
      HEAP8[$1_1 + 2 | 0] = 0;
      HEAP8[$1_1 + 3 | 0] = 0;
      HEAP8[$1_1 + 4 | 0] = 0;
      HEAP8[$1_1 + 5 | 0] = 0;
      HEAP8[$1_1 + 6 | 0] = 0;
      HEAP8[$1_1 + 7 | 0] = 0;
      $1_1 = $12_1 + 32 | 0;
      HEAP8[$1_1 | 0] = 0;
      HEAP8[$1_1 + 1 | 0] = 0;
      HEAP8[$1_1 + 2 | 0] = 0;
      HEAP8[$1_1 + 3 | 0] = 0;
      HEAP8[$1_1 + 4 | 0] = 0;
      HEAP8[$1_1 + 5 | 0] = 0;
      HEAP8[$1_1 + 6 | 0] = 0;
      HEAP8[$1_1 + 7 | 0] = 0;
      $1_1 = $12_1 + 24 | 0;
      HEAP8[$1_1 | 0] = 0;
      HEAP8[$1_1 + 1 | 0] = 0;
      HEAP8[$1_1 + 2 | 0] = 0;
      HEAP8[$1_1 + 3 | 0] = 0;
      HEAP8[$1_1 + 4 | 0] = 0;
      HEAP8[$1_1 + 5 | 0] = 0;
      HEAP8[$1_1 + 6 | 0] = 0;
      HEAP8[$1_1 + 7 | 0] = 0;
      $1_1 = $12_1 + 16 | 0;
      HEAP8[$1_1 | 0] = 0;
      HEAP8[$1_1 + 1 | 0] = 0;
      HEAP8[$1_1 + 2 | 0] = 0;
      HEAP8[$1_1 + 3 | 0] = 0;
      HEAP8[$1_1 + 4 | 0] = 0;
      HEAP8[$1_1 + 5 | 0] = 0;
      HEAP8[$1_1 + 6 | 0] = 0;
      HEAP8[$1_1 + 7 | 0] = 0;
      $1_1 = $12_1 + 8 | 0;
      HEAP8[$1_1 | 0] = 0;
      HEAP8[$1_1 + 1 | 0] = 0;
      HEAP8[$1_1 + 2 | 0] = 0;
      HEAP8[$1_1 + 3 | 0] = 0;
      HEAP8[$1_1 + 4 | 0] = 0;
      HEAP8[$1_1 + 5 | 0] = 0;
      HEAP8[$1_1 + 6 | 0] = 0;
      HEAP8[$1_1 + 7 | 0] = 0;
     }
     $1_1 = 0;
    }
    global$0 = $3_1 + 640 | 0;
    if (!$1_1) {
     break label$6
    }
    HEAP32[$10_1 + 144 >> 2] = $0_1;
    $0_1 = $36(HEAP32[172688], $10_1 + 144 | 0, $10_1 + 80 | 0, ($0_1 | 0) == 33 ? 258 : 2);
    HEAP32[$10_1 + 148 >> 2] = $0_1;
    if (($0_1 | 0) != 1) {
     break label$5
    }
    $25_1 = 1;
   }
   global$0 = $10_1 + 176 | 0;
   return $25_1 | 0;
  }
  HEAP32[$10_1 + 160 >> 2] = 0;
  $5($10_1 + 152 | 0);
  wasm2js_trap();
 }
 
 function $26() {
  var $0_1 = 0, $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0;
  $3_1 = global$0 - 192 | 0;
  global$0 = $3_1;
  $0_1 = $3_1 + 128 | 0;
  $2_1 = $0_1 + 56 | 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  $2_1 = $0_1 + 48 | 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  $2_1 = $0_1 + 40 | 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  $2_1 = $0_1 + 32 | 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  $2_1 = $0_1 + 24 | 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  $2_1 = $0_1 + 16 | 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  $2_1 = $0_1 + 8 | 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  HEAP32[$3_1 + 128 >> 2] = 0;
  HEAP32[$3_1 + 132 >> 2] = 0;
  label$1 : {
   if (($57(HEAP32[172688], $0_1, 690885) | 0) == 1) {
    $2_1 = $3_1 + 128 | 0;
    $0_1 = $2_1 + 15 | 0;
    $6_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $4_1 = $3_1 - -64 | 0;
    $5_1 = $4_1 + 8 | 0;
    HEAP32[$5_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP32[$5_1 + 4 >> 2] = $6_1;
    $0_1 = $2_1 + 23 | 0;
    $1_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $6_1 = $4_1 + 16 | 0;
    HEAP32[$6_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP32[$6_1 + 4 >> 2] = $1_1;
    $0_1 = $2_1 + 31 | 0;
    $9_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $1_1 = $4_1 + 24 | 0;
    HEAP32[$1_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP32[$1_1 + 4 >> 2] = $9_1;
    $0_1 = $2_1 + 39 | 0;
    $7_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $9_1 = $4_1 + 32 | 0;
    HEAP32[$9_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP32[$9_1 + 4 >> 2] = $7_1;
    $0_1 = $2_1 + 47 | 0;
    $11_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $7_1 = $4_1 + 40 | 0;
    HEAP32[$7_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP32[$7_1 + 4 >> 2] = $11_1;
    $0_1 = $2_1 + 55 | 0;
    $10_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
    $11_1 = $4_1 + 48 | 0;
    HEAP32[$11_1 >> 2] = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
    HEAP32[$11_1 + 4 >> 2] = $10_1;
    $0_1 = $4_1 + 56 | 0;
    HEAP8[$0_1 | 0] = HEAPU8[$2_1 + 63 | 0];
    HEAP8[$3_1 + 2 | 0] = HEAPU8[$3_1 + 130 | 0];
    HEAP16[$3_1 >> 1] = HEAPU16[$3_1 + 128 >> 1];
    $2_1 = HEAPU8[$3_1 + 139 | 0] | HEAPU8[$3_1 + 140 | 0] << 8 | (HEAPU8[$3_1 + 141 | 0] << 16 | HEAPU8[$3_1 + 142 | 0] << 24);
    HEAP32[$3_1 + 64 >> 2] = HEAPU8[$3_1 + 135 | 0] | HEAPU8[$3_1 + 136 | 0] << 8 | (HEAPU8[$3_1 + 137 | 0] << 16 | HEAPU8[$3_1 + 138 | 0] << 24);
    HEAP32[$3_1 + 68 >> 2] = $2_1;
    $2_1 = HEAPU8[$3_1 + 131 | 0] | HEAPU8[$3_1 + 132 | 0] << 8 | (HEAPU8[$3_1 + 133 | 0] << 16 | HEAPU8[$3_1 + 134 | 0] << 24);
    HEAP8[$3_1 + 63 | 0] = HEAPU8[$0_1 | 0];
    $4_1 = HEAP32[$11_1 + 4 >> 2];
    $0_1 = $3_1 + 55 | 0;
    $11_1 = HEAP32[$11_1 >> 2];
    HEAP8[$0_1 | 0] = $11_1;
    HEAP8[$0_1 + 1 | 0] = $11_1 >>> 8;
    HEAP8[$0_1 + 2 | 0] = $11_1 >>> 16;
    HEAP8[$0_1 + 3 | 0] = $11_1 >>> 24;
    HEAP8[$0_1 + 4 | 0] = $4_1;
    HEAP8[$0_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$0_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$0_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$7_1 + 4 >> 2];
    $0_1 = $3_1 + 47 | 0;
    $7_1 = HEAP32[$7_1 >> 2];
    HEAP8[$0_1 | 0] = $7_1;
    HEAP8[$0_1 + 1 | 0] = $7_1 >>> 8;
    HEAP8[$0_1 + 2 | 0] = $7_1 >>> 16;
    HEAP8[$0_1 + 3 | 0] = $7_1 >>> 24;
    HEAP8[$0_1 + 4 | 0] = $4_1;
    HEAP8[$0_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$0_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$0_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$9_1 + 4 >> 2];
    $0_1 = $3_1 + 39 | 0;
    $9_1 = HEAP32[$9_1 >> 2];
    HEAP8[$0_1 | 0] = $9_1;
    HEAP8[$0_1 + 1 | 0] = $9_1 >>> 8;
    HEAP8[$0_1 + 2 | 0] = $9_1 >>> 16;
    HEAP8[$0_1 + 3 | 0] = $9_1 >>> 24;
    HEAP8[$0_1 + 4 | 0] = $4_1;
    HEAP8[$0_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$0_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$0_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$1_1 + 4 >> 2];
    $0_1 = $3_1 + 31 | 0;
    $1_1 = HEAP32[$1_1 >> 2];
    HEAP8[$0_1 | 0] = $1_1;
    HEAP8[$0_1 + 1 | 0] = $1_1 >>> 8;
    HEAP8[$0_1 + 2 | 0] = $1_1 >>> 16;
    HEAP8[$0_1 + 3 | 0] = $1_1 >>> 24;
    HEAP8[$0_1 + 4 | 0] = $4_1;
    HEAP8[$0_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$0_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$0_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$6_1 + 4 >> 2];
    $0_1 = $3_1 + 23 | 0;
    $6_1 = HEAP32[$6_1 >> 2];
    HEAP8[$0_1 | 0] = $6_1;
    HEAP8[$0_1 + 1 | 0] = $6_1 >>> 8;
    HEAP8[$0_1 + 2 | 0] = $6_1 >>> 16;
    HEAP8[$0_1 + 3 | 0] = $6_1 >>> 24;
    HEAP8[$0_1 + 4 | 0] = $4_1;
    HEAP8[$0_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$0_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$0_1 + 7 | 0] = $4_1 >>> 24;
    $4_1 = HEAP32[$5_1 + 4 >> 2];
    $0_1 = $3_1 + 15 | 0;
    $5_1 = HEAP32[$5_1 >> 2];
    HEAP8[$0_1 | 0] = $5_1;
    HEAP8[$0_1 + 1 | 0] = $5_1 >>> 8;
    HEAP8[$0_1 + 2 | 0] = $5_1 >>> 16;
    HEAP8[$0_1 + 3 | 0] = $5_1 >>> 24;
    HEAP8[$0_1 + 4 | 0] = $4_1;
    HEAP8[$0_1 + 5 | 0] = $4_1 >>> 8;
    HEAP8[$0_1 + 6 | 0] = $4_1 >>> 16;
    HEAP8[$0_1 + 7 | 0] = $4_1 >>> 24;
    HEAP8[$3_1 + 3 | 0] = $2_1;
    HEAP8[$3_1 + 4 | 0] = $2_1 >>> 8;
    HEAP8[$3_1 + 5 | 0] = $2_1 >>> 16;
    HEAP8[$3_1 + 6 | 0] = $2_1 >>> 24;
    $0_1 = HEAP32[$3_1 + 68 >> 2];
    $2_1 = HEAP32[$3_1 + 64 >> 2];
    HEAP8[$3_1 + 7 | 0] = $2_1;
    HEAP8[$3_1 + 8 | 0] = $2_1 >>> 8;
    HEAP8[$3_1 + 9 | 0] = $2_1 >>> 16;
    HEAP8[$3_1 + 10 | 0] = $2_1 >>> 24;
    HEAP8[$3_1 + 11 | 0] = $0_1;
    HEAP8[$3_1 + 12 | 0] = $0_1 >>> 8;
    HEAP8[$3_1 + 13 | 0] = $0_1 >>> 16;
    HEAP8[$3_1 + 14 | 0] = $0_1 >>> 24;
    $16_1 = $6();
    $1_1 = global$0 - 496 | 0;
    global$0 = $1_1;
    label$3 : {
     if (!$3_1) {
      FUNCTION_TABLE[HEAP32[$16_1 + 168 >> 2]](689638, HEAP32[$16_1 + 172 >> 2]);
      break label$3;
     }
     if (!$32($1_1 + 136 | 0, 690981)) {
      break label$3
     }
     $38($1_1 + 464 | 0, 691013, $1_1 + 12 | 0);
     if (HEAP32[$1_1 + 12 >> 2]) {
      break label$3
     }
     $2_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
     $6_1 = $2_1;
     $10_1 = $2_1 >>> 20 | 0;
     $5_1 = $10_1;
     $0_1 = HEAPU8[$3_1 + 12 | 0] | HEAPU8[$3_1 + 13 | 0] << 8 | (HEAPU8[$3_1 + 14 | 0] << 16 | HEAPU8[$3_1 + 15 | 0] << 24);
     $12_1 = $0_1;
     $22_1 = HEAPU8[$3_1 + 8 | 0] | HEAPU8[$3_1 + 9 | 0] << 8 | (HEAPU8[$3_1 + 10 | 0] << 16 | HEAPU8[$3_1 + 11 | 0] << 24);
     $2_1 = $22_1;
     $0_1 = $0_1 << 12 | $2_1 >>> 20;
     $17_1 = $2_1 << 12;
     $23_1 = $5_1 | $17_1 & -4096;
     $11_1 = $0_1;
     $24_1 = $0_1 & 1048575;
     $25_1 = $12_1 >>> 8 | 0;
     $9_1 = $25_1;
     $0_1 = HEAPU8[$3_1 + 20 | 0] | HEAPU8[$3_1 + 21 | 0] << 8 | (HEAPU8[$3_1 + 22 | 0] << 16 | HEAPU8[$3_1 + 23 | 0] << 24);
     $7_1 = $0_1;
     $20_1 = HEAPU8[$3_1 + 16 | 0] | HEAPU8[$3_1 + 17 | 0] << 8 | (HEAPU8[$3_1 + 18 | 0] << 16 | HEAPU8[$3_1 + 19 | 0] << 24);
     $2_1 = $20_1;
     $0_1 = $0_1 << 24 | $2_1 >>> 8;
     $26_1 = $9_1 | $2_1 << 24 & -16777216;
     $2_1 = $0_1;
     $27_1 = $0_1 & 1048575;
     $5_1 = HEAPU8[$3_1 + 28 | 0] | HEAPU8[$3_1 + 29 | 0] << 8 | (HEAPU8[$3_1 + 30 | 0] << 16 | HEAPU8[$3_1 + 31 | 0] << 24);
     $9_1 = $5_1;
     $14_1 = HEAPU8[$3_1 + 24 | 0] | HEAPU8[$3_1 + 25 | 0] << 8 | (HEAPU8[$3_1 + 26 | 0] << 16 | HEAPU8[$3_1 + 27 | 0] << 24);
     $18_1 = ($5_1 & 65535) << 16 | $14_1 >>> 16;
     $15_1 = $5_1 >>> 16 | 0;
     $5_1 = $7_1 >>> 28 | 0;
     $8_1 = ($7_1 & 268435455) << 4 | $20_1 >>> 28;
     $19_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
     $4_1 = $14_1;
     $0_1 = $4_1 << 4;
     $28_1 = $5_1 | $0_1 & 1048560;
     $13_1 = $6_1 & 1048575;
     if (!($8_1 | ($26_1 | ($18_1 | ($19_1 | $23_1))) | ($28_1 | ($27_1 | ($15_1 | ($13_1 | $24_1)))))) {
      FUNCTION_TABLE[HEAP32[$16_1 + 168 >> 2]](690116, HEAP32[$16_1 + 172 >> 2]);
      break label$3;
     }
     $14_1 = HEAPU8[$3_1 + 56 | 0] | HEAPU8[$3_1 + 57 | 0] << 8 | (HEAPU8[$3_1 + 58 | 0] << 16 | HEAPU8[$3_1 + 59 | 0] << 24);
     $16_1 = HEAPU8[$3_1 + 60 | 0] | HEAPU8[$3_1 + 61 | 0] << 8 | (HEAPU8[$3_1 + 62 | 0] << 16 | HEAPU8[$3_1 + 63 | 0] << 24);
     $21_1 = HEAPU8[$3_1 + 48 | 0] | HEAPU8[$3_1 + 49 | 0] << 8 | (HEAPU8[$3_1 + 50 | 0] << 16 | HEAPU8[$3_1 + 51 | 0] << 24);
     $30_1 = HEAPU8[$3_1 + 52 | 0] | HEAPU8[$3_1 + 53 | 0] << 8 | (HEAPU8[$3_1 + 54 | 0] << 16 | HEAPU8[$3_1 + 55 | 0] << 24);
     $31_1 = HEAPU8[$3_1 + 40 | 0] | HEAPU8[$3_1 + 41 | 0] << 8 | (HEAPU8[$3_1 + 42 | 0] << 16 | HEAPU8[$3_1 + 43 | 0] << 24);
     $32_1 = HEAPU8[$3_1 + 44 | 0] | HEAPU8[$3_1 + 45 | 0] << 8 | (HEAPU8[$3_1 + 46 | 0] << 16 | HEAPU8[$3_1 + 47 | 0] << 24);
     $33_1 = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
     $29_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
     HEAP8[$1_1 + 34 | 0] = $25_1;
     HEAP8[$1_1 + 21 | 0] = $18_1;
     HEAP8[$1_1 + 38 | 0] = ($11_1 & 1048575) << 12 | $17_1 >>> 20;
     HEAP8[$1_1 + 37 | 0] = ($11_1 & 268435455) << 4 | $17_1 >>> 28;
     HEAP8[$1_1 + 36 | 0] = $11_1 >>> 4;
     HEAP8[$1_1 + 35 | 0] = $11_1 >>> 12;
     HEAP8[$1_1 + 30 | 0] = $2_1;
     HEAP8[$1_1 + 29 | 0] = $2_1 >>> 8;
     HEAP8[$1_1 + 22 | 0] = $0_1 >>> 12;
     HEAP8[$1_1 + 47 | 0] = $19_1;
     HEAP8[$1_1 + 46 | 0] = ($6_1 & 255) << 24 | $19_1 >>> 8;
     HEAP8[$1_1 + 45 | 0] = ($6_1 & 65535) << 16 | $19_1 >>> 16;
     HEAP8[$1_1 + 44 | 0] = ($6_1 & 16777215) << 8 | $19_1 >>> 24;
     HEAP8[$1_1 + 43 | 0] = $6_1;
     HEAP8[$1_1 + 42 | 0] = $6_1 >>> 8;
     HEAP8[$1_1 + 41 | 0] = $10_1 << 4 | $13_1 >>> 16;
     HEAP8[$1_1 + 40 | 0] = $6_1 >>> 24;
     HEAP8[$1_1 + 39 | 0] = $22_1;
     HEAP8[$1_1 + 33 | 0] = $12_1 >>> 16;
     HEAP8[$1_1 + 32 | 0] = $12_1 >>> 24;
     HEAP8[$1_1 + 31 | 0] = $20_1;
     $0_1 = $7_1;
     HEAP8[$1_1 + 27 | 0] = $0_1;
     HEAP8[$1_1 + 26 | 0] = $0_1 >>> 8;
     HEAP8[$1_1 + 25 | 0] = $0_1 >>> 16;
     HEAP8[$1_1 + 24 | 0] = $0_1 >>> 24;
     HEAP8[$1_1 + 23 | 0] = $4_1;
     $0_1 = $9_1;
     HEAP8[$1_1 + 20 | 0] = ($0_1 & 16777215) << 8 | $4_1 >>> 24;
     HEAP8[$1_1 + 19 | 0] = $0_1;
     HEAP8[$1_1 + 18 | 0] = $0_1 >>> 8;
     HEAP8[$1_1 + 17 | 0] = $0_1 >>> 16;
     HEAP8[$1_1 + 16 | 0] = $0_1 >>> 24;
     HEAP8[$1_1 + 28 | 0] = $2_1 >>> 16 & 15 | $8_1 << 4;
     HEAP32[$1_1 + 400 >> 2] = 64;
     HEAP32[$1_1 + 404 >> 2] = 0;
     HEAP32[$1_1 + 328 >> 2] = -1862921884;
     HEAP32[$1_1 + 332 >> 2] = 870954602;
     HEAP32[$1_1 + 320 >> 2] = -1748470448;
     HEAP32[$1_1 + 324 >> 2] = 3983205;
     HEAP32[$1_1 + 312 >> 2] = 292000018;
     HEAP32[$1_1 + 316 >> 2] = -782074353;
     HEAP32[$1_1 + 304 >> 2] = -1662207471;
     HEAP32[$1_1 + 308 >> 2] = 596792193;
     $6_1 = $1_1 + 304 | 0;
     $29($6_1, 690981, 32);
     $29($6_1, $1_1 + 16 | 0, 32);
     $29($6_1, 655649, 32);
     $7_1 = $1_1 + 48 | 0;
     $30($6_1, $7_1);
     $17_1 = $1_1 + 432 | 0;
     $38($17_1, $7_1, 0);
     $2_1 = $16_1;
     $0_1 = $2_1 >>> 16 | 0;
     $9_1 = $1_1 + 176 | 0;
     $4_1 = $9_1 + 72 | 0;
     HEAP32[$4_1 >> 2] = ($2_1 & 65535) << 16 | $14_1 >>> 16;
     HEAP32[$4_1 + 4 >> 2] = $0_1;
     $5_1 = $14_1 << 4 & 1048560;
     $2_1 = $30_1;
     $0_1 = $2_1 >>> 28 | 0;
     $4_1 = $9_1 - -64 | 0;
     HEAP32[$4_1 >> 2] = ($2_1 & 268435455) << 4 | $21_1 >>> 28;
     HEAP32[$4_1 + 4 >> 2] = $0_1 | $5_1;
     $0_1 = $2_1 << 24 | $21_1 >>> 8;
     $4_1 = $9_1 + 56 | 0;
     $2_1 = $32_1;
     HEAP32[$4_1 >> 2] = $21_1 << 24 & -16777216 | $2_1 >>> 8;
     HEAP32[$4_1 + 4 >> 2] = $0_1 & 1048575;
     $0_1 = $2_1 << 12;
     $2_1 = $31_1;
     $5_1 = ($0_1 | $2_1 >>> 20) & 1048575;
     $4_1 = $9_1 + 48 | 0;
     HEAP32[$4_1 >> 2] = $2_1 << 12 & -4096 | $29_1 >>> 20;
     HEAP32[$4_1 + 4 >> 2] = $5_1;
     HEAP32[$1_1 + 296 >> 2] = 0;
     HEAP32[$1_1 + 256 >> 2] = 1;
     HEAP32[$1_1 + 260 >> 2] = 0;
     HEAP32[$1_1 + 216 >> 2] = $33_1;
     HEAP32[$1_1 + 220 >> 2] = $29_1 & 1048575;
     HEAP32[$1_1 + 208 >> 2] = $18_1;
     HEAP32[$1_1 + 212 >> 2] = $15_1;
     HEAP32[$1_1 + 200 >> 2] = $8_1;
     HEAP32[$1_1 + 204 >> 2] = $28_1;
     HEAP32[$1_1 + 192 >> 2] = $26_1;
     HEAP32[$1_1 + 196 >> 2] = $27_1;
     HEAP32[$1_1 + 184 >> 2] = $23_1;
     HEAP32[$1_1 + 188 >> 2] = $24_1;
     HEAP32[$1_1 + 176 >> 2] = $19_1;
     HEAP32[$1_1 + 180 >> 2] = $13_1;
     $11_1 = HEAP32[$1_1 + 456 >> 2];
     $13_1 = HEAP32[$1_1 + 448 >> 2];
     $12_1 = HEAP32[$1_1 + 440 >> 2];
     $0_1 = HEAP32[$1_1 + 432 >> 2];
     $18_1 = HEAP32[$1_1 + 460 >> 2];
     $14_1 = HEAP32[$1_1 + 452 >> 2];
     $8_1 = HEAP32[$1_1 + 444 >> 2];
     $2_1 = HEAP32[$1_1 + 436 >> 2];
     $4_1 = $11_1 | ($13_1 | ($12_1 | $0_1)) | ($18_1 | ($14_1 | ($8_1 | $2_1))) ? -1 : 0;
     $0_1 = $0_1 ^ -1;
     $15_1 = $0_1 - 801750718 | 0;
     HEAP32[$1_1 + 432 >> 2] = $4_1 & $15_1;
     $5_1 = $2_1 ^ -1;
     $10_1 = $5_1 - (($0_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
     HEAP32[$1_1 + 436 >> 2] = $10_1 & $4_1;
     $0_1 = ($5_1 | 0) == ($10_1 | 0) & $0_1 >>> 0 > $15_1 >>> 0 | $5_1 >>> 0 > $10_1 >>> 0;
     $10_1 = $12_1 ^ -1;
     $5_1 = $0_1 + $10_1 | 0;
     $12_1 = $8_1 ^ -1;
     $0_1 = $12_1;
     $15_1 = $5_1 - 1354194885 | 0;
     HEAP32[$1_1 + 440 >> 2] = $15_1 & $4_1;
     $0_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
     $8_1 = $0_1 - (($5_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
     HEAP32[$1_1 + 444 >> 2] = $8_1 & $4_1;
     $16_1 = $13_1 ^ -1;
     $2_1 = ($0_1 | 0) == ($12_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $0_1 >>> 0 < $12_1 >>> 0;
     $10_1 = ($0_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $15_1 >>> 0 | $0_1 >>> 0 > $8_1 >>> 0;
     $5_1 = $2_1 + $10_1 | 0;
     $13_1 = $14_1 ^ -1;
     $0_1 = $13_1 + ($5_1 >>> 0 < $10_1 >>> 0) | 0;
     $2_1 = $5_1;
     $5_1 = $5_1 + $16_1 | 0;
     $0_1 = $2_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
     $12_1 = $5_1 - 2 | 0;
     HEAP32[$1_1 + 448 >> 2] = $12_1 & $4_1;
     $10_1 = $0_1 - ($5_1 >>> 0 < 2) | 0;
     HEAP32[$1_1 + 452 >> 2] = $10_1 & $4_1;
     $2_1 = ($0_1 | 0) == ($13_1 | 0) & $5_1 >>> 0 < $16_1 >>> 0 | $0_1 >>> 0 < $13_1 >>> 0;
     $5_1 = ($0_1 | 0) == ($10_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $0_1 >>> 0 > $10_1 >>> 0;
     $2_1 = $2_1 + $5_1 | 0;
     $0_1 = $2_1 >>> 0 < $5_1 >>> 0;
     $5_1 = $2_1 - $11_1 | 0;
     HEAP32[$1_1 + 456 >> 2] = $5_1 - 2 & $4_1;
     HEAP32[$1_1 + 460 >> 2] = ($0_1 - (($2_1 >>> 0 < $11_1 >>> 0) + $18_1 | 0) | 0) - ($5_1 >>> 0 < 2) & $4_1;
     $0_1 = $1_1 + 288 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     $0_1 = $1_1 + 280 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     $0_1 = $1_1 + 272 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     $0_1 = $1_1 + 264 | 0;
     HEAP32[$0_1 >> 2] = 0;
     HEAP32[$0_1 + 4 >> 2] = 0;
     $42($6_1, $9_1, $17_1, $1_1 + 464 | 0);
     $56($7_1, $6_1);
     if (HEAP32[$1_1 + 128 >> 2]) {
      break label$3
     }
     $5_1 = HEAP32[$1_1 + 92 >> 2];
     $4_1 = $1_1 + 48 | 0;
     $0_1 = $4_1 + 72 | 0;
     $8_1 = HEAP32[$0_1 >> 2];
     $6_1 = HEAP32[$0_1 + 4 >> 2];
     $13_1 = $6_1;
     $0_1 = HEAP32[$1_1 + 88 >> 2];
     $2_1 = __wasm_i64_mul($6_1 >>> 16 | 0, 0, 977, 1);
     $9_1 = $0_1 + $2_1 | 0;
     $0_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
     $7_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
     $0_1 = $4_1 + 48 | 0;
     $5_1 = HEAP32[$0_1 >> 2];
     $0_1 = HEAP32[$0_1 + 4 >> 2];
     $2_1 = $7_1 >>> 20 | 0;
     $6_1 = $2_1;
     $2_1 = $2_1 + $5_1 | 0;
     $6_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
     $11_1 = $6_1 & 1048575;
     $0_1 = $4_1 - -64 | 0;
     $10_1 = HEAP32[$0_1 >> 2];
     $14_1 = HEAP32[$0_1 + 4 >> 2];
     $0_1 = $4_1 + 56 | 0;
     $5_1 = HEAP32[$0_1 >> 2];
     $0_1 = HEAP32[$0_1 + 4 >> 2];
     $4_1 = $6_1 >>> 20 | 0;
     $5_1 = $4_1 + $5_1 | 0;
     $12_1 = $4_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
     $0_1 = $14_1;
     $4_1 = $12_1 >>> 20 | 0;
     $14_1 = $4_1;
     $4_1 = $4_1 + $10_1 | 0;
     $0_1 = $14_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
     $10_1 = $0_1 & 1048575;
     $12_1 = $12_1 & 1048575;
     $14_1 = ($2_1 & $5_1 & $4_1) == -1 & ($6_1 & $12_1 & $0_1) == 1048575;
     $6_1 = $0_1;
     $0_1 = $13_1 & 65535;
     $6_1 = $6_1 >>> 20 | 0;
     $8_1 = $6_1 + $8_1 | 0;
     $6_1 = $6_1 >>> 0 > $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
     $0_1 = $7_1 & 1048575;
     $13_1 = $0_1;
     $7_1 = $8_1;
     if ($14_1 & (($7_1 | 0) == -1 & ($6_1 | 0) == 65535) & (($0_1 | 0) == 1048574 & $9_1 >>> 0 > 4294966318 | $0_1 >>> 0 > 1048574) | $6_1 >>> 16) {
      $0_1 = $13_1 + 1 | 0;
      $9_1 = $9_1 + 977 | 0;
      $0_1 = $9_1 >>> 0 < 977 ? $0_1 + 1 | 0 : $0_1;
      $13_1 = $0_1 & 1048575;
      $8_1 = $0_1;
      $0_1 = $11_1;
      $8_1 = $8_1 >>> 20 | 0;
      $2_1 = $2_1 + $8_1 | 0;
      $0_1 = $8_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $11_1 = $0_1 & 1048575;
      $8_1 = $0_1;
      $0_1 = $12_1;
      $8_1 = $8_1 >>> 20 | 0;
      $5_1 = $5_1 + $8_1 | 0;
      $0_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $12_1 = $0_1 & 1048575;
      $8_1 = $0_1;
      $0_1 = $10_1;
      $8_1 = $8_1 >>> 20 | 0;
      $4_1 = $4_1 + $8_1 | 0;
      $0_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
      $10_1 = $0_1 & 1048575;
      $8_1 = $0_1;
      $0_1 = $6_1;
      $6_1 = $7_1;
      $7_1 = ($8_1 >>> 20 | 0) + $7_1 | 0;
      $6_1 = ($6_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) & 65535;
     }
     HEAP32[$1_1 + 120 >> 2] = $7_1;
     HEAP32[$1_1 + 124 >> 2] = $6_1;
     HEAP32[$1_1 + 112 >> 2] = $4_1;
     HEAP32[$1_1 + 116 >> 2] = $10_1;
     HEAP32[$1_1 + 104 >> 2] = $5_1;
     HEAP32[$1_1 + 108 >> 2] = $12_1;
     HEAP32[$1_1 + 96 >> 2] = $2_1;
     HEAP32[$1_1 + 100 >> 2] = $11_1;
     HEAP32[$1_1 + 88 >> 2] = $9_1;
     HEAP32[$1_1 + 92 >> 2] = $13_1;
     if ($9_1 & 1) {
      break label$3
     }
     $0_1 = HEAP32[$1_1 + 48 >> 2];
     $2_1 = HEAP32[$1_1 + 136 >> 2];
     $4_1 = $0_1 - $2_1 | 0;
     $6_1 = HEAP32[$1_1 + 52 >> 2] - (HEAP32[$1_1 + 140 >> 2] + ($0_1 >>> 0 < $2_1 >>> 0) | 0) | 0;
     $0_1 = HEAP32[$1_1 + 80 >> 2];
     $5_1 = HEAP32[$1_1 + 168 >> 2];
     $2_1 = ($0_1 - $5_1 | 0) - 4 | 0;
     $0_1 = (HEAP32[$1_1 + 84 >> 2] - (HEAP32[$1_1 + 172 >> 2] + ($0_1 >>> 0 < $5_1 >>> 0) | 0) | 0) + 262143 | 0;
     $5_1 = $2_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
     $9_1 = __wasm_i64_mul($5_1 >>> 16 | 0, 0, 977, 1);
     $4_1 = $9_1 + $4_1 | 0;
     $0_1 = $6_1 + i64toi32_i32$HIGH_BITS | 0;
     $0_1 = ($4_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194299 | 0;
     $4_1 = $4_1 - 3908 | 0;
     $0_1 = $4_1 >>> 0 < 4294963388 ? $0_1 + 1 | 0 : $0_1;
     $6_1 = $0_1 & 1048575;
     $13_1 = $6_1;
     $12_1 = $4_1 ^ 976;
     $14_1 = $6_1 ^ 1;
     if ((($12_1 | 0) != -1 | ($14_1 | 0) != 1048575) & ($4_1 | $6_1) != 0) {
      break label$3
     }
     $10_1 = $2_1;
     $18_1 = $5_1 & 65535;
     $2_1 = HEAP32[$1_1 + 72 >> 2];
     $5_1 = HEAP32[$1_1 + 160 >> 2];
     $11_1 = $2_1 - $5_1 | 0;
     $8_1 = HEAP32[$1_1 + 76 >> 2] - (HEAP32[$1_1 + 164 >> 2] + ($2_1 >>> 0 < $5_1 >>> 0) | 0) | 0;
     $2_1 = HEAP32[$1_1 + 64 >> 2];
     $5_1 = HEAP32[$1_1 + 152 >> 2];
     $9_1 = $2_1 - $5_1 | 0;
     $7_1 = HEAP32[$1_1 + 68 >> 2] - (HEAP32[$1_1 + 156 >> 2] + ($2_1 >>> 0 < $5_1 >>> 0) | 0) | 0;
     $2_1 = $0_1 >>> 20 | 0;
     $17_1 = HEAP32[$1_1 + 144 >> 2];
     $15_1 = $2_1 - $17_1 | 0;
     $5_1 = $15_1 + HEAP32[$1_1 + 56 >> 2] | 0;
     $0_1 = HEAP32[$1_1 + 60 >> 2] - (HEAP32[$1_1 + 148 >> 2] + ($2_1 >>> 0 < $17_1 >>> 0) | 0) | 0;
     $0_1 = ($5_1 >>> 0 < $15_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194303 | 0;
     $2_1 = $5_1 - 4 | 0;
     $5_1 = $2_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
     $0_1 = $7_1;
     $6_1 = $5_1 >>> 20 | 0;
     $7_1 = $6_1;
     $6_1 = $6_1 + $9_1 | 0;
     $0_1 = ($7_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194303 | 0;
     $6_1 = $6_1 - 4 | 0;
     $9_1 = $6_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
     $0_1 = $8_1;
     $7_1 = $9_1 >>> 20 | 0;
     $8_1 = $7_1;
     $7_1 = $7_1 + $11_1 | 0;
     $0_1 = ($8_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194303 | 0;
     $7_1 = $7_1 - 4 | 0;
     $11_1 = $7_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
     $0_1 = $18_1;
     $8_1 = $11_1 >>> 20 | 0;
     $10_1 = $8_1 + $10_1 | 0;
     $0_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
     if (($2_1 & $12_1 & $6_1 & $7_1 & $10_1) == -1) {
      $8_1 = ($5_1 & $14_1 & $9_1 & $11_1 & ($0_1 ^ 983040)) == 1048575
     } else {
      $8_1 = 0
     }
     if ($8_1) {
      $2_1 = 0;
      $0_1 = 0;
     } else {
      $2_1 = $7_1 | ($6_1 | ($2_1 | $4_1)) | $10_1;
      $0_1 = $11_1 & 1048575 | ($9_1 & 1048575 | ($5_1 & 1048575 | $13_1)) | $0_1;
     }
     $34_1 = !($0_1 | $2_1);
    }
    global$0 = $1_1 + 496 | 0;
    break label$1;
   }
   fimport$1(1);
  }
  global$0 = $3_1 + 192 | 0;
  return $34_1 | 0;
 }
 
 function $27($0_1, $1_1, $2_1, $3_1, $4_1) {
  var $5_1 = 0;
  label$1 : {
   label$2 : {
    if (($2_1 | 0) != 1114112) {
     $5_1 = 1;
     if (FUNCTION_TABLE[HEAP32[$1_1 + 16 >> 2]]($0_1, $2_1) | 0) {
      break label$2
     }
    }
    if ($3_1) {
     break label$1
    }
    $5_1 = 0;
   }
   return $5_1;
  }
  return FUNCTION_TABLE[HEAP32[$1_1 + 12 >> 2]]($0_1, $3_1, $4_1) | 0;
 }
 
 function $28($0_1, $1_1) {
  $0_1 = $0_1 | 0;
  $1_1 = $1_1 | 0;
  var $2_1 = 0;
  if (HEAPU8[$0_1 | 0]) {
   $1_1 = $0_1 + 1 | 0;
   $0_1 = 0;
   while (1) {
    $2_1 = $0_1 + $1_1 | 0;
    $0_1 = $0_1 + 1 | 0;
    if (HEAPU8[$2_1 | 0]) {
     continue
    }
    break;
   };
  }
  wasm2js_trap();
 }
 
 function $29($0_1, $1_1, $2_1) {
  var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0, $51_1 = 0, $52_1 = 0, $53_1 = 0, $54_1 = 0, $55_1 = 0, $56_1 = 0, $57_1 = 0, $58_1 = 0, $59_1 = 0, $60_1 = 0, $61_1 = 0, $62_1 = 0, $63_1 = 0, $64_1 = 0, $65_1 = 0, $66_1 = 0, $67_1 = 0, $68_1 = 0, $69_1 = 0, $70_1 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;
  $3_1 = HEAP32[$0_1 + 100 >> 2];
  $4_1 = HEAP32[$0_1 + 96 >> 2];
  $7_1 = $4_1 + $2_1 | 0;
  $3_1 = $7_1 >>> 0 < $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$0_1 + 96 >> 2] = $7_1;
  HEAP32[$0_1 + 100 >> 2] = $3_1;
  $3_1 = $4_1 & 63;
  $61_1 = 64 - $3_1 | 0;
  if ($61_1 >>> 0 <= $2_1 >>> 0) {
   $74 = $0_1 + 32 | 0;
   while (1) {
    $70($3_1 + $74 | 0, $1_1, $61_1);
    $4_1 = HEAPU8[$0_1 + 67 | 0];
    $3_1 = HEAPU8[$0_1 + 65 | 0] << 16 | HEAPU8[$0_1 + 64 | 0] << 24;
    $38_1 = $4_1 | ($3_1 | HEAPU8[$0_1 + 66 | 0] << 8);
    $9_1 = HEAPU8[$0_1 + 39 | 0];
    $7_1 = HEAPU8[$0_1 + 37 | 0] << 16 | HEAPU8[$0_1 + 36 | 0] << 24;
    $11_1 = $9_1 | ($7_1 | HEAPU8[$0_1 + 38 | 0] << 8);
    $22_1 = HEAPU8[$0_1 + 59 | 0];
    $23_1 = HEAPU8[$0_1 + 57 | 0] << 16 | HEAPU8[$0_1 + 56 | 0] << 24;
    $20_1 = $22_1 | ($23_1 | HEAPU8[$0_1 + 58 | 0] << 8);
    $6_1 = HEAPU8[$0_1 + 51 | 0];
    $17_1 = HEAPU8[$0_1 + 49 | 0] << 16 | HEAPU8[$0_1 + 48 | 0] << 24;
    $14_1 = $6_1 | ($17_1 | HEAPU8[$0_1 + 50 | 0] << 8);
    $12_1 = HEAPU8[$0_1 + 43 | 0];
    $10_1 = HEAPU8[$0_1 + 41 | 0] << 16 | HEAPU8[$0_1 + 40 | 0] << 24;
    $13_1 = $12_1 | ($10_1 | HEAPU8[$0_1 + 42 | 0] << 8);
    $59_1 = ($4_1 << 25 | $38_1 >>> 7) ^ ($38_1 << 14 | $3_1 >>> 18) ^ $38_1 >>> 3;
    $15_1 = HEAPU8[$0_1 + 63 | 0];
    $4_1 = HEAPU8[$0_1 + 61 | 0] << 16 | HEAPU8[$0_1 + 60 | 0] << 24;
    $21_1 = $15_1 | ($4_1 | HEAPU8[$0_1 + 62 | 0] << 8);
    $19_1 = HEAPU8[$0_1 + 71 | 0];
    $16_1 = HEAPU8[$0_1 + 69 | 0] << 16 | HEAPU8[$0_1 + 68 | 0] << 24;
    $43_1 = $19_1 | ($16_1 | HEAPU8[$0_1 + 70 | 0] << 8);
    $3_1 = HEAPU8[$0_1 + 32 | 0] | HEAPU8[$0_1 + 33 | 0] << 8 | (HEAPU8[$0_1 + 34 | 0] << 16 | HEAPU8[$0_1 + 35 | 0] << 24);
    $52_1 = $3_1 << 8 & 16711680 | $3_1 << 24 | ($3_1 >>> 8 & 65280 | $3_1 >>> 24);
    $8_1 = $43_1 + ($52_1 + (($9_1 << 25 | $11_1 >>> 7) ^ ($11_1 << 14 | $7_1 >>> 18) ^ $11_1 >>> 3) | 0) | 0;
    $7_1 = HEAPU8[$0_1 + 89 | 0] << 16 | HEAPU8[$0_1 + 88 | 0] << 24;
    $3_1 = $7_1 | HEAPU8[$0_1 + 90 | 0] << 8;
    $24_1 = HEAPU8[$0_1 + 91 | 0];
    $26_1 = $3_1 | $24_1;
    $5_1 = $8_1 + (($26_1 << 15 | $7_1 >>> 17) ^ (($26_1 << 13 | $7_1 >>> 19) ^ $3_1 >>> 10)) | 0;
    $53_1 = ($22_1 << 25 | $20_1 >>> 7) ^ ($20_1 << 14 | $23_1 >>> 18) ^ $20_1 >>> 3;
    $22_1 = HEAPU8[$0_1 + 55 | 0];
    $23_1 = HEAPU8[$0_1 + 53 | 0] << 16 | HEAPU8[$0_1 + 52 | 0] << 24;
    $18_1 = $22_1 | ($23_1 | HEAPU8[$0_1 + 54 | 0] << 8);
    $33_1 = HEAPU8[$0_1 + 83 | 0];
    $28_1 = HEAPU8[$0_1 + 81 | 0] << 16 | HEAPU8[$0_1 + 80 | 0] << 24;
    $44_1 = $33_1 | ($28_1 | HEAPU8[$0_1 + 82 | 0] << 8);
    $8_1 = ($6_1 << 25 | $14_1 >>> 7) ^ ($14_1 << 14 | $17_1 >>> 18) ^ $14_1 >>> 3;
    $25_1 = HEAPU8[$0_1 + 47 | 0];
    $17_1 = HEAPU8[$0_1 + 45 | 0] << 16 | HEAPU8[$0_1 + 44 | 0] << 24;
    $54_1 = $25_1 | ($17_1 | HEAPU8[$0_1 + 46 | 0] << 8);
    $34_1 = HEAPU8[$0_1 + 75 | 0];
    $35_1 = HEAPU8[$0_1 + 73 | 0] << 16 | HEAPU8[$0_1 + 72 | 0] << 24;
    $45_1 = $34_1 | ($35_1 | HEAPU8[$0_1 + 74 | 0] << 8);
    $36_1 = HEAPU8[$0_1 + 95 | 0];
    $9_1 = HEAPU8[$0_1 + 93 | 0] << 16 | HEAPU8[$0_1 + 92 | 0] << 24;
    $3_1 = $9_1 | HEAPU8[$0_1 + 94 | 0] << 8;
    $27_1 = $36_1 | $3_1;
    $6_1 = ($45_1 + ((($12_1 << 25 | $13_1 >>> 7) ^ ($13_1 << 14 | $10_1 >>> 18) ^ $13_1 >>> 3) + $11_1 | 0) | 0) + (($27_1 << 15 | $9_1 >>> 17) ^ (($27_1 << 13 | $9_1 >>> 19) ^ $3_1 >>> 10)) | 0;
    $10_1 = ($44_1 + ($8_1 + $54_1 | 0) | 0) + (__wasm_rotl_i32($6_1, 15) ^ __wasm_rotl_i32($6_1, 13) ^ $6_1 >>> 10) | 0;
    $12_1 = (($53_1 + $18_1 | 0) + $26_1 | 0) + (__wasm_rotl_i32($10_1, 15) ^ __wasm_rotl_i32($10_1, 13) ^ $10_1 >>> 10) | 0;
    $3_1 = (($59_1 + $21_1 | 0) + $5_1 | 0) + (__wasm_rotl_i32($12_1, 15) ^ __wasm_rotl_i32($12_1, 13) ^ $12_1 >>> 10) | 0;
    $69_1 = ((($19_1 << 25 | $43_1 >>> 7) ^ ($43_1 << 14 | $16_1 >>> 18) ^ $43_1 >>> 3) + $38_1 | 0) + $6_1 | 0;
    $59_1 = ((($15_1 << 25 | $21_1 >>> 7) ^ ($21_1 << 14 | $4_1 >>> 18) ^ $21_1 >>> 3) + $20_1 | 0) + $27_1 | 0;
    $53_1 = (($22_1 << 25 | $18_1 >>> 7) ^ ($18_1 << 14 | $23_1 >>> 18) ^ $18_1 >>> 3) + $14_1 | 0;
    $22_1 = HEAPU8[$0_1 + 87 | 0];
    $23_1 = HEAPU8[$0_1 + 85 | 0] << 16 | HEAPU8[$0_1 + 84 | 0] << 24;
    $60_1 = $22_1 | ($23_1 | HEAPU8[$0_1 + 86 | 0] << 8);
    $8_1 = (($25_1 << 25 | $54_1 >>> 7) ^ ($54_1 << 14 | $17_1 >>> 18) ^ $54_1 >>> 3) + $13_1 | 0;
    $37_1 = HEAPU8[$0_1 + 79 | 0];
    $17_1 = HEAPU8[$0_1 + 77 | 0] << 16 | HEAPU8[$0_1 + 76 | 0] << 24;
    $46_1 = $37_1 | ($17_1 | HEAPU8[$0_1 + 78 | 0] << 8);
    $15_1 = ($8_1 + $46_1 | 0) + (__wasm_rotl_i32($5_1, 15) ^ __wasm_rotl_i32($5_1, 13) ^ $5_1 >>> 10) | 0;
    $16_1 = ($53_1 + $60_1 | 0) + (__wasm_rotl_i32($15_1, 15) ^ __wasm_rotl_i32($15_1, 13) ^ $15_1 >>> 10) | 0;
    $19_1 = $59_1 + (__wasm_rotl_i32($16_1, 15) ^ __wasm_rotl_i32($16_1, 13) ^ $16_1 >>> 10) | 0;
    $4_1 = $69_1 + (__wasm_rotl_i32($19_1, 15) ^ __wasm_rotl_i32($19_1, 13) ^ $19_1 >>> 10) | 0;
    $29_1 = $4_1 + ((__wasm_rotl_i32($5_1, 25) ^ __wasm_rotl_i32($5_1, 14) ^ $5_1 >>> 3) + $27_1 | 0) | 0;
    $8_1 = ((($24_1 << 25 | $26_1 >>> 7) ^ ($26_1 << 14 | $7_1 >>> 18) ^ $26_1 >>> 3) + $60_1 | 0) + $19_1 | 0;
    $24_1 = (((($34_1 << 25 | $45_1 >>> 7) ^ ($45_1 << 14 | $35_1 >>> 18) ^ $45_1 >>> 3) + $43_1 | 0) + $15_1 | 0) + (__wasm_rotl_i32($3_1, 15) ^ __wasm_rotl_i32($3_1, 13) ^ $3_1 >>> 10) | 0;
    $25_1 = (((($33_1 << 25 | $44_1 >>> 7) ^ ($44_1 << 14 | $28_1 >>> 18) ^ $44_1 >>> 3) + $46_1 | 0) + $16_1 | 0) + (__wasm_rotl_i32($24_1, 15) ^ __wasm_rotl_i32($24_1, 13) ^ $24_1 >>> 10) | 0;
    $28_1 = $8_1 + (__wasm_rotl_i32($25_1, 15) ^ __wasm_rotl_i32($25_1, 13) ^ $25_1 >>> 10) | 0;
    $7_1 = $29_1 + (__wasm_rotl_i32($28_1, 15) ^ __wasm_rotl_i32($28_1, 13) ^ $28_1 >>> 10) | 0;
    $39_1 = $7_1 + ((__wasm_rotl_i32($3_1, 25) ^ __wasm_rotl_i32($3_1, 14) ^ $3_1 >>> 3) + $19_1 | 0) | 0;
    $29_1 = ((__wasm_rotl_i32($12_1, 25) ^ __wasm_rotl_i32($12_1, 14) ^ $12_1 >>> 3) + $16_1 | 0) + $28_1 | 0;
    $30_1 = ((__wasm_rotl_i32($10_1, 25) ^ __wasm_rotl_i32($10_1, 14) ^ $10_1 >>> 3) + $15_1 | 0) + $25_1 | 0;
    $31_1 = ((__wasm_rotl_i32($6_1, 25) ^ __wasm_rotl_i32($6_1, 14) ^ $6_1 >>> 3) + $5_1 | 0) + $24_1 | 0;
    $33_1 = (((($37_1 << 25 | $46_1 >>> 7) ^ ($46_1 << 14 | $17_1 >>> 18) ^ $46_1 >>> 3) + $45_1 | 0) + $10_1 | 0) + (__wasm_rotl_i32($4_1, 15) ^ __wasm_rotl_i32($4_1, 13) ^ $4_1 >>> 10) | 0;
    $35_1 = (((($22_1 << 25 | $60_1 >>> 7) ^ ($60_1 << 14 | $23_1 >>> 18) ^ $60_1 >>> 3) + $44_1 | 0) + $12_1 | 0) + (__wasm_rotl_i32($33_1, 15) ^ __wasm_rotl_i32($33_1, 13) ^ $33_1 >>> 10) | 0;
    $34_1 = (((($36_1 << 25 | $27_1 >>> 7) ^ ($27_1 << 14 | $9_1 >>> 18) ^ $27_1 >>> 3) + $26_1 | 0) + $3_1 | 0) + (__wasm_rotl_i32($35_1, 15) ^ __wasm_rotl_i32($35_1, 13) ^ $35_1 >>> 10) | 0;
    $36_1 = $31_1 + (__wasm_rotl_i32($34_1, 15) ^ __wasm_rotl_i32($34_1, 13) ^ $34_1 >>> 10) | 0;
    $37_1 = $30_1 + (__wasm_rotl_i32($36_1, 15) ^ __wasm_rotl_i32($36_1, 13) ^ $36_1 >>> 10) | 0;
    $29_1 = $29_1 + (__wasm_rotl_i32($37_1, 15) ^ __wasm_rotl_i32($37_1, 13) ^ $37_1 >>> 10) | 0;
    $9_1 = $39_1 + (__wasm_rotl_i32($29_1, 15) ^ __wasm_rotl_i32($29_1, 13) ^ $29_1 >>> 10) | 0;
    $23_1 = $9_1 + ((__wasm_rotl_i32($34_1, 25) ^ __wasm_rotl_i32($34_1, 14) ^ $34_1 >>> 3) + $28_1 | 0) | 0;
    $22_1 = ((__wasm_rotl_i32($35_1, 25) ^ __wasm_rotl_i32($35_1, 14) ^ $35_1 >>> 3) + $25_1 | 0) + $29_1 | 0;
    $17_1 = ((__wasm_rotl_i32($33_1, 25) ^ __wasm_rotl_i32($33_1, 14) ^ $33_1 >>> 3) + $24_1 | 0) + $37_1 | 0;
    $40_1 = ((__wasm_rotl_i32($4_1, 25) ^ __wasm_rotl_i32($4_1, 14) ^ $4_1 >>> 3) + $3_1 | 0) + $36_1 | 0;
    $31_1 = ((__wasm_rotl_i32($19_1, 25) ^ __wasm_rotl_i32($19_1, 14) ^ $19_1 >>> 3) + $12_1 | 0) + $34_1 | 0;
    $30_1 = ((__wasm_rotl_i32($16_1, 25) ^ __wasm_rotl_i32($16_1, 14) ^ $16_1 >>> 3) + $10_1 | 0) + $35_1 | 0;
    $39_1 = (((__wasm_rotl_i32($15_1, 25) ^ __wasm_rotl_i32($15_1, 14) ^ $15_1 >>> 3) + $6_1 | 0) + $33_1 | 0) + (__wasm_rotl_i32($7_1, 15) ^ __wasm_rotl_i32($7_1, 13) ^ $7_1 >>> 10) | 0;
    $30_1 = $30_1 + (__wasm_rotl_i32($39_1, 15) ^ __wasm_rotl_i32($39_1, 13) ^ $39_1 >>> 10) | 0;
    $31_1 = $31_1 + (__wasm_rotl_i32($30_1, 15) ^ __wasm_rotl_i32($30_1, 13) ^ $30_1 >>> 10) | 0;
    $40_1 = $40_1 + (__wasm_rotl_i32($31_1, 15) ^ __wasm_rotl_i32($31_1, 13) ^ $31_1 >>> 10) | 0;
    $47_1 = $17_1 + (__wasm_rotl_i32($40_1, 15) ^ __wasm_rotl_i32($40_1, 13) ^ $40_1 >>> 10) | 0;
    $48_1 = $22_1 + (__wasm_rotl_i32($47_1, 15) ^ __wasm_rotl_i32($47_1, 13) ^ $47_1 >>> 10) | 0;
    $23_1 = $23_1 + (__wasm_rotl_i32($48_1, 15) ^ __wasm_rotl_i32($48_1, 13) ^ $48_1 >>> 10) | 0;
    $22_1 = ((__wasm_rotl_i32($7_1, 25) ^ __wasm_rotl_i32($7_1, 14) ^ $7_1 >>> 3) + $34_1 | 0) + $40_1 | 0;
    $17_1 = ((__wasm_rotl_i32($28_1, 25) ^ __wasm_rotl_i32($28_1, 14) ^ $28_1 >>> 3) + $35_1 | 0) + $31_1 | 0;
    $41_1 = ((__wasm_rotl_i32($25_1, 25) ^ __wasm_rotl_i32($25_1, 14) ^ $25_1 >>> 3) + $33_1 | 0) + $30_1 | 0;
    $49_1 = (((__wasm_rotl_i32($24_1, 25) ^ __wasm_rotl_i32($24_1, 14) ^ $24_1 >>> 3) + $4_1 | 0) + $39_1 | 0) + (__wasm_rotl_i32($9_1, 15) ^ __wasm_rotl_i32($9_1, 13) ^ $9_1 >>> 10) | 0;
    $41_1 = $41_1 + (__wasm_rotl_i32($49_1, 15) ^ __wasm_rotl_i32($49_1, 13) ^ $49_1 >>> 10) | 0;
    $50_1 = $17_1 + (__wasm_rotl_i32($41_1, 15) ^ __wasm_rotl_i32($41_1, 13) ^ $41_1 >>> 10) | 0;
    $22_1 = $22_1 + (__wasm_rotl_i32($50_1, 15) ^ __wasm_rotl_i32($50_1, 13) ^ $50_1 >>> 10) | 0;
    $17_1 = $22_1 + ((__wasm_rotl_i32($9_1, 25) ^ __wasm_rotl_i32($9_1, 14) ^ $9_1 >>> 3) + $31_1 | 0) | 0;
    $32_1 = ((__wasm_rotl_i32($29_1, 25) ^ __wasm_rotl_i32($29_1, 14) ^ $29_1 >>> 3) + $30_1 | 0) + $50_1 | 0;
    $42_1 = ((__wasm_rotl_i32($37_1, 25) ^ __wasm_rotl_i32($37_1, 14) ^ $37_1 >>> 3) + $39_1 | 0) + $41_1 | 0;
    $51_1 = (((__wasm_rotl_i32($36_1, 25) ^ __wasm_rotl_i32($36_1, 14) ^ $36_1 >>> 3) + $7_1 | 0) + $49_1 | 0) + (__wasm_rotl_i32($23_1, 15) ^ __wasm_rotl_i32($23_1, 13) ^ $23_1 >>> 10) | 0;
    $62_1 = $42_1 + (__wasm_rotl_i32($51_1, 15) ^ __wasm_rotl_i32($51_1, 13) ^ $51_1 >>> 10) | 0;
    $63_1 = $32_1 + (__wasm_rotl_i32($62_1, 15) ^ __wasm_rotl_i32($62_1, 13) ^ $62_1 >>> 10) | 0;
    $64_1 = $17_1 + (__wasm_rotl_i32($63_1, 15) ^ __wasm_rotl_i32($63_1, 13) ^ $63_1 >>> 10) | 0;
    $17_1 = $64_1 + ((__wasm_rotl_i32($23_1, 25) ^ __wasm_rotl_i32($23_1, 14) ^ $23_1 >>> 3) + $50_1 | 0) | 0;
    $32_1 = ((__wasm_rotl_i32($48_1, 25) ^ __wasm_rotl_i32($48_1, 14) ^ $48_1 >>> 3) + $41_1 | 0) + $63_1 | 0;
    $55_1 = ((__wasm_rotl_i32($47_1, 25) ^ __wasm_rotl_i32($47_1, 14) ^ $47_1 >>> 3) + $49_1 | 0) + $62_1 | 0;
    $56_1 = ((__wasm_rotl_i32($40_1, 25) ^ __wasm_rotl_i32($40_1, 14) ^ $40_1 >>> 3) + $9_1 | 0) + $51_1 | 0;
    $57_1 = ((__wasm_rotl_i32($31_1, 25) ^ __wasm_rotl_i32($31_1, 14) ^ $31_1 >>> 3) + $29_1 | 0) + $23_1 | 0;
    $58_1 = ((__wasm_rotl_i32($30_1, 25) ^ __wasm_rotl_i32($30_1, 14) ^ $30_1 >>> 3) + $37_1 | 0) + $48_1 | 0;
    $42_1 = (((__wasm_rotl_i32($39_1, 25) ^ __wasm_rotl_i32($39_1, 14) ^ $39_1 >>> 3) + $36_1 | 0) + $47_1 | 0) + (__wasm_rotl_i32($22_1, 15) ^ __wasm_rotl_i32($22_1, 13) ^ $22_1 >>> 10) | 0;
    $58_1 = $58_1 + (__wasm_rotl_i32($42_1, 15) ^ __wasm_rotl_i32($42_1, 13) ^ $42_1 >>> 10) | 0;
    $57_1 = $57_1 + (__wasm_rotl_i32($58_1, 15) ^ __wasm_rotl_i32($58_1, 13) ^ $58_1 >>> 10) | 0;
    $56_1 = $56_1 + (__wasm_rotl_i32($57_1, 15) ^ __wasm_rotl_i32($57_1, 13) ^ $57_1 >>> 10) | 0;
    $55_1 = $55_1 + (__wasm_rotl_i32($56_1, 15) ^ __wasm_rotl_i32($56_1, 13) ^ $56_1 >>> 10) | 0;
    $70_1 = $32_1 + (__wasm_rotl_i32($55_1, 15) ^ __wasm_rotl_i32($55_1, 13) ^ $55_1 >>> 10) | 0;
    $71 = $17_1 + (__wasm_rotl_i32($70_1, 15) ^ __wasm_rotl_i32($70_1, 13) ^ $70_1 >>> 10) | 0;
    $69_1 = HEAP32[$0_1 + 12 >> 2];
    $59_1 = HEAP32[$0_1 + 28 >> 2];
    $32_1 = HEAP32[$0_1 + 16 >> 2];
    $17_1 = $59_1 + (__wasm_rotl_i32($32_1, 26) ^ __wasm_rotl_i32($32_1, 21) ^ __wasm_rotl_i32($32_1, 7)) | 0;
    $65_1 = HEAP32[$0_1 + 20 >> 2];
    $72 = HEAP32[$0_1 + 24 >> 2];
    $66_1 = ($52_1 + ($17_1 + (($65_1 ^ $72) & $32_1 ^ $72) | 0) | 0) + 1116352408 | 0;
    $17_1 = $66_1 + $69_1 | 0;
    $52_1 = HEAP32[$0_1 + 4 >> 2];
    $8_1 = $13_1 + $65_1 | 0;
    $73 = HEAP32[$0_1 + 8 >> 2];
    $67_1 = ((($72 + ($17_1 & ($32_1 ^ $65_1) ^ $65_1) | 0) + $11_1 | 0) + (__wasm_rotl_i32($17_1, 26) ^ __wasm_rotl_i32($17_1, 21) ^ __wasm_rotl_i32($17_1, 7)) | 0) + 1899447441 | 0;
    $13_1 = $73 + $67_1 | 0;
    $68_1 = (($8_1 + ($13_1 & ($17_1 ^ $32_1) ^ $32_1) | 0) + (__wasm_rotl_i32($13_1, 26) ^ __wasm_rotl_i32($13_1, 21) ^ __wasm_rotl_i32($13_1, 7)) | 0) - 1245643825 | 0;
    $11_1 = $52_1 + $68_1 | 0;
    $8_1 = $14_1 + $17_1 | 0;
    $53_1 = ((($32_1 + $54_1 | 0) + ($11_1 & ($13_1 ^ $17_1) ^ $17_1) | 0) + (__wasm_rotl_i32($11_1, 26) ^ __wasm_rotl_i32($11_1, 21) ^ __wasm_rotl_i32($11_1, 7)) | 0) - 373957723 | 0;
    $17_1 = HEAP32[$0_1 >> 2];
    $14_1 = $53_1 + $17_1 | 0;
    $54_1 = (($8_1 + ($14_1 & ($11_1 ^ $13_1) ^ $13_1) | 0) + (__wasm_rotl_i32($14_1, 26) ^ __wasm_rotl_i32($14_1, 21) ^ __wasm_rotl_i32($14_1, 7)) | 0) + 961987163 | 0;
    $8_1 = $13_1 + $18_1 | 0;
    $13_1 = (($73 & ($17_1 | $52_1) | $17_1 & $52_1) + (__wasm_rotl_i32($17_1, 30) ^ __wasm_rotl_i32($17_1, 19) ^ __wasm_rotl_i32($17_1, 10)) | 0) + $66_1 | 0;
    $18_1 = $13_1 + $54_1 | 0;
    $66_1 = (($8_1 + ($18_1 & ($11_1 ^ $14_1) ^ $11_1) | 0) + (__wasm_rotl_i32($18_1, 26) ^ __wasm_rotl_i32($18_1, 21) ^ __wasm_rotl_i32($18_1, 7)) | 0) + 1508970993 | 0;
    $8_1 = $11_1 + $20_1 | 0;
    $11_1 = ((($13_1 | $17_1) & $52_1 | $13_1 & $17_1) + (__wasm_rotl_i32($13_1, 30) ^ __wasm_rotl_i32($13_1, 19) ^ __wasm_rotl_i32($13_1, 10)) | 0) + $67_1 | 0;
    $20_1 = $11_1 + $66_1 | 0;
    $67_1 = (($8_1 + ($20_1 & ($14_1 ^ $18_1) ^ $14_1) | 0) + (__wasm_rotl_i32($20_1, 26) ^ __wasm_rotl_i32($20_1, 21) ^ __wasm_rotl_i32($20_1, 7)) | 0) - 1841331548 | 0;
    $8_1 = $14_1 + $21_1 | 0;
    $14_1 = ((($11_1 | $13_1) & $17_1 | $11_1 & $13_1) + (__wasm_rotl_i32($11_1, 30) ^ __wasm_rotl_i32($11_1, 19) ^ __wasm_rotl_i32($11_1, 10)) | 0) + $68_1 | 0;
    $21_1 = $14_1 + $67_1 | 0;
    $68_1 = (($8_1 + ($21_1 & ($18_1 ^ $20_1) ^ $18_1) | 0) + (__wasm_rotl_i32($21_1, 26) ^ __wasm_rotl_i32($21_1, 21) ^ __wasm_rotl_i32($21_1, 7)) | 0) - 1424204075 | 0;
    $8_1 = $18_1 + $38_1 | 0;
    $13_1 = ((($11_1 | $14_1) & $13_1 | $11_1 & $14_1) + (__wasm_rotl_i32($14_1, 30) ^ __wasm_rotl_i32($14_1, 19) ^ __wasm_rotl_i32($14_1, 10)) | 0) + $53_1 | 0;
    $18_1 = $13_1 + $68_1 | 0;
    $38_1 = (($8_1 + ($18_1 & ($20_1 ^ $21_1) ^ $20_1) | 0) + (__wasm_rotl_i32($18_1, 26) ^ __wasm_rotl_i32($18_1, 21) ^ __wasm_rotl_i32($18_1, 7)) | 0) - 670586216 | 0;
    $8_1 = $20_1 + $43_1 | 0;
    $11_1 = ((($13_1 | $14_1) & $11_1 | $13_1 & $14_1) + (__wasm_rotl_i32($13_1, 30) ^ __wasm_rotl_i32($13_1, 19) ^ __wasm_rotl_i32($13_1, 10)) | 0) + $54_1 | 0;
    $20_1 = $11_1 + $38_1 | 0;
    $43_1 = (($8_1 + ($20_1 & ($18_1 ^ $21_1) ^ $21_1) | 0) + (__wasm_rotl_i32($20_1, 26) ^ __wasm_rotl_i32($20_1, 21) ^ __wasm_rotl_i32($20_1, 7)) | 0) + 310598401 | 0;
    $8_1 = $21_1 + $45_1 | 0;
    $14_1 = ((($11_1 | $13_1) & $14_1 | $11_1 & $13_1) + (__wasm_rotl_i32($11_1, 30) ^ __wasm_rotl_i32($11_1, 19) ^ __wasm_rotl_i32($11_1, 10)) | 0) + $66_1 | 0;
    $21_1 = $14_1 + $43_1 | 0;
    $45_1 = (($8_1 + ($21_1 & ($18_1 ^ $20_1) ^ $18_1) | 0) + (__wasm_rotl_i32($21_1, 26) ^ __wasm_rotl_i32($21_1, 21) ^ __wasm_rotl_i32($21_1, 7)) | 0) + 607225278 | 0;
    $8_1 = $18_1 + $46_1 | 0;
    $13_1 = ((($11_1 | $14_1) & $13_1 | $11_1 & $14_1) + (__wasm_rotl_i32($14_1, 30) ^ __wasm_rotl_i32($14_1, 19) ^ __wasm_rotl_i32($14_1, 10)) | 0) + $67_1 | 0;
    $18_1 = $13_1 + $45_1 | 0;
    $46_1 = (($8_1 + ($18_1 & ($20_1 ^ $21_1) ^ $20_1) | 0) + (__wasm_rotl_i32($18_1, 26) ^ __wasm_rotl_i32($18_1, 21) ^ __wasm_rotl_i32($18_1, 7)) | 0) + 1426881987 | 0;
    $8_1 = $20_1 + $44_1 | 0;
    $11_1 = ((($13_1 | $14_1) & $11_1 | $13_1 & $14_1) + (__wasm_rotl_i32($13_1, 30) ^ __wasm_rotl_i32($13_1, 19) ^ __wasm_rotl_i32($13_1, 10)) | 0) + $68_1 | 0;
    $20_1 = $11_1 + $46_1 | 0;
    $44_1 = (($8_1 + ($20_1 & ($18_1 ^ $21_1) ^ $21_1) | 0) + (__wasm_rotl_i32($20_1, 26) ^ __wasm_rotl_i32($20_1, 21) ^ __wasm_rotl_i32($20_1, 7)) | 0) + 1925078388 | 0;
    $8_1 = $21_1 + $60_1 | 0;
    $14_1 = ((($11_1 | $13_1) & $14_1 | $11_1 & $13_1) + (__wasm_rotl_i32($11_1, 30) ^ __wasm_rotl_i32($11_1, 19) ^ __wasm_rotl_i32($11_1, 10)) | 0) + $38_1 | 0;
    $21_1 = $14_1 + $44_1 | 0;
    $38_1 = (($8_1 + ($21_1 & ($18_1 ^ $20_1) ^ $18_1) | 0) + (__wasm_rotl_i32($21_1, 26) ^ __wasm_rotl_i32($21_1, 21) ^ __wasm_rotl_i32($21_1, 7)) | 0) - 2132889090 | 0;
    $8_1 = $18_1 + $26_1 | 0;
    $13_1 = ((($11_1 | $14_1) & $13_1 | $11_1 & $14_1) + (__wasm_rotl_i32($14_1, 30) ^ __wasm_rotl_i32($14_1, 19) ^ __wasm_rotl_i32($14_1, 10)) | 0) + $43_1 | 0;
    $26_1 = $13_1 + $38_1 | 0;
    $18_1 = (($8_1 + ($26_1 & ($20_1 ^ $21_1) ^ $20_1) | 0) + (__wasm_rotl_i32($26_1, 26) ^ __wasm_rotl_i32($26_1, 21) ^ __wasm_rotl_i32($26_1, 7)) | 0) - 1680079193 | 0;
    $8_1 = $20_1 + $27_1 | 0;
    $11_1 = ((($13_1 | $14_1) & $11_1 | $13_1 & $14_1) + (__wasm_rotl_i32($13_1, 30) ^ __wasm_rotl_i32($13_1, 19) ^ __wasm_rotl_i32($13_1, 10)) | 0) + $45_1 | 0;
    $27_1 = $11_1 + $18_1 | 0;
    $20_1 = (($8_1 + ($27_1 & ($21_1 ^ $26_1) ^ $21_1) | 0) + (__wasm_rotl_i32($27_1, 26) ^ __wasm_rotl_i32($27_1, 21) ^ __wasm_rotl_i32($27_1, 7)) | 0) - 1046744716 | 0;
    $8_1 = $5_1 + $21_1 | 0;
    $5_1 = ((($11_1 | $13_1) & $14_1 | $11_1 & $13_1) + (__wasm_rotl_i32($11_1, 30) ^ __wasm_rotl_i32($11_1, 19) ^ __wasm_rotl_i32($11_1, 10)) | 0) + $46_1 | 0;
    $14_1 = $5_1 + $20_1 | 0;
    $21_1 = (($8_1 + ($14_1 & ($26_1 ^ $27_1) ^ $26_1) | 0) + (__wasm_rotl_i32($14_1, 26) ^ __wasm_rotl_i32($14_1, 21) ^ __wasm_rotl_i32($14_1, 7)) | 0) - 459576895 | 0;
    $8_1 = $6_1 + $26_1 | 0;
    $6_1 = ((($5_1 | $11_1) & $13_1 | $5_1 & $11_1) + (__wasm_rotl_i32($5_1, 30) ^ __wasm_rotl_i32($5_1, 19) ^ __wasm_rotl_i32($5_1, 10)) | 0) + $44_1 | 0;
    $13_1 = $6_1 + $21_1 | 0;
    $26_1 = (($8_1 + ($13_1 & ($14_1 ^ $27_1) ^ $27_1) | 0) + (__wasm_rotl_i32($13_1, 26) ^ __wasm_rotl_i32($13_1, 21) ^ __wasm_rotl_i32($13_1, 7)) | 0) - 272742522 | 0;
    $8_1 = $15_1 + $27_1 | 0;
    $15_1 = ((($5_1 | $6_1) & $11_1 | $5_1 & $6_1) + (__wasm_rotl_i32($6_1, 30) ^ __wasm_rotl_i32($6_1, 19) ^ __wasm_rotl_i32($6_1, 10)) | 0) + $38_1 | 0;
    $11_1 = $15_1 + $26_1 | 0;
    $27_1 = (($8_1 + ($11_1 & ($13_1 ^ $14_1) ^ $14_1) | 0) + (__wasm_rotl_i32($11_1, 26) ^ __wasm_rotl_i32($11_1, 21) ^ __wasm_rotl_i32($11_1, 7)) | 0) + 264347078 | 0;
    $8_1 = $10_1 + $14_1 | 0;
    $5_1 = ((($6_1 | $15_1) & $5_1 | $6_1 & $15_1) + (__wasm_rotl_i32($15_1, 30) ^ __wasm_rotl_i32($15_1, 19) ^ __wasm_rotl_i32($15_1, 10)) | 0) + $18_1 | 0;
    $14_1 = $5_1 + $27_1 | 0;
    $18_1 = (($8_1 + ($14_1 & ($11_1 ^ $13_1) ^ $13_1) | 0) + (__wasm_rotl_i32($14_1, 26) ^ __wasm_rotl_i32($14_1, 21) ^ __wasm_rotl_i32($14_1, 7)) | 0) + 604807628 | 0;
    $8_1 = $13_1 + $16_1 | 0;
    $6_1 = ((($5_1 | $15_1) & $6_1 | $5_1 & $15_1) + (__wasm_rotl_i32($5_1, 30) ^ __wasm_rotl_i32($5_1, 19) ^ __wasm_rotl_i32($5_1, 10)) | 0) + $20_1 | 0;
    $16_1 = $6_1 + $18_1 | 0;
    $13_1 = (($8_1 + ($16_1 & ($11_1 ^ $14_1) ^ $11_1) | 0) + (__wasm_rotl_i32($16_1, 26) ^ __wasm_rotl_i32($16_1, 21) ^ __wasm_rotl_i32($16_1, 7)) | 0) + 770255983 | 0;
    $8_1 = $11_1 + $12_1 | 0;
    $10_1 = ((($5_1 | $6_1) & $15_1 | $5_1 & $6_1) + (__wasm_rotl_i32($6_1, 30) ^ __wasm_rotl_i32($6_1, 19) ^ __wasm_rotl_i32($6_1, 10)) | 0) + $21_1 | 0;
    $12_1 = $10_1 + $13_1 | 0;
    $11_1 = (($8_1 + ($12_1 & ($14_1 ^ $16_1) ^ $14_1) | 0) + (__wasm_rotl_i32($12_1, 26) ^ __wasm_rotl_i32($12_1, 21) ^ __wasm_rotl_i32($12_1, 7)) | 0) + 1249150122 | 0;
    $5_1 = ((($6_1 | $10_1) & $5_1 | $6_1 & $10_1) + (__wasm_rotl_i32($10_1, 30) ^ __wasm_rotl_i32($10_1, 19) ^ __wasm_rotl_i32($10_1, 10)) | 0) + $26_1 | 0;
    $15_1 = $5_1 + $11_1 | 0;
    $19_1 = ((($14_1 + $19_1 | 0) + ($15_1 & ($12_1 ^ $16_1) ^ $16_1) | 0) + (__wasm_rotl_i32($15_1, 26) ^ __wasm_rotl_i32($15_1, 21) ^ __wasm_rotl_i32($15_1, 7)) | 0) + 1555081692 | 0;
    $8_1 = $3_1 + $16_1 | 0;
    $3_1 = ((($5_1 | $10_1) & $6_1 | $5_1 & $10_1) + (__wasm_rotl_i32($5_1, 30) ^ __wasm_rotl_i32($5_1, 19) ^ __wasm_rotl_i32($5_1, 10)) | 0) + $27_1 | 0;
    $6_1 = $3_1 + $19_1 | 0;
    $16_1 = (($8_1 + ($6_1 & ($12_1 ^ $15_1) ^ $12_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 1996064986 | 0;
    $8_1 = $4_1 + $12_1 | 0;
    $4_1 = ((($3_1 | $5_1) & $10_1 | $3_1 & $5_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $18_1 | 0;
    $10_1 = $4_1 + $16_1 | 0;
    $14_1 = (($8_1 + ($10_1 & ($6_1 ^ $15_1) ^ $15_1) | 0) + (__wasm_rotl_i32($10_1, 26) ^ __wasm_rotl_i32($10_1, 21) ^ __wasm_rotl_i32($10_1, 7)) | 0) - 1740746414 | 0;
    $5_1 = ((($3_1 | $4_1) & $5_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $13_1 | 0;
    $12_1 = $5_1 + $14_1 | 0;
    $15_1 = ((($15_1 + $24_1 | 0) + ($12_1 & ($6_1 ^ $10_1) ^ $6_1) | 0) + (__wasm_rotl_i32($12_1, 26) ^ __wasm_rotl_i32($12_1, 21) ^ __wasm_rotl_i32($12_1, 7)) | 0) - 1473132947 | 0;
    $8_1 = $6_1 + $33_1 | 0;
    $3_1 = ((($4_1 | $5_1) & $3_1 | $4_1 & $5_1) + (__wasm_rotl_i32($5_1, 30) ^ __wasm_rotl_i32($5_1, 19) ^ __wasm_rotl_i32($5_1, 10)) | 0) + $11_1 | 0;
    $6_1 = $3_1 + $15_1 | 0;
    $24_1 = (($8_1 + ($6_1 & ($10_1 ^ $12_1) ^ $10_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) - 1341970488 | 0;
    $8_1 = $10_1 + $25_1 | 0;
    $4_1 = ((($3_1 | $5_1) & $4_1 | $3_1 & $5_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $19_1 | 0;
    $10_1 = $4_1 + $24_1 | 0;
    $19_1 = (($8_1 + ($10_1 & ($6_1 ^ $12_1) ^ $12_1) | 0) + (__wasm_rotl_i32($10_1, 26) ^ __wasm_rotl_i32($10_1, 21) ^ __wasm_rotl_i32($10_1, 7)) | 0) - 1084653625 | 0;
    $8_1 = $12_1 + $35_1 | 0;
    $5_1 = ((($3_1 | $4_1) & $5_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $16_1 | 0;
    $12_1 = $5_1 + $19_1 | 0;
    $16_1 = (($8_1 + ($12_1 & ($6_1 ^ $10_1) ^ $6_1) | 0) + (__wasm_rotl_i32($12_1, 26) ^ __wasm_rotl_i32($12_1, 21) ^ __wasm_rotl_i32($12_1, 7)) | 0) - 958395405 | 0;
    $8_1 = $6_1 + $28_1 | 0;
    $3_1 = ((($4_1 | $5_1) & $3_1 | $4_1 & $5_1) + (__wasm_rotl_i32($5_1, 30) ^ __wasm_rotl_i32($5_1, 19) ^ __wasm_rotl_i32($5_1, 10)) | 0) + $14_1 | 0;
    $6_1 = $3_1 + $16_1 | 0;
    $25_1 = (($8_1 + ($6_1 & ($10_1 ^ $12_1) ^ $10_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) - 710438585 | 0;
    $8_1 = $10_1 + $34_1 | 0;
    $4_1 = ((($3_1 | $5_1) & $4_1 | $3_1 & $5_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $15_1 | 0;
    $10_1 = $4_1 + $25_1 | 0;
    $15_1 = (($8_1 + ($10_1 & ($6_1 ^ $12_1) ^ $12_1) | 0) + (__wasm_rotl_i32($10_1, 26) ^ __wasm_rotl_i32($10_1, 21) ^ __wasm_rotl_i32($10_1, 7)) | 0) + 113926993 | 0;
    $8_1 = $7_1 + $12_1 | 0;
    $7_1 = ((($3_1 | $4_1) & $5_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $24_1 | 0;
    $5_1 = $7_1 + $15_1 | 0;
    $12_1 = (($8_1 + ($5_1 & ($6_1 ^ $10_1) ^ $6_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) + 338241895 | 0;
    $8_1 = $6_1 + $36_1 | 0;
    $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $19_1 | 0;
    $6_1 = $3_1 + $12_1 | 0;
    $19_1 = (($8_1 + ($6_1 & ($5_1 ^ $10_1) ^ $10_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 666307205 | 0;
    $8_1 = $10_1 + $39_1 | 0;
    $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $16_1 | 0;
    $10_1 = $4_1 + $19_1 | 0;
    $16_1 = (($8_1 + ($10_1 & ($5_1 ^ $6_1) ^ $5_1) | 0) + (__wasm_rotl_i32($10_1, 26) ^ __wasm_rotl_i32($10_1, 21) ^ __wasm_rotl_i32($10_1, 7)) | 0) + 773529912 | 0;
    $8_1 = $5_1 + $37_1 | 0;
    $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $25_1 | 0;
    $5_1 = $7_1 + $16_1 | 0;
    $24_1 = (($8_1 + ($5_1 & ($6_1 ^ $10_1) ^ $6_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) + 1294757372 | 0;
    $8_1 = $6_1 + $30_1 | 0;
    $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $15_1 | 0;
    $6_1 = $3_1 + $24_1 | 0;
    $15_1 = (($8_1 + ($6_1 & ($5_1 ^ $10_1) ^ $10_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 1396182291 | 0;
    $8_1 = $10_1 + $29_1 | 0;
    $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $12_1 | 0;
    $10_1 = $4_1 + $15_1 | 0;
    $12_1 = (($8_1 + ($10_1 & ($5_1 ^ $6_1) ^ $5_1) | 0) + (__wasm_rotl_i32($10_1, 26) ^ __wasm_rotl_i32($10_1, 21) ^ __wasm_rotl_i32($10_1, 7)) | 0) + 1695183700 | 0;
    $8_1 = $5_1 + $31_1 | 0;
    $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $19_1 | 0;
    $5_1 = $7_1 + $12_1 | 0;
    $19_1 = (($8_1 + ($5_1 & ($6_1 ^ $10_1) ^ $6_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) + 1986661051 | 0;
    $8_1 = $6_1 + $9_1 | 0;
    $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $16_1 | 0;
    $9_1 = $3_1 + $19_1 | 0;
    $16_1 = (($8_1 + ($9_1 & ($5_1 ^ $10_1) ^ $10_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) - 2117940946 | 0;
    $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $24_1 | 0;
    $6_1 = $4_1 + $16_1 | 0;
    $10_1 = ((($10_1 + $40_1 | 0) + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) - 1838011259 | 0;
    $8_1 = $5_1 + $49_1 | 0;
    $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $15_1 | 0;
    $5_1 = $7_1 + $10_1 | 0;
    $15_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) - 1564481375 | 0;
    $8_1 = $9_1 + $47_1 | 0;
    $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $12_1 | 0;
    $9_1 = $3_1 + $15_1 | 0;
    $12_1 = (($8_1 + ($9_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) - 1474664885 | 0;
    $8_1 = $6_1 + $41_1 | 0;
    $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $19_1 | 0;
    $6_1 = $4_1 + $12_1 | 0;
    $19_1 = (($8_1 + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) - 1035236496 | 0;
    $8_1 = $5_1 + $48_1 | 0;
    $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $16_1 | 0;
    $5_1 = $7_1 + $19_1 | 0;
    $16_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) - 949202525 | 0;
    $8_1 = $9_1 + $50_1 | 0;
    $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $10_1 | 0;
    $9_1 = $3_1 + $16_1 | 0;
    $10_1 = (($8_1 + ($9_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) - 778901479 | 0;
    $8_1 = $6_1 + $23_1 | 0;
    $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $15_1 | 0;
    $6_1 = $4_1 + $10_1 | 0;
    $15_1 = (($8_1 + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) - 694614492 | 0;
    $8_1 = $5_1 + $22_1 | 0;
    $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $12_1 | 0;
    $5_1 = $7_1 + $15_1 | 0;
    $12_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) - 200395387 | 0;
    $8_1 = $9_1 + $51_1 | 0;
    $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $19_1 | 0;
    $9_1 = $3_1 + $12_1 | 0;
    $19_1 = (($8_1 + ($9_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) + 275423344 | 0;
    $8_1 = $6_1 + $42_1 | 0;
    $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $16_1 | 0;
    $6_1 = $4_1 + $19_1 | 0;
    $16_1 = (($8_1 + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 430227734 | 0;
    $8_1 = $5_1 + $62_1 | 0;
    $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $10_1 | 0;
    $5_1 = $7_1 + $16_1 | 0;
    $10_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) + 506948616 | 0;
    $8_1 = $9_1 + $58_1 | 0;
    $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $15_1 | 0;
    $9_1 = $3_1 + $10_1 | 0;
    $24_1 = (($8_1 + ($9_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) + 659060556 | 0;
    $8_1 = $6_1 + $63_1 | 0;
    $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $12_1 | 0;
    $6_1 = $4_1 + $24_1 | 0;
    $12_1 = (($8_1 + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 883997877 | 0;
    $8_1 = $5_1 + $57_1 | 0;
    $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $19_1 | 0;
    $5_1 = $7_1 + $12_1 | 0;
    $19_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) + 958139571 | 0;
    $8_1 = $9_1 + $64_1 | 0;
    $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $16_1 | 0;
    $9_1 = $3_1 + $19_1 | 0;
    $25_1 = (($8_1 + ($9_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) + 1322822218 | 0;
    $8_1 = $6_1 + $56_1 | 0;
    $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $10_1 | 0;
    $6_1 = $4_1 + $25_1 | 0;
    $28_1 = (($8_1 + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 1537002063 | 0;
    $15_1 = (((__wasm_rotl_i32($49_1, 25) ^ __wasm_rotl_i32($49_1, 14) ^ $49_1 >>> 3) + $40_1 | 0) + $42_1 | 0) + (__wasm_rotl_i32($64_1, 15) ^ __wasm_rotl_i32($64_1, 13) ^ $64_1 >>> 10) | 0;
    $8_1 = $15_1 + $5_1 | 0;
    $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $24_1 | 0;
    $5_1 = $7_1 + $28_1 | 0;
    $24_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) + 1747873779 | 0;
    $8_1 = $9_1 + $55_1 | 0;
    $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $12_1 | 0;
    $9_1 = $3_1 + $24_1 | 0;
    $12_1 = (($8_1 + ($9_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($9_1, 26) ^ __wasm_rotl_i32($9_1, 21) ^ __wasm_rotl_i32($9_1, 7)) | 0) + 1955562222 | 0;
    $16_1 = ((__wasm_rotl_i32($50_1, 25) ^ __wasm_rotl_i32($50_1, 14) ^ $50_1 >>> 3) + $48_1 | 0) + $57_1 | 0;
    $10_1 = (((__wasm_rotl_i32($41_1, 25) ^ __wasm_rotl_i32($41_1, 14) ^ $41_1 >>> 3) + $47_1 | 0) + $58_1 | 0) + (__wasm_rotl_i32($15_1, 15) ^ __wasm_rotl_i32($15_1, 13) ^ $15_1 >>> 10) | 0;
    $16_1 = $16_1 + (__wasm_rotl_i32($10_1, 15) ^ __wasm_rotl_i32($10_1, 13) ^ $10_1 >>> 10) | 0;
    $8_1 = $6_1 + $10_1 | 0;
    $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $19_1 | 0;
    $6_1 = $4_1 + $12_1 | 0;
    $19_1 = (($8_1 + ($6_1 & ($5_1 ^ $9_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) + 2024104815 | 0;
    $8_1 = $5_1 + $70_1 | 0;
    $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $25_1 | 0;
    $5_1 = $7_1 + $19_1 | 0;
    $25_1 = (($8_1 + ($5_1 & ($6_1 ^ $9_1) ^ $9_1) | 0) + (__wasm_rotl_i32($5_1, 26) ^ __wasm_rotl_i32($5_1, 21) ^ __wasm_rotl_i32($5_1, 7)) | 0) - 2067236844 | 0;
    $3_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $28_1 | 0;
    $10_1 = $3_1 + $25_1 | 0;
    $28_1 = ((($9_1 + $16_1 | 0) + ($10_1 & ($5_1 ^ $6_1) ^ $6_1) | 0) + (__wasm_rotl_i32($10_1, 26) ^ __wasm_rotl_i32($10_1, 21) ^ __wasm_rotl_i32($10_1, 7)) | 0) - 1933114872 | 0;
    $8_1 = $6_1 + $71 | 0;
    $4_1 = ((($3_1 | $7_1) & $4_1 | $3_1 & $7_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $24_1 | 0;
    $6_1 = $4_1 + $28_1 | 0;
    $24_1 = (($8_1 + ($6_1 & ($5_1 ^ $10_1) ^ $5_1) | 0) + (__wasm_rotl_i32($6_1, 26) ^ __wasm_rotl_i32($6_1, 21) ^ __wasm_rotl_i32($6_1, 7)) | 0) - 1866530822 | 0;
    $7_1 = ((($3_1 | $4_1) & $7_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $12_1 | 0;
    $12_1 = $24_1 + $7_1 | 0;
    HEAP32[$0_1 + 28 >> 2] = $12_1 + $59_1;
    $9_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $19_1 | 0;
    $3_1 = (($4_1 & ($9_1 | $7_1) | $7_1 & $9_1) + (__wasm_rotl_i32($9_1, 30) ^ __wasm_rotl_i32($9_1, 19) ^ __wasm_rotl_i32($9_1, 10)) | 0) + $25_1 | 0;
    $4_1 = ((($3_1 | $9_1) & $7_1 | $3_1 & $9_1) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $28_1 | 0;
    $7_1 = ((($4_1 | $3_1) & $9_1 | $3_1 & $4_1) + (__wasm_rotl_i32($4_1, 30) ^ __wasm_rotl_i32($4_1, 19) ^ __wasm_rotl_i32($4_1, 10)) | 0) + $24_1 | 0;
    HEAP32[$0_1 + 12 >> 2] = $7_1 + $69_1;
    $53_1 = $9_1;
    $8_1 = $5_1;
    $5_1 = (((__wasm_rotl_i32($22_1, 25) ^ __wasm_rotl_i32($22_1, 14) ^ $22_1 >>> 3) + $23_1 | 0) + $56_1 | 0) + (__wasm_rotl_i32($16_1, 15) ^ __wasm_rotl_i32($16_1, 13) ^ $16_1 >>> 10) | 0;
    $9_1 = ((($8_1 + $5_1 | 0) + ($12_1 & ($6_1 ^ $10_1) ^ $10_1) | 0) + (__wasm_rotl_i32($12_1, 26) ^ __wasm_rotl_i32($12_1, 21) ^ __wasm_rotl_i32($12_1, 7)) | 0) - 1538233109 | 0;
    $23_1 = $53_1 + $9_1 | 0;
    HEAP32[$0_1 + 24 >> 2] = $23_1 + $72;
    $9_1 = ((($4_1 | $7_1) & $3_1 | $4_1 & $7_1) + (__wasm_rotl_i32($7_1, 30) ^ __wasm_rotl_i32($7_1, 19) ^ __wasm_rotl_i32($7_1, 10)) | 0) + $9_1 | 0;
    HEAP32[$0_1 + 8 >> 2] = $9_1 + $73;
    $8_1 = $3_1;
    $3_1 = (((((($22_1 + (__wasm_rotl_i32($51_1, 25) ^ __wasm_rotl_i32($51_1, 14) ^ $51_1 >>> 3) | 0) + $15_1 | 0) + (__wasm_rotl_i32($71, 15) ^ __wasm_rotl_i32($71, 13) ^ $71 >>> 10) | 0) + $10_1 | 0) + ($23_1 & ($6_1 ^ $12_1) ^ $6_1) | 0) + (__wasm_rotl_i32($23_1, 26) ^ __wasm_rotl_i32($23_1, 21) ^ __wasm_rotl_i32($23_1, 7)) | 0) - 1090935817 | 0;
    $22_1 = $8_1 + $3_1 | 0;
    HEAP32[$0_1 + 20 >> 2] = $22_1 + $65_1;
    $3_1 = ((($7_1 | $9_1) & $4_1 | $7_1 & $9_1) + (__wasm_rotl_i32($9_1, 30) ^ __wasm_rotl_i32($9_1, 19) ^ __wasm_rotl_i32($9_1, 10)) | 0) + $3_1 | 0;
    HEAP32[$0_1 + 4 >> 2] = $3_1 + $52_1;
    $8_1 = $4_1 + $32_1 | 0;
    $4_1 = (((((($51_1 + (__wasm_rotl_i32($42_1, 25) ^ __wasm_rotl_i32($42_1, 14) ^ $42_1 >>> 3) | 0) + $55_1 | 0) + (__wasm_rotl_i32($5_1, 15) ^ __wasm_rotl_i32($5_1, 13) ^ $5_1 >>> 10) | 0) + $6_1 | 0) + ($22_1 & ($12_1 ^ $23_1) ^ $12_1) | 0) + (__wasm_rotl_i32($22_1, 26) ^ __wasm_rotl_i32($22_1, 21) ^ __wasm_rotl_i32($22_1, 7)) | 0) - 965641998 | 0;
    HEAP32[$0_1 + 16 >> 2] = $8_1 + $4_1;
    (wasm2js_i32$0 = $0_1, wasm2js_i32$1 = (($17_1 + (($3_1 | $9_1) & $7_1 | $3_1 & $9_1) | 0) + (__wasm_rotl_i32($3_1, 30) ^ __wasm_rotl_i32($3_1, 19) ^ __wasm_rotl_i32($3_1, 10)) | 0) + $4_1 | 0), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
    $1_1 = $1_1 + $61_1 | 0;
    $2_1 = $2_1 - $61_1 | 0;
    $61_1 = 64;
    $3_1 = 0;
    if ($2_1 >>> 0 > 63) {
     continue
    }
    break;
   };
  }
  if ($2_1) {
   $70(($0_1 + $3_1 | 0) + 32 | 0, $1_1, $2_1)
  }
 }
 
 function $30($0_1, $1_1) {
  var $2_1 = 0, $3_1 = 0, $4_1 = 0;
  $3_1 = global$0 - 16 | 0;
  global$0 = $3_1;
  $2_1 = HEAP32[$0_1 + 100 >> 2];
  $4_1 = HEAP32[$0_1 + 96 >> 2];
  HEAP8[$3_1 + 11 | 0] = ($2_1 & 536870911) << 3 | $4_1 >>> 29;
  HEAP8[$3_1 + 10 | 0] = $2_1 >>> 5;
  HEAP8[$3_1 + 9 | 0] = $2_1 >>> 13;
  HEAP8[$3_1 + 8 | 0] = $2_1 >>> 21;
  HEAP8[$3_1 + 15 | 0] = $4_1 << 3;
  HEAP8[$3_1 + 14 | 0] = $4_1 >>> 5;
  HEAP8[$3_1 + 13 | 0] = $4_1 >>> 13;
  HEAP8[$3_1 + 12 | 0] = $4_1 >>> 21;
  $29($0_1, 690512, (55 - $4_1 & 63) + 1 | 0);
  $29($0_1, $3_1 + 8 | 0, 8);
  $2_1 = HEAP32[$0_1 >> 2];
  $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
  HEAP8[$1_1 | 0] = $2_1;
  HEAP8[$1_1 + 1 | 0] = $2_1 >>> 8;
  HEAP8[$1_1 + 2 | 0] = $2_1 >>> 16;
  HEAP8[$1_1 + 3 | 0] = $2_1 >>> 24;
  HEAP32[$0_1 >> 2] = 0;
  $2_1 = HEAP32[$0_1 + 4 >> 2];
  $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
  HEAP8[$1_1 + 4 | 0] = $2_1;
  HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
  HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
  HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
  HEAP32[$0_1 + 4 >> 2] = 0;
  $2_1 = HEAP32[$0_1 + 8 >> 2];
  $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
  HEAP8[$1_1 + 8 | 0] = $2_1;
  HEAP8[$1_1 + 9 | 0] = $2_1 >>> 8;
  HEAP8[$1_1 + 10 | 0] = $2_1 >>> 16;
  HEAP8[$1_1 + 11 | 0] = $2_1 >>> 24;
  HEAP32[$0_1 + 8 >> 2] = 0;
  $2_1 = HEAP32[$0_1 + 12 >> 2];
  $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
  HEAP8[$1_1 + 12 | 0] = $2_1;
  HEAP8[$1_1 + 13 | 0] = $2_1 >>> 8;
  HEAP8[$1_1 + 14 | 0] = $2_1 >>> 16;
  HEAP8[$1_1 + 15 | 0] = $2_1 >>> 24;
  HEAP32[$0_1 + 12 >> 2] = 0;
  $2_1 = HEAP32[$0_1 + 16 >> 2];
  $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
  HEAP8[$1_1 + 16 | 0] = $2_1;
  HEAP8[$1_1 + 17 | 0] = $2_1 >>> 8;
  HEAP8[$1_1 + 18 | 0] = $2_1 >>> 16;
  HEAP8[$1_1 + 19 | 0] = $2_1 >>> 24;
  HEAP32[$0_1 + 16 >> 2] = 0;
  $2_1 = HEAP32[$0_1 + 20 >> 2];
  $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
  HEAP8[$1_1 + 20 | 0] = $2_1;
  HEAP8[$1_1 + 21 | 0] = $2_1 >>> 8;
  HEAP8[$1_1 + 22 | 0] = $2_1 >>> 16;
  HEAP8[$1_1 + 23 | 0] = $2_1 >>> 24;
  HEAP32[$0_1 + 20 >> 2] = 0;
  $2_1 = HEAP32[$0_1 + 24 >> 2];
  $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
  HEAP8[$1_1 + 24 | 0] = $2_1;
  HEAP8[$1_1 + 25 | 0] = $2_1 >>> 8;
  HEAP8[$1_1 + 26 | 0] = $2_1 >>> 16;
  HEAP8[$1_1 + 27 | 0] = $2_1 >>> 24;
  HEAP32[$0_1 + 24 >> 2] = 0;
  $2_1 = HEAP32[$0_1 + 28 >> 2];
  $2_1 = $2_1 << 8 & 16711680 | $2_1 << 24 | ($2_1 >>> 8 & 65280 | $2_1 >>> 24);
  HEAP8[$1_1 + 28 | 0] = $2_1;
  HEAP8[$1_1 + 29 | 0] = $2_1 >>> 8;
  HEAP8[$1_1 + 30 | 0] = $2_1 >>> 16;
  HEAP8[$1_1 + 31 | 0] = $2_1 >>> 24;
  HEAP32[$0_1 + 28 >> 2] = 0;
  global$0 = $3_1 + 16 | 0;
 }
 
 function $31($0_1, $1_1, $2_1, $3_1) {
  var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0;
  $6_1 = global$0 - 880 | 0;
  global$0 = $6_1;
  label$1 : {
   if (!$1_1) {
    FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689638, HEAP32[$0_1 + 172 >> 2]);
    $0_1 = 0;
    break label$1;
   }
   HEAP8[$1_1 | 0] = 0;
   HEAP8[$1_1 + 1 | 0] = 0;
   HEAP8[$1_1 + 2 | 0] = 0;
   HEAP8[$1_1 + 3 | 0] = 0;
   HEAP8[$1_1 + 4 | 0] = 0;
   HEAP8[$1_1 + 5 | 0] = 0;
   HEAP8[$1_1 + 6 | 0] = 0;
   HEAP8[$1_1 + 7 | 0] = 0;
   $4_1 = $1_1 + 56 | 0;
   HEAP8[$4_1 | 0] = 0;
   HEAP8[$4_1 + 1 | 0] = 0;
   HEAP8[$4_1 + 2 | 0] = 0;
   HEAP8[$4_1 + 3 | 0] = 0;
   HEAP8[$4_1 + 4 | 0] = 0;
   HEAP8[$4_1 + 5 | 0] = 0;
   HEAP8[$4_1 + 6 | 0] = 0;
   HEAP8[$4_1 + 7 | 0] = 0;
   $4_1 = $1_1 + 48 | 0;
   HEAP8[$4_1 | 0] = 0;
   HEAP8[$4_1 + 1 | 0] = 0;
   HEAP8[$4_1 + 2 | 0] = 0;
   HEAP8[$4_1 + 3 | 0] = 0;
   HEAP8[$4_1 + 4 | 0] = 0;
   HEAP8[$4_1 + 5 | 0] = 0;
   HEAP8[$4_1 + 6 | 0] = 0;
   HEAP8[$4_1 + 7 | 0] = 0;
   $4_1 = $1_1 + 40 | 0;
   HEAP8[$4_1 | 0] = 0;
   HEAP8[$4_1 + 1 | 0] = 0;
   HEAP8[$4_1 + 2 | 0] = 0;
   HEAP8[$4_1 + 3 | 0] = 0;
   HEAP8[$4_1 + 4 | 0] = 0;
   HEAP8[$4_1 + 5 | 0] = 0;
   HEAP8[$4_1 + 6 | 0] = 0;
   HEAP8[$4_1 + 7 | 0] = 0;
   $4_1 = $1_1 + 32 | 0;
   HEAP8[$4_1 | 0] = 0;
   HEAP8[$4_1 + 1 | 0] = 0;
   HEAP8[$4_1 + 2 | 0] = 0;
   HEAP8[$4_1 + 3 | 0] = 0;
   HEAP8[$4_1 + 4 | 0] = 0;
   HEAP8[$4_1 + 5 | 0] = 0;
   HEAP8[$4_1 + 6 | 0] = 0;
   HEAP8[$4_1 + 7 | 0] = 0;
   $4_1 = $1_1 + 24 | 0;
   HEAP8[$4_1 | 0] = 0;
   HEAP8[$4_1 + 1 | 0] = 0;
   HEAP8[$4_1 + 2 | 0] = 0;
   HEAP8[$4_1 + 3 | 0] = 0;
   HEAP8[$4_1 + 4 | 0] = 0;
   HEAP8[$4_1 + 5 | 0] = 0;
   HEAP8[$4_1 + 6 | 0] = 0;
   HEAP8[$4_1 + 7 | 0] = 0;
   $4_1 = $1_1 + 16 | 0;
   HEAP8[$4_1 | 0] = 0;
   HEAP8[$4_1 + 1 | 0] = 0;
   HEAP8[$4_1 + 2 | 0] = 0;
   HEAP8[$4_1 + 3 | 0] = 0;
   HEAP8[$4_1 + 4 | 0] = 0;
   HEAP8[$4_1 + 5 | 0] = 0;
   HEAP8[$4_1 + 6 | 0] = 0;
   HEAP8[$4_1 + 7 | 0] = 0;
   $4_1 = $1_1 + 8 | 0;
   HEAP8[$4_1 | 0] = 0;
   HEAP8[$4_1 + 1 | 0] = 0;
   HEAP8[$4_1 + 2 | 0] = 0;
   HEAP8[$4_1 + 3 | 0] = 0;
   HEAP8[$4_1 + 4 | 0] = 0;
   HEAP8[$4_1 + 5 | 0] = 0;
   HEAP8[$4_1 + 6 | 0] = 0;
   HEAP8[$4_1 + 7 | 0] = 0;
   if (!$2_1) {
    FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689668, HEAP32[$0_1 + 172 >> 2]);
    $0_1 = 0;
    break label$1;
   }
   $0_1 = 0;
   label$4 : {
    if (($3_1 | 0) != 65) {
     if (($3_1 | 0) != 33) {
      break label$1
     }
     if ((HEAPU8[$2_1 | 0] & 254) != 2) {
      break label$1
     }
     if (!$32($6_1 + 840 | 0, $2_1 + 1 | 0)) {
      $3_1 = 0;
      break label$4;
     }
     $3_1 = ($33($6_1 + 672 | 0, $6_1 + 840 | 0, HEAPU8[$2_1 | 0] == 3) | 0) != 0;
     break label$4;
    }
    $3_1 = HEAPU8[$2_1 | 0];
    if ($3_1 >>> 0 > 7) {
     break label$1
    }
    if (!(1 << $3_1 & 208)) {
     break label$1
    }
    $3_1 = 0;
    if (!$32($6_1 + 800 | 0, $2_1 + 1 | 0)) {
     break label$4
    }
    if (!$32($6_1 + 760 | 0, $2_1 + 33 | 0)) {
     break label$4
    }
    $7_1 = $6_1 + 800 | 0;
    $5_1 = $7_1 + 8 | 0;
    $4_1 = HEAP32[$5_1 + 4 >> 2];
    $8_1 = $6_1 + 672 | 0;
    $3_1 = $8_1 + 8 | 0;
    HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
    HEAP32[$3_1 + 4 >> 2] = $4_1;
    $5_1 = $7_1 + 16 | 0;
    $4_1 = HEAP32[$5_1 + 4 >> 2];
    $3_1 = $8_1 + 16 | 0;
    HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
    HEAP32[$3_1 + 4 >> 2] = $4_1;
    $5_1 = $7_1 + 24 | 0;
    $4_1 = HEAP32[$5_1 + 4 >> 2];
    $3_1 = $8_1 + 24 | 0;
    HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
    HEAP32[$3_1 + 4 >> 2] = $4_1;
    $5_1 = $7_1 + 32 | 0;
    $4_1 = HEAP32[$5_1 + 4 >> 2];
    $3_1 = $8_1 + 32 | 0;
    HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
    HEAP32[$3_1 + 4 >> 2] = $4_1;
    $5_1 = $6_1 + 760 | 0;
    $4_1 = $5_1 + 8 | 0;
    $3_1 = HEAP32[$4_1 + 4 >> 2];
    $19_1 = $6_1 + 720 | 0;
    HEAP32[$19_1 >> 2] = HEAP32[$4_1 >> 2];
    HEAP32[$19_1 + 4 >> 2] = $3_1;
    $4_1 = $5_1 + 16 | 0;
    $3_1 = HEAP32[$4_1 + 4 >> 2];
    $14_1 = $6_1 + 728 | 0;
    HEAP32[$14_1 >> 2] = HEAP32[$4_1 >> 2];
    HEAP32[$14_1 + 4 >> 2] = $3_1;
    $4_1 = $5_1 + 24 | 0;
    $3_1 = HEAP32[$4_1 + 4 >> 2];
    $7_1 = $6_1 + 736 | 0;
    HEAP32[$7_1 >> 2] = HEAP32[$4_1 >> 2];
    HEAP32[$7_1 + 4 >> 2] = $3_1;
    $4_1 = $5_1 + 32 | 0;
    $3_1 = HEAP32[$4_1 + 4 >> 2];
    $23_1 = $6_1 + 744 | 0;
    HEAP32[$23_1 >> 2] = HEAP32[$4_1 >> 2];
    HEAP32[$23_1 + 4 >> 2] = $3_1;
    HEAP32[$6_1 + 752 >> 2] = 0;
    $3_1 = HEAP32[$6_1 + 804 >> 2];
    HEAP32[$6_1 + 672 >> 2] = HEAP32[$6_1 + 800 >> 2];
    HEAP32[$6_1 + 676 >> 2] = $3_1;
    $3_1 = HEAP32[$6_1 + 764 >> 2];
    HEAP32[$6_1 + 712 >> 2] = HEAP32[$6_1 + 760 >> 2];
    HEAP32[$6_1 + 716 >> 2] = $3_1;
    $2_1 = HEAPU8[$2_1 | 0];
    if (($2_1 & 254) == 6) {
     $3_1 = 0;
     if ((HEAP8[$6_1 + 760 | 0] & 1) == (($2_1 | 0) != 7 | 0)) {
      break label$4
     }
    }
    $2_1 = HEAP32[$6_1 + 716 >> 2];
    $28_1 = $2_1;
    $9_1 = HEAP32[$6_1 + 712 >> 2];
    $3_1 = $9_1;
    $2_1 = $2_1 << 1 | $3_1 >>> 31;
    $15_1 = $6_1 + 96 | 0;
    $10_1 = HEAP32[$7_1 >> 2];
    $11_1 = HEAP32[$7_1 + 4 >> 2];
    $24_1 = $3_1 << 1;
    $30_1 = $2_1;
    $69($15_1, $10_1, $11_1, 0, 0, $24_1, $2_1, 0, 0);
    $2_1 = HEAP32[$19_1 + 4 >> 2];
    $25_1 = $2_1;
    $26_1 = HEAP32[$19_1 >> 2];
    $4_1 = $26_1;
    $2_1 = $2_1 << 1 | $4_1 >>> 31;
    $12_1 = $6_1 + 160 | 0;
    $13_1 = HEAP32[$14_1 >> 2];
    $14_1 = HEAP32[$14_1 + 4 >> 2];
    $4_1 = $4_1 << 1;
    $5_1 = $2_1;
    $69($12_1, $13_1, $14_1, 0, 0, $4_1, $2_1, 0, 0);
    $19_1 = $6_1 + 288 | 0;
    $3_1 = HEAP32[$23_1 >> 2];
    $2_1 = HEAP32[$23_1 + 4 >> 2];
    $69($19_1, $3_1, $2_1, 0, 0, $3_1, $2_1, 0, 0);
    $7_1 = $6_1 + 272 | 0;
    $69($7_1, HEAP32[$6_1 + 288 >> 2], HEAP32[$6_1 + 292 >> 2], 0, 0, 15632, 16, 0, 0);
    $2_1 = $2_1 << 1 | $3_1 >>> 31;
    $33_1 = $6_1 + 128 | 0;
    $17_1 = $3_1 << 1;
    $23_1 = $2_1;
    $69($33_1, $17_1, $2_1, 0, 0, $9_1, $28_1, 0, 0);
    $34_1 = $6_1 + 144 | 0;
    $69($34_1, $10_1, $11_1, 0, 0, $4_1, $5_1, 0, 0);
    $35_1 = $6_1 + 224 | 0;
    $69($35_1, $13_1, $14_1, 0, 0, $13_1, $14_1, 0, 0);
    $16_1 = $6_1 + 256 | 0;
    $2_1 = $19_1 + 8 | 0;
    $69($16_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $43_1 = $6_1 + 112 | 0;
    $69($43_1, $9_1, $28_1, 0, 0, $9_1, $28_1, 0, 0);
    $31_1 = $6_1 + 192 | 0;
    $69($31_1, $17_1, $23_1, 0, 0, $26_1, $25_1, 0, 0);
    $38_1 = $6_1 + 240 | 0;
    $69($38_1, $10_1, $11_1, 0, 0, $13_1 << 1, $14_1 << 1 | $13_1 >>> 31, 0, 0);
    $28_1 = HEAP32[$6_1 + 100 >> 2];
    $2_1 = $28_1 + HEAP32[$6_1 + 164 >> 2] | 0;
    $8_1 = HEAP32[$6_1 + 96 >> 2];
    $3_1 = HEAP32[$6_1 + 160 >> 2];
    $5_1 = $8_1 + $3_1 | 0;
    $4_1 = HEAP32[$6_1 + 272 >> 2];
    $39_1 = $5_1 + $4_1 | 0;
    $3_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $3_1 + HEAP32[$6_1 + 276 >> 2] | 0;
    $4_1 = $4_1 >>> 0 > $39_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $9_1 = ($3_1 | 0) == ($4_1 | 0) & $5_1 >>> 0 > $39_1 >>> 0 | $3_1 >>> 0 > $4_1 >>> 0;
    $2_1 = $7_1 + 8 | 0;
    $19_1 = HEAP32[$2_1 >> 2];
    $7_1 = HEAP32[$2_1 + 4 >> 2];
    $8_1 = ($3_1 | 0) == ($28_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $3_1 >>> 0 < $28_1 >>> 0;
    $5_1 = $12_1 + 8 | 0;
    $3_1 = HEAP32[$5_1 >> 2];
    $2_1 = $15_1 + 8 | 0;
    $12_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
    $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $8_1 + $12_1 | 0;
    $2_1 = ($3_1 >>> 0 < $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $7_1 | 0;
    $5_1 = $3_1;
    $3_1 = $3_1 + $19_1 | 0;
    $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $3_1;
    $3_1 = $3_1 + $9_1 | 0;
    $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $40_1 = $4_1;
    $19_1 = $3_1 << 12 | $4_1 >>> 20;
    $5_1 = $2_1;
    $8_1 = $2_1 << 12 | $3_1 >>> 20;
    $21_1 = HEAP32[$6_1 + 144 >> 2];
    $3_1 = HEAP32[$6_1 + 224 >> 2];
    $12_1 = $21_1 + $3_1 | 0;
    $32_1 = HEAP32[$6_1 + 148 >> 2];
    $2_1 = $32_1 + HEAP32[$6_1 + 228 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = HEAP32[$6_1 + 128 >> 2];
    $9_1 = $3_1 + $12_1 | 0;
    $15_1 = $2_1;
    $2_1 = $2_1 + HEAP32[$6_1 + 132 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = HEAP32[$6_1 + 256 >> 2];
    $7_1 = $3_1 + $9_1 | 0;
    $4_1 = $2_1;
    $2_1 = $2_1 + HEAP32[$6_1 + 260 >> 2] | 0;
    $3_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $3_1 + $8_1 | 0;
    $44_1 = $6_1 + 32 | 0;
    $29_1 = $44_1;
    $19_1 = $7_1 + $19_1 | 0;
    $8_1 = $19_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $27_1 = ($3_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 > $19_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
    $22_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
    $2_1 = $16_1 + 8 | 0;
    $18_1 = HEAP32[$2_1 >> 2];
    $20_1 = HEAP32[$2_1 + 4 >> 2];
    $28_1 = ($4_1 | 0) == ($15_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $4_1 >>> 0 < $15_1 >>> 0;
    $2_1 = $33_1 + 8 | 0;
    $16_1 = HEAP32[$2_1 >> 2];
    $9_1 = HEAP32[$2_1 + 4 >> 2];
    $7_1 = ($15_1 | 0) == ($32_1 | 0) & $12_1 >>> 0 < $21_1 >>> 0 | $15_1 >>> 0 < $32_1 >>> 0;
    $4_1 = $35_1 + 8 | 0;
    $3_1 = HEAP32[$4_1 >> 2];
    $2_1 = $34_1 + 8 | 0;
    $12_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
    $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $7_1 + $12_1 | 0;
    $2_1 = ($3_1 >>> 0 < $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $9_1 | 0;
    $4_1 = $3_1;
    $3_1 = $3_1 + $16_1 | 0;
    $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $3_1;
    $3_1 = $3_1 + $28_1 | 0;
    $2_1 = ($4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $20_1 | 0;
    $4_1 = $3_1;
    $3_1 = $3_1 + $18_1 | 0;
    $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $3_1 + $22_1 | 0;
    $2_1 = $4_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $5_1 >>> 20 | 0;
    $3_1 = $4_1 + $5_1 | 0;
    $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $3_1;
    $3_1 = $3_1 + $27_1 | 0;
    $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $8_1;
    $7_1 = $3_1 << 12 | $4_1 >>> 20;
    $5_1 = $2_1;
    $8_1 = $2_1 << 12 | $3_1 >>> 20;
    $18_1 = HEAP32[$6_1 + 192 >> 2];
    $3_1 = HEAP32[$6_1 + 240 >> 2];
    $9_1 = $18_1 + $3_1 | 0;
    $22_1 = HEAP32[$6_1 + 196 >> 2];
    $2_1 = $22_1 + HEAP32[$6_1 + 244 >> 2] | 0;
    $3_1 = $3_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $3_1 + $8_1 | 0;
    $7_1 = $7_1 + $9_1 | 0;
    $2_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $15_1 = $7_1 << 4 & -16;
    $8_1 = $2_1;
    $12_1 = ($2_1 << 4 | $7_1 >>> 28) & 16777215;
    $28_1 = $4_1;
    $69($29_1, $15_1 | $4_1 >>> 16 & 15, $12_1, 0, 0, 977, 1, 0, 0);
    $45_1 = $6_1 + 16 | 0;
    $69($45_1, $26_1, $25_1, 0, 0, $24_1, $30_1, 0, 0);
    $20_1 = $6_1 + 208 | 0;
    $69($20_1, $17_1, $23_1, 0, 0, $13_1, $14_1, 0, 0);
    $16_1 = $6_1 + 320 | 0;
    $69($16_1, $10_1, $11_1, 0, 0, $10_1, $11_1, 0, 0);
    $46_1 = $6_1 + 80 | 0;
    $15_1 = $46_1;
    $12_1 = ($3_1 | 0) == ($2_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 > $2_1 >>> 0;
    $7_1 = ($3_1 | 0) == ($22_1 | 0) & $9_1 >>> 0 < $18_1 >>> 0 | $3_1 >>> 0 < $22_1 >>> 0;
    $4_1 = $38_1 + 8 | 0;
    $3_1 = HEAP32[$4_1 >> 2];
    $2_1 = $31_1 + 8 | 0;
    $9_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
    $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $7_1 + $9_1 | 0;
    $2_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $5_1 >>> 20 | 0;
    $3_1 = $4_1 + $5_1 | 0;
    $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $3_1;
    $3_1 = $3_1 + $12_1 | 0;
    $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $8_1 = $3_1 << 12 | $8_1 >>> 20;
    $4_1 = $2_1;
    $9_1 = $2_1 << 12 | $3_1 >>> 20;
    $18_1 = HEAP32[$6_1 + 212 >> 2];
    $2_1 = $18_1 + HEAP32[$6_1 + 324 >> 2] | 0;
    $12_1 = HEAP32[$6_1 + 208 >> 2];
    $3_1 = HEAP32[$6_1 + 320 >> 2];
    $5_1 = $12_1 + $3_1 | 0;
    $7_1 = $5_1;
    $8_1 = $5_1 + $8_1 | 0;
    $3_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $3_1 + $9_1 | 0;
    $5_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $69($15_1, $8_1, $5_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $69($6_1, $13_1, $14_1, 0, 0, $24_1, $30_1, 0, 0);
    $47_1 = $6_1 + 176 | 0;
    $69($47_1, $26_1, $25_1, 0, 0, $26_1, $25_1, 0, 0);
    $9_1 = $6_1 + 304 | 0;
    $69($9_1, $17_1, $23_1, 0, 0, $10_1, $11_1, 0, 0);
    $48_1 = $6_1 - -64 | 0;
    $11_1 = $48_1;
    $14_1 = ($3_1 | 0) == ($5_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $3_1 >>> 0 > $5_1 >>> 0;
    $7_1 = ($3_1 | 0) == ($18_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $3_1 >>> 0 < $18_1 >>> 0;
    $8_1 = $16_1 + 8 | 0;
    $3_1 = HEAP32[$8_1 >> 2];
    $2_1 = $20_1 + 8 | 0;
    $10_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
    $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $8_1 = $7_1 + $10_1 | 0;
    $2_1 = $8_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $4_1 >>> 20 | 0;
    $3_1 = $4_1 + $8_1 | 0;
    $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $3_1;
    $3_1 = $3_1 + $14_1 | 0;
    $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $8_1 = $3_1 << 12 | $5_1 >>> 20;
    $5_1 = HEAP32[$6_1 + 304 >> 2];
    $14_1 = $8_1 + $5_1 | 0;
    $4_1 = $2_1;
    $3_1 = $2_1 << 12 | $3_1 >>> 20;
    $2_1 = $3_1 + HEAP32[$6_1 + 308 >> 2] | 0;
    $2_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $69($11_1, $14_1, $2_1, 0, 0, 15632, 16, 0, 0);
    $49_1 = $6_1 + 48 | 0;
    $7_1 = $49_1;
    $8_1 = ($2_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $14_1 >>> 0 | $2_1 >>> 0 < $3_1 >>> 0;
    $2_1 = $9_1 + 8 | 0;
    $5_1 = HEAP32[$2_1 >> 2];
    $2_1 = HEAP32[$2_1 + 4 >> 2];
    $4_1 = $4_1 >>> 20 | 0;
    $3_1 = $4_1 + $5_1 | 0;
    $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $3_1;
    $3_1 = $3_1 + $8_1 | 0;
    $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $69($7_1, $3_1, $2_1, 0, 0, 64028672, 65536, 0, 0);
    $2_1 = HEAP32[$6_1 + 676 >> 2];
    $13_1 = $2_1;
    $11_1 = HEAP32[$6_1 + 672 >> 2];
    $3_1 = $11_1;
    $2_1 = $2_1 << 1 | $3_1 >>> 31;
    $9_1 = $6_1 + 432 | 0;
    $16_1 = HEAP32[$6_1 + 696 >> 2];
    $15_1 = HEAP32[$6_1 + 700 >> 2];
    $27_1 = $3_1 << 1;
    $29_1 = $2_1;
    $69($9_1, $16_1, $15_1, 0, 0, $27_1, $2_1, 0, 0);
    $2_1 = HEAP32[$6_1 + 684 >> 2];
    $42_1 = $2_1;
    $41_1 = HEAP32[$6_1 + 680 >> 2];
    $4_1 = $41_1;
    $2_1 = $2_1 << 1 | $4_1 >>> 31;
    $10_1 = $6_1 + 496 | 0;
    $18_1 = HEAP32[$6_1 + 688 >> 2];
    $17_1 = HEAP32[$6_1 + 692 >> 2];
    $4_1 = $4_1 << 1;
    $5_1 = $2_1;
    $69($10_1, $18_1, $17_1, 0, 0, $4_1, $2_1, 0, 0);
    $14_1 = $6_1 + 624 | 0;
    $3_1 = HEAP32[$6_1 + 704 >> 2];
    $2_1 = HEAP32[$6_1 + 708 >> 2];
    $69($14_1, $3_1, $2_1, 0, 0, $3_1, $2_1, 0, 0);
    $7_1 = $6_1 + 608 | 0;
    $69($7_1, HEAP32[$6_1 + 624 >> 2], HEAP32[$6_1 + 628 >> 2], 0, 0, 15632, 16, 0, 0);
    $2_1 = $2_1 << 1 | $3_1 >>> 31;
    $26_1 = $6_1 + 464 | 0;
    $38_1 = $3_1 << 1;
    $22_1 = $2_1;
    $69($26_1, $38_1, $2_1, 0, 0, $11_1, $13_1, 0, 0);
    $32_1 = $6_1 + 480 | 0;
    $69($32_1, $16_1, $15_1, 0, 0, $4_1, $5_1, 0, 0);
    $33_1 = $6_1 + 560 | 0;
    $69($33_1, $18_1, $17_1, 0, 0, $18_1, $17_1, 0, 0);
    $12_1 = $6_1 + 592 | 0;
    $2_1 = $14_1 + 8 | 0;
    $69($12_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $50_1 = $6_1 + 448 | 0;
    $69($50_1, $11_1, $13_1, 0, 0, $11_1, $13_1, 0, 0);
    $36_1 = $6_1 + 528 | 0;
    $69($36_1, $38_1, $22_1, 0, 0, $41_1, $42_1, 0, 0);
    $37_1 = $6_1 + 576 | 0;
    $69($37_1, $16_1, $15_1, 0, 0, $18_1 << 1, $17_1 << 1 | $18_1 >>> 31, 0, 0);
    $13_1 = HEAP32[$6_1 + 436 >> 2];
    $2_1 = $13_1 + HEAP32[$6_1 + 500 >> 2] | 0;
    $8_1 = HEAP32[$6_1 + 432 >> 2];
    $3_1 = HEAP32[$6_1 + 496 >> 2];
    $4_1 = $8_1 + $3_1 | 0;
    $5_1 = HEAP32[$6_1 + 608 >> 2];
    $30_1 = $4_1 + $5_1 | 0;
    $3_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $3_1 + HEAP32[$6_1 + 612 >> 2] | 0;
    $5_1 = $5_1 >>> 0 > $30_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $11_1 = ($3_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $30_1 >>> 0 | $3_1 >>> 0 > $5_1 >>> 0;
    $2_1 = $7_1 + 8 | 0;
    $14_1 = HEAP32[$2_1 >> 2];
    $7_1 = HEAP32[$2_1 + 4 >> 2];
    $8_1 = ($3_1 | 0) == ($13_1 | 0) & $4_1 >>> 0 < $8_1 >>> 0 | $3_1 >>> 0 < $13_1 >>> 0;
    $4_1 = $10_1 + 8 | 0;
    $3_1 = HEAP32[$4_1 >> 2];
    $2_1 = $9_1 + 8 | 0;
    $10_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
    $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $8_1 + $10_1 | 0;
    $2_1 = ($3_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $7_1 | 0;
    $4_1 = $3_1;
    $3_1 = $3_1 + $14_1 | 0;
    $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $3_1;
    $3_1 = $3_1 + $11_1 | 0;
    $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $24_1 = $5_1;
    $14_1 = $3_1 << 12 | $5_1 >>> 20;
    $4_1 = $2_1;
    $8_1 = $2_1 << 12 | $3_1 >>> 20;
    $34_1 = HEAP32[$6_1 + 480 >> 2];
    $3_1 = HEAP32[$6_1 + 560 >> 2];
    $11_1 = $34_1 + $3_1 | 0;
    $25_1 = HEAP32[$6_1 + 484 >> 2];
    $2_1 = $25_1 + HEAP32[$6_1 + 564 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = HEAP32[$6_1 + 464 >> 2];
    $7_1 = $3_1 + $11_1 | 0;
    $9_1 = $2_1;
    $2_1 = $2_1 + HEAP32[$6_1 + 468 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = HEAP32[$6_1 + 592 >> 2];
    $5_1 = $3_1 + $7_1 | 0;
    $10_1 = $2_1;
    $2_1 = $2_1 + HEAP32[$6_1 + 596 >> 2] | 0;
    $3_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $3_1 + $8_1 | 0;
    $35_1 = $6_1 + 368 | 0;
    $14_1 = $5_1 + $14_1 | 0;
    $8_1 = $14_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $31_1 = ($3_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $14_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
    $21_1 = ($3_1 | 0) == ($10_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $3_1 >>> 0 < $10_1 >>> 0;
    $2_1 = $12_1 + 8 | 0;
    $20_1 = HEAP32[$2_1 >> 2];
    $23_1 = HEAP32[$2_1 + 4 >> 2];
    $13_1 = ($9_1 | 0) == ($10_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $9_1 >>> 0 > $10_1 >>> 0;
    $2_1 = $26_1 + 8 | 0;
    $12_1 = HEAP32[$2_1 >> 2];
    $10_1 = HEAP32[$2_1 + 4 >> 2];
    $7_1 = ($9_1 | 0) == ($25_1 | 0) & $11_1 >>> 0 < $34_1 >>> 0 | $9_1 >>> 0 < $25_1 >>> 0;
    $5_1 = $33_1 + 8 | 0;
    $3_1 = HEAP32[$5_1 >> 2];
    $2_1 = $32_1 + 8 | 0;
    $11_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
    $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $7_1 + $11_1 | 0;
    $2_1 = ($3_1 >>> 0 < $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $10_1 | 0;
    $5_1 = $3_1;
    $3_1 = $3_1 + $12_1 | 0;
    $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $3_1;
    $3_1 = $3_1 + $13_1 | 0;
    $2_1 = ($5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $23_1 | 0;
    $5_1 = $3_1;
    $3_1 = $3_1 + $20_1 | 0;
    $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $3_1 + $21_1 | 0;
    $2_1 = $5_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $4_1 >>> 20 | 0;
    $3_1 = $4_1 + $5_1 | 0;
    $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $3_1;
    $3_1 = $3_1 + $31_1 | 0;
    $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $8_1;
    $7_1 = $3_1 << 12 | $4_1 >>> 20;
    $5_1 = $2_1;
    $11_1 = $2_1 << 12 | $3_1 >>> 20;
    $21_1 = HEAP32[$6_1 + 532 >> 2];
    $2_1 = $21_1 + HEAP32[$6_1 + 580 >> 2] | 0;
    $13_1 = HEAP32[$6_1 + 528 >> 2];
    $3_1 = HEAP32[$6_1 + 576 >> 2];
    $8_1 = $13_1 + $3_1 | 0;
    $9_1 = $8_1;
    $7_1 = $8_1 + $7_1 | 0;
    $3_1 = $3_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $3_1 + $11_1 | 0;
    $10_1 = $7_1 << 4 & -16;
    $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $11_1 = ($8_1 << 4 | $7_1 >>> 28) & 16777215;
    $23_1 = $4_1;
    $69($35_1, $10_1 | $4_1 >>> 16 & 15, $11_1, 0, 0, 977, 1, 0, 0);
    $11_1 = HEAP32[$6_1 + 372 >> 2];
    $2_1 = $11_1 + HEAP32[$6_1 + 452 >> 2] | 0;
    $31_1 = HEAP32[$6_1 + 368 >> 2];
    $4_1 = HEAP32[$6_1 + 448 >> 2];
    $10_1 = $31_1 + $4_1 | 0;
    HEAP32[$6_1 + 840 >> 2] = $10_1;
    $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$6_1 + 844 >> 2] = $4_1 & 1048575;
    $25_1 = $6_1 + 352 | 0;
    $69($25_1, $41_1, $42_1, 0, 0, $27_1, $29_1, 0, 0);
    $26_1 = $6_1 + 544 | 0;
    $69($26_1, $38_1, $22_1, 0, 0, $18_1, $17_1, 0, 0);
    $32_1 = $6_1 + 656 | 0;
    $69($32_1, $16_1, $15_1, 0, 0, $16_1, $15_1, 0, 0);
    $33_1 = $6_1 + 416 | 0;
    $20_1 = $33_1;
    $12_1 = ($3_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
    $9_1 = ($3_1 | 0) == ($21_1 | 0) & $9_1 >>> 0 < $13_1 >>> 0 | $3_1 >>> 0 < $21_1 >>> 0;
    $7_1 = $37_1 + 8 | 0;
    $3_1 = HEAP32[$7_1 >> 2];
    $2_1 = $36_1 + 8 | 0;
    $13_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
    $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $13_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $7_1 = $9_1 + $13_1 | 0;
    $2_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $5_1 >>> 20 | 0;
    $3_1 = $5_1 + $7_1 | 0;
    $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $3_1;
    $3_1 = $3_1 + $12_1 | 0;
    $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $9_1 = $3_1 << 12 | $8_1 >>> 20;
    $7_1 = $2_1;
    $8_1 = $2_1 << 12 | $3_1 >>> 20;
    $36_1 = HEAP32[$6_1 + 548 >> 2];
    $2_1 = $36_1 + HEAP32[$6_1 + 660 >> 2] | 0;
    $34_1 = HEAP32[$6_1 + 544 >> 2];
    $5_1 = HEAP32[$6_1 + 656 >> 2];
    $3_1 = $34_1 + $5_1 | 0;
    $21_1 = $3_1;
    $13_1 = $3_1 + $9_1 | 0;
    $5_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $5_1 + $8_1 | 0;
    $9_1 = $13_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $69($20_1, $13_1, $9_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $10_1 = ($4_1 | 0) == ($11_1 | 0) & $10_1 >>> 0 < $31_1 >>> 0 | $4_1 >>> 0 < $11_1 >>> 0;
    $8_1 = $50_1 + 8 | 0;
    $3_1 = HEAP32[$8_1 >> 2];
    $2_1 = $35_1 + 8 | 0;
    $12_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
    $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $10_1 + $12_1 | 0;
    $2_1 = $3_1 >>> 0 < $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $12_1 = $3_1 << 12 | $4_1 >>> 20;
    $8_1 = $2_1;
    $10_1 = $2_1 << 12 | $3_1 >>> 20;
    $35_1 = HEAP32[$6_1 + 416 >> 2];
    $3_1 = HEAP32[$6_1 + 352 >> 2];
    $20_1 = $35_1 + $3_1 | 0;
    $37_1 = HEAP32[$6_1 + 420 >> 2];
    $2_1 = $37_1 + HEAP32[$6_1 + 356 >> 2] | 0;
    $4_1 = $3_1 >>> 0 > $20_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $4_1 + $10_1 | 0;
    $12_1 = $12_1 + $20_1 | 0;
    $2_1 = $12_1 >>> 0 < $20_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$6_1 + 848 >> 2] = $12_1;
    $10_1 = $2_1;
    HEAP32[$6_1 + 852 >> 2] = $2_1 & 1048575;
    $31_1 = $6_1 + 336 | 0;
    $69($31_1, $18_1, $17_1, 0, 0, $27_1, $29_1, 0, 0);
    $29_1 = $6_1 + 512 | 0;
    $69($29_1, $41_1, $42_1, 0, 0, $41_1, $42_1, 0, 0);
    $27_1 = $6_1 + 640 | 0;
    $69($27_1, $38_1, $22_1, 0, 0, $16_1, $15_1, 0, 0);
    $18_1 = $6_1 + 400 | 0;
    $16_1 = $18_1;
    $17_1 = ($5_1 | 0) == ($9_1 | 0) & $13_1 >>> 0 < $21_1 >>> 0 | $5_1 >>> 0 > $9_1 >>> 0;
    $13_1 = ($5_1 | 0) == ($36_1 | 0) & $21_1 >>> 0 < $34_1 >>> 0 | $5_1 >>> 0 < $36_1 >>> 0;
    $5_1 = $32_1 + 8 | 0;
    $3_1 = HEAP32[$5_1 >> 2];
    $2_1 = $26_1 + 8 | 0;
    $15_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
    $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $13_1 + $15_1 | 0;
    $2_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $7_1 = $7_1 >>> 20 | 0;
    $3_1 = $5_1 + $7_1 | 0;
    $2_1 = $7_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $3_1;
    $3_1 = $3_1 + $17_1 | 0;
    $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $15_1 = $3_1 << 12 | $9_1 >>> 20;
    $7_1 = HEAP32[$6_1 + 640 >> 2];
    $9_1 = $15_1 + $7_1 | 0;
    $5_1 = $2_1;
    $21_1 = $2_1 << 12 | $3_1 >>> 20;
    $2_1 = $21_1 + HEAP32[$6_1 + 644 >> 2] | 0;
    $13_1 = $7_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $69($16_1, $9_1, $13_1, 0, 0, 15632, 16, 0, 0);
    $12_1 = ($4_1 | 0) == ($10_1 | 0) & $12_1 >>> 0 < $20_1 >>> 0 | $4_1 >>> 0 > $10_1 >>> 0;
    $11_1 = ($4_1 | 0) == ($37_1 | 0) & $20_1 >>> 0 < $35_1 >>> 0 | $4_1 >>> 0 < $37_1 >>> 0;
    $4_1 = $25_1 + 8 | 0;
    $3_1 = HEAP32[$4_1 >> 2];
    $2_1 = $33_1 + 8 | 0;
    $17_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
    $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $17_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $11_1 + $17_1 | 0;
    $2_1 = $4_1 >>> 0 < $17_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $8_1 = $8_1 >>> 20 | 0;
    $3_1 = $4_1 + $8_1 | 0;
    $2_1 = $8_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $3_1;
    $3_1 = $3_1 + $12_1 | 0;
    $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $11_1 = $3_1 << 12 | $10_1 >>> 20;
    $4_1 = $2_1;
    $8_1 = $2_1 << 12 | $3_1 >>> 20;
    $20_1 = HEAP32[$6_1 + 336 >> 2];
    $3_1 = HEAP32[$6_1 + 512 >> 2];
    $12_1 = $20_1 + $3_1 | 0;
    $22_1 = HEAP32[$6_1 + 340 >> 2];
    $2_1 = $22_1 + HEAP32[$6_1 + 516 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = HEAP32[$6_1 + 400 >> 2];
    $10_1 = $3_1 + $12_1 | 0;
    $17_1 = $2_1;
    $2_1 = $2_1 + HEAP32[$6_1 + 404 >> 2] | 0;
    $3_1 = $3_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $3_1 + $8_1 | 0;
    $11_1 = $11_1 + $10_1 | 0;
    $2_1 = $11_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$6_1 + 856 >> 2] = $11_1;
    $8_1 = $2_1;
    HEAP32[$6_1 + 860 >> 2] = $2_1 & 1048575;
    $16_1 = $6_1 + 384 | 0;
    $15_1 = ($13_1 | 0) == ($21_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $13_1 >>> 0 < $21_1 >>> 0;
    $2_1 = $27_1 + 8 | 0;
    $13_1 = HEAP32[$2_1 >> 2];
    $2_1 = HEAP32[$2_1 + 4 >> 2];
    $5_1 = $5_1 >>> 20 | 0;
    $7_1 = $5_1;
    $5_1 = $5_1 + $13_1 | 0;
    $2_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $7_1 = $5_1;
    $5_1 = $5_1 + $15_1 | 0;
    $2_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $69($16_1, $5_1, $2_1, 0, 0, 64028672, 65536, 0, 0);
    $15_1 = ($3_1 | 0) == ($8_1 | 0) & $11_1 >>> 0 < $10_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
    $13_1 = ($3_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $3_1 >>> 0 < $17_1 >>> 0;
    $2_1 = $18_1 + 8 | 0;
    $9_1 = HEAP32[$2_1 >> 2];
    $10_1 = HEAP32[$2_1 + 4 >> 2];
    $11_1 = ($17_1 | 0) == ($22_1 | 0) & $12_1 >>> 0 < $20_1 >>> 0 | $17_1 >>> 0 < $22_1 >>> 0;
    $7_1 = $29_1 + 8 | 0;
    $3_1 = HEAP32[$7_1 >> 2];
    $2_1 = $31_1 + 8 | 0;
    $12_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
    $2_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
    $2_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $11_1 + $12_1 | 0;
    $2_1 = ($3_1 >>> 0 < $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $10_1 | 0;
    $5_1 = $3_1;
    $3_1 = $3_1 + $9_1 | 0;
    $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $7_1 = $3_1 + $13_1 | 0;
    $2_1 = $7_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $4_1 >>> 20 | 0;
    $3_1 = $4_1 + $7_1 | 0;
    $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $3_1;
    $3_1 = $3_1 + $15_1 | 0;
    $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $7_1 = $3_1 << 12 | $8_1 >>> 20;
    $4_1 = $2_1;
    $10_1 = $2_1 << 12 | $3_1 >>> 20;
    $12_1 = HEAP32[$6_1 + 384 >> 2];
    $8_1 = $30_1 & -2;
    $3_1 = $12_1 + $8_1 | 0;
    $13_1 = HEAP32[$6_1 + 388 >> 2];
    $2_1 = $13_1 + ($24_1 & 1048575) | 0;
    $11_1 = $3_1 >>> 0 < $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $11_1 + $10_1 | 0;
    $5_1 = $7_1;
    $7_1 = $3_1;
    $8_1 = $5_1 + $3_1 | 0;
    HEAP32[$6_1 + 864 >> 2] = $8_1;
    $3_1 = $3_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    HEAP32[$6_1 + 868 >> 2] = $3_1 & 1048575;
    $9_1 = $23_1 & 65535;
    $10_1 = ($3_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $3_1 >>> 0 < $11_1 >>> 0;
    $5_1 = ($11_1 | 0) == ($13_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $11_1 >>> 0 < $13_1 >>> 0;
    $2_1 = $16_1 + 8 | 0;
    $8_1 = $5_1 + HEAP32[$2_1 >> 2] | 0;
    $2_1 = HEAP32[$2_1 + 4 >> 2];
    $2_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $4_1 >>> 20 | 0;
    $5_1 = $4_1;
    $4_1 = $4_1 + $8_1 | 0;
    $2_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $4_1;
    $4_1 = $4_1 + $10_1 | 0;
    $2_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $4_1 << 12 | $3_1 >>> 20;
    $5_1 = $3_1 + $14_1 | 0;
    $2_1 = $9_1 + ($2_1 << 12 | $4_1 >>> 20) | 0;
    HEAP32[$6_1 + 872 >> 2] = $5_1;
    HEAP32[$6_1 + 876 >> 2] = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $43_1 + 8 | 0;
    $7_1 = HEAP32[$2_1 >> 2];
    $8_1 = HEAP32[$2_1 + 4 >> 2];
    $2_1 = $44_1 + 8 | 0;
    $32_1 = HEAP32[$2_1 >> 2];
    $4_1 = HEAP32[$2_1 + 4 >> 2];
    $5_1 = HEAP32[$6_1 + 112 >> 2];
    $3_1 = HEAP32[$6_1 + 116 >> 2];
    $13_1 = HEAP32[$6_1 + 32 >> 2];
    $36_1 = HEAP32[$6_1 + 36 >> 2];
    $2_1 = $45_1 + 8 | 0;
    $20_1 = HEAP32[$2_1 >> 2];
    $16_1 = HEAP32[$2_1 + 4 >> 2];
    $2_1 = $46_1 + 8 | 0;
    $33_1 = HEAP32[$2_1 >> 2];
    $24_1 = HEAP32[$2_1 + 4 >> 2];
    $18_1 = HEAP32[$6_1 + 16 >> 2];
    $12_1 = HEAP32[$6_1 + 20 >> 2];
    $34_1 = HEAP32[$6_1 + 80 >> 2];
    $37_1 = HEAP32[$6_1 + 84 >> 2];
    $2_1 = $47_1 + 8 | 0;
    $15_1 = HEAP32[$2_1 >> 2];
    $17_1 = HEAP32[$2_1 + 4 >> 2];
    $2_1 = $6_1 + 8 | 0;
    $35_1 = HEAP32[$2_1 >> 2];
    $30_1 = HEAP32[$2_1 + 4 >> 2];
    $21_1 = HEAP32[$6_1 + 176 >> 2];
    $9_1 = HEAP32[$6_1 + 180 >> 2];
    $29_1 = HEAP32[$6_1 >> 2];
    $25_1 = HEAP32[$6_1 + 4 >> 2];
    $2_1 = $48_1 + 8 | 0;
    $11_1 = HEAP32[$2_1 >> 2];
    $14_1 = HEAP32[$2_1 + 4 >> 2];
    $27_1 = HEAP32[$6_1 + 64 >> 2];
    $10_1 = HEAP32[$6_1 + 68 >> 2];
    $31_1 = HEAP32[$6_1 + 48 >> 2];
    $26_1 = HEAP32[$6_1 + 52 >> 2];
    $2_1 = $49_1 + 8 | 0;
    $38_1 = HEAP32[$2_1 >> 2];
    $23_1 = HEAP32[$2_1 + 4 >> 2];
    $2_1 = $6_1 + 840 | 0;
    $34($2_1, $2_1, $6_1 + 672 | 0);
    $2_1 = $3_1 + $36_1 | 0;
    $3_1 = $5_1 + $13_1 | 0;
    $5_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $22_1 = $3_1;
    $3_1 = ($36_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 < $13_1 >>> 0 | $5_1 >>> 0 < $36_1 >>> 0;
    $2_1 = $4_1 + $8_1 | 0;
    $4_1 = $7_1 + $32_1 | 0;
    $2_1 = $4_1 >>> 0 < $32_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $3_1 = $3_1 + $4_1 | 0;
    $2_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $13_1 = $5_1;
    $7_1 = $3_1 << 12 | $5_1 >>> 20;
    $4_1 = $2_1;
    $8_1 = $2_1 << 12 | $3_1 >>> 20;
    $2_1 = $12_1 + $37_1 | 0;
    $5_1 = $18_1 + $34_1 | 0;
    $3_1 = $5_1 >>> 0 < $18_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $3_1 + $8_1 | 0;
    $18_1 = $5_1 + $7_1 | 0;
    $8_1 = $18_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $7_1 = ($3_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $18_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
    $3_1 = ($3_1 | 0) == ($37_1 | 0) & $5_1 >>> 0 < $34_1 >>> 0 | $3_1 >>> 0 < $37_1 >>> 0;
    $2_1 = $16_1 + $24_1 | 0;
    $5_1 = $20_1 + $33_1 | 0;
    $2_1 = $5_1 >>> 0 < $33_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $20_1 = $5_1;
    $5_1 = $3_1 + $5_1 | 0;
    $2_1 = $20_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $4_1 >>> 20 | 0;
    $3_1 = $4_1 + $5_1 | 0;
    $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $3_1;
    $3_1 = $3_1 + $7_1 | 0;
    $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $12_1 = $8_1;
    $24_1 = $3_1 << 12 | $8_1 >>> 20;
    $5_1 = $2_1;
    $7_1 = $2_1 << 12 | $3_1 >>> 20;
    $2_1 = $9_1 + $25_1 | 0;
    $3_1 = $21_1 + $29_1 | 0;
    $4_1 = $3_1 >>> 0 < $21_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $10_1 + $4_1 | 0;
    $10_1 = $3_1;
    $8_1 = $3_1 + $27_1 | 0;
    $3_1 = $8_1 >>> 0 < $27_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $3_1 + $7_1 | 0;
    $9_1 = $8_1;
    $7_1 = $8_1 + $24_1 | 0;
    $8_1 = $8_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $20_1 = $7_1;
    $24_1 = ($3_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
    $2_1 = $4_1;
    $9_1 = ($2_1 | 0) == ($3_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $2_1 >>> 0 > $3_1 >>> 0;
    $4_1 = $11_1;
    $3_1 = $14_1;
    $7_1 = ($2_1 | 0) == ($25_1 | 0) & $10_1 >>> 0 < $29_1 >>> 0 | $2_1 >>> 0 < $25_1 >>> 0;
    $2_1 = $17_1 + $30_1 | 0;
    $14_1 = $15_1 + $35_1 | 0;
    $2_1 = $14_1 >>> 0 < $35_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $7_1 = $7_1 + $14_1 | 0;
    $2_1 = ($7_1 >>> 0 < $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $3_1 | 0;
    $3_1 = $4_1 + $7_1 | 0;
    $2_1 = $3_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $3_1 + $9_1 | 0;
    $2_1 = $4_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $5_1 >>> 20 | 0;
    $3_1 = $4_1 + $5_1 | 0;
    $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $3_1;
    $3_1 = $3_1 + $24_1 | 0;
    $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $9_1 = $8_1;
    $8_1 = $3_1 << 12 | $8_1 >>> 20;
    $4_1 = $2_1;
    $5_1 = $2_1 << 12 | $3_1 >>> 20;
    $3_1 = $39_1 & -2;
    $16_1 = $3_1 + $31_1 | 0;
    $2_1 = $26_1 + ($40_1 & 1048575) | 0;
    $3_1 = $3_1 >>> 0 > $16_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $2_1 = $3_1 + $5_1 | 0;
    $5_1 = $8_1 + $16_1 | 0;
    $2_1 = $5_1 >>> 0 < $16_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $40_1 = $5_1;
    $8_1 = $2_1;
    $21_1 = HEAP32[$6_1 + 864 >> 2];
    $29_1 = HEAP32[$6_1 + 868 >> 2];
    $27_1 = HEAP32[$6_1 + 856 >> 2];
    $30_1 = HEAP32[$6_1 + 860 >> 2];
    $24_1 = HEAP32[$6_1 + 848 >> 2];
    $10_1 = HEAP32[$6_1 + 852 >> 2];
    $7_1 = HEAP32[$6_1 + 844 >> 2];
    $14_1 = HEAP32[$6_1 + 872 >> 2];
    $5_1 = HEAP32[$6_1 + 876 >> 2];
    $39_1 = $5_1;
    $2_1 = HEAP32[$6_1 + 840 >> 2];
    $5_1 = __wasm_i64_mul($5_1 >>> 16 | 0, 0, 977, 1);
    $11_1 = $2_1 + $5_1 | 0;
    $2_1 = $7_1 + i64toi32_i32$HIGH_BITS | 0;
    $2_1 = $5_1 >>> 0 > $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $5_1 = $11_1 + 7 | 0;
    $2_1 = $5_1 >>> 0 < 7 ? $2_1 + 1 | 0 : $2_1;
    $15_1 = $5_1;
    $7_1 = $2_1;
    $2_1 = $10_1;
    $5_1 = $7_1 >>> 20 | 0;
    $10_1 = $5_1;
    $5_1 = $5_1 + $24_1 | 0;
    $2_1 = $10_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $17_1 = $5_1;
    $10_1 = $2_1;
    $2_1 = $30_1;
    $5_1 = $10_1 >>> 20 | 0;
    $11_1 = $5_1;
    $5_1 = $5_1 + $27_1 | 0;
    $2_1 = $11_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $30_1 = $5_1;
    $11_1 = $2_1;
    $2_1 = $29_1;
    $5_1 = $11_1 >>> 20 | 0;
    $29_1 = $5_1;
    $5_1 = $5_1 + $21_1 | 0;
    $2_1 = $29_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $24_1 = $5_1;
    $5_1 = $2_1;
    $27_1 = $15_1 - $22_1 | 0;
    $22_1 = ($7_1 & 1048575) - (($13_1 & 1048575) + ($15_1 >>> 0 < $22_1 >>> 0) | 0) | 0;
    $39_1 = $39_1 & 65535;
    $15_1 = $28_1 & 65535;
    $13_1 = ($3_1 | 0) == ($8_1 | 0) & $16_1 >>> 0 > $40_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
    $3_1 = ($3_1 | 0) == ($26_1 | 0) & $16_1 >>> 0 < $31_1 >>> 0 | $3_1 >>> 0 < $26_1 >>> 0;
    $7_1 = $3_1 + $38_1 | 0;
    $2_1 = $23_1;
    $2_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $4_1 >>> 20 | 0;
    $3_1 = $4_1 + $7_1 | 0;
    $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $3_1;
    $3_1 = $3_1 + $13_1 | 0;
    $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $3_1 << 12 | $8_1 >>> 20;
    $7_1 = $4_1 + $19_1 | 0;
    $2_1 = $15_1 + ($2_1 << 12 | $3_1 >>> 20) | 0;
    $2_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = $14_1 - $7_1 | 0;
    $2_1 = $39_1 - (($7_1 >>> 0 > $14_1 >>> 0) + $2_1 | 0) | 0;
    $7_1 = $5_1 >>> 20 | 0;
    $3_1 = $4_1 + $7_1 | 0;
    $2_1 = ($7_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + 262143 | 0;
    $3_1 = $3_1 - 4 | 0;
    $14_1 = $3_1 >>> 0 < 4294967292 ? $2_1 + 1 | 0 : $2_1;
    $4_1 = __wasm_i64_mul($14_1 >>> 16 | 0, 0, 977, 1);
    $7_1 = $4_1 + $27_1 | 0;
    $2_1 = $22_1 + i64toi32_i32$HIGH_BITS | 0;
    $2_1 = ($4_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + 4194299 | 0;
    $4_1 = $7_1 - 3908 | 0;
    $2_1 = $4_1 >>> 0 < 4294963388 ? $2_1 + 1 | 0 : $2_1;
    $28_1 = $4_1 ^ 976;
    $7_1 = $2_1 & 1048575;
    $16_1 = $7_1 ^ 1;
    if ((($28_1 | 0) != -1 | ($16_1 | 0) != 1048575) & ($4_1 | $7_1) != 0) {
     $3_1 = 0
    } else {
     $15_1 = $24_1 - $40_1 | 0;
     $23_1 = ($5_1 & 1048575) - (($8_1 & 1048575) + ($24_1 >>> 0 < $40_1 >>> 0) | 0) | 0;
     $13_1 = $30_1 - $20_1 | 0;
     $19_1 = ($11_1 & 1048575) - (($9_1 & 1048575) + ($20_1 >>> 0 > $30_1 >>> 0) | 0) | 0;
     $4_1 = $2_1;
     $2_1 = ($10_1 & 1048575) - (($12_1 & 1048575) + ($17_1 >>> 0 < $18_1 >>> 0) | 0) | 0;
     $4_1 = $4_1 >>> 20 | 0;
     $5_1 = $4_1;
     $4_1 = $4_1 + ($17_1 - $18_1 | 0) | 0;
     $2_1 = ($5_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + 4194303 | 0;
     $7_1 = $4_1 - 4 | 0;
     $8_1 = $7_1 >>> 0 < 4294967292 ? $2_1 + 1 | 0 : $2_1;
     $2_1 = $19_1;
     $4_1 = $8_1 >>> 20 | 0;
     $5_1 = $4_1;
     $4_1 = $4_1 + $13_1 | 0;
     $2_1 = ($5_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + 4194303 | 0;
     $5_1 = $4_1 - 4 | 0;
     $4_1 = $5_1 >>> 0 < 4294967292 ? $2_1 + 1 | 0 : $2_1;
     $2_1 = $23_1;
     $19_1 = $4_1 >>> 20 | 0;
     $9_1 = $19_1;
     $19_1 = $15_1 + $19_1 | 0;
     $2_1 = ($9_1 >>> 0 > $19_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + 4194303 | 0;
     $19_1 = $19_1 - 4 | 0;
     $2_1 = $19_1 >>> 0 < 4294967292 ? $2_1 + 1 | 0 : $2_1;
     $7_1 = $19_1 & ($7_1 & $28_1 & $5_1);
     $8_1 = $2_1 & ($8_1 & $16_1 & $4_1);
     $4_1 = $3_1;
     $3_1 = $2_1;
     $2_1 = $14_1 & 65535;
     $3_1 = $3_1 >>> 20 | 0;
     $5_1 = $3_1;
     $3_1 = $3_1 + $4_1 | 0;
     $2_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
     $3_1 = ($3_1 & $7_1) == -1 & ($8_1 & ($2_1 ^ 983040)) == 1048575;
    }
   }
   if (!$3_1) {
    break label$1
   }
   $35($1_1, $6_1 + 672 | 0);
   $0_1 = 1;
  }
  global$0 = $6_1 + 880 | 0;
  return $0_1;
 }
 
 function $32($0_1, $1_1) {
  var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0;
  $4_1 = $0_1;
  $2_1 = HEAPU8[$1_1 + 30 | 0];
  $0_1 = $2_1 >>> 24 | 0;
  $3_1 = HEAPU8[$1_1 + 31 | 0] | $2_1 << 8;
  $2_1 = $0_1;
  $5_1 = HEAPU8[$1_1 + 29 | 0];
  $0_1 = $5_1 >>> 16 | 0;
  $5_1 = $5_1 << 16 | $3_1;
  $3_1 = $0_1 | $2_1;
  $2_1 = HEAPU8[$1_1 + 28 | 0];
  $0_1 = $2_1 >>> 8 | 0;
  $2_1 = $2_1 << 24 | $5_1;
  $0_1 = HEAPU8[$1_1 + 27 | 0] | ($0_1 | $3_1) | HEAPU8[$1_1 + 26 | 0] << 8 | (HEAPU8[$1_1 + 25 | 0] & 15) << 16;
  $5_1 = $0_1;
  $13_1 = $2_1;
  HEAP32[$4_1 >> 2] = $2_1;
  HEAP32[$4_1 + 4 >> 2] = $0_1;
  $2_1 = HEAPU8[$1_1 + 24 | 0];
  $0_1 = $2_1 >>> 28 | 0;
  $6_1 = $2_1 << 4 | HEAPU8[$1_1 + 25 | 0] >>> 4;
  $2_1 = $0_1;
  $3_1 = HEAPU8[$1_1 + 23 | 0];
  $0_1 = $3_1 >>> 20 | 0;
  $3_1 = $3_1 << 12 | $6_1;
  $6_1 = $0_1 | $2_1;
  $2_1 = HEAPU8[$1_1 + 22 | 0];
  $0_1 = $2_1 >>> 12 | 0;
  $3_1 = $2_1 << 20 | $3_1;
  $6_1 = $0_1 | $6_1;
  $2_1 = HEAPU8[$1_1 + 21 | 0];
  $0_1 = $2_1 >>> 4 | 0;
  $2_1 = $2_1 << 28 | $3_1;
  $3_1 = $0_1 | $6_1 | HEAPU8[$1_1 + 20 | 0] << 4;
  $0_1 = HEAPU8[$1_1 + 19 | 0] << 12;
  $6_1 = $2_1;
  HEAP32[$4_1 + 8 >> 2] = $2_1;
  $10_1 = $0_1 | $3_1;
  HEAP32[$4_1 + 12 >> 2] = $10_1;
  $2_1 = HEAPU8[$1_1 + 17 | 0];
  $0_1 = $2_1 >>> 24 | 0;
  $8_1 = HEAPU8[$1_1 + 18 | 0] | $2_1 << 8;
  $2_1 = $0_1;
  $3_1 = HEAPU8[$1_1 + 16 | 0];
  $0_1 = $3_1 >>> 16 | 0;
  $3_1 = $3_1 << 16 | $8_1;
  $8_1 = $0_1 | $2_1;
  $2_1 = HEAPU8[$1_1 + 15 | 0];
  $0_1 = $2_1 >>> 8 | 0;
  $2_1 = $2_1 << 24 | $3_1;
  $3_1 = HEAPU8[$1_1 + 14 | 0] | ($0_1 | $8_1) | HEAPU8[$1_1 + 13 | 0] << 8;
  $0_1 = (HEAPU8[$1_1 + 12 | 0] & 15) << 16;
  $8_1 = $2_1;
  HEAP32[$4_1 + 16 >> 2] = $2_1;
  $11_1 = $0_1 | $3_1;
  HEAP32[$4_1 + 20 >> 2] = $11_1;
  $2_1 = HEAPU8[$1_1 + 11 | 0];
  $0_1 = $2_1 >>> 28 | 0;
  $7_1 = $2_1 << 4 | HEAPU8[$1_1 + 12 | 0] >>> 4;
  $2_1 = $0_1;
  $3_1 = HEAPU8[$1_1 + 10 | 0];
  $0_1 = $3_1 >>> 20 | 0;
  $3_1 = $3_1 << 12 | $7_1;
  $7_1 = $0_1 | $2_1;
  $2_1 = HEAPU8[$1_1 + 9 | 0];
  $0_1 = $2_1 >>> 12 | 0;
  $3_1 = $2_1 << 20 | $3_1;
  $7_1 = $0_1 | $7_1;
  $2_1 = HEAPU8[$1_1 + 8 | 0];
  $0_1 = $2_1 >>> 4 | 0;
  $2_1 = $2_1 << 28 | $3_1;
  $3_1 = $0_1 | $7_1 | HEAPU8[$1_1 + 7 | 0] << 4;
  $0_1 = HEAPU8[$1_1 + 6 | 0] << 12;
  $7_1 = $2_1;
  HEAP32[$4_1 + 24 >> 2] = $2_1;
  $12_1 = $0_1 | $3_1;
  HEAP32[$4_1 + 28 >> 2] = $12_1;
  $2_1 = HEAPU8[$1_1 + 4 | 0];
  $0_1 = $2_1 >>> 24 | 0;
  $9_1 = HEAPU8[$1_1 + 5 | 0] | $2_1 << 8;
  $2_1 = $0_1;
  $3_1 = HEAPU8[$1_1 + 3 | 0];
  $0_1 = $3_1 >>> 16 | 0;
  $3_1 = $3_1 << 16 | $9_1;
  $9_1 = $0_1 | $2_1;
  $2_1 = HEAPU8[$1_1 + 2 | 0];
  $0_1 = $2_1 >>> 8 | 0;
  $2_1 = $2_1 << 24 | $3_1;
  $3_1 = HEAPU8[$1_1 + 1 | 0] | ($0_1 | $9_1);
  $0_1 = HEAPU8[$1_1 | 0] << 8;
  HEAP32[$4_1 + 32 >> 2] = $2_1;
  $0_1 = $0_1 | $3_1;
  HEAP32[$4_1 + 36 >> 2] = $0_1;
  return ($6_1 & $8_1 & $7_1) != -1 | ($10_1 & $11_1 & $12_1) != 1048575 | (($2_1 | 0) != -1 | ($0_1 | 0) != 65535) | (($5_1 | 0) == 1048574 & $13_1 >>> 0 < 4294966319 | $5_1 >>> 0 < 1048574);
 }
 
 function $33($0_1, $1_1, $2_1) {
  var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0;
  $6_1 = global$0 - 7616 | 0;
  global$0 = $6_1;
  $5_1 = $1_1 + 32 | 0;
  $4_1 = HEAP32[$5_1 + 4 >> 2];
  $3_1 = $0_1 + 32 | 0;
  HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
  HEAP32[$3_1 + 4 >> 2] = $4_1;
  $5_1 = $1_1 + 24 | 0;
  $4_1 = HEAP32[$5_1 + 4 >> 2];
  $3_1 = $0_1 + 24 | 0;
  HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
  HEAP32[$3_1 + 4 >> 2] = $4_1;
  $5_1 = $1_1 + 16 | 0;
  $4_1 = HEAP32[$5_1 + 4 >> 2];
  $3_1 = $0_1 + 16 | 0;
  HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
  HEAP32[$3_1 + 4 >> 2] = $4_1;
  $5_1 = $1_1 + 8 | 0;
  $4_1 = HEAP32[$5_1 + 4 >> 2];
  $3_1 = $0_1 + 8 | 0;
  HEAP32[$3_1 >> 2] = HEAP32[$5_1 >> 2];
  HEAP32[$3_1 + 4 >> 2] = $4_1;
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
  HEAP32[$0_1 + 4 >> 2] = $3_1;
  $3_1 = $6_1 + 7096 | 0;
  $54($3_1, $1_1);
  $41_1 = $6_1 + 7056 | 0;
  $34($41_1, $1_1, $3_1);
  HEAP32[$0_1 + 80 >> 2] = 0;
  $3_1 = HEAP32[$6_1 + 7060 >> 2];
  $4_1 = HEAP32[$6_1 + 7056 >> 2] + 7 | 0;
  $1_1 = $4_1 >>> 0 < 7 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1;
  HEAP32[$6_1 + 7056 >> 2] = $3_1;
  HEAP32[$6_1 + 7060 >> 2] = $1_1;
  $13_1 = $6_1 + 6848 | 0;
  $21_1 = HEAP32[$6_1 + 7080 >> 2];
  $17_1 = HEAP32[$6_1 + 7084 >> 2];
  $28_1 = $3_1 << 1;
  $7_1 = $3_1;
  $22_1 = $1_1 << 1 | $3_1 >>> 31;
  $69($13_1, $21_1, $17_1, 0, 0, $28_1, $22_1, 0, 0);
  $3_1 = HEAP32[$6_1 + 7068 >> 2];
  $40_1 = $3_1;
  $33_1 = HEAP32[$6_1 + 7064 >> 2];
  $5_1 = $33_1;
  $3_1 = $3_1 << 1 | $5_1 >>> 31;
  $12_1 = $6_1 + 6880 | 0;
  $24_1 = HEAP32[$6_1 + 7072 >> 2];
  $18_1 = HEAP32[$6_1 + 7076 >> 2];
  $5_1 = $5_1 << 1;
  $8_1 = $3_1;
  $69($12_1, $24_1, $18_1, 0, 0, $5_1, $3_1, 0, 0);
  $9_1 = $6_1 + 7008 | 0;
  $4_1 = HEAP32[$6_1 + 7088 >> 2];
  $3_1 = HEAP32[$6_1 + 7092 >> 2];
  $69($9_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
  $10_1 = $6_1 + 6992 | 0;
  $69($10_1, HEAP32[$6_1 + 7008 >> 2], HEAP32[$6_1 + 7012 >> 2], 0, 0, 15632, 16, 0, 0);
  $3_1 = $3_1 << 1 | $4_1 >>> 31;
  $31_1 = $6_1 + 6800 | 0;
  $23_1 = $4_1 << 1;
  $20_1 = $3_1;
  $69($31_1, $23_1, $3_1, 0, 0, $7_1, $1_1, 0, 0);
  $37_1 = $6_1 + 6864 | 0;
  $69($37_1, $21_1, $17_1, 0, 0, $5_1, $8_1, 0, 0);
  $30_1 = $6_1 + 6944 | 0;
  $69($30_1, $24_1, $18_1, 0, 0, $24_1, $18_1, 0, 0);
  $14_1 = $6_1 + 6976 | 0;
  $3_1 = $9_1 + 8 | 0;
  $69($14_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $39_1 = $6_1 + 6720 | 0;
  $69($39_1, $7_1, $1_1, 0, 0, $7_1, $1_1, 0, 0);
  $38_1 = $6_1 + 6912 | 0;
  $69($38_1, $23_1, $20_1, 0, 0, $33_1, $40_1, 0, 0);
  $35_1 = $6_1 + 6960 | 0;
  $69($35_1, $21_1, $17_1, 0, 0, $24_1 << 1, $18_1 << 1 | $24_1 >>> 31, 0, 0);
  $16_1 = HEAP32[$6_1 + 6852 >> 2];
  $3_1 = $16_1 + HEAP32[$6_1 + 6884 >> 2] | 0;
  $8_1 = HEAP32[$6_1 + 6848 >> 2];
  $4_1 = HEAP32[$6_1 + 6880 >> 2];
  $1_1 = $8_1 + $4_1 | 0;
  $5_1 = HEAP32[$6_1 + 6992 >> 2];
  $15_1 = $1_1 + $5_1 | 0;
  $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1 + HEAP32[$6_1 + 6996 >> 2] | 0;
  $5_1 = $5_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $15_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
  $3_1 = $10_1 + 8 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $7_1 = HEAP32[$3_1 + 4 >> 2];
  $8_1 = ($4_1 | 0) == ($16_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
  $3_1 = $12_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $13_1 + 8 | 0;
  $10_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $10_1 | 0;
  $3_1 = ($1_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $11_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $16_1 = $5_1;
  $11_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $32_1 = HEAP32[$6_1 + 6864 >> 2];
  $1_1 = HEAP32[$6_1 + 6944 >> 2];
  $9_1 = $32_1 + $1_1 | 0;
  $34_1 = HEAP32[$6_1 + 6868 >> 2];
  $3_1 = $34_1 + HEAP32[$6_1 + 6948 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 6800 >> 2];
  $7_1 = $1_1 + $9_1 | 0;
  $12_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 6804 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 6976 >> 2];
  $5_1 = $1_1 + $7_1 | 0;
  $10_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 6980 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $36_1 = $6_1 + 6736 | 0;
  $29_1 = $36_1;
  $11_1 = $5_1 + $11_1 | 0;
  $8_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $27_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
  $25_1 = ($1_1 | 0) == ($10_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $10_1 >>> 0;
  $1_1 = $14_1 + 8 | 0;
  $19_1 = HEAP32[$1_1 >> 2];
  $26_1 = HEAP32[$1_1 + 4 >> 2];
  $13_1 = ($10_1 | 0) == ($12_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $10_1 >>> 0 < $12_1 >>> 0;
  $1_1 = $31_1 + 8 | 0;
  $14_1 = HEAP32[$1_1 >> 2];
  $10_1 = HEAP32[$1_1 + 4 >> 2];
  $7_1 = ($12_1 | 0) == ($34_1 | 0) & $9_1 >>> 0 < $32_1 >>> 0 | $12_1 >>> 0 < $34_1 >>> 0;
  $3_1 = $30_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $37_1 + 8 | 0;
  $9_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $7_1 + $9_1 | 0;
  $3_1 = ($1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $14_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $13_1 | 0;
  $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $19_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1 + $25_1 | 0;
  $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $27_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $8_1;
  $7_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $14_1 = HEAP32[$6_1 + 6912 >> 2];
  $1_1 = HEAP32[$6_1 + 6960 >> 2];
  $10_1 = $14_1 + $1_1 | 0;
  $19_1 = HEAP32[$6_1 + 6916 >> 2];
  $3_1 = $19_1 + HEAP32[$6_1 + 6964 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $7_1 = $7_1 + $10_1 | 0;
  $3_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $7_1 << 4 & -16;
  $8_1 = $3_1;
  $9_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
  $13_1 = $4_1;
  $69($29_1, $12_1 | $4_1 >>> 16 & 15, $9_1, 0, 0, 977, 1, 0, 0);
  $27_1 = HEAP32[$6_1 + 6740 >> 2];
  $3_1 = $27_1 + HEAP32[$6_1 + 6724 >> 2] | 0;
  $25_1 = HEAP32[$6_1 + 6736 >> 2];
  $4_1 = HEAP32[$6_1 + 6720 >> 2];
  $9_1 = $25_1 + $4_1 | 0;
  HEAP32[$6_1 + 7576 >> 2] = $9_1;
  $4_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$6_1 + 7580 >> 2] = $4_1 & 1048575;
  $31_1 = $6_1 + 6832 | 0;
  $69($31_1, $33_1, $40_1, 0, 0, $28_1, $22_1, 0, 0);
  $37_1 = $6_1 + 6928 | 0;
  $69($37_1, $23_1, $20_1, 0, 0, $24_1, $18_1, 0, 0);
  $30_1 = $6_1 + 7040 | 0;
  $69($30_1, $21_1, $17_1, 0, 0, $21_1, $17_1, 0, 0);
  $32_1 = $6_1 + 6784 | 0;
  $26_1 = $32_1;
  $12_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
  $10_1 = ($1_1 | 0) == ($19_1 | 0) & $10_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 < $19_1 >>> 0;
  $3_1 = $35_1 + 8 | 0;
  $7_1 = HEAP32[$3_1 >> 2];
  $1_1 = $38_1 + 8 | 0;
  $14_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $7_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $10_1 + $14_1 | 0;
  $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $5_1 + $7_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $12_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $1_1 << 12 | $8_1 >>> 20;
  $7_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $35_1 = HEAP32[$6_1 + 6932 >> 2];
  $3_1 = $35_1 + HEAP32[$6_1 + 7044 >> 2] | 0;
  $29_1 = HEAP32[$6_1 + 6928 >> 2];
  $5_1 = HEAP32[$6_1 + 7040 >> 2];
  $1_1 = $29_1 + $5_1 | 0;
  $19_1 = $1_1;
  $14_1 = $1_1 + $10_1 | 0;
  $5_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $5_1 + $8_1 | 0;
  $10_1 = $14_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($26_1, $14_1, $10_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $9_1 = ($4_1 | 0) == ($27_1 | 0) & $9_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $27_1 >>> 0;
  $3_1 = $39_1 + 8 | 0;
  $8_1 = HEAP32[$3_1 >> 2];
  $1_1 = $36_1 + 8 | 0;
  $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $9_1 + $12_1 | 0;
  $3_1 = $1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $1_1 << 12 | $4_1 >>> 20;
  $8_1 = $3_1;
  $9_1 = $3_1 << 12 | $1_1 >>> 20;
  $27_1 = HEAP32[$6_1 + 6784 >> 2];
  $1_1 = HEAP32[$6_1 + 6832 >> 2];
  $26_1 = $27_1 + $1_1 | 0;
  $36_1 = HEAP32[$6_1 + 6788 >> 2];
  $3_1 = $36_1 + HEAP32[$6_1 + 6836 >> 2] | 0;
  $4_1 = $1_1 >>> 0 > $26_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1 + $9_1 | 0;
  $12_1 = $12_1 + $26_1 | 0;
  $3_1 = $12_1 >>> 0 < $26_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$6_1 + 7584 >> 2] = $12_1;
  $9_1 = $3_1;
  HEAP32[$6_1 + 7588 >> 2] = $3_1 & 1048575;
  $25_1 = $6_1 + 6816 | 0;
  $69($25_1, $24_1, $18_1, 0, 0, $28_1, $22_1, 0, 0);
  $22_1 = $6_1 + 6896 | 0;
  $69($22_1, $33_1, $40_1, 0, 0, $33_1, $40_1, 0, 0);
  $28_1 = $6_1 + 7024 | 0;
  $69($28_1, $23_1, $20_1, 0, 0, $21_1, $17_1, 0, 0);
  $24_1 = $6_1 + 6768 | 0;
  $21_1 = $24_1;
  $18_1 = ($5_1 | 0) == ($10_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $5_1 >>> 0 > $10_1 >>> 0;
  $14_1 = ($5_1 | 0) == ($35_1 | 0) & $19_1 >>> 0 < $29_1 >>> 0 | $5_1 >>> 0 < $35_1 >>> 0;
  $3_1 = $30_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $37_1 + 8 | 0;
  $17_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $14_1 + $17_1 | 0;
  $3_1 = $5_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $7_1 >>> 20 | 0;
  $1_1 = $5_1 + $7_1 | 0;
  $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $18_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $17_1 = $1_1 << 12 | $10_1 >>> 20;
  $7_1 = HEAP32[$6_1 + 7024 >> 2];
  $10_1 = $17_1 + $7_1 | 0;
  $5_1 = $3_1;
  $19_1 = $3_1 << 12 | $1_1 >>> 20;
  $3_1 = $19_1 + HEAP32[$6_1 + 7028 >> 2] | 0;
  $14_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($21_1, $10_1, $14_1, 0, 0, 15632, 16, 0, 0);
  $12_1 = ($4_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $26_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
  $7_1 = ($4_1 | 0) == ($36_1 | 0) & $26_1 >>> 0 < $27_1 >>> 0 | $4_1 >>> 0 < $36_1 >>> 0;
  $3_1 = $31_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $32_1 + 8 | 0;
  $18_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $7_1 + $18_1 | 0;
  $3_1 = $4_1 >>> 0 < $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $8_1 >>> 20 | 0;
  $1_1 = $4_1 + $8_1 | 0;
  $3_1 = $8_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $12_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 << 12 | $9_1 >>> 20;
  $4_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $26_1 = HEAP32[$6_1 + 6816 >> 2];
  $1_1 = HEAP32[$6_1 + 6896 >> 2];
  $12_1 = $26_1 + $1_1 | 0;
  $20_1 = HEAP32[$6_1 + 6820 >> 2];
  $3_1 = $20_1 + HEAP32[$6_1 + 6900 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 6768 >> 2];
  $9_1 = $1_1 + $12_1 | 0;
  $18_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 6772 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $7_1 = $7_1 + $9_1 | 0;
  $3_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$6_1 + 7592 >> 2] = $7_1;
  $8_1 = $3_1;
  HEAP32[$6_1 + 7596 >> 2] = $3_1 & 1048575;
  $21_1 = $6_1 + 6752 | 0;
  $17_1 = ($14_1 | 0) == ($19_1 | 0) & $10_1 >>> 0 < $17_1 >>> 0 | $14_1 >>> 0 < $19_1 >>> 0;
  $3_1 = $28_1 + 8 | 0;
  $14_1 = HEAP32[$3_1 >> 2];
  $3_1 = HEAP32[$3_1 + 4 >> 2];
  $5_1 = $5_1 >>> 20 | 0;
  $10_1 = $5_1;
  $5_1 = $5_1 + $14_1 | 0;
  $3_1 = $10_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $5_1;
  $5_1 = $5_1 + $17_1 | 0;
  $3_1 = $10_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($21_1, $5_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
  $17_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
  $14_1 = ($1_1 | 0) == ($18_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $18_1 >>> 0;
  $1_1 = $24_1 + 8 | 0;
  $10_1 = HEAP32[$1_1 >> 2];
  $9_1 = HEAP32[$1_1 + 4 >> 2];
  $7_1 = ($18_1 | 0) == ($20_1 | 0) & $12_1 >>> 0 < $26_1 >>> 0 | $18_1 >>> 0 < $20_1 >>> 0;
  $3_1 = $22_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $25_1 + 8 | 0;
  $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $7_1 + $12_1 | 0;
  $3_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $9_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $10_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1 + $14_1 | 0;
  $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $17_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = $1_1 << 12 | $8_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $12_1 = HEAP32[$6_1 + 6752 >> 2];
  $1_1 = $15_1 & -2;
  $8_1 = $12_1 + $1_1 | 0;
  $14_1 = HEAP32[$6_1 + 6756 >> 2];
  $3_1 = $14_1 + ($16_1 & 1048575) | 0;
  $7_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $7_1 + $5_1 | 0;
  $5_1 = $8_1 + $9_1 | 0;
  $3_1 = $5_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$6_1 + 7600 >> 2] = $5_1;
  $1_1 = $3_1;
  HEAP32[$6_1 + 7604 >> 2] = $3_1 & 1048575;
  $10_1 = $13_1 & 65535;
  $9_1 = ($3_1 | 0) == ($7_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $3_1 >>> 0 < $7_1 >>> 0;
  $5_1 = ($7_1 | 0) == ($14_1 | 0) & $8_1 >>> 0 < $12_1 >>> 0 | $7_1 >>> 0 < $14_1 >>> 0;
  $3_1 = $21_1 + 8 | 0;
  $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
  $3_1 = HEAP32[$3_1 + 4 >> 2];
  $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $5_1 = $4_1;
  $4_1 = $4_1 + $8_1 | 0;
  $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $4_1;
  $4_1 = $4_1 + $9_1 | 0;
  $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $4_1 << 12 | $1_1 >>> 20;
  $5_1 = $1_1 + $11_1 | 0;
  $3_1 = $10_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
  HEAP32[$6_1 + 7608 >> 2] = $5_1;
  HEAP32[$6_1 + 7612 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $40_1 = $6_1 + 7576 | 0;
  $34($40_1, $40_1, $41_1);
  $1_1 = HEAP32[$6_1 + 7580 >> 2];
  $16_1 = $1_1;
  $13_1 = HEAP32[$6_1 + 7576 >> 2];
  $7_1 = $13_1;
  $3_1 = $1_1 << 1 | $7_1 >>> 31;
  $12_1 = $6_1 + 6448 | 0;
  $24_1 = HEAP32[$6_1 + 7600 >> 2];
  $26_1 = HEAP32[$6_1 + 7604 >> 2];
  $19_1 = $7_1 << 1;
  $23_1 = $3_1;
  $69($12_1, $24_1, $26_1, 0, 0, $19_1, $3_1, 0, 0);
  $1_1 = HEAP32[$6_1 + 7588 >> 2];
  $44_1 = $1_1;
  $43_1 = HEAP32[$6_1 + 7584 >> 2];
  $4_1 = $43_1;
  $3_1 = $1_1 << 1 | $4_1 >>> 31;
  $10_1 = $6_1 + 6656 | 0;
  $28_1 = HEAP32[$6_1 + 7592 >> 2];
  $21_1 = HEAP32[$6_1 + 7596 >> 2];
  $4_1 = $4_1 << 1;
  $5_1 = $3_1;
  $69($10_1, $28_1, $21_1, 0, 0, $4_1, $3_1, 0, 0);
  $9_1 = $6_1 + 6608 | 0;
  $8_1 = HEAP32[$6_1 + 7608 >> 2];
  $1_1 = HEAP32[$6_1 + 7612 >> 2];
  $69($9_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
  $11_1 = $6_1 + 6592 | 0;
  $69($11_1, HEAP32[$6_1 + 6608 >> 2], HEAP32[$6_1 + 6612 >> 2], 0, 0, 15632, 16, 0, 0);
  $3_1 = $1_1 << 1 | $8_1 >>> 31;
  $36_1 = $6_1 + 6560 | 0;
  $27_1 = $8_1 << 1;
  $22_1 = $3_1;
  $69($36_1, $27_1, $3_1, 0, 0, $7_1, $16_1, 0, 0);
  $31_1 = $6_1 + 6464 | 0;
  $69($31_1, $24_1, $26_1, 0, 0, $4_1, $5_1, 0, 0);
  $37_1 = $6_1 + 6640 | 0;
  $69($37_1, $28_1, $21_1, 0, 0, $28_1, $21_1, 0, 0);
  $14_1 = $6_1 + 6576 | 0;
  $1_1 = $9_1 + 8 | 0;
  $69($14_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $39_1 = $6_1 + 6704 | 0;
  $69($39_1, $7_1, $16_1, 0, 0, $7_1, $16_1, 0, 0);
  $38_1 = $6_1 + 6544 | 0;
  $69($38_1, $27_1, $3_1, 0, 0, $43_1, $44_1, 0, 0);
  $30_1 = $6_1 + 6480 | 0;
  $69($30_1, $24_1, $26_1, 0, 0, $28_1 << 1, $21_1 << 1 | $28_1 >>> 31, 0, 0);
  $13_1 = HEAP32[$6_1 + 6452 >> 2];
  $3_1 = $13_1 + HEAP32[$6_1 + 6660 >> 2] | 0;
  $8_1 = HEAP32[$6_1 + 6448 >> 2];
  $4_1 = HEAP32[$6_1 + 6656 >> 2];
  $1_1 = $8_1 + $4_1 | 0;
  $5_1 = HEAP32[$6_1 + 6592 >> 2];
  $17_1 = $1_1 + $5_1 | 0;
  $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1 + HEAP32[$6_1 + 6596 >> 2] | 0;
  $5_1 = $5_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $17_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
  $3_1 = $11_1 + 8 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $7_1 = HEAP32[$3_1 + 4 >> 2];
  $8_1 = ($4_1 | 0) == ($13_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $13_1 >>> 0;
  $3_1 = $10_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $12_1 + 8 | 0;
  $10_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $10_1 | 0;
  $3_1 = ($1_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $11_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $18_1 = $5_1;
  $11_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $32_1 = HEAP32[$6_1 + 6464 >> 2];
  $1_1 = HEAP32[$6_1 + 6640 >> 2];
  $9_1 = $32_1 + $1_1 | 0;
  $35_1 = HEAP32[$6_1 + 6468 >> 2];
  $3_1 = $35_1 + HEAP32[$6_1 + 6644 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 6560 >> 2];
  $7_1 = $1_1 + $9_1 | 0;
  $12_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 6564 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 6576 >> 2];
  $5_1 = $1_1 + $7_1 | 0;
  $10_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 6580 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $29_1 = $6_1 + 6384 | 0;
  $11_1 = $5_1 + $11_1 | 0;
  $8_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $25_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
  $20_1 = ($1_1 | 0) == ($10_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $10_1 >>> 0;
  $1_1 = $14_1 + 8 | 0;
  $15_1 = HEAP32[$1_1 >> 2];
  $16_1 = HEAP32[$1_1 + 4 >> 2];
  $13_1 = ($10_1 | 0) == ($12_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $10_1 >>> 0 < $12_1 >>> 0;
  $1_1 = $36_1 + 8 | 0;
  $14_1 = HEAP32[$1_1 >> 2];
  $10_1 = HEAP32[$1_1 + 4 >> 2];
  $7_1 = ($12_1 | 0) == ($35_1 | 0) & $9_1 >>> 0 < $32_1 >>> 0 | $12_1 >>> 0 < $35_1 >>> 0;
  $3_1 = $37_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $31_1 + 8 | 0;
  $9_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $7_1 + $9_1 | 0;
  $3_1 = ($1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $14_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $13_1 | 0;
  $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $15_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1 + $20_1 | 0;
  $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $25_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $8_1;
  $7_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $14_1 = HEAP32[$6_1 + 6544 >> 2];
  $1_1 = HEAP32[$6_1 + 6480 >> 2];
  $9_1 = $14_1 + $1_1 | 0;
  $13_1 = HEAP32[$6_1 + 6548 >> 2];
  $3_1 = $13_1 + HEAP32[$6_1 + 6484 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $7_1 = $7_1 + $9_1 | 0;
  $3_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $7_1 << 4 & -16;
  $8_1 = $3_1;
  $10_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
  $15_1 = $4_1;
  $69($29_1, $12_1 | $4_1 >>> 16 & 15, $10_1, 0, 0, 977, 1, 0, 0);
  $35_1 = $6_1 + 6688 | 0;
  $69($35_1, $43_1, $44_1, 0, 0, $19_1, $23_1, 0, 0);
  $36_1 = $6_1 + 6528 | 0;
  $69($36_1, $27_1, $22_1, 0, 0, $28_1, $21_1, 0, 0);
  $31_1 = $6_1 + 6496 | 0;
  $69($31_1, $24_1, $26_1, 0, 0, $24_1, $26_1, 0, 0);
  $37_1 = $6_1 + 6432 | 0;
  $12_1 = $37_1;
  $10_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $7_1 = ($1_1 | 0) == ($13_1 | 0) & $9_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 < $13_1 >>> 0;
  $3_1 = $30_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $38_1 + 8 | 0;
  $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $7_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $10_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $8_1 >>> 20;
  $7_1 = $3_1;
  $4_1 = $3_1 << 12 | $1_1 >>> 20;
  $30_1 = HEAP32[$6_1 + 6528 >> 2];
  $1_1 = HEAP32[$6_1 + 6496 >> 2];
  $20_1 = $30_1 + $1_1 | 0;
  $33_1 = HEAP32[$6_1 + 6532 >> 2];
  $3_1 = $33_1 + HEAP32[$6_1 + 6500 >> 2] | 0;
  $5_1 = $1_1 >>> 0 > $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $5_1 + $4_1 | 0;
  $16_1 = $8_1 + $20_1 | 0;
  $3_1 = $16_1 >>> 0 < $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $3_1;
  $69($12_1, $16_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $8_1 = HEAP32[$6_1 + 6384 >> 2];
  $1_1 = HEAP32[$6_1 + 6704 >> 2];
  $13_1 = $8_1 + $1_1 | 0;
  $9_1 = HEAP32[$6_1 + 6388 >> 2];
  $3_1 = $9_1 + HEAP32[$6_1 + 6708 >> 2] | 0;
  $42_1 = $6_1 + 7536 | 0;
  $34_1 = $42_1 + 8 | 0;
  $4_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = ($9_1 | 0) == ($4_1 | 0) & $8_1 >>> 0 > $13_1 >>> 0 | $4_1 >>> 0 < $9_1 >>> 0;
  $3_1 = $39_1 + 8 | 0;
  $8_1 = HEAP32[$3_1 >> 2];
  $1_1 = $29_1 + 8 | 0;
  $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $9_1 + $12_1 | 0;
  $3_1 = $1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = $4_1;
  $12_1 = $1_1 << 12 | $4_1 >>> 20;
  $8_1 = $3_1;
  $9_1 = $3_1 << 12 | $1_1 >>> 20;
  $38_1 = HEAP32[$6_1 + 6436 >> 2];
  $3_1 = $38_1 + HEAP32[$6_1 + 6692 >> 2] | 0;
  $32_1 = HEAP32[$6_1 + 6432 >> 2];
  $4_1 = HEAP32[$6_1 + 6688 >> 2];
  $1_1 = $32_1 + $4_1 | 0;
  $25_1 = $1_1;
  $12_1 = $1_1 + $12_1 | 0;
  $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1 + $9_1 | 0;
  HEAP32[$34_1 >> 2] = $12_1;
  $9_1 = $12_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$34_1 + 4 >> 2] = $9_1 & 1048575;
  $29_1 = $6_1 + 6624 | 0;
  $69($29_1, $28_1, $21_1, 0, 0, $19_1, $23_1, 0, 0);
  $23_1 = $6_1 + 6672 | 0;
  $69($23_1, $43_1, $44_1, 0, 0, $43_1, $44_1, 0, 0);
  $19_1 = $6_1 + 6512 | 0;
  $69($19_1, $27_1, $22_1, 0, 0, $24_1, $26_1, 0, 0);
  $22_1 = $6_1 + 6416 | 0;
  $21_1 = ($5_1 | 0) == ($10_1 | 0) & $16_1 >>> 0 < $20_1 >>> 0 | $5_1 >>> 0 > $10_1 >>> 0;
  $16_1 = ($5_1 | 0) == ($33_1 | 0) & $20_1 >>> 0 < $30_1 >>> 0 | $5_1 >>> 0 < $33_1 >>> 0;
  $3_1 = $31_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $36_1 + 8 | 0;
  $24_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $16_1 + $24_1 | 0;
  $3_1 = $5_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $7_1 >>> 20 | 0;
  $1_1 = $5_1 + $7_1 | 0;
  $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $21_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $28_1 = $1_1 << 12 | $10_1 >>> 20;
  $7_1 = HEAP32[$6_1 + 6512 >> 2];
  $10_1 = $28_1 + $7_1 | 0;
  $5_1 = $3_1;
  $30_1 = $3_1 << 12 | $1_1 >>> 20;
  $3_1 = $30_1 + HEAP32[$6_1 + 6516 >> 2] | 0;
  $16_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($22_1, $10_1, $16_1, 0, 0, 15632, 16, 0, 0);
  $27_1 = $42_1 + 16 | 0;
  $24_1 = $27_1;
  $12_1 = ($4_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
  $7_1 = ($4_1 | 0) == ($38_1 | 0) & $25_1 >>> 0 < $32_1 >>> 0 | $4_1 >>> 0 < $38_1 >>> 0;
  $3_1 = $35_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $37_1 + 8 | 0;
  $21_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $7_1 + $21_1 | 0;
  $3_1 = $4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $8_1 >>> 20 | 0;
  $1_1 = $4_1 + $8_1 | 0;
  $3_1 = $8_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $12_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 << 12 | $9_1 >>> 20;
  $4_1 = $3_1;
  $26_1 = $3_1 << 12 | $1_1 >>> 20;
  $20_1 = HEAP32[$6_1 + 6624 >> 2];
  $1_1 = HEAP32[$6_1 + 6672 >> 2];
  $9_1 = $20_1 + $1_1 | 0;
  $25_1 = HEAP32[$6_1 + 6628 >> 2];
  $3_1 = $25_1 + HEAP32[$6_1 + 6676 >> 2] | 0;
  $21_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $21_1 + HEAP32[$6_1 + 6420 >> 2] | 0;
  $1_1 = HEAP32[$6_1 + 6416 >> 2];
  $8_1 = $1_1 + $9_1 | 0;
  $12_1 = $8_1;
  $7_1 = $8_1 + $7_1 | 0;
  $1_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $26_1 | 0;
  HEAP32[$24_1 >> 2] = $7_1;
  $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$24_1 + 4 >> 2] = $8_1 & 1048575;
  $24_1 = $6_1 + 6400 | 0;
  $26_1 = ($16_1 | 0) == ($30_1 | 0) & $10_1 >>> 0 < $28_1 >>> 0 | $16_1 >>> 0 < $30_1 >>> 0;
  $3_1 = $19_1 + 8 | 0;
  $16_1 = HEAP32[$3_1 >> 2];
  $3_1 = HEAP32[$3_1 + 4 >> 2];
  $5_1 = $5_1 >>> 20 | 0;
  $10_1 = $5_1;
  $5_1 = $5_1 + $16_1 | 0;
  $3_1 = $10_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $16_1 = $5_1;
  $5_1 = $5_1 + $26_1 | 0;
  $3_1 = $16_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($24_1, $5_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
  $28_1 = $42_1 + 24 | 0;
  $26_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
  $16_1 = ($1_1 | 0) == ($21_1 | 0) & $9_1 >>> 0 > $12_1 >>> 0 | $1_1 >>> 0 < $21_1 >>> 0;
  $1_1 = $22_1 + 8 | 0;
  $12_1 = HEAP32[$1_1 >> 2];
  $10_1 = HEAP32[$1_1 + 4 >> 2];
  $7_1 = ($21_1 | 0) == ($25_1 | 0) & $9_1 >>> 0 < $20_1 >>> 0 | $21_1 >>> 0 < $25_1 >>> 0;
  $3_1 = $23_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $29_1 + 8 | 0;
  $9_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $7_1 + $9_1 | 0;
  $3_1 = ($1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $12_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1 + $16_1 | 0;
  $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $26_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $8_1 >>> 20;
  $4_1 = $3_1;
  $9_1 = $3_1 << 12 | $1_1 >>> 20;
  $12_1 = HEAP32[$6_1 + 6400 >> 2];
  $5_1 = $17_1 & -2;
  $1_1 = $12_1 + $5_1 | 0;
  $17_1 = HEAP32[$6_1 + 6404 >> 2];
  $3_1 = $17_1 + ($18_1 & 1048575) | 0;
  $7_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $7_1 + $9_1 | 0;
  $5_1 = $8_1;
  $8_1 = $1_1;
  $5_1 = $5_1 + $1_1 | 0;
  HEAP32[$28_1 >> 2] = $5_1;
  $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$28_1 + 4 >> 2] = $1_1 & 1048575;
  $18_1 = $42_1 + 32 | 0;
  $16_1 = $18_1;
  $10_1 = $15_1 & 65535;
  $9_1 = ($1_1 | 0) == ($7_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $1_1 >>> 0 < $7_1 >>> 0;
  $5_1 = ($7_1 | 0) == ($17_1 | 0) & $8_1 >>> 0 < $12_1 >>> 0 | $7_1 >>> 0 < $17_1 >>> 0;
  $3_1 = $24_1 + 8 | 0;
  $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
  $3_1 = HEAP32[$3_1 + 4 >> 2];
  $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $5_1 = $4_1;
  $4_1 = $4_1 + $8_1 | 0;
  $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $4_1;
  $4_1 = $4_1 + $9_1 | 0;
  $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $4_1 << 12 | $1_1 >>> 20;
  $5_1 = $1_1 + $11_1 | 0;
  $3_1 = $10_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
  HEAP32[$16_1 >> 2] = $5_1;
  HEAP32[$16_1 + 4 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$6_1 + 7536 >> 2] = $13_1;
  HEAP32[$6_1 + 7540 >> 2] = $14_1 & 1048575;
  $34($42_1, $42_1, $41_1);
  $1_1 = HEAP32[$6_1 + 7540 >> 2];
  $22_1 = $1_1;
  $20_1 = HEAP32[$6_1 + 7536 >> 2];
  $7_1 = $20_1;
  $3_1 = $1_1 << 1 | $7_1 >>> 31;
  $15_1 = $6_1 + 6224 | 0;
  $12_1 = HEAP32[$28_1 >> 2];
  $10_1 = HEAP32[$28_1 + 4 >> 2];
  $21_1 = $7_1 << 1;
  $26_1 = $3_1;
  $69($15_1, $12_1, $10_1, 0, 0, $21_1, $3_1, 0, 0);
  $1_1 = HEAP32[$34_1 + 4 >> 2];
  $41_1 = $1_1;
  $33_1 = HEAP32[$34_1 >> 2];
  $4_1 = $33_1;
  $3_1 = $1_1 << 1 | $4_1 >>> 31;
  $16_1 = $6_1 + 6320 | 0;
  $13_1 = HEAP32[$27_1 >> 2];
  $9_1 = HEAP32[$27_1 + 4 >> 2];
  $4_1 = $4_1 << 1;
  $5_1 = $3_1;
  $69($16_1, $13_1, $9_1, 0, 0, $4_1, $3_1, 0, 0);
  $14_1 = $6_1 + 6208 | 0;
  $8_1 = HEAP32[$18_1 >> 2];
  $1_1 = HEAP32[$18_1 + 4 >> 2];
  $69($14_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
  $11_1 = $6_1 + 6192 | 0;
  $69($11_1, HEAP32[$6_1 + 6208 >> 2], HEAP32[$6_1 + 6212 >> 2], 0, 0, 15632, 16, 0, 0);
  $3_1 = $1_1 << 1 | $8_1 >>> 31;
  $39_1 = $6_1 + 6160 | 0;
  $24_1 = $8_1 << 1;
  $17_1 = $3_1;
  $69($39_1, $24_1, $3_1, 0, 0, $7_1, $22_1, 0, 0);
  $38_1 = $6_1 + 6240 | 0;
  $69($38_1, $12_1, $10_1, 0, 0, $4_1, $5_1, 0, 0);
  $35_1 = $6_1 + 6304 | 0;
  $69($35_1, $13_1, $9_1, 0, 0, $13_1, $9_1, 0, 0);
  $28_1 = $6_1 + 6176 | 0;
  $1_1 = $14_1 + 8 | 0;
  $69($28_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $36_1 = $6_1 + 6368 | 0;
  $69($36_1, $7_1, $22_1, 0, 0, $7_1, $22_1, 0, 0);
  $31_1 = $6_1 + 6144 | 0;
  $69($31_1, $24_1, $3_1, 0, 0, $33_1, $41_1, 0, 0);
  $37_1 = $6_1 + 6256 | 0;
  $69($37_1, $12_1, $10_1, 0, 0, $13_1 << 1, $9_1 << 1 | $13_1 >>> 31, 0, 0);
  $20_1 = HEAP32[$6_1 + 6228 >> 2];
  $3_1 = $20_1 + HEAP32[$6_1 + 6324 >> 2] | 0;
  $8_1 = HEAP32[$6_1 + 6224 >> 2];
  $4_1 = HEAP32[$6_1 + 6320 >> 2];
  $1_1 = $8_1 + $4_1 | 0;
  $5_1 = HEAP32[$6_1 + 6192 >> 2];
  $18_1 = $1_1 + $5_1 | 0;
  $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1 + HEAP32[$6_1 + 6196 >> 2] | 0;
  $5_1 = $5_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
  $3_1 = $11_1 + 8 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $7_1 = HEAP32[$3_1 + 4 >> 2];
  $8_1 = ($4_1 | 0) == ($20_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $20_1 >>> 0;
  $3_1 = $16_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $15_1 + 8 | 0;
  $16_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $16_1 | 0;
  $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $11_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $14_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $15_1 = $5_1;
  $11_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $30_1 = HEAP32[$6_1 + 6240 >> 2];
  $1_1 = HEAP32[$6_1 + 6304 >> 2];
  $14_1 = $30_1 + $1_1 | 0;
  $34_1 = HEAP32[$6_1 + 6244 >> 2];
  $3_1 = $34_1 + HEAP32[$6_1 + 6308 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 6160 >> 2];
  $7_1 = $1_1 + $14_1 | 0;
  $20_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 6164 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 6176 >> 2];
  $5_1 = $1_1 + $7_1 | 0;
  $16_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 6180 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $32_1 = $6_1 + 6128 | 0;
  $29_1 = $32_1;
  $11_1 = $5_1 + $11_1 | 0;
  $8_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $27_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
  $25_1 = ($1_1 | 0) == ($16_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
  $1_1 = $28_1 + 8 | 0;
  $23_1 = HEAP32[$1_1 >> 2];
  $19_1 = HEAP32[$1_1 + 4 >> 2];
  $22_1 = ($16_1 | 0) == ($20_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $16_1 >>> 0 < $20_1 >>> 0;
  $1_1 = $39_1 + 8 | 0;
  $28_1 = HEAP32[$1_1 >> 2];
  $16_1 = HEAP32[$1_1 + 4 >> 2];
  $7_1 = ($20_1 | 0) == ($34_1 | 0) & $14_1 >>> 0 < $30_1 >>> 0 | $20_1 >>> 0 < $34_1 >>> 0;
  $3_1 = $35_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $38_1 + 8 | 0;
  $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $7_1 + $14_1 | 0;
  $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $28_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $22_1 | 0;
  $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $23_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1 + $25_1 | 0;
  $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $27_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $8_1;
  $7_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $16_1 = $3_1 << 12 | $1_1 >>> 20;
  $23_1 = HEAP32[$6_1 + 6148 >> 2];
  $3_1 = $23_1 + HEAP32[$6_1 + 6260 >> 2] | 0;
  $19_1 = HEAP32[$6_1 + 6144 >> 2];
  $1_1 = HEAP32[$6_1 + 6256 >> 2];
  $8_1 = $19_1 + $1_1 | 0;
  $14_1 = $8_1;
  $7_1 = $8_1 + $7_1 | 0;
  $1_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $16_1 | 0;
  $28_1 = $7_1 << 4 & -16;
  $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $20_1 = ($8_1 << 4 | $7_1 >>> 28) & 16777215;
  $16_1 = $4_1;
  $69($29_1, $28_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
  $29_1 = $6_1 + 6352 | 0;
  $69($29_1, $33_1, $41_1, 0, 0, $21_1, $26_1, 0, 0);
  $25_1 = $6_1 + 6096 | 0;
  $69($25_1, $24_1, $17_1, 0, 0, $13_1, $9_1, 0, 0);
  $22_1 = $6_1 + 6272 | 0;
  $69($22_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
  $28_1 = $6_1 + 6080 | 0;
  $20_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
  $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
  $3_1 = $37_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $31_1 + 8 | 0;
  $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $7_1 + $14_1 | 0;
  $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $8_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $20_1 = HEAP32[$6_1 + 6096 >> 2];
  $1_1 = HEAP32[$6_1 + 6272 >> 2];
  $7_1 = $20_1 + $1_1 | 0;
  $27_1 = HEAP32[$6_1 + 6100 >> 2];
  $3_1 = $27_1 + HEAP32[$6_1 + 6276 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $8_1 = $7_1 + $8_1 | 0;
  $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $3_1;
  $69($28_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $23_1 = $6_1 + 6288 | 0;
  $69($23_1, $13_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
  $19_1 = $6_1 + 6336 | 0;
  $69($19_1, $33_1, $41_1, 0, 0, $33_1, $41_1, 0, 0);
  $14_1 = $6_1 + 6032 | 0;
  $69($14_1, $24_1, $17_1, 0, 0, $12_1, $10_1, 0, 0);
  $21_1 = $6_1 + 6016 | 0;
  $10_1 = $21_1;
  $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $7_1 = ($1_1 | 0) == ($27_1 | 0) & $7_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $27_1 >>> 0;
  $3_1 = $22_1 + 8 | 0;
  $8_1 = HEAP32[$3_1 >> 2];
  $1_1 = $25_1 + 8 | 0;
  $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $7_1 + $12_1 | 0;
  $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $5_1 >>> 20;
  $5_1 = HEAP32[$6_1 + 6032 >> 2];
  $9_1 = $8_1 + $5_1 | 0;
  $4_1 = $3_1;
  $1_1 = $3_1 << 12 | $1_1 >>> 20;
  $3_1 = $1_1 + HEAP32[$6_1 + 6036 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
  $27_1 = $6_1 + 5952 | 0;
  $7_1 = $27_1;
  $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $1_1 = $14_1 + 8 | 0;
  $5_1 = HEAP32[$1_1 >> 2];
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
  $4_1 = HEAP32[$6_1 + 6128 >> 2];
  $1_1 = HEAP32[$6_1 + 6368 >> 2];
  $7_1 = $4_1 + $1_1 | 0;
  $8_1 = HEAP32[$6_1 + 6132 >> 2];
  $3_1 = $8_1 + HEAP32[$6_1 + 6372 >> 2] | 0;
  $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
  $3_1 = $36_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $32_1 + 8 | 0;
  $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $9_1 | 0;
  $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $5_1;
  $8_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $10_1 = HEAP32[$6_1 + 6080 >> 2];
  $1_1 = HEAP32[$6_1 + 6352 >> 2];
  $9_1 = $10_1 + $1_1 | 0;
  $14_1 = HEAP32[$6_1 + 6084 >> 2];
  $3_1 = $14_1 + HEAP32[$6_1 + 6356 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $8_1 = $8_1 + $9_1 | 0;
  $5_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
  $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
  $3_1 = $29_1 + 8 | 0;
  $9_1 = HEAP32[$3_1 >> 2];
  $1_1 = $28_1 + 8 | 0;
  $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = $10_1 + $14_1 | 0;
  $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $12_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = $5_1;
  $9_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $22_1 = HEAP32[$6_1 + 6288 >> 2];
  $1_1 = HEAP32[$6_1 + 6336 >> 2];
  $12_1 = $22_1 + $1_1 | 0;
  $29_1 = HEAP32[$6_1 + 6292 >> 2];
  $3_1 = $29_1 + HEAP32[$6_1 + 6340 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 6016 >> 2];
  $10_1 = $1_1 + $12_1 | 0;
  $17_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 6020 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $25_1 = $6_1 + 5936 | 0;
  $28_1 = $25_1;
  $5_1 = $9_1 + $10_1 | 0;
  $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
  $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
  $1_1 = $21_1 + 8 | 0;
  $26_1 = HEAP32[$1_1 >> 2];
  $21_1 = HEAP32[$1_1 + 4 >> 2];
  $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
  $3_1 = $19_1 + 8 | 0;
  $10_1 = HEAP32[$3_1 >> 2];
  $1_1 = $23_1 + 8 | 0;
  $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $12_1 + $17_1 | 0;
  $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
  $12_1 = $1_1;
  $1_1 = $1_1 + $26_1 | 0;
  $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $1_1 + $24_1 | 0;
  $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $10_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $9_1;
  $12_1 = $1_1 << 12 | $9_1 >>> 20;
  $4_1 = $3_1;
  $17_1 = $3_1 << 12 | $1_1 >>> 20;
  $29_1 = HEAP32[$6_1 + 5956 >> 2];
  $3_1 = $29_1 + ($15_1 & 1048575) | 0;
  $22_1 = HEAP32[$6_1 + 5952 >> 2];
  $1_1 = $18_1 & -2;
  $9_1 = $22_1 + $1_1 | 0;
  $15_1 = $9_1;
  $12_1 = $9_1 + $12_1 | 0;
  $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $17_1 | 0;
  $9_1 = $12_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $17_1 = $9_1 & 1048575;
  $3_1 = $13_1 & 1048575;
  $32_1 = $3_1;
  $13_1 = $7_1;
  $3_1 = $3_1 << 1 | $7_1 >>> 31;
  $26_1 = $7_1 << 1;
  $24_1 = $3_1;
  $69($28_1, $12_1, $17_1, 0, 0, $26_1, $3_1, 0, 0);
  $3_1 = $14_1 & 1048575;
  $33_1 = $3_1;
  $23_1 = $6_1 + 5968 | 0;
  $18_1 = $10_1 & 1048575;
  $7_1 = $8_1 << 1;
  $28_1 = $8_1;
  $10_1 = $3_1 << 1 | $8_1 >>> 31;
  $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
  $19_1 = $6_1 + 5872 | 0;
  $20_1 = $19_1;
  $21_1 = $16_1 & 65535;
  $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
  $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
  $1_1 = $27_1 + 8 | 0;
  $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $16_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $9_1 >>> 20;
  $4_1 = $8_1 + $11_1 | 0;
  $3_1 = $21_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
  $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($20_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
  $11_1 = $6_1 + 5856 | 0;
  $69($11_1, HEAP32[$6_1 + 5872 >> 2], HEAP32[$6_1 + 5876 >> 2], 0, 0, 15632, 16, 0, 0);
  $1_1 = $4_1;
  $3_1 = $3_1 << 1 | $1_1 >>> 31;
  $39_1 = $6_1 + 5824 | 0;
  $20_1 = $1_1 << 1;
  $21_1 = $3_1;
  $69($39_1, $20_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
  $38_1 = $6_1 + 5920 | 0;
  $69($38_1, $12_1, $17_1, 0, 0, $7_1, $10_1, 0, 0);
  $35_1 = $6_1 + 5984 | 0;
  $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
  $22_1 = $6_1 + 5840 | 0;
  $1_1 = $19_1 + 8 | 0;
  $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $36_1 = $6_1 + 6112 | 0;
  $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
  $31_1 = $6_1 + 5808 | 0;
  $69($31_1, $20_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
  $37_1 = $6_1 + 5888 | 0;
  $10_1 = $17_1;
  $9_1 = $18_1;
  $17_1 = $5_1;
  $69($37_1, $12_1, $10_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
  $8_1 = HEAP32[$6_1 + 5936 >> 2];
  $4_1 = HEAP32[$6_1 + 5968 >> 2];
  $1_1 = $8_1 + $4_1 | 0;
  $13_1 = HEAP32[$6_1 + 5940 >> 2];
  $3_1 = $13_1 + HEAP32[$6_1 + 5972 >> 2] | 0;
  $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = HEAP32[$6_1 + 5856 >> 2];
  $18_1 = $4_1 + $1_1 | 0;
  $5_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 5860 >> 2] | 0;
  $4_1 = $4_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
  $3_1 = $11_1 + 8 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $7_1 = HEAP32[$3_1 + 4 >> 2];
  $8_1 = ($5_1 | 0) == ($13_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $13_1 >>> 0;
  $3_1 = $23_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $25_1 + 8 | 0;
  $13_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $13_1 | 0;
  $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $11_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $14_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $15_1 = $4_1;
  $11_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $30_1 = HEAP32[$6_1 + 5920 >> 2];
  $1_1 = HEAP32[$6_1 + 5984 >> 2];
  $13_1 = $30_1 + $1_1 | 0;
  $34_1 = HEAP32[$6_1 + 5924 >> 2];
  $3_1 = $34_1 + HEAP32[$6_1 + 5988 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 5824 >> 2];
  $14_1 = $1_1 + $13_1 | 0;
  $4_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 5828 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 5840 >> 2];
  $7_1 = $1_1 + $14_1 | 0;
  $16_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 5844 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $32_1 = $6_1 + 5712 | 0;
  $29_1 = $32_1;
  $11_1 = $7_1 + $11_1 | 0;
  $8_1 = $11_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $27_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
  $25_1 = ($1_1 | 0) == ($16_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
  $1_1 = $22_1 + 8 | 0;
  $23_1 = HEAP32[$1_1 >> 2];
  $19_1 = HEAP32[$1_1 + 4 >> 2];
  $22_1 = ($4_1 | 0) == ($16_1 | 0) & $13_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 > $16_1 >>> 0;
  $1_1 = $39_1 + 8 | 0;
  $16_1 = HEAP32[$1_1 >> 2];
  $14_1 = HEAP32[$1_1 + 4 >> 2];
  $7_1 = ($4_1 | 0) == ($34_1 | 0) & $13_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
  $3_1 = $35_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $38_1 + 8 | 0;
  $13_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $7_1 + $13_1 | 0;
  $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $14_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $16_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $22_1 | 0;
  $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $23_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1 + $25_1 | 0;
  $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $27_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $8_1;
  $7_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $19_1 = HEAP32[$6_1 + 5808 >> 2];
  $1_1 = HEAP32[$6_1 + 5888 >> 2];
  $14_1 = $19_1 + $1_1 | 0;
  $23_1 = HEAP32[$6_1 + 5812 >> 2];
  $3_1 = $23_1 + HEAP32[$6_1 + 5892 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $7_1 = $7_1 + $14_1 | 0;
  $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $22_1 = $7_1 << 4 & -16;
  $8_1 = $3_1;
  $13_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
  $16_1 = $4_1;
  $69($29_1, $22_1 | $4_1 >>> 16 & 15, $13_1, 0, 0, 977, 1, 0, 0);
  $29_1 = $6_1 + 6048 | 0;
  $69($29_1, $28_1, $33_1, 0, 0, $26_1, $24_1, 0, 0);
  $27_1 = $6_1 + 5792 | 0;
  $69($27_1, $20_1, $21_1, 0, 0, $17_1, $9_1, 0, 0);
  $25_1 = $6_1 + 5904 | 0;
  $69($25_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
  $22_1 = $6_1 + 5776 | 0;
  $13_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
  $3_1 = $37_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $31_1 + 8 | 0;
  $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $7_1 + $14_1 | 0;
  $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $13_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $8_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $13_1 = HEAP32[$6_1 + 5792 >> 2];
  $1_1 = HEAP32[$6_1 + 5904 >> 2];
  $7_1 = $13_1 + $1_1 | 0;
  $30_1 = HEAP32[$6_1 + 5796 >> 2];
  $3_1 = $30_1 + HEAP32[$6_1 + 5908 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $8_1 = $7_1 + $8_1 | 0;
  $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $3_1;
  $69($22_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $23_1 = $6_1 + 6e3 | 0;
  $69($23_1, $17_1, $9_1, 0, 0, $26_1, $24_1, 0, 0);
  $19_1 = $6_1 + 6064 | 0;
  $69($19_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
  $14_1 = $6_1 + 5760 | 0;
  $69($14_1, $12_1, $10_1, 0, 0, $20_1, $21_1, 0, 0);
  $21_1 = $6_1 + 5744 | 0;
  $10_1 = $21_1;
  $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $7_1 = ($1_1 | 0) == ($30_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
  $3_1 = $25_1 + 8 | 0;
  $8_1 = HEAP32[$3_1 >> 2];
  $1_1 = $27_1 + 8 | 0;
  $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $7_1 + $12_1 | 0;
  $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $5_1 >>> 20;
  $5_1 = HEAP32[$6_1 + 5760 >> 2];
  $9_1 = $8_1 + $5_1 | 0;
  $4_1 = $3_1;
  $1_1 = $3_1 << 12 | $1_1 >>> 20;
  $3_1 = $1_1 + HEAP32[$6_1 + 5764 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
  $27_1 = $6_1 + 5728 | 0;
  $7_1 = $27_1;
  $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $1_1 = $14_1 + 8 | 0;
  $5_1 = HEAP32[$1_1 >> 2];
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
  $4_1 = HEAP32[$6_1 + 5712 >> 2];
  $1_1 = HEAP32[$6_1 + 6112 >> 2];
  $7_1 = $4_1 + $1_1 | 0;
  $8_1 = HEAP32[$6_1 + 5716 >> 2];
  $3_1 = $8_1 + HEAP32[$6_1 + 6116 >> 2] | 0;
  $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
  $3_1 = $36_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $32_1 + 8 | 0;
  $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $9_1 | 0;
  $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $5_1;
  $8_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $10_1 = HEAP32[$6_1 + 5776 >> 2];
  $1_1 = HEAP32[$6_1 + 6048 >> 2];
  $9_1 = $10_1 + $1_1 | 0;
  $14_1 = HEAP32[$6_1 + 5780 >> 2];
  $3_1 = $14_1 + HEAP32[$6_1 + 6052 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $8_1 = $8_1 + $9_1 | 0;
  $5_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
  $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
  $3_1 = $29_1 + 8 | 0;
  $9_1 = HEAP32[$3_1 >> 2];
  $1_1 = $22_1 + 8 | 0;
  $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = $10_1 + $14_1 | 0;
  $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $12_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = $5_1;
  $9_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $22_1 = HEAP32[$6_1 + 6e3 >> 2];
  $1_1 = HEAP32[$6_1 + 6064 >> 2];
  $12_1 = $22_1 + $1_1 | 0;
  $29_1 = HEAP32[$6_1 + 6004 >> 2];
  $3_1 = $29_1 + HEAP32[$6_1 + 6068 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 5744 >> 2];
  $10_1 = $1_1 + $12_1 | 0;
  $17_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 5748 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $25_1 = $6_1 + 5632 | 0;
  $28_1 = $25_1;
  $5_1 = $9_1 + $10_1 | 0;
  $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
  $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
  $1_1 = $21_1 + 8 | 0;
  $26_1 = HEAP32[$1_1 >> 2];
  $21_1 = HEAP32[$1_1 + 4 >> 2];
  $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
  $3_1 = $19_1 + 8 | 0;
  $10_1 = HEAP32[$3_1 >> 2];
  $1_1 = $23_1 + 8 | 0;
  $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $12_1 + $17_1 | 0;
  $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
  $12_1 = $1_1;
  $1_1 = $1_1 + $26_1 | 0;
  $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $1_1 + $24_1 | 0;
  $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $10_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $9_1;
  $12_1 = $1_1 << 12 | $9_1 >>> 20;
  $4_1 = $3_1;
  $17_1 = $3_1 << 12 | $1_1 >>> 20;
  $29_1 = HEAP32[$6_1 + 5732 >> 2];
  $3_1 = $29_1 + ($15_1 & 1048575) | 0;
  $22_1 = HEAP32[$6_1 + 5728 >> 2];
  $1_1 = $18_1 & -2;
  $9_1 = $22_1 + $1_1 | 0;
  $15_1 = $9_1;
  $12_1 = $9_1 + $12_1 | 0;
  $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $17_1 | 0;
  $9_1 = $12_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $20_1 = $9_1 & 1048575;
  $18_1 = $20_1;
  $3_1 = $13_1 & 1048575;
  $32_1 = $3_1;
  $13_1 = $7_1;
  $3_1 = $3_1 << 1 | $7_1 >>> 31;
  $21_1 = $7_1 << 1;
  $26_1 = $3_1;
  $69($28_1, $12_1, $18_1, 0, 0, $21_1, $3_1, 0, 0);
  $3_1 = $14_1 & 1048575;
  $33_1 = $3_1;
  $23_1 = $6_1 + 5584 | 0;
  $18_1 = $10_1 & 1048575;
  $7_1 = $8_1 << 1;
  $28_1 = $8_1;
  $10_1 = $3_1 << 1 | $8_1 >>> 31;
  $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
  $19_1 = $6_1 + 5536 | 0;
  $17_1 = $16_1 & 65535;
  $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
  $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
  $1_1 = $27_1 + 8 | 0;
  $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $16_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $9_1 >>> 20;
  $4_1 = $8_1 + $11_1 | 0;
  $3_1 = $17_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
  $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($19_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
  $11_1 = $6_1 + 5520 | 0;
  $69($11_1, HEAP32[$6_1 + 5536 >> 2], HEAP32[$6_1 + 5540 >> 2], 0, 0, 15632, 16, 0, 0);
  $1_1 = $4_1;
  $3_1 = $3_1 << 1 | $1_1 >>> 31;
  $39_1 = $6_1 + 5488 | 0;
  $24_1 = $1_1 << 1;
  $17_1 = $3_1;
  $69($39_1, $24_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
  $38_1 = $6_1 + 5568 | 0;
  $69($38_1, $12_1, $20_1, 0, 0, $7_1, $10_1, 0, 0);
  $35_1 = $6_1 + 5680 | 0;
  $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
  $22_1 = $6_1 + 5504 | 0;
  $1_1 = $19_1 + 8 | 0;
  $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $36_1 = $6_1 + 5648 | 0;
  $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
  $31_1 = $6_1 + 5472 | 0;
  $69($31_1, $24_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
  $37_1 = $6_1 + 5552 | 0;
  $16_1 = $12_1;
  $13_1 = $20_1;
  $9_1 = $18_1;
  $18_1 = $5_1;
  $69($37_1, $12_1, $13_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
  $8_1 = HEAP32[$6_1 + 5632 >> 2];
  $4_1 = HEAP32[$6_1 + 5584 >> 2];
  $1_1 = $8_1 + $4_1 | 0;
  $12_1 = HEAP32[$6_1 + 5636 >> 2];
  $3_1 = $12_1 + HEAP32[$6_1 + 5588 >> 2] | 0;
  $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = HEAP32[$6_1 + 5520 >> 2];
  $14_1 = $4_1 + $1_1 | 0;
  $5_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 5524 >> 2] | 0;
  $4_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
  $3_1 = $11_1 + 8 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $7_1 = HEAP32[$3_1 + 4 >> 2];
  $8_1 = ($5_1 | 0) == ($12_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $12_1 >>> 0;
  $3_1 = $23_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $25_1 + 8 | 0;
  $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $12_1 | 0;
  $3_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $11_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $10_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $4_1;
  $7_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $30_1 = HEAP32[$6_1 + 5568 >> 2];
  $1_1 = HEAP32[$6_1 + 5680 >> 2];
  $15_1 = $30_1 + $1_1 | 0;
  $34_1 = HEAP32[$6_1 + 5572 >> 2];
  $3_1 = $34_1 + HEAP32[$6_1 + 5684 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 5488 >> 2];
  $10_1 = $1_1 + $15_1 | 0;
  $4_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 5492 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 5504 >> 2];
  $11_1 = $1_1 + $10_1 | 0;
  $20_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 5508 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $32_1 = $6_1 + 5376 | 0;
  $29_1 = $32_1;
  $8_1 = $7_1 + $11_1 | 0;
  $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $27_1 = ($1_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
  $25_1 = ($1_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 < $20_1 >>> 0;
  $1_1 = $22_1 + 8 | 0;
  $23_1 = HEAP32[$1_1 >> 2];
  $19_1 = HEAP32[$1_1 + 4 >> 2];
  $22_1 = ($4_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $20_1 >>> 0;
  $1_1 = $39_1 + 8 | 0;
  $20_1 = HEAP32[$1_1 >> 2];
  $10_1 = HEAP32[$1_1 + 4 >> 2];
  $11_1 = ($4_1 | 0) == ($34_1 | 0) & $15_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
  $3_1 = $35_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $38_1 + 8 | 0;
  $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $11_1 + $15_1 | 0;
  $3_1 = ($1_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $22_1 | 0;
  $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $23_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1 + $25_1 | 0;
  $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $27_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $7_1;
  $11_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $7_1 = $3_1 << 12 | $1_1 >>> 20;
  $19_1 = HEAP32[$6_1 + 5472 >> 2];
  $1_1 = HEAP32[$6_1 + 5552 >> 2];
  $15_1 = $19_1 + $1_1 | 0;
  $30_1 = HEAP32[$6_1 + 5476 >> 2];
  $3_1 = $30_1 + HEAP32[$6_1 + 5556 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $7_1 | 0;
  $11_1 = $11_1 + $15_1 | 0;
  $3_1 = $11_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $22_1 = $11_1 << 4 & -16;
  $7_1 = $3_1;
  $20_1 = ($3_1 << 4 | $11_1 >>> 28) & 16777215;
  $10_1 = $4_1;
  $69($29_1, $22_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
  $29_1 = $6_1 + 5616 | 0;
  $69($29_1, $28_1, $33_1, 0, 0, $21_1, $26_1, 0, 0);
  $27_1 = $6_1 + 5456 | 0;
  $69($27_1, $24_1, $17_1, 0, 0, $18_1, $9_1, 0, 0);
  $25_1 = $6_1 + 5696 | 0;
  $69($25_1, $16_1, $13_1, 0, 0, $16_1, $13_1, 0, 0);
  $23_1 = $6_1 + 5440 | 0;
  $22_1 = $23_1;
  $20_1 = ($1_1 | 0) == ($3_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $11_1 = ($1_1 | 0) == ($30_1 | 0) & $15_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
  $3_1 = $37_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $31_1 + 8 | 0;
  $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $11_1 + $15_1 | 0;
  $3_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 << 12 | $7_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $20_1 = HEAP32[$6_1 + 5456 >> 2];
  $1_1 = HEAP32[$6_1 + 5696 >> 2];
  $11_1 = $20_1 + $1_1 | 0;
  $30_1 = HEAP32[$6_1 + 5460 >> 2];
  $3_1 = $30_1 + HEAP32[$6_1 + 5700 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $7_1 = $7_1 + $11_1 | 0;
  $3_1 = $7_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $3_1;
  $69($22_1, $7_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $19_1 = $6_1 + 5600 | 0;
  $69($19_1, $18_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
  $22_1 = $6_1 + 5664 | 0;
  $69($22_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
  $15_1 = $6_1 + 5424 | 0;
  $69($15_1, $16_1, $13_1, 0, 0, $24_1, $17_1, 0, 0);
  $18_1 = $6_1 + 5408 | 0;
  $13_1 = $18_1;
  $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $11_1 = ($1_1 | 0) == ($30_1 | 0) & $11_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
  $3_1 = $25_1 + 8 | 0;
  $7_1 = HEAP32[$3_1 >> 2];
  $1_1 = $27_1 + 8 | 0;
  $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $11_1 + $16_1 | 0;
  $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $7_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 << 12 | $5_1 >>> 20;
  $5_1 = HEAP32[$6_1 + 5424 >> 2];
  $9_1 = $7_1 + $5_1 | 0;
  $4_1 = $3_1;
  $1_1 = $3_1 << 12 | $1_1 >>> 20;
  $3_1 = $1_1 + HEAP32[$6_1 + 5428 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($13_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
  $20_1 = $6_1 + 5392 | 0;
  $11_1 = $20_1;
  $7_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $1_1 = $15_1 + 8 | 0;
  $5_1 = HEAP32[$1_1 >> 2];
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $7_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($11_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
  $4_1 = HEAP32[$6_1 + 5376 >> 2];
  $1_1 = HEAP32[$6_1 + 5648 >> 2];
  $9_1 = $4_1 + $1_1 | 0;
  $7_1 = HEAP32[$6_1 + 5380 >> 2];
  $3_1 = $7_1 + HEAP32[$6_1 + 5652 >> 2] | 0;
  $30_1 = $6_1 + 7496 | 0;
  $27_1 = $30_1 + 8 | 0;
  $16_1 = $27_1;
  $5_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = ($7_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $9_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
  $3_1 = $36_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $32_1 + 8 | 0;
  $11_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $7_1 + $11_1 | 0;
  $3_1 = $1_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $11_1 = $5_1;
  $7_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $15_1 = HEAP32[$6_1 + 5440 >> 2];
  $1_1 = HEAP32[$6_1 + 5616 >> 2];
  $13_1 = $15_1 + $1_1 | 0;
  $21_1 = HEAP32[$6_1 + 5444 >> 2];
  $3_1 = $21_1 + HEAP32[$6_1 + 5620 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $7_1 = $7_1 + $13_1 | 0;
  $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$16_1 >> 2] = $7_1;
  $5_1 = $3_1;
  HEAP32[$16_1 + 4 >> 2] = $3_1 & 1048575;
  $25_1 = $30_1 + 16 | 0;
  $17_1 = $25_1;
  $16_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $13_1 = ($1_1 | 0) == ($21_1 | 0) & $13_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 < $21_1 >>> 0;
  $3_1 = $29_1 + 8 | 0;
  $7_1 = HEAP32[$3_1 >> 2];
  $1_1 = $23_1 + 8 | 0;
  $15_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $7_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $13_1 + $15_1 | 0;
  $3_1 = $7_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $7_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $16_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $24_1 = HEAP32[$6_1 + 5600 >> 2];
  $1_1 = HEAP32[$6_1 + 5664 >> 2];
  $16_1 = $24_1 + $1_1 | 0;
  $23_1 = HEAP32[$6_1 + 5604 >> 2];
  $3_1 = $23_1 + HEAP32[$6_1 + 5668 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 5408 >> 2];
  $13_1 = $1_1 + $16_1 | 0;
  $15_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 5412 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $7_1 = $7_1 + $13_1 | 0;
  $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$17_1 >> 2] = $7_1;
  $5_1 = $3_1;
  HEAP32[$17_1 + 4 >> 2] = $3_1 & 1048575;
  $28_1 = $30_1 + 24 | 0;
  $26_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $21_1 = ($1_1 | 0) == ($15_1 | 0) & $13_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 < $15_1 >>> 0;
  $1_1 = $18_1 + 8 | 0;
  $17_1 = HEAP32[$1_1 >> 2];
  $18_1 = HEAP32[$1_1 + 4 >> 2];
  $13_1 = ($15_1 | 0) == ($23_1 | 0) & $16_1 >>> 0 < $24_1 >>> 0 | $15_1 >>> 0 < $23_1 >>> 0;
  $3_1 = $22_1 + 8 | 0;
  $7_1 = HEAP32[$3_1 >> 2];
  $1_1 = $19_1 + 8 | 0;
  $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $13_1 + $16_1 | 0;
  $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
  $7_1 = $1_1;
  $1_1 = $1_1 + $17_1 | 0;
  $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 + $21_1 | 0;
  $3_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $7_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $26_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $7_1 = $3_1 << 12 | $1_1 >>> 20;
  $16_1 = HEAP32[$6_1 + 5392 >> 2];
  $5_1 = $14_1 & -2;
  $1_1 = $16_1 + $5_1 | 0;
  $17_1 = HEAP32[$6_1 + 5396 >> 2];
  $3_1 = $17_1 + ($12_1 & 1048575) | 0;
  $14_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $14_1 + $7_1 | 0;
  $12_1 = $1_1;
  $5_1 = $1_1 + $13_1 | 0;
  HEAP32[$28_1 >> 2] = $5_1;
  $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$28_1 + 4 >> 2] = $1_1 & 1048575;
  $18_1 = $30_1 + 32 | 0;
  $15_1 = $18_1;
  $7_1 = $8_1;
  $13_1 = $10_1 & 65535;
  $10_1 = ($1_1 | 0) == ($14_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
  $5_1 = ($14_1 | 0) == ($17_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $14_1 >>> 0 < $17_1 >>> 0;
  $3_1 = $20_1 + 8 | 0;
  $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
  $3_1 = HEAP32[$3_1 + 4 >> 2];
  $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $5_1 = $4_1;
  $4_1 = $4_1 + $8_1 | 0;
  $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $4_1;
  $4_1 = $4_1 + $10_1 | 0;
  $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $4_1 << 12 | $1_1 >>> 20;
  $5_1 = $1_1 + $7_1 | 0;
  $3_1 = $13_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
  HEAP32[$15_1 >> 2] = $5_1;
  HEAP32[$15_1 + 4 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$6_1 + 7496 >> 2] = $9_1;
  HEAP32[$6_1 + 7500 >> 2] = $11_1 & 1048575;
  $34($30_1, $30_1, $42_1);
  $1_1 = HEAP32[$6_1 + 7500 >> 2];
  $22_1 = $1_1;
  $20_1 = HEAP32[$6_1 + 7496 >> 2];
  $7_1 = $20_1;
  $3_1 = $1_1 << 1 | $7_1 >>> 31;
  $15_1 = $6_1 + 5216 | 0;
  $12_1 = HEAP32[$28_1 >> 2];
  $10_1 = HEAP32[$28_1 + 4 >> 2];
  $21_1 = $7_1 << 1;
  $26_1 = $3_1;
  $69($15_1, $12_1, $10_1, 0, 0, $21_1, $3_1, 0, 0);
  $1_1 = HEAP32[$27_1 + 4 >> 2];
  $41_1 = $1_1;
  $33_1 = HEAP32[$27_1 >> 2];
  $4_1 = $33_1;
  $3_1 = $1_1 << 1 | $4_1 >>> 31;
  $16_1 = $6_1 + 5312 | 0;
  $13_1 = HEAP32[$25_1 >> 2];
  $9_1 = HEAP32[$25_1 + 4 >> 2];
  $4_1 = $4_1 << 1;
  $5_1 = $3_1;
  $69($16_1, $13_1, $9_1, 0, 0, $4_1, $3_1, 0, 0);
  $14_1 = $6_1 + 5200 | 0;
  $8_1 = HEAP32[$18_1 >> 2];
  $1_1 = HEAP32[$18_1 + 4 >> 2];
  $69($14_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
  $11_1 = $6_1 + 5184 | 0;
  $69($11_1, HEAP32[$6_1 + 5200 >> 2], HEAP32[$6_1 + 5204 >> 2], 0, 0, 15632, 16, 0, 0);
  $3_1 = $1_1 << 1 | $8_1 >>> 31;
  $39_1 = $6_1 + 5152 | 0;
  $24_1 = $8_1 << 1;
  $17_1 = $3_1;
  $69($39_1, $24_1, $3_1, 0, 0, $7_1, $22_1, 0, 0);
  $38_1 = $6_1 + 5232 | 0;
  $69($38_1, $12_1, $10_1, 0, 0, $4_1, $5_1, 0, 0);
  $35_1 = $6_1 + 5296 | 0;
  $69($35_1, $13_1, $9_1, 0, 0, $13_1, $9_1, 0, 0);
  $28_1 = $6_1 + 5168 | 0;
  $1_1 = $14_1 + 8 | 0;
  $69($28_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $36_1 = $6_1 + 5360 | 0;
  $69($36_1, $7_1, $22_1, 0, 0, $7_1, $22_1, 0, 0);
  $31_1 = $6_1 + 5136 | 0;
  $69($31_1, $24_1, $3_1, 0, 0, $33_1, $41_1, 0, 0);
  $37_1 = $6_1 + 5248 | 0;
  $69($37_1, $12_1, $10_1, 0, 0, $13_1 << 1, $9_1 << 1 | $13_1 >>> 31, 0, 0);
  $20_1 = HEAP32[$6_1 + 5220 >> 2];
  $3_1 = $20_1 + HEAP32[$6_1 + 5316 >> 2] | 0;
  $8_1 = HEAP32[$6_1 + 5216 >> 2];
  $4_1 = HEAP32[$6_1 + 5312 >> 2];
  $1_1 = $8_1 + $4_1 | 0;
  $5_1 = HEAP32[$6_1 + 5184 >> 2];
  $18_1 = $1_1 + $5_1 | 0;
  $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1 + HEAP32[$6_1 + 5188 >> 2] | 0;
  $5_1 = $5_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
  $3_1 = $11_1 + 8 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $7_1 = HEAP32[$3_1 + 4 >> 2];
  $8_1 = ($4_1 | 0) == ($20_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $20_1 >>> 0;
  $3_1 = $16_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $15_1 + 8 | 0;
  $16_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $16_1 | 0;
  $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $11_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $14_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $15_1 = $5_1;
  $11_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $30_1 = HEAP32[$6_1 + 5232 >> 2];
  $1_1 = HEAP32[$6_1 + 5296 >> 2];
  $14_1 = $30_1 + $1_1 | 0;
  $34_1 = HEAP32[$6_1 + 5236 >> 2];
  $3_1 = $34_1 + HEAP32[$6_1 + 5300 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 5152 >> 2];
  $7_1 = $1_1 + $14_1 | 0;
  $20_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 5156 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 5168 >> 2];
  $5_1 = $1_1 + $7_1 | 0;
  $16_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 5172 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $32_1 = $6_1 + 5120 | 0;
  $29_1 = $32_1;
  $11_1 = $5_1 + $11_1 | 0;
  $8_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $27_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
  $25_1 = ($1_1 | 0) == ($16_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
  $1_1 = $28_1 + 8 | 0;
  $23_1 = HEAP32[$1_1 >> 2];
  $19_1 = HEAP32[$1_1 + 4 >> 2];
  $22_1 = ($16_1 | 0) == ($20_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $16_1 >>> 0 < $20_1 >>> 0;
  $1_1 = $39_1 + 8 | 0;
  $28_1 = HEAP32[$1_1 >> 2];
  $16_1 = HEAP32[$1_1 + 4 >> 2];
  $7_1 = ($20_1 | 0) == ($34_1 | 0) & $14_1 >>> 0 < $30_1 >>> 0 | $20_1 >>> 0 < $34_1 >>> 0;
  $3_1 = $35_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $38_1 + 8 | 0;
  $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $7_1 + $14_1 | 0;
  $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $28_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $22_1 | 0;
  $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $23_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1 + $25_1 | 0;
  $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $27_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $8_1;
  $7_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $19_1 = HEAP32[$6_1 + 5136 >> 2];
  $1_1 = HEAP32[$6_1 + 5248 >> 2];
  $14_1 = $19_1 + $1_1 | 0;
  $23_1 = HEAP32[$6_1 + 5140 >> 2];
  $3_1 = $23_1 + HEAP32[$6_1 + 5252 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $7_1 = $7_1 + $14_1 | 0;
  $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $28_1 = $7_1 << 4 & -16;
  $8_1 = $3_1;
  $20_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
  $16_1 = $4_1;
  $69($29_1, $28_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
  $29_1 = $6_1 + 5344 | 0;
  $69($29_1, $33_1, $41_1, 0, 0, $21_1, $26_1, 0, 0);
  $25_1 = $6_1 + 5088 | 0;
  $69($25_1, $24_1, $17_1, 0, 0, $13_1, $9_1, 0, 0);
  $22_1 = $6_1 + 5264 | 0;
  $69($22_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
  $28_1 = $6_1 + 5072 | 0;
  $20_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
  $3_1 = $37_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $31_1 + 8 | 0;
  $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $7_1 + $14_1 | 0;
  $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $8_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $20_1 = HEAP32[$6_1 + 5088 >> 2];
  $1_1 = HEAP32[$6_1 + 5264 >> 2];
  $7_1 = $20_1 + $1_1 | 0;
  $27_1 = HEAP32[$6_1 + 5092 >> 2];
  $3_1 = $27_1 + HEAP32[$6_1 + 5268 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $8_1 = $7_1 + $8_1 | 0;
  $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $3_1;
  $69($28_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $23_1 = $6_1 + 5280 | 0;
  $69($23_1, $13_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
  $19_1 = $6_1 + 5328 | 0;
  $69($19_1, $33_1, $41_1, 0, 0, $33_1, $41_1, 0, 0);
  $14_1 = $6_1 + 5024 | 0;
  $69($14_1, $24_1, $17_1, 0, 0, $12_1, $10_1, 0, 0);
  $21_1 = $6_1 + 5008 | 0;
  $10_1 = $21_1;
  $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $7_1 = ($1_1 | 0) == ($27_1 | 0) & $7_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $27_1 >>> 0;
  $3_1 = $22_1 + 8 | 0;
  $8_1 = HEAP32[$3_1 >> 2];
  $1_1 = $25_1 + 8 | 0;
  $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $7_1 + $12_1 | 0;
  $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $5_1 >>> 20;
  $5_1 = HEAP32[$6_1 + 5024 >> 2];
  $9_1 = $8_1 + $5_1 | 0;
  $4_1 = $3_1;
  $1_1 = $3_1 << 12 | $1_1 >>> 20;
  $3_1 = $1_1 + HEAP32[$6_1 + 5028 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
  $27_1 = $6_1 + 4944 | 0;
  $7_1 = $27_1;
  $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $1_1 = $14_1 + 8 | 0;
  $5_1 = HEAP32[$1_1 >> 2];
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
  $4_1 = HEAP32[$6_1 + 5120 >> 2];
  $1_1 = HEAP32[$6_1 + 5360 >> 2];
  $7_1 = $4_1 + $1_1 | 0;
  $8_1 = HEAP32[$6_1 + 5124 >> 2];
  $3_1 = $8_1 + HEAP32[$6_1 + 5364 >> 2] | 0;
  $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
  $3_1 = $36_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $32_1 + 8 | 0;
  $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $9_1 | 0;
  $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $5_1;
  $8_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $10_1 = HEAP32[$6_1 + 5072 >> 2];
  $1_1 = HEAP32[$6_1 + 5344 >> 2];
  $9_1 = $10_1 + $1_1 | 0;
  $14_1 = HEAP32[$6_1 + 5076 >> 2];
  $3_1 = $14_1 + HEAP32[$6_1 + 5348 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $8_1 = $8_1 + $9_1 | 0;
  $5_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
  $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
  $3_1 = $29_1 + 8 | 0;
  $9_1 = HEAP32[$3_1 >> 2];
  $1_1 = $28_1 + 8 | 0;
  $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = $10_1 + $14_1 | 0;
  $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $12_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = $5_1;
  $9_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $22_1 = HEAP32[$6_1 + 5280 >> 2];
  $1_1 = HEAP32[$6_1 + 5328 >> 2];
  $12_1 = $22_1 + $1_1 | 0;
  $29_1 = HEAP32[$6_1 + 5284 >> 2];
  $3_1 = $29_1 + HEAP32[$6_1 + 5332 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 5008 >> 2];
  $10_1 = $1_1 + $12_1 | 0;
  $17_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 5012 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $25_1 = $6_1 + 4928 | 0;
  $28_1 = $25_1;
  $5_1 = $9_1 + $10_1 | 0;
  $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
  $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
  $1_1 = $21_1 + 8 | 0;
  $26_1 = HEAP32[$1_1 >> 2];
  $21_1 = HEAP32[$1_1 + 4 >> 2];
  $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
  $3_1 = $19_1 + 8 | 0;
  $10_1 = HEAP32[$3_1 >> 2];
  $1_1 = $23_1 + 8 | 0;
  $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $12_1 + $17_1 | 0;
  $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
  $12_1 = $1_1;
  $1_1 = $1_1 + $26_1 | 0;
  $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $1_1 + $24_1 | 0;
  $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $10_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $9_1;
  $12_1 = $1_1 << 12 | $9_1 >>> 20;
  $4_1 = $3_1;
  $17_1 = $3_1 << 12 | $1_1 >>> 20;
  $29_1 = HEAP32[$6_1 + 4948 >> 2];
  $3_1 = $29_1 + ($15_1 & 1048575) | 0;
  $22_1 = HEAP32[$6_1 + 4944 >> 2];
  $1_1 = $18_1 & -2;
  $9_1 = $22_1 + $1_1 | 0;
  $15_1 = $9_1;
  $12_1 = $9_1 + $12_1 | 0;
  $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $17_1 | 0;
  $9_1 = $12_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $17_1 = $9_1 & 1048575;
  $3_1 = $13_1 & 1048575;
  $32_1 = $3_1;
  $13_1 = $7_1;
  $3_1 = $3_1 << 1 | $7_1 >>> 31;
  $26_1 = $7_1 << 1;
  $24_1 = $3_1;
  $69($28_1, $12_1, $17_1, 0, 0, $26_1, $3_1, 0, 0);
  $3_1 = $14_1 & 1048575;
  $33_1 = $3_1;
  $23_1 = $6_1 + 4960 | 0;
  $18_1 = $10_1 & 1048575;
  $7_1 = $8_1 << 1;
  $28_1 = $8_1;
  $10_1 = $3_1 << 1 | $8_1 >>> 31;
  $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
  $19_1 = $6_1 + 4864 | 0;
  $20_1 = $19_1;
  $21_1 = $16_1 & 65535;
  $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
  $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
  $1_1 = $27_1 + 8 | 0;
  $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $16_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $9_1 >>> 20;
  $4_1 = $8_1 + $11_1 | 0;
  $3_1 = $21_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
  $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($20_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
  $11_1 = $6_1 + 4848 | 0;
  $69($11_1, HEAP32[$6_1 + 4864 >> 2], HEAP32[$6_1 + 4868 >> 2], 0, 0, 15632, 16, 0, 0);
  $1_1 = $4_1;
  $3_1 = $3_1 << 1 | $1_1 >>> 31;
  $39_1 = $6_1 + 4816 | 0;
  $20_1 = $1_1 << 1;
  $21_1 = $3_1;
  $69($39_1, $20_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
  $38_1 = $6_1 + 4912 | 0;
  $69($38_1, $12_1, $17_1, 0, 0, $7_1, $10_1, 0, 0);
  $35_1 = $6_1 + 4976 | 0;
  $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
  $22_1 = $6_1 + 4832 | 0;
  $1_1 = $19_1 + 8 | 0;
  $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $36_1 = $6_1 + 5104 | 0;
  $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
  $31_1 = $6_1 + 4800 | 0;
  $69($31_1, $20_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
  $37_1 = $6_1 + 4880 | 0;
  $10_1 = $17_1;
  $9_1 = $18_1;
  $17_1 = $5_1;
  $69($37_1, $12_1, $10_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
  $8_1 = HEAP32[$6_1 + 4928 >> 2];
  $4_1 = HEAP32[$6_1 + 4960 >> 2];
  $1_1 = $8_1 + $4_1 | 0;
  $13_1 = HEAP32[$6_1 + 4932 >> 2];
  $3_1 = $13_1 + HEAP32[$6_1 + 4964 >> 2] | 0;
  $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = HEAP32[$6_1 + 4848 >> 2];
  $18_1 = $4_1 + $1_1 | 0;
  $5_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 4852 >> 2] | 0;
  $4_1 = $4_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
  $3_1 = $11_1 + 8 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $7_1 = HEAP32[$3_1 + 4 >> 2];
  $8_1 = ($5_1 | 0) == ($13_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $13_1 >>> 0;
  $3_1 = $23_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $25_1 + 8 | 0;
  $13_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $13_1 | 0;
  $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $11_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $14_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $15_1 = $4_1;
  $11_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $30_1 = HEAP32[$6_1 + 4912 >> 2];
  $1_1 = HEAP32[$6_1 + 4976 >> 2];
  $13_1 = $30_1 + $1_1 | 0;
  $34_1 = HEAP32[$6_1 + 4916 >> 2];
  $3_1 = $34_1 + HEAP32[$6_1 + 4980 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 4816 >> 2];
  $14_1 = $1_1 + $13_1 | 0;
  $4_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 4820 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 4832 >> 2];
  $7_1 = $1_1 + $14_1 | 0;
  $16_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 4836 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $32_1 = $6_1 + 4704 | 0;
  $29_1 = $32_1;
  $11_1 = $7_1 + $11_1 | 0;
  $8_1 = $11_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $27_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
  $25_1 = ($1_1 | 0) == ($16_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
  $1_1 = $22_1 + 8 | 0;
  $23_1 = HEAP32[$1_1 >> 2];
  $19_1 = HEAP32[$1_1 + 4 >> 2];
  $22_1 = ($4_1 | 0) == ($16_1 | 0) & $13_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 > $16_1 >>> 0;
  $1_1 = $39_1 + 8 | 0;
  $16_1 = HEAP32[$1_1 >> 2];
  $14_1 = HEAP32[$1_1 + 4 >> 2];
  $7_1 = ($4_1 | 0) == ($34_1 | 0) & $13_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
  $3_1 = $35_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $38_1 + 8 | 0;
  $13_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $7_1 + $13_1 | 0;
  $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $14_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $16_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $22_1 | 0;
  $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $23_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1 + $25_1 | 0;
  $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $27_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $8_1;
  $7_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $19_1 = HEAP32[$6_1 + 4800 >> 2];
  $1_1 = HEAP32[$6_1 + 4880 >> 2];
  $14_1 = $19_1 + $1_1 | 0;
  $23_1 = HEAP32[$6_1 + 4804 >> 2];
  $3_1 = $23_1 + HEAP32[$6_1 + 4884 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $7_1 = $7_1 + $14_1 | 0;
  $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $22_1 = $7_1 << 4 & -16;
  $8_1 = $3_1;
  $13_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
  $16_1 = $4_1;
  $69($29_1, $22_1 | $4_1 >>> 16 & 15, $13_1, 0, 0, 977, 1, 0, 0);
  $29_1 = $6_1 + 5040 | 0;
  $69($29_1, $28_1, $33_1, 0, 0, $26_1, $24_1, 0, 0);
  $27_1 = $6_1 + 4784 | 0;
  $69($27_1, $20_1, $21_1, 0, 0, $17_1, $9_1, 0, 0);
  $25_1 = $6_1 + 4896 | 0;
  $69($25_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
  $22_1 = $6_1 + 4768 | 0;
  $13_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
  $3_1 = $37_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $31_1 + 8 | 0;
  $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $7_1 + $14_1 | 0;
  $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $13_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $8_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $13_1 = HEAP32[$6_1 + 4784 >> 2];
  $1_1 = HEAP32[$6_1 + 4896 >> 2];
  $7_1 = $13_1 + $1_1 | 0;
  $30_1 = HEAP32[$6_1 + 4788 >> 2];
  $3_1 = $30_1 + HEAP32[$6_1 + 4900 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $8_1 = $7_1 + $8_1 | 0;
  $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $3_1;
  $69($22_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $23_1 = $6_1 + 4992 | 0;
  $69($23_1, $17_1, $9_1, 0, 0, $26_1, $24_1, 0, 0);
  $19_1 = $6_1 + 5056 | 0;
  $69($19_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
  $14_1 = $6_1 + 4752 | 0;
  $69($14_1, $12_1, $10_1, 0, 0, $20_1, $21_1, 0, 0);
  $21_1 = $6_1 + 4736 | 0;
  $10_1 = $21_1;
  $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $7_1 = ($1_1 | 0) == ($30_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
  $3_1 = $25_1 + 8 | 0;
  $8_1 = HEAP32[$3_1 >> 2];
  $1_1 = $27_1 + 8 | 0;
  $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $7_1 + $12_1 | 0;
  $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $5_1 >>> 20;
  $5_1 = HEAP32[$6_1 + 4752 >> 2];
  $9_1 = $8_1 + $5_1 | 0;
  $4_1 = $3_1;
  $1_1 = $3_1 << 12 | $1_1 >>> 20;
  $3_1 = $1_1 + HEAP32[$6_1 + 4756 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
  $27_1 = $6_1 + 4720 | 0;
  $7_1 = $27_1;
  $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $1_1 = $14_1 + 8 | 0;
  $5_1 = HEAP32[$1_1 >> 2];
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
  $4_1 = HEAP32[$6_1 + 4704 >> 2];
  $1_1 = HEAP32[$6_1 + 5104 >> 2];
  $7_1 = $4_1 + $1_1 | 0;
  $8_1 = HEAP32[$6_1 + 4708 >> 2];
  $3_1 = $8_1 + HEAP32[$6_1 + 5108 >> 2] | 0;
  $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
  $3_1 = $36_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $32_1 + 8 | 0;
  $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $9_1 | 0;
  $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $5_1;
  $8_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $12_1 = $3_1 << 12 | $1_1 >>> 20;
  $14_1 = HEAP32[$6_1 + 4772 >> 2];
  $3_1 = $14_1 + HEAP32[$6_1 + 5044 >> 2] | 0;
  $10_1 = HEAP32[$6_1 + 4768 >> 2];
  $1_1 = HEAP32[$6_1 + 5040 >> 2];
  $5_1 = $10_1 + $1_1 | 0;
  $9_1 = $5_1;
  $8_1 = $5_1 + $8_1 | 0;
  $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $12_1 | 0;
  $5_1 = $8_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
  $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
  $3_1 = $29_1 + 8 | 0;
  $9_1 = HEAP32[$3_1 >> 2];
  $1_1 = $22_1 + 8 | 0;
  $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = $10_1 + $14_1 | 0;
  $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $12_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = $5_1;
  $9_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $22_1 = HEAP32[$6_1 + 4992 >> 2];
  $1_1 = HEAP32[$6_1 + 5056 >> 2];
  $12_1 = $22_1 + $1_1 | 0;
  $29_1 = HEAP32[$6_1 + 4996 >> 2];
  $3_1 = $29_1 + HEAP32[$6_1 + 5060 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 4736 >> 2];
  $10_1 = $1_1 + $12_1 | 0;
  $17_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 4740 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $25_1 = $6_1 + 4624 | 0;
  $28_1 = $25_1;
  $5_1 = $9_1 + $10_1 | 0;
  $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
  $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
  $1_1 = $21_1 + 8 | 0;
  $26_1 = HEAP32[$1_1 >> 2];
  $21_1 = HEAP32[$1_1 + 4 >> 2];
  $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
  $3_1 = $19_1 + 8 | 0;
  $10_1 = HEAP32[$3_1 >> 2];
  $1_1 = $23_1 + 8 | 0;
  $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $12_1 + $17_1 | 0;
  $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
  $12_1 = $1_1;
  $1_1 = $1_1 + $26_1 | 0;
  $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $1_1 + $24_1 | 0;
  $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $10_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $9_1;
  $17_1 = $1_1 << 12 | $9_1 >>> 20;
  $4_1 = $3_1;
  $12_1 = $3_1 << 12 | $1_1 >>> 20;
  $29_1 = HEAP32[$6_1 + 4724 >> 2];
  $3_1 = $29_1 + ($15_1 & 1048575) | 0;
  $22_1 = HEAP32[$6_1 + 4720 >> 2];
  $9_1 = $18_1 & -2;
  $1_1 = $22_1 + $9_1 | 0;
  $15_1 = $1_1;
  $1_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $12_1 | 0;
  $12_1 = $15_1 + $17_1 | 0;
  $9_1 = $12_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $20_1 = $9_1 & 1048575;
  $18_1 = $20_1;
  $3_1 = $13_1 & 1048575;
  $32_1 = $3_1;
  $13_1 = $7_1;
  $3_1 = $3_1 << 1 | $7_1 >>> 31;
  $21_1 = $7_1 << 1;
  $26_1 = $3_1;
  $69($28_1, $12_1, $18_1, 0, 0, $21_1, $3_1, 0, 0);
  $3_1 = $14_1 & 1048575;
  $33_1 = $3_1;
  $23_1 = $6_1 + 4576 | 0;
  $18_1 = $10_1 & 1048575;
  $7_1 = $8_1 << 1;
  $28_1 = $8_1;
  $10_1 = $3_1 << 1 | $8_1 >>> 31;
  $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
  $19_1 = $6_1 + 4528 | 0;
  $17_1 = $16_1 & 65535;
  $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
  $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
  $1_1 = $27_1 + 8 | 0;
  $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $16_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $9_1 >>> 20;
  $4_1 = $8_1 + $11_1 | 0;
  $3_1 = $17_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
  $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($19_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
  $11_1 = $6_1 + 4512 | 0;
  $69($11_1, HEAP32[$6_1 + 4528 >> 2], HEAP32[$6_1 + 4532 >> 2], 0, 0, 15632, 16, 0, 0);
  $1_1 = $4_1;
  $3_1 = $3_1 << 1 | $1_1 >>> 31;
  $39_1 = $6_1 + 4480 | 0;
  $24_1 = $1_1 << 1;
  $17_1 = $3_1;
  $69($39_1, $24_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
  $38_1 = $6_1 + 4560 | 0;
  $69($38_1, $12_1, $20_1, 0, 0, $7_1, $10_1, 0, 0);
  $35_1 = $6_1 + 4672 | 0;
  $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
  $22_1 = $6_1 + 4496 | 0;
  $1_1 = $19_1 + 8 | 0;
  $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $36_1 = $6_1 + 4640 | 0;
  $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
  $31_1 = $6_1 + 4464 | 0;
  $69($31_1, $24_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
  $37_1 = $6_1 + 4544 | 0;
  $16_1 = $12_1;
  $13_1 = $20_1;
  $9_1 = $18_1;
  $18_1 = $5_1;
  $69($37_1, $12_1, $13_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
  $8_1 = HEAP32[$6_1 + 4624 >> 2];
  $4_1 = HEAP32[$6_1 + 4576 >> 2];
  $1_1 = $8_1 + $4_1 | 0;
  $12_1 = HEAP32[$6_1 + 4628 >> 2];
  $3_1 = $12_1 + HEAP32[$6_1 + 4580 >> 2] | 0;
  $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = HEAP32[$6_1 + 4512 >> 2];
  $14_1 = $4_1 + $1_1 | 0;
  $5_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 4516 >> 2] | 0;
  $4_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
  $3_1 = $11_1 + 8 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $7_1 = HEAP32[$3_1 + 4 >> 2];
  $8_1 = ($5_1 | 0) == ($12_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $12_1 >>> 0;
  $3_1 = $23_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $25_1 + 8 | 0;
  $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $12_1 | 0;
  $3_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $11_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $10_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $4_1;
  $7_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $30_1 = HEAP32[$6_1 + 4560 >> 2];
  $1_1 = HEAP32[$6_1 + 4672 >> 2];
  $15_1 = $30_1 + $1_1 | 0;
  $34_1 = HEAP32[$6_1 + 4564 >> 2];
  $3_1 = $34_1 + HEAP32[$6_1 + 4676 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 4480 >> 2];
  $10_1 = $1_1 + $15_1 | 0;
  $4_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 4484 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 4496 >> 2];
  $11_1 = $1_1 + $10_1 | 0;
  $20_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 4500 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $32_1 = $6_1 + 4368 | 0;
  $29_1 = $32_1;
  $8_1 = $7_1 + $11_1 | 0;
  $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $27_1 = ($1_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
  $25_1 = ($1_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 < $20_1 >>> 0;
  $1_1 = $22_1 + 8 | 0;
  $23_1 = HEAP32[$1_1 >> 2];
  $19_1 = HEAP32[$1_1 + 4 >> 2];
  $22_1 = ($4_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $20_1 >>> 0;
  $1_1 = $39_1 + 8 | 0;
  $20_1 = HEAP32[$1_1 >> 2];
  $10_1 = HEAP32[$1_1 + 4 >> 2];
  $11_1 = ($4_1 | 0) == ($34_1 | 0) & $15_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
  $3_1 = $35_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $38_1 + 8 | 0;
  $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $11_1 + $15_1 | 0;
  $3_1 = ($1_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $22_1 | 0;
  $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $23_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1 + $25_1 | 0;
  $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $27_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $7_1;
  $11_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $7_1 = $3_1 << 12 | $1_1 >>> 20;
  $19_1 = HEAP32[$6_1 + 4464 >> 2];
  $1_1 = HEAP32[$6_1 + 4544 >> 2];
  $15_1 = $19_1 + $1_1 | 0;
  $30_1 = HEAP32[$6_1 + 4468 >> 2];
  $3_1 = $30_1 + HEAP32[$6_1 + 4548 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $7_1 | 0;
  $11_1 = $11_1 + $15_1 | 0;
  $3_1 = $11_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $22_1 = $11_1 << 4 & -16;
  $7_1 = $3_1;
  $20_1 = ($3_1 << 4 | $11_1 >>> 28) & 16777215;
  $10_1 = $4_1;
  $69($29_1, $22_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
  $29_1 = $6_1 + 4608 | 0;
  $69($29_1, $28_1, $33_1, 0, 0, $21_1, $26_1, 0, 0);
  $27_1 = $6_1 + 4448 | 0;
  $69($27_1, $24_1, $17_1, 0, 0, $18_1, $9_1, 0, 0);
  $25_1 = $6_1 + 4688 | 0;
  $69($25_1, $16_1, $13_1, 0, 0, $16_1, $13_1, 0, 0);
  $23_1 = $6_1 + 4432 | 0;
  $22_1 = $23_1;
  $20_1 = ($1_1 | 0) == ($3_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $11_1 = ($1_1 | 0) == ($30_1 | 0) & $15_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
  $3_1 = $37_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $31_1 + 8 | 0;
  $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $11_1 + $15_1 | 0;
  $3_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 << 12 | $7_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $20_1 = HEAP32[$6_1 + 4448 >> 2];
  $1_1 = HEAP32[$6_1 + 4688 >> 2];
  $11_1 = $20_1 + $1_1 | 0;
  $30_1 = HEAP32[$6_1 + 4452 >> 2];
  $3_1 = $30_1 + HEAP32[$6_1 + 4692 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $7_1 = $7_1 + $11_1 | 0;
  $3_1 = $7_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $3_1;
  $69($22_1, $7_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $19_1 = $6_1 + 4592 | 0;
  $69($19_1, $18_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
  $22_1 = $6_1 + 4656 | 0;
  $69($22_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
  $15_1 = $6_1 + 4416 | 0;
  $69($15_1, $16_1, $13_1, 0, 0, $24_1, $17_1, 0, 0);
  $18_1 = $6_1 + 4400 | 0;
  $13_1 = $18_1;
  $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $11_1 = ($1_1 | 0) == ($30_1 | 0) & $11_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
  $3_1 = $25_1 + 8 | 0;
  $7_1 = HEAP32[$3_1 >> 2];
  $1_1 = $27_1 + 8 | 0;
  $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $11_1 + $16_1 | 0;
  $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $7_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 << 12 | $5_1 >>> 20;
  $5_1 = HEAP32[$6_1 + 4416 >> 2];
  $9_1 = $7_1 + $5_1 | 0;
  $4_1 = $3_1;
  $1_1 = $3_1 << 12 | $1_1 >>> 20;
  $3_1 = $1_1 + HEAP32[$6_1 + 4420 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($13_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
  $20_1 = $6_1 + 4384 | 0;
  $11_1 = $20_1;
  $7_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $1_1 = $15_1 + 8 | 0;
  $5_1 = HEAP32[$1_1 >> 2];
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $7_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($11_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
  $4_1 = HEAP32[$6_1 + 4368 >> 2];
  $1_1 = HEAP32[$6_1 + 4640 >> 2];
  $9_1 = $4_1 + $1_1 | 0;
  $7_1 = HEAP32[$6_1 + 4372 >> 2];
  $3_1 = $7_1 + HEAP32[$6_1 + 4644 >> 2] | 0;
  $30_1 = $6_1 + 7456 | 0;
  $27_1 = $30_1 + 8 | 0;
  $17_1 = $27_1;
  $5_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = ($7_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $9_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
  $3_1 = $36_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $32_1 + 8 | 0;
  $11_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $7_1 + $11_1 | 0;
  $3_1 = $1_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $11_1 = $5_1;
  $7_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $16_1 = $3_1 << 12 | $1_1 >>> 20;
  $21_1 = HEAP32[$6_1 + 4436 >> 2];
  $3_1 = $21_1 + HEAP32[$6_1 + 4612 >> 2] | 0;
  $15_1 = HEAP32[$6_1 + 4432 >> 2];
  $1_1 = HEAP32[$6_1 + 4608 >> 2];
  $5_1 = $15_1 + $1_1 | 0;
  $13_1 = $5_1;
  $7_1 = $5_1 + $7_1 | 0;
  $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $16_1 | 0;
  HEAP32[$17_1 >> 2] = $7_1;
  $5_1 = $7_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$17_1 + 4 >> 2] = $5_1 & 1048575;
  $25_1 = $30_1 + 16 | 0;
  $17_1 = $25_1;
  $16_1 = ($1_1 | 0) == ($5_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
  $13_1 = ($1_1 | 0) == ($21_1 | 0) & $13_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 < $21_1 >>> 0;
  $3_1 = $29_1 + 8 | 0;
  $7_1 = HEAP32[$3_1 >> 2];
  $1_1 = $23_1 + 8 | 0;
  $15_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $7_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $13_1 + $15_1 | 0;
  $3_1 = $7_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $7_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $16_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $24_1 = HEAP32[$6_1 + 4592 >> 2];
  $1_1 = HEAP32[$6_1 + 4656 >> 2];
  $16_1 = $24_1 + $1_1 | 0;
  $23_1 = HEAP32[$6_1 + 4596 >> 2];
  $3_1 = $23_1 + HEAP32[$6_1 + 4660 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 4400 >> 2];
  $13_1 = $1_1 + $16_1 | 0;
  $15_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 4404 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $7_1 = $7_1 + $13_1 | 0;
  $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$17_1 >> 2] = $7_1;
  $5_1 = $3_1;
  HEAP32[$17_1 + 4 >> 2] = $3_1 & 1048575;
  $28_1 = $30_1 + 24 | 0;
  $26_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $21_1 = ($1_1 | 0) == ($15_1 | 0) & $13_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 < $15_1 >>> 0;
  $1_1 = $18_1 + 8 | 0;
  $17_1 = HEAP32[$1_1 >> 2];
  $18_1 = HEAP32[$1_1 + 4 >> 2];
  $13_1 = ($15_1 | 0) == ($23_1 | 0) & $16_1 >>> 0 < $24_1 >>> 0 | $15_1 >>> 0 < $23_1 >>> 0;
  $3_1 = $22_1 + 8 | 0;
  $7_1 = HEAP32[$3_1 >> 2];
  $1_1 = $19_1 + 8 | 0;
  $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $13_1 + $16_1 | 0;
  $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
  $7_1 = $1_1;
  $1_1 = $1_1 + $17_1 | 0;
  $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 + $21_1 | 0;
  $3_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $7_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $26_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $7_1 = $3_1 << 12 | $1_1 >>> 20;
  $16_1 = HEAP32[$6_1 + 4384 >> 2];
  $5_1 = $14_1 & -2;
  $1_1 = $16_1 + $5_1 | 0;
  $17_1 = HEAP32[$6_1 + 4388 >> 2];
  $3_1 = $17_1 + ($12_1 & 1048575) | 0;
  $14_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $14_1 + $7_1 | 0;
  $12_1 = $1_1;
  $5_1 = $1_1 + $13_1 | 0;
  HEAP32[$28_1 >> 2] = $5_1;
  $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$28_1 + 4 >> 2] = $1_1 & 1048575;
  $18_1 = $30_1 + 32 | 0;
  $15_1 = $18_1;
  $7_1 = $8_1;
  $13_1 = $10_1 & 65535;
  $10_1 = ($1_1 | 0) == ($14_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
  $5_1 = ($14_1 | 0) == ($17_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $14_1 >>> 0 < $17_1 >>> 0;
  $3_1 = $20_1 + 8 | 0;
  $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
  $3_1 = HEAP32[$3_1 + 4 >> 2];
  $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $5_1 = $4_1;
  $4_1 = $4_1 + $8_1 | 0;
  $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $4_1;
  $4_1 = $4_1 + $10_1 | 0;
  $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $4_1 << 12 | $1_1 >>> 20;
  $5_1 = $1_1 + $7_1 | 0;
  $3_1 = $13_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
  HEAP32[$15_1 >> 2] = $5_1;
  HEAP32[$15_1 + 4 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$6_1 + 7456 >> 2] = $9_1;
  HEAP32[$6_1 + 7460 >> 2] = $11_1 & 1048575;
  $34($30_1, $30_1, $42_1);
  $1_1 = HEAP32[$6_1 + 7460 >> 2];
  $22_1 = $1_1;
  $20_1 = HEAP32[$6_1 + 7456 >> 2];
  $7_1 = $20_1;
  $3_1 = $1_1 << 1 | $7_1 >>> 31;
  $15_1 = $6_1 + 4208 | 0;
  $12_1 = HEAP32[$28_1 >> 2];
  $10_1 = HEAP32[$28_1 + 4 >> 2];
  $21_1 = $7_1 << 1;
  $26_1 = $3_1;
  $69($15_1, $12_1, $10_1, 0, 0, $21_1, $3_1, 0, 0);
  $1_1 = HEAP32[$27_1 + 4 >> 2];
  $41_1 = $1_1;
  $33_1 = HEAP32[$27_1 >> 2];
  $4_1 = $33_1;
  $3_1 = $1_1 << 1 | $4_1 >>> 31;
  $16_1 = $6_1 + 4304 | 0;
  $13_1 = HEAP32[$25_1 >> 2];
  $9_1 = HEAP32[$25_1 + 4 >> 2];
  $4_1 = $4_1 << 1;
  $5_1 = $3_1;
  $69($16_1, $13_1, $9_1, 0, 0, $4_1, $3_1, 0, 0);
  $14_1 = $6_1 + 4192 | 0;
  $8_1 = HEAP32[$18_1 >> 2];
  $1_1 = HEAP32[$18_1 + 4 >> 2];
  $69($14_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
  $11_1 = $6_1 + 4176 | 0;
  $69($11_1, HEAP32[$6_1 + 4192 >> 2], HEAP32[$6_1 + 4196 >> 2], 0, 0, 15632, 16, 0, 0);
  $3_1 = $1_1 << 1 | $8_1 >>> 31;
  $39_1 = $6_1 + 4144 | 0;
  $24_1 = $8_1 << 1;
  $17_1 = $3_1;
  $69($39_1, $24_1, $3_1, 0, 0, $7_1, $22_1, 0, 0);
  $38_1 = $6_1 + 4224 | 0;
  $69($38_1, $12_1, $10_1, 0, 0, $4_1, $5_1, 0, 0);
  $35_1 = $6_1 + 4288 | 0;
  $69($35_1, $13_1, $9_1, 0, 0, $13_1, $9_1, 0, 0);
  $28_1 = $6_1 + 4160 | 0;
  $1_1 = $14_1 + 8 | 0;
  $69($28_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $36_1 = $6_1 + 4352 | 0;
  $69($36_1, $7_1, $22_1, 0, 0, $7_1, $22_1, 0, 0);
  $31_1 = $6_1 + 4128 | 0;
  $69($31_1, $24_1, $3_1, 0, 0, $33_1, $41_1, 0, 0);
  $37_1 = $6_1 + 4240 | 0;
  $69($37_1, $12_1, $10_1, 0, 0, $13_1 << 1, $9_1 << 1 | $13_1 >>> 31, 0, 0);
  $20_1 = HEAP32[$6_1 + 4212 >> 2];
  $3_1 = $20_1 + HEAP32[$6_1 + 4308 >> 2] | 0;
  $8_1 = HEAP32[$6_1 + 4208 >> 2];
  $4_1 = HEAP32[$6_1 + 4304 >> 2];
  $1_1 = $8_1 + $4_1 | 0;
  $5_1 = HEAP32[$6_1 + 4176 >> 2];
  $18_1 = $1_1 + $5_1 | 0;
  $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1 + HEAP32[$6_1 + 4180 >> 2] | 0;
  $5_1 = $5_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
  $3_1 = $11_1 + 8 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $7_1 = HEAP32[$3_1 + 4 >> 2];
  $8_1 = ($4_1 | 0) == ($20_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $20_1 >>> 0;
  $3_1 = $16_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $15_1 + 8 | 0;
  $16_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $16_1 | 0;
  $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $11_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $14_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $15_1 = $5_1;
  $11_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $30_1 = HEAP32[$6_1 + 4224 >> 2];
  $1_1 = HEAP32[$6_1 + 4288 >> 2];
  $14_1 = $30_1 + $1_1 | 0;
  $34_1 = HEAP32[$6_1 + 4228 >> 2];
  $3_1 = $34_1 + HEAP32[$6_1 + 4292 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 4144 >> 2];
  $7_1 = $1_1 + $14_1 | 0;
  $20_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 4148 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 4160 >> 2];
  $5_1 = $1_1 + $7_1 | 0;
  $16_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 4164 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $32_1 = $6_1 + 4112 | 0;
  $29_1 = $32_1;
  $11_1 = $5_1 + $11_1 | 0;
  $8_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $27_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
  $25_1 = ($1_1 | 0) == ($16_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
  $1_1 = $28_1 + 8 | 0;
  $23_1 = HEAP32[$1_1 >> 2];
  $19_1 = HEAP32[$1_1 + 4 >> 2];
  $22_1 = ($16_1 | 0) == ($20_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $16_1 >>> 0 < $20_1 >>> 0;
  $1_1 = $39_1 + 8 | 0;
  $28_1 = HEAP32[$1_1 >> 2];
  $16_1 = HEAP32[$1_1 + 4 >> 2];
  $7_1 = ($20_1 | 0) == ($34_1 | 0) & $14_1 >>> 0 < $30_1 >>> 0 | $20_1 >>> 0 < $34_1 >>> 0;
  $3_1 = $35_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $38_1 + 8 | 0;
  $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $7_1 + $14_1 | 0;
  $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $28_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $22_1 | 0;
  $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $23_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1 + $25_1 | 0;
  $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $27_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $8_1;
  $7_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $19_1 = HEAP32[$6_1 + 4128 >> 2];
  $1_1 = HEAP32[$6_1 + 4240 >> 2];
  $14_1 = $19_1 + $1_1 | 0;
  $23_1 = HEAP32[$6_1 + 4132 >> 2];
  $3_1 = $23_1 + HEAP32[$6_1 + 4244 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $7_1 = $7_1 + $14_1 | 0;
  $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $28_1 = $7_1 << 4 & -16;
  $8_1 = $3_1;
  $20_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
  $16_1 = $4_1;
  $69($29_1, $28_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
  $29_1 = $6_1 + 4336 | 0;
  $69($29_1, $33_1, $41_1, 0, 0, $21_1, $26_1, 0, 0);
  $25_1 = $6_1 + 4080 | 0;
  $69($25_1, $24_1, $17_1, 0, 0, $13_1, $9_1, 0, 0);
  $22_1 = $6_1 + 4256 | 0;
  $69($22_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
  $28_1 = $6_1 + 4064 | 0;
  $20_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
  $3_1 = $37_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $31_1 + 8 | 0;
  $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $7_1 + $14_1 | 0;
  $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $8_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $20_1 = HEAP32[$6_1 + 4080 >> 2];
  $1_1 = HEAP32[$6_1 + 4256 >> 2];
  $7_1 = $20_1 + $1_1 | 0;
  $27_1 = HEAP32[$6_1 + 4084 >> 2];
  $3_1 = $27_1 + HEAP32[$6_1 + 4260 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $8_1 = $7_1 + $8_1 | 0;
  $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $3_1;
  $69($28_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $23_1 = $6_1 + 4272 | 0;
  $69($23_1, $13_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
  $19_1 = $6_1 + 4320 | 0;
  $69($19_1, $33_1, $41_1, 0, 0, $33_1, $41_1, 0, 0);
  $14_1 = $6_1 + 4016 | 0;
  $69($14_1, $24_1, $17_1, 0, 0, $12_1, $10_1, 0, 0);
  $21_1 = $6_1 + 4e3 | 0;
  $10_1 = $21_1;
  $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $7_1 = ($1_1 | 0) == ($27_1 | 0) & $7_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $27_1 >>> 0;
  $3_1 = $22_1 + 8 | 0;
  $8_1 = HEAP32[$3_1 >> 2];
  $1_1 = $25_1 + 8 | 0;
  $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $7_1 + $12_1 | 0;
  $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $5_1 >>> 20;
  $5_1 = HEAP32[$6_1 + 4016 >> 2];
  $9_1 = $8_1 + $5_1 | 0;
  $4_1 = $3_1;
  $1_1 = $3_1 << 12 | $1_1 >>> 20;
  $3_1 = $1_1 + HEAP32[$6_1 + 4020 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
  $27_1 = $6_1 + 3936 | 0;
  $7_1 = $27_1;
  $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $1_1 = $14_1 + 8 | 0;
  $5_1 = HEAP32[$1_1 >> 2];
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
  $4_1 = HEAP32[$6_1 + 4112 >> 2];
  $1_1 = HEAP32[$6_1 + 4352 >> 2];
  $7_1 = $4_1 + $1_1 | 0;
  $8_1 = HEAP32[$6_1 + 4116 >> 2];
  $3_1 = $8_1 + HEAP32[$6_1 + 4356 >> 2] | 0;
  $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
  $3_1 = $36_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $32_1 + 8 | 0;
  $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $9_1 | 0;
  $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $5_1;
  $8_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $10_1 = HEAP32[$6_1 + 4064 >> 2];
  $1_1 = HEAP32[$6_1 + 4336 >> 2];
  $9_1 = $10_1 + $1_1 | 0;
  $14_1 = HEAP32[$6_1 + 4068 >> 2];
  $3_1 = $14_1 + HEAP32[$6_1 + 4340 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $8_1 = $8_1 + $9_1 | 0;
  $5_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
  $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
  $3_1 = $29_1 + 8 | 0;
  $9_1 = HEAP32[$3_1 >> 2];
  $1_1 = $28_1 + 8 | 0;
  $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = $10_1 + $14_1 | 0;
  $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $12_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = $5_1;
  $9_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $22_1 = HEAP32[$6_1 + 4272 >> 2];
  $1_1 = HEAP32[$6_1 + 4320 >> 2];
  $12_1 = $22_1 + $1_1 | 0;
  $29_1 = HEAP32[$6_1 + 4276 >> 2];
  $3_1 = $29_1 + HEAP32[$6_1 + 4324 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 4e3 >> 2];
  $10_1 = $1_1 + $12_1 | 0;
  $17_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 4004 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $25_1 = $6_1 + 3920 | 0;
  $28_1 = $25_1;
  $5_1 = $9_1 + $10_1 | 0;
  $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
  $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
  $1_1 = $21_1 + 8 | 0;
  $26_1 = HEAP32[$1_1 >> 2];
  $21_1 = HEAP32[$1_1 + 4 >> 2];
  $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
  $3_1 = $19_1 + 8 | 0;
  $10_1 = HEAP32[$3_1 >> 2];
  $1_1 = $23_1 + 8 | 0;
  $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $12_1 + $17_1 | 0;
  $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
  $12_1 = $1_1;
  $1_1 = $1_1 + $26_1 | 0;
  $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $1_1 + $24_1 | 0;
  $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $10_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $9_1;
  $12_1 = $1_1 << 12 | $9_1 >>> 20;
  $4_1 = $3_1;
  $17_1 = $3_1 << 12 | $1_1 >>> 20;
  $29_1 = HEAP32[$6_1 + 3940 >> 2];
  $3_1 = $29_1 + ($15_1 & 1048575) | 0;
  $22_1 = HEAP32[$6_1 + 3936 >> 2];
  $1_1 = $18_1 & -2;
  $9_1 = $22_1 + $1_1 | 0;
  $15_1 = $9_1;
  $12_1 = $9_1 + $12_1 | 0;
  $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $17_1 | 0;
  $9_1 = $12_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $20_1 = $9_1 & 1048575;
  $18_1 = $20_1;
  $3_1 = $13_1 & 1048575;
  $32_1 = $3_1;
  $13_1 = $7_1;
  $3_1 = $3_1 << 1 | $7_1 >>> 31;
  $21_1 = $7_1 << 1;
  $26_1 = $3_1;
  $69($28_1, $12_1, $18_1, 0, 0, $21_1, $3_1, 0, 0);
  $3_1 = $14_1 & 1048575;
  $33_1 = $3_1;
  $23_1 = $6_1 + 3952 | 0;
  $18_1 = $10_1 & 1048575;
  $7_1 = $8_1 << 1;
  $28_1 = $8_1;
  $10_1 = $3_1 << 1 | $8_1 >>> 31;
  $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
  $19_1 = $6_1 + 3856 | 0;
  $17_1 = $16_1 & 65535;
  $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
  $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
  $1_1 = $27_1 + 8 | 0;
  $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $16_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $9_1 >>> 20;
  $4_1 = $8_1 + $11_1 | 0;
  $3_1 = $17_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
  $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($19_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
  $11_1 = $6_1 + 3840 | 0;
  $69($11_1, HEAP32[$6_1 + 3856 >> 2], HEAP32[$6_1 + 3860 >> 2], 0, 0, 15632, 16, 0, 0);
  $1_1 = $4_1;
  $3_1 = $3_1 << 1 | $1_1 >>> 31;
  $39_1 = $6_1 + 3808 | 0;
  $24_1 = $1_1 << 1;
  $17_1 = $3_1;
  $69($39_1, $24_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
  $38_1 = $6_1 + 3904 | 0;
  $69($38_1, $12_1, $20_1, 0, 0, $7_1, $10_1, 0, 0);
  $35_1 = $6_1 + 3968 | 0;
  $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
  $22_1 = $6_1 + 3824 | 0;
  $1_1 = $19_1 + 8 | 0;
  $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $36_1 = $6_1 + 4096 | 0;
  $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
  $31_1 = $6_1 + 3792 | 0;
  $69($31_1, $24_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
  $37_1 = $6_1 + 3872 | 0;
  $16_1 = $12_1;
  $13_1 = $20_1;
  $9_1 = $18_1;
  $18_1 = $5_1;
  $69($37_1, $12_1, $13_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
  $8_1 = HEAP32[$6_1 + 3920 >> 2];
  $4_1 = HEAP32[$6_1 + 3952 >> 2];
  $1_1 = $8_1 + $4_1 | 0;
  $12_1 = HEAP32[$6_1 + 3924 >> 2];
  $3_1 = $12_1 + HEAP32[$6_1 + 3956 >> 2] | 0;
  $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = HEAP32[$6_1 + 3840 >> 2];
  $14_1 = $4_1 + $1_1 | 0;
  $5_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 3844 >> 2] | 0;
  $4_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
  $3_1 = $11_1 + 8 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $7_1 = HEAP32[$3_1 + 4 >> 2];
  $8_1 = ($5_1 | 0) == ($12_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $12_1 >>> 0;
  $3_1 = $23_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $25_1 + 8 | 0;
  $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $12_1 | 0;
  $3_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $11_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $10_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $4_1;
  $7_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $30_1 = HEAP32[$6_1 + 3904 >> 2];
  $1_1 = HEAP32[$6_1 + 3968 >> 2];
  $15_1 = $30_1 + $1_1 | 0;
  $34_1 = HEAP32[$6_1 + 3908 >> 2];
  $3_1 = $34_1 + HEAP32[$6_1 + 3972 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 3808 >> 2];
  $10_1 = $1_1 + $15_1 | 0;
  $4_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 3812 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 3824 >> 2];
  $11_1 = $1_1 + $10_1 | 0;
  $20_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 3828 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $32_1 = $6_1 + 3696 | 0;
  $29_1 = $32_1;
  $8_1 = $7_1 + $11_1 | 0;
  $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $27_1 = ($1_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
  $25_1 = ($1_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 < $20_1 >>> 0;
  $1_1 = $22_1 + 8 | 0;
  $23_1 = HEAP32[$1_1 >> 2];
  $19_1 = HEAP32[$1_1 + 4 >> 2];
  $22_1 = ($4_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $20_1 >>> 0;
  $1_1 = $39_1 + 8 | 0;
  $20_1 = HEAP32[$1_1 >> 2];
  $10_1 = HEAP32[$1_1 + 4 >> 2];
  $11_1 = ($4_1 | 0) == ($34_1 | 0) & $15_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
  $3_1 = $35_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $38_1 + 8 | 0;
  $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $11_1 + $15_1 | 0;
  $3_1 = ($1_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $22_1 | 0;
  $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $23_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1 + $25_1 | 0;
  $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $27_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $7_1;
  $11_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $7_1 = $3_1 << 12 | $1_1 >>> 20;
  $19_1 = HEAP32[$6_1 + 3792 >> 2];
  $1_1 = HEAP32[$6_1 + 3872 >> 2];
  $15_1 = $19_1 + $1_1 | 0;
  $30_1 = HEAP32[$6_1 + 3796 >> 2];
  $3_1 = $30_1 + HEAP32[$6_1 + 3876 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $7_1 | 0;
  $11_1 = $11_1 + $15_1 | 0;
  $3_1 = $11_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $22_1 = $11_1 << 4 & -16;
  $7_1 = $3_1;
  $20_1 = ($3_1 << 4 | $11_1 >>> 28) & 16777215;
  $10_1 = $4_1;
  $69($29_1, $22_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
  $29_1 = $6_1 + 4032 | 0;
  $69($29_1, $28_1, $33_1, 0, 0, $21_1, $26_1, 0, 0);
  $27_1 = $6_1 + 3776 | 0;
  $69($27_1, $24_1, $17_1, 0, 0, $18_1, $9_1, 0, 0);
  $25_1 = $6_1 + 3888 | 0;
  $69($25_1, $16_1, $13_1, 0, 0, $16_1, $13_1, 0, 0);
  $23_1 = $6_1 + 3760 | 0;
  $22_1 = $23_1;
  $20_1 = ($1_1 | 0) == ($3_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $11_1 = ($1_1 | 0) == ($30_1 | 0) & $15_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
  $3_1 = $37_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $31_1 + 8 | 0;
  $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $11_1 + $15_1 | 0;
  $3_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 << 12 | $7_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $20_1 = HEAP32[$6_1 + 3776 >> 2];
  $1_1 = HEAP32[$6_1 + 3888 >> 2];
  $11_1 = $20_1 + $1_1 | 0;
  $30_1 = HEAP32[$6_1 + 3780 >> 2];
  $3_1 = $30_1 + HEAP32[$6_1 + 3892 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $7_1 = $7_1 + $11_1 | 0;
  $3_1 = $7_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $3_1;
  $69($22_1, $7_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $19_1 = $6_1 + 3984 | 0;
  $69($19_1, $18_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
  $22_1 = $6_1 + 4048 | 0;
  $69($22_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
  $15_1 = $6_1 + 3744 | 0;
  $69($15_1, $16_1, $13_1, 0, 0, $24_1, $17_1, 0, 0);
  $18_1 = $6_1 + 3728 | 0;
  $13_1 = $18_1;
  $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $11_1 = ($1_1 | 0) == ($30_1 | 0) & $11_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
  $3_1 = $25_1 + 8 | 0;
  $7_1 = HEAP32[$3_1 >> 2];
  $1_1 = $27_1 + 8 | 0;
  $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $11_1 + $16_1 | 0;
  $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $7_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 << 12 | $5_1 >>> 20;
  $5_1 = HEAP32[$6_1 + 3744 >> 2];
  $9_1 = $7_1 + $5_1 | 0;
  $4_1 = $3_1;
  $1_1 = $3_1 << 12 | $1_1 >>> 20;
  $3_1 = $1_1 + HEAP32[$6_1 + 3748 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($13_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
  $20_1 = $6_1 + 3712 | 0;
  $11_1 = $20_1;
  $7_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $1_1 = $15_1 + 8 | 0;
  $5_1 = HEAP32[$1_1 >> 2];
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $7_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($11_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
  $4_1 = HEAP32[$6_1 + 3696 >> 2];
  $1_1 = HEAP32[$6_1 + 4096 >> 2];
  $9_1 = $4_1 + $1_1 | 0;
  $7_1 = HEAP32[$6_1 + 3700 >> 2];
  $3_1 = $7_1 + HEAP32[$6_1 + 4100 >> 2] | 0;
  $30_1 = $6_1 + 7416 | 0;
  $27_1 = $30_1 + 8 | 0;
  $17_1 = $27_1;
  $5_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = ($7_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $9_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
  $3_1 = $36_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $32_1 + 8 | 0;
  $11_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $7_1 + $11_1 | 0;
  $3_1 = $1_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $11_1 = $5_1;
  $7_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $16_1 = $3_1 << 12 | $1_1 >>> 20;
  $21_1 = HEAP32[$6_1 + 3764 >> 2];
  $3_1 = $21_1 + HEAP32[$6_1 + 4036 >> 2] | 0;
  $15_1 = HEAP32[$6_1 + 3760 >> 2];
  $1_1 = HEAP32[$6_1 + 4032 >> 2];
  $5_1 = $15_1 + $1_1 | 0;
  $13_1 = $5_1;
  $7_1 = $5_1 + $7_1 | 0;
  $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $16_1 | 0;
  HEAP32[$17_1 >> 2] = $7_1;
  $5_1 = $7_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$17_1 + 4 >> 2] = $5_1 & 1048575;
  $25_1 = $30_1 + 16 | 0;
  $17_1 = $25_1;
  $16_1 = ($1_1 | 0) == ($5_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
  $13_1 = ($1_1 | 0) == ($21_1 | 0) & $13_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 < $21_1 >>> 0;
  $3_1 = $29_1 + 8 | 0;
  $7_1 = HEAP32[$3_1 >> 2];
  $1_1 = $23_1 + 8 | 0;
  $15_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $7_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $13_1 + $15_1 | 0;
  $3_1 = $7_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $7_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $16_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $24_1 = HEAP32[$6_1 + 3984 >> 2];
  $1_1 = HEAP32[$6_1 + 4048 >> 2];
  $16_1 = $24_1 + $1_1 | 0;
  $23_1 = HEAP32[$6_1 + 3988 >> 2];
  $3_1 = $23_1 + HEAP32[$6_1 + 4052 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 3728 >> 2];
  $13_1 = $1_1 + $16_1 | 0;
  $15_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 3732 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $7_1 = $7_1 + $13_1 | 0;
  $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$17_1 >> 2] = $7_1;
  $5_1 = $3_1;
  HEAP32[$17_1 + 4 >> 2] = $3_1 & 1048575;
  $28_1 = $30_1 + 24 | 0;
  $26_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $21_1 = ($1_1 | 0) == ($15_1 | 0) & $13_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 < $15_1 >>> 0;
  $1_1 = $18_1 + 8 | 0;
  $17_1 = HEAP32[$1_1 >> 2];
  $18_1 = HEAP32[$1_1 + 4 >> 2];
  $13_1 = ($15_1 | 0) == ($23_1 | 0) & $16_1 >>> 0 < $24_1 >>> 0 | $15_1 >>> 0 < $23_1 >>> 0;
  $3_1 = $22_1 + 8 | 0;
  $7_1 = HEAP32[$3_1 >> 2];
  $1_1 = $19_1 + 8 | 0;
  $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $13_1 + $16_1 | 0;
  $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
  $7_1 = $1_1;
  $1_1 = $1_1 + $17_1 | 0;
  $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 + $21_1 | 0;
  $3_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $7_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $26_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $7_1 = $3_1 << 12 | $1_1 >>> 20;
  $16_1 = HEAP32[$6_1 + 3712 >> 2];
  $5_1 = $14_1 & -2;
  $1_1 = $16_1 + $5_1 | 0;
  $18_1 = HEAP32[$6_1 + 3716 >> 2];
  $3_1 = $18_1 + ($12_1 & 1048575) | 0;
  $14_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $14_1 + $7_1 | 0;
  $12_1 = $1_1;
  $5_1 = $1_1 + $13_1 | 0;
  HEAP32[$28_1 >> 2] = $5_1;
  $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$28_1 + 4 >> 2] = $1_1 & 1048575;
  $15_1 = $30_1 + 32 | 0;
  $7_1 = $8_1;
  $13_1 = $10_1 & 65535;
  $10_1 = ($1_1 | 0) == ($14_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
  $5_1 = ($14_1 | 0) == ($18_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $14_1 >>> 0 < $18_1 >>> 0;
  $3_1 = $20_1 + 8 | 0;
  $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
  $3_1 = HEAP32[$3_1 + 4 >> 2];
  $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $5_1 = $4_1;
  $4_1 = $4_1 + $8_1 | 0;
  $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $4_1;
  $4_1 = $4_1 + $10_1 | 0;
  $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $4_1 << 12 | $1_1 >>> 20;
  $5_1 = $1_1 + $7_1 | 0;
  $3_1 = $13_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
  HEAP32[$15_1 >> 2] = $5_1;
  HEAP32[$15_1 + 4 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$6_1 + 7416 >> 2] = $9_1;
  HEAP32[$6_1 + 7420 >> 2] = $11_1 & 1048575;
  $34($30_1, $30_1, $40_1);
  $9_1 = HEAP32[$15_1 + 4 >> 2];
  $3_1 = $6_1 + 7376 | 0;
  $1_1 = $3_1 + 32 | 0;
  $4_1 = HEAP32[$15_1 >> 2];
  HEAP32[$1_1 >> 2] = $4_1;
  HEAP32[$1_1 + 4 >> 2] = $9_1;
  $10_1 = HEAP32[$28_1 + 4 >> 2];
  $1_1 = $3_1 + 24 | 0;
  $11_1 = HEAP32[$28_1 >> 2];
  HEAP32[$1_1 >> 2] = $11_1;
  HEAP32[$1_1 + 4 >> 2] = $10_1;
  $13_1 = HEAP32[$25_1 + 4 >> 2];
  $1_1 = $3_1 + 16 | 0;
  $7_1 = HEAP32[$25_1 >> 2];
  HEAP32[$1_1 >> 2] = $7_1;
  HEAP32[$1_1 + 4 >> 2] = $13_1;
  $14_1 = HEAP32[$27_1 + 4 >> 2];
  $1_1 = $3_1 + 8 | 0;
  $8_1 = HEAP32[$27_1 >> 2];
  HEAP32[$1_1 >> 2] = $8_1;
  HEAP32[$1_1 + 4 >> 2] = $14_1;
  $12_1 = HEAP32[$6_1 + 7420 >> 2];
  $5_1 = HEAP32[$6_1 + 7416 >> 2];
  HEAP32[$6_1 + 7376 >> 2] = $5_1;
  HEAP32[$6_1 + 7380 >> 2] = $12_1;
  $1_1 = 11;
  while (1) {
   $15_1 = $5_1;
   $3_1 = $12_1 << 1 | $5_1 >>> 31;
   $25_1 = $6_1 + 3664 | 0;
   $20_1 = $5_1 << 1;
   $28_1 = $3_1;
   $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
   $19_1 = $6_1 + 3584 | 0;
   $5_1 = $8_1 << 1;
   $16_1 = $14_1;
   $24_1 = $8_1;
   $8_1 = $14_1 << 1 | $8_1 >>> 31;
   $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
   $17_1 = $6_1 + 3520 | 0;
   $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
   $18_1 = $6_1 + 3504 | 0;
   $69($18_1, HEAP32[$6_1 + 3520 >> 2], HEAP32[$6_1 + 3524 >> 2], 0, 0, 15632, 16, 0, 0);
   $3_1 = $9_1 << 1 | $4_1 >>> 31;
   $33_1 = $6_1 + 3472 | 0;
   $22_1 = $4_1 << 1;
   $26_1 = $3_1;
   $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
   $34_1 = $6_1 + 3632 | 0;
   $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
   $39_1 = $6_1 + 3568 | 0;
   $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
   $23_1 = $6_1 + 3488 | 0;
   $3_1 = $17_1 + 8 | 0;
   $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
   $38_1 = $6_1 + 3680 | 0;
   $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
   $35_1 = $6_1 + 3456 | 0;
   $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
   $36_1 = $6_1 + 3536 | 0;
   $12_1 = $11_1;
   $21_1 = $7_1;
   $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
   $15_1 = HEAP32[$6_1 + 3668 >> 2];
   $3_1 = $15_1 + HEAP32[$6_1 + 3588 >> 2] | 0;
   $7_1 = HEAP32[$6_1 + 3664 >> 2];
   $5_1 = HEAP32[$6_1 + 3584 >> 2];
   $4_1 = $7_1 + $5_1 | 0;
   $8_1 = HEAP32[$6_1 + 3504 >> 2];
   $17_1 = $4_1 + $8_1 | 0;
   $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $5_1 + HEAP32[$6_1 + 3508 >> 2] | 0;
   $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
   $3_1 = $18_1 + 8 | 0;
   $9_1 = HEAP32[$3_1 >> 2];
   $11_1 = HEAP32[$3_1 + 4 >> 2];
   $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
   $5_1 = $19_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $25_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $7_1 + $15_1 | 0;
   $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
   $5_1 = $4_1;
   $4_1 = $4_1 + $9_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $14_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $14_1 = $8_1;
   $9_1 = $4_1 << 12 | $8_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 3632 >> 2];
   $4_1 = HEAP32[$6_1 + 3568 >> 2];
   $15_1 = $31_1 + $4_1 | 0;
   $40_1 = HEAP32[$6_1 + 3636 >> 2];
   $3_1 = $40_1 + HEAP32[$6_1 + 3572 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 3472 >> 2];
   $11_1 = $4_1 + $15_1 | 0;
   $19_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 3476 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 3488 >> 2];
   $8_1 = $4_1 + $11_1 | 0;
   $18_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 3492 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $7_1 | 0;
   $37_1 = $6_1 + 3440 | 0;
   $9_1 = $8_1 + $9_1 | 0;
   $7_1 = $9_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
   $3_1 = $23_1 + 8 | 0;
   $29_1 = HEAP32[$3_1 >> 2];
   $27_1 = HEAP32[$3_1 + 4 >> 2];
   $25_1 = ($18_1 | 0) == ($19_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
   $3_1 = $33_1 + 8 | 0;
   $23_1 = HEAP32[$3_1 >> 2];
   $18_1 = HEAP32[$3_1 + 4 >> 2];
   $11_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
   $8_1 = $39_1 + 8 | 0;
   $4_1 = HEAP32[$8_1 >> 2];
   $3_1 = $34_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $11_1 + $15_1 | 0;
   $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + $23_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $4_1;
   $4_1 = $4_1 + $25_1 | 0;
   $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + $29_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $4_1 + $32_1 | 0;
   $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $30_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $7_1;
   $11_1 = $4_1 << 12 | $5_1 >>> 20;
   $8_1 = $3_1;
   $18_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 3460 >> 2];
   $3_1 = $31_1 + HEAP32[$6_1 + 3540 >> 2] | 0;
   $25_1 = HEAP32[$6_1 + 3456 >> 2];
   $4_1 = HEAP32[$6_1 + 3536 >> 2];
   $7_1 = $25_1 + $4_1 | 0;
   $15_1 = $7_1;
   $11_1 = $7_1 + $11_1 | 0;
   $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $18_1 | 0;
   $23_1 = $11_1 << 4 & -16;
   $7_1 = $11_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $19_1 = ($7_1 << 4 | $11_1 >>> 28) & 16777215;
   $18_1 = $5_1;
   $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
   $30_1 = $6_1 + 3616 | 0;
   $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
   $32_1 = $6_1 + 3424 | 0;
   $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
   $29_1 = $6_1 + 3648 | 0;
   $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
   $27_1 = $6_1 + 3408 | 0;
   $23_1 = $27_1;
   $19_1 = ($4_1 | 0) == ($7_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $11_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
   $5_1 = $36_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $35_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $11_1 + $15_1 | 0;
   $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $8_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $19_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $4_1 << 12 | $7_1 >>> 20;
   $5_1 = $3_1;
   $19_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 3428 >> 2];
   $3_1 = $31_1 + HEAP32[$6_1 + 3652 >> 2] | 0;
   $15_1 = HEAP32[$6_1 + 3424 >> 2];
   $4_1 = HEAP32[$6_1 + 3648 >> 2];
   $8_1 = $15_1 + $4_1 | 0;
   $11_1 = $8_1;
   $7_1 = $8_1 + $7_1 | 0;
   $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $19_1 | 0;
   $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($23_1, $7_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
   $25_1 = $6_1 + 3552 | 0;
   $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
   $23_1 = $6_1 + 3600 | 0;
   $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
   $13_1 = $6_1 + 3392 | 0;
   $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
   $26_1 = $6_1 + 3376 | 0;
   $12_1 = $26_1;
   $10_1 = ($4_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $8_1 >>> 0;
   $11_1 = ($4_1 | 0) == ($31_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
   $7_1 = $29_1 + 8 | 0;
   $4_1 = HEAP32[$7_1 >> 2];
   $3_1 = $32_1 + 8 | 0;
   $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $11_1 + $16_1 | 0;
   $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $7_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $4_1 << 12 | $8_1 >>> 20;
   $8_1 = HEAP32[$6_1 + 3392 >> 2];
   $10_1 = $7_1 + $8_1 | 0;
   $5_1 = $3_1;
   $4_1 = $3_1 << 12 | $4_1 >>> 20;
   $3_1 = $4_1 + HEAP32[$6_1 + 3396 >> 2] | 0;
   $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
   $19_1 = $6_1 + 3360 | 0;
   $11_1 = $19_1;
   $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
   $3_1 = $13_1 + 8 | 0;
   $8_1 = HEAP32[$3_1 >> 2];
   $3_1 = HEAP32[$3_1 + 4 >> 2];
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $7_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($11_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
   $5_1 = HEAP32[$6_1 + 3440 >> 2];
   $4_1 = HEAP32[$6_1 + 3680 >> 2];
   $12_1 = $5_1 + $4_1 | 0;
   $7_1 = HEAP32[$6_1 + 3444 >> 2];
   $3_1 = $7_1 + HEAP32[$6_1 + 3684 >> 2] | 0;
   $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
   $5_1 = $38_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $37_1 + 8 | 0;
   $11_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $7_1 + $11_1 | 0;
   $3_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $15_1 = $8_1;
   $7_1 = $4_1 << 12 | $8_1 >>> 20;
   $5_1 = $3_1;
   $8_1 = $3_1 << 12 | $4_1 >>> 20;
   $10_1 = HEAP32[$6_1 + 3408 >> 2];
   $4_1 = HEAP32[$6_1 + 3616 >> 2];
   $11_1 = $10_1 + $4_1 | 0;
   $16_1 = HEAP32[$6_1 + 3412 >> 2];
   $3_1 = $16_1 + HEAP32[$6_1 + 3620 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $8_1 | 0;
   $8_1 = $7_1 + $11_1 | 0;
   $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $10_1 = ($4_1 | 0) == ($16_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
   $11_1 = $30_1 + 8 | 0;
   $4_1 = HEAP32[$11_1 >> 2];
   $3_1 = $27_1 + 8 | 0;
   $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$11_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $11_1 = $10_1 + $16_1 | 0;
   $3_1 = $11_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $11_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $13_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $16_1 = $7_1;
   $11_1 = $4_1 << 12 | $7_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $22_1 = HEAP32[$6_1 + 3552 >> 2];
   $4_1 = HEAP32[$6_1 + 3600 >> 2];
   $13_1 = $22_1 + $4_1 | 0;
   $27_1 = HEAP32[$6_1 + 3556 >> 2];
   $3_1 = $27_1 + HEAP32[$6_1 + 3604 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 3376 >> 2];
   $10_1 = $4_1 + $13_1 | 0;
   $21_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 3380 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $7_1 | 0;
   $7_1 = $10_1 + $11_1 | 0;
   $11_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $28_1 = ($4_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
   $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
   $3_1 = $26_1 + 8 | 0;
   $24_1 = HEAP32[$3_1 >> 2];
   $26_1 = HEAP32[$3_1 + 4 >> 2];
   $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
   $10_1 = $23_1 + 8 | 0;
   $4_1 = HEAP32[$10_1 >> 2];
   $3_1 = $25_1 + 8 | 0;
   $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $13_1 + $21_1 | 0;
   $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
   $13_1 = $4_1;
   $4_1 = $4_1 + $24_1 | 0;
   $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $4_1 + $20_1 | 0;
   $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $28_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $13_1 = $11_1;
   $21_1 = $4_1 << 12 | $11_1 >>> 20;
   $5_1 = $3_1;
   $10_1 = $3_1 << 12 | $4_1 >>> 20;
   $24_1 = HEAP32[$6_1 + 3360 >> 2];
   $11_1 = $24_1 + ($17_1 & -2) | 0;
   $26_1 = HEAP32[$6_1 + 3364 >> 2];
   $3_1 = $26_1 + ($14_1 & 1048575) | 0;
   $3_1 = $11_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $17_1 = $11_1;
   $11_1 = $11_1 + $21_1 | 0;
   $4_1 = $3_1;
   $3_1 = $3_1 + $10_1 | 0;
   $14_1 = $9_1;
   $21_1 = $18_1 & 65535;
   $10_1 = $11_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $18_1 = ($4_1 | 0) == ($10_1 | 0) & $11_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $10_1 >>> 0;
   $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
   $3_1 = $19_1 + 8 | 0;
   $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2];
   $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $9_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $18_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $9_1 = $4_1 << 12 | $10_1 >>> 20;
   $5_1 = $9_1 + $14_1 | 0;
   $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
   $4_1 = $5_1;
   $9_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $10_1 & 1048575;
   $13_1 = $13_1 & 1048575;
   $14_1 = $16_1 & 1048575;
   $5_1 = $12_1;
   $12_1 = $15_1 & 1048575;
   $1_1 = $1_1 - 1 | 0;
   if ($1_1) {
    continue
   }
   break;
  };
  $1_1 = $6_1 + 7376 | 0;
  $17_1 = $1_1 + 32 | 0;
  HEAP32[$17_1 >> 2] = $4_1;
  HEAP32[$17_1 + 4 >> 2] = $9_1;
  $18_1 = $1_1 + 24 | 0;
  HEAP32[$18_1 >> 2] = $11_1;
  HEAP32[$18_1 + 4 >> 2] = $10_1;
  $15_1 = $1_1 + 16 | 0;
  HEAP32[$15_1 >> 2] = $7_1;
  HEAP32[$15_1 + 4 >> 2] = $13_1;
  $16_1 = $1_1 + 8 | 0;
  HEAP32[$16_1 >> 2] = $8_1;
  HEAP32[$16_1 + 4 >> 2] = $14_1;
  HEAP32[$6_1 + 7376 >> 2] = $5_1;
  HEAP32[$6_1 + 7380 >> 2] = $12_1;
  $34($1_1, $1_1, $6_1 + 7416 | 0);
  $9_1 = HEAP32[$17_1 + 4 >> 2];
  $3_1 = $6_1 + 7336 | 0;
  $1_1 = $3_1 + 32 | 0;
  $4_1 = HEAP32[$17_1 >> 2];
  HEAP32[$1_1 >> 2] = $4_1;
  HEAP32[$1_1 + 4 >> 2] = $9_1;
  $10_1 = HEAP32[$18_1 + 4 >> 2];
  $1_1 = $3_1 + 24 | 0;
  $11_1 = HEAP32[$18_1 >> 2];
  HEAP32[$1_1 >> 2] = $11_1;
  HEAP32[$1_1 + 4 >> 2] = $10_1;
  $13_1 = HEAP32[$15_1 + 4 >> 2];
  $1_1 = $3_1 + 16 | 0;
  $7_1 = HEAP32[$15_1 >> 2];
  HEAP32[$1_1 >> 2] = $7_1;
  HEAP32[$1_1 + 4 >> 2] = $13_1;
  $14_1 = HEAP32[$16_1 + 4 >> 2];
  $1_1 = $3_1 + 8 | 0;
  $8_1 = HEAP32[$16_1 >> 2];
  HEAP32[$1_1 >> 2] = $8_1;
  HEAP32[$1_1 + 4 >> 2] = $14_1;
  $12_1 = HEAP32[$6_1 + 7380 >> 2];
  $5_1 = HEAP32[$6_1 + 7376 >> 2];
  HEAP32[$6_1 + 7336 >> 2] = $5_1;
  HEAP32[$6_1 + 7340 >> 2] = $12_1;
  $1_1 = 22;
  while (1) {
   $15_1 = $5_1;
   $3_1 = $12_1 << 1 | $5_1 >>> 31;
   $25_1 = $6_1 + 3328 | 0;
   $20_1 = $5_1 << 1;
   $28_1 = $3_1;
   $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
   $19_1 = $6_1 + 3248 | 0;
   $5_1 = $8_1 << 1;
   $16_1 = $14_1;
   $24_1 = $8_1;
   $8_1 = $14_1 << 1 | $8_1 >>> 31;
   $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
   $17_1 = $6_1 + 3184 | 0;
   $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
   $18_1 = $6_1 + 3168 | 0;
   $69($18_1, HEAP32[$6_1 + 3184 >> 2], HEAP32[$6_1 + 3188 >> 2], 0, 0, 15632, 16, 0, 0);
   $3_1 = $9_1 << 1 | $4_1 >>> 31;
   $33_1 = $6_1 + 3136 | 0;
   $22_1 = $4_1 << 1;
   $26_1 = $3_1;
   $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
   $34_1 = $6_1 + 3296 | 0;
   $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
   $39_1 = $6_1 + 3232 | 0;
   $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
   $23_1 = $6_1 + 3152 | 0;
   $3_1 = $17_1 + 8 | 0;
   $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
   $38_1 = $6_1 + 3344 | 0;
   $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
   $35_1 = $6_1 + 3120 | 0;
   $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
   $36_1 = $6_1 + 3200 | 0;
   $12_1 = $11_1;
   $21_1 = $7_1;
   $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
   $15_1 = HEAP32[$6_1 + 3332 >> 2];
   $3_1 = $15_1 + HEAP32[$6_1 + 3252 >> 2] | 0;
   $7_1 = HEAP32[$6_1 + 3328 >> 2];
   $5_1 = HEAP32[$6_1 + 3248 >> 2];
   $4_1 = $7_1 + $5_1 | 0;
   $8_1 = HEAP32[$6_1 + 3168 >> 2];
   $17_1 = $4_1 + $8_1 | 0;
   $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $5_1 + HEAP32[$6_1 + 3172 >> 2] | 0;
   $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
   $3_1 = $18_1 + 8 | 0;
   $9_1 = HEAP32[$3_1 >> 2];
   $11_1 = HEAP32[$3_1 + 4 >> 2];
   $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
   $5_1 = $19_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $25_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $7_1 + $15_1 | 0;
   $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
   $5_1 = $4_1;
   $4_1 = $4_1 + $9_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $14_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $14_1 = $8_1;
   $11_1 = $4_1 << 12 | $8_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 3296 >> 2];
   $4_1 = HEAP32[$6_1 + 3232 >> 2];
   $15_1 = $31_1 + $4_1 | 0;
   $40_1 = HEAP32[$6_1 + 3300 >> 2];
   $3_1 = $40_1 + HEAP32[$6_1 + 3236 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 3136 >> 2];
   $9_1 = $4_1 + $15_1 | 0;
   $19_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 3140 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 3152 >> 2];
   $8_1 = $4_1 + $9_1 | 0;
   $18_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 3156 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $7_1 | 0;
   $37_1 = $6_1 + 3104 | 0;
   $11_1 = $8_1 + $11_1 | 0;
   $7_1 = $11_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
   $3_1 = $23_1 + 8 | 0;
   $29_1 = HEAP32[$3_1 >> 2];
   $27_1 = HEAP32[$3_1 + 4 >> 2];
   $25_1 = ($18_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
   $3_1 = $33_1 + 8 | 0;
   $23_1 = HEAP32[$3_1 >> 2];
   $18_1 = HEAP32[$3_1 + 4 >> 2];
   $9_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
   $8_1 = $39_1 + 8 | 0;
   $4_1 = HEAP32[$8_1 >> 2];
   $3_1 = $34_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $9_1 + $15_1 | 0;
   $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + $23_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $4_1;
   $4_1 = $4_1 + $25_1 | 0;
   $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + $29_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $4_1 + $32_1 | 0;
   $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $30_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $7_1;
   $9_1 = $4_1 << 12 | $5_1 >>> 20;
   $8_1 = $3_1;
   $18_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 3124 >> 2];
   $3_1 = $31_1 + HEAP32[$6_1 + 3204 >> 2] | 0;
   $25_1 = HEAP32[$6_1 + 3120 >> 2];
   $4_1 = HEAP32[$6_1 + 3200 >> 2];
   $7_1 = $25_1 + $4_1 | 0;
   $15_1 = $7_1;
   $9_1 = $7_1 + $9_1 | 0;
   $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $18_1 | 0;
   $23_1 = $9_1 << 4 & -16;
   $7_1 = $9_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $19_1 = ($7_1 << 4 | $9_1 >>> 28) & 16777215;
   $18_1 = $5_1;
   $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
   $30_1 = $6_1 + 3280 | 0;
   $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
   $32_1 = $6_1 + 3088 | 0;
   $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
   $29_1 = $6_1 + 3312 | 0;
   $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
   $27_1 = $6_1 + 3072 | 0;
   $23_1 = $27_1;
   $19_1 = ($4_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $9_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
   $5_1 = $36_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $35_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $9_1 + $15_1 | 0;
   $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $8_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $19_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $4_1 << 12 | $7_1 >>> 20;
   $5_1 = $3_1;
   $19_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 3092 >> 2];
   $3_1 = $31_1 + HEAP32[$6_1 + 3316 >> 2] | 0;
   $15_1 = HEAP32[$6_1 + 3088 >> 2];
   $4_1 = HEAP32[$6_1 + 3312 >> 2];
   $8_1 = $15_1 + $4_1 | 0;
   $9_1 = $8_1;
   $7_1 = $8_1 + $7_1 | 0;
   $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $19_1 | 0;
   $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($23_1, $7_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
   $25_1 = $6_1 + 3216 | 0;
   $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
   $23_1 = $6_1 + 3264 | 0;
   $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
   $13_1 = $6_1 + 3056 | 0;
   $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
   $26_1 = $6_1 + 3040 | 0;
   $12_1 = $26_1;
   $10_1 = ($4_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $8_1 >>> 0;
   $9_1 = ($4_1 | 0) == ($31_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
   $7_1 = $29_1 + 8 | 0;
   $4_1 = HEAP32[$7_1 >> 2];
   $3_1 = $32_1 + 8 | 0;
   $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $9_1 + $16_1 | 0;
   $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $7_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $4_1 << 12 | $8_1 >>> 20;
   $8_1 = HEAP32[$6_1 + 3056 >> 2];
   $10_1 = $7_1 + $8_1 | 0;
   $5_1 = $3_1;
   $4_1 = $3_1 << 12 | $4_1 >>> 20;
   $3_1 = $4_1 + HEAP32[$6_1 + 3060 >> 2] | 0;
   $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
   $19_1 = $6_1 + 3024 | 0;
   $9_1 = $19_1;
   $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
   $3_1 = $13_1 + 8 | 0;
   $8_1 = HEAP32[$3_1 >> 2];
   $3_1 = HEAP32[$3_1 + 4 >> 2];
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $7_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($9_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
   $5_1 = HEAP32[$6_1 + 3104 >> 2];
   $4_1 = HEAP32[$6_1 + 3344 >> 2];
   $12_1 = $5_1 + $4_1 | 0;
   $7_1 = HEAP32[$6_1 + 3108 >> 2];
   $3_1 = $7_1 + HEAP32[$6_1 + 3348 >> 2] | 0;
   $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
   $5_1 = $38_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $37_1 + 8 | 0;
   $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $7_1 + $9_1 | 0;
   $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $15_1 = $8_1;
   $9_1 = $4_1 << 12 | $8_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $10_1 = HEAP32[$6_1 + 3072 >> 2];
   $4_1 = HEAP32[$6_1 + 3280 >> 2];
   $8_1 = $10_1 + $4_1 | 0;
   $16_1 = HEAP32[$6_1 + 3076 >> 2];
   $3_1 = $16_1 + HEAP32[$6_1 + 3284 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $9_1;
   $9_1 = $8_1;
   $8_1 = $4_1 + $8_1 | 0;
   $4_1 = $3_1;
   $3_1 = $3_1 + $7_1 | 0;
   $7_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $10_1 = ($4_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
   $9_1 = $30_1 + 8 | 0;
   $4_1 = HEAP32[$9_1 >> 2];
   $3_1 = $27_1 + 8 | 0;
   $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$9_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $9_1 = $10_1 + $16_1 | 0;
   $3_1 = $9_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $9_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $13_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $16_1 = $7_1;
   $9_1 = $4_1 << 12 | $7_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $22_1 = HEAP32[$6_1 + 3216 >> 2];
   $4_1 = HEAP32[$6_1 + 3264 >> 2];
   $13_1 = $22_1 + $4_1 | 0;
   $27_1 = HEAP32[$6_1 + 3220 >> 2];
   $3_1 = $27_1 + HEAP32[$6_1 + 3268 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 3040 >> 2];
   $10_1 = $4_1 + $13_1 | 0;
   $21_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 3044 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $7_1 | 0;
   $7_1 = $9_1 + $10_1 | 0;
   $9_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $28_1 = ($4_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
   $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
   $3_1 = $26_1 + 8 | 0;
   $24_1 = HEAP32[$3_1 >> 2];
   $26_1 = HEAP32[$3_1 + 4 >> 2];
   $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
   $10_1 = $23_1 + 8 | 0;
   $4_1 = HEAP32[$10_1 >> 2];
   $3_1 = $25_1 + 8 | 0;
   $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $13_1 + $21_1 | 0;
   $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
   $13_1 = $4_1;
   $4_1 = $4_1 + $24_1 | 0;
   $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $4_1 + $20_1 | 0;
   $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $28_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $13_1 = $9_1;
   $10_1 = $4_1 << 12 | $9_1 >>> 20;
   $5_1 = $3_1;
   $9_1 = $3_1 << 12 | $4_1 >>> 20;
   $24_1 = HEAP32[$6_1 + 3024 >> 2];
   $17_1 = $24_1 + ($17_1 & -2) | 0;
   $26_1 = HEAP32[$6_1 + 3028 >> 2];
   $3_1 = $26_1 + ($14_1 & 1048575) | 0;
   $4_1 = $17_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $9_1 | 0;
   $14_1 = $11_1;
   $21_1 = $18_1 & 65535;
   $10_1 = $10_1 + $17_1 | 0;
   $9_1 = $10_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $11_1 = $10_1;
   $18_1 = ($4_1 | 0) == ($9_1 | 0) & $10_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
   $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
   $3_1 = $19_1 + 8 | 0;
   $10_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2];
   $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $18_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $9_1;
   $10_1 = $4_1 << 12 | $5_1 >>> 20;
   $9_1 = $10_1 + $14_1 | 0;
   $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
   $4_1 = $9_1;
   $9_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $5_1 & 1048575;
   $13_1 = $13_1 & 1048575;
   $14_1 = $16_1 & 1048575;
   $5_1 = $12_1;
   $12_1 = $15_1 & 1048575;
   $1_1 = $1_1 - 1 | 0;
   if ($1_1) {
    continue
   }
   break;
  };
  $1_1 = $6_1 + 7336 | 0;
  $17_1 = $1_1 + 32 | 0;
  HEAP32[$17_1 >> 2] = $4_1;
  HEAP32[$17_1 + 4 >> 2] = $9_1;
  $18_1 = $1_1 + 24 | 0;
  HEAP32[$18_1 >> 2] = $11_1;
  HEAP32[$18_1 + 4 >> 2] = $10_1;
  $15_1 = $1_1 + 16 | 0;
  HEAP32[$15_1 >> 2] = $7_1;
  HEAP32[$15_1 + 4 >> 2] = $13_1;
  $16_1 = $1_1 + 8 | 0;
  HEAP32[$16_1 >> 2] = $8_1;
  HEAP32[$16_1 + 4 >> 2] = $14_1;
  HEAP32[$6_1 + 7336 >> 2] = $5_1;
  HEAP32[$6_1 + 7340 >> 2] = $12_1;
  $34($1_1, $1_1, $6_1 + 7376 | 0);
  $9_1 = HEAP32[$17_1 + 4 >> 2];
  $3_1 = $6_1 + 7296 | 0;
  $1_1 = $3_1 + 32 | 0;
  $4_1 = HEAP32[$17_1 >> 2];
  HEAP32[$1_1 >> 2] = $4_1;
  HEAP32[$1_1 + 4 >> 2] = $9_1;
  $10_1 = HEAP32[$18_1 + 4 >> 2];
  $1_1 = $3_1 + 24 | 0;
  $11_1 = HEAP32[$18_1 >> 2];
  HEAP32[$1_1 >> 2] = $11_1;
  HEAP32[$1_1 + 4 >> 2] = $10_1;
  $13_1 = HEAP32[$15_1 + 4 >> 2];
  $1_1 = $3_1 + 16 | 0;
  $7_1 = HEAP32[$15_1 >> 2];
  HEAP32[$1_1 >> 2] = $7_1;
  HEAP32[$1_1 + 4 >> 2] = $13_1;
  $14_1 = HEAP32[$16_1 + 4 >> 2];
  $1_1 = $3_1 + 8 | 0;
  $8_1 = HEAP32[$16_1 >> 2];
  HEAP32[$1_1 >> 2] = $8_1;
  HEAP32[$1_1 + 4 >> 2] = $14_1;
  $12_1 = HEAP32[$6_1 + 7340 >> 2];
  $5_1 = HEAP32[$6_1 + 7336 >> 2];
  HEAP32[$6_1 + 7296 >> 2] = $5_1;
  HEAP32[$6_1 + 7300 >> 2] = $12_1;
  $1_1 = 44;
  while (1) {
   $15_1 = $5_1;
   $3_1 = $12_1 << 1 | $5_1 >>> 31;
   $25_1 = $6_1 + 2992 | 0;
   $20_1 = $5_1 << 1;
   $28_1 = $3_1;
   $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
   $19_1 = $6_1 + 2912 | 0;
   $5_1 = $8_1 << 1;
   $16_1 = $14_1;
   $24_1 = $8_1;
   $8_1 = $14_1 << 1 | $8_1 >>> 31;
   $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
   $17_1 = $6_1 + 2848 | 0;
   $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
   $18_1 = $6_1 + 2832 | 0;
   $69($18_1, HEAP32[$6_1 + 2848 >> 2], HEAP32[$6_1 + 2852 >> 2], 0, 0, 15632, 16, 0, 0);
   $3_1 = $9_1 << 1 | $4_1 >>> 31;
   $33_1 = $6_1 + 2800 | 0;
   $22_1 = $4_1 << 1;
   $26_1 = $3_1;
   $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
   $34_1 = $6_1 + 2960 | 0;
   $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
   $39_1 = $6_1 + 2896 | 0;
   $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
   $23_1 = $6_1 + 2816 | 0;
   $3_1 = $17_1 + 8 | 0;
   $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
   $38_1 = $6_1 + 3008 | 0;
   $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
   $35_1 = $6_1 + 2784 | 0;
   $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
   $36_1 = $6_1 + 2864 | 0;
   $12_1 = $11_1;
   $21_1 = $7_1;
   $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
   $15_1 = HEAP32[$6_1 + 2996 >> 2];
   $3_1 = $15_1 + HEAP32[$6_1 + 2916 >> 2] | 0;
   $7_1 = HEAP32[$6_1 + 2992 >> 2];
   $5_1 = HEAP32[$6_1 + 2912 >> 2];
   $4_1 = $7_1 + $5_1 | 0;
   $8_1 = HEAP32[$6_1 + 2832 >> 2];
   $17_1 = $4_1 + $8_1 | 0;
   $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $5_1 + HEAP32[$6_1 + 2836 >> 2] | 0;
   $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
   $3_1 = $18_1 + 8 | 0;
   $9_1 = HEAP32[$3_1 >> 2];
   $11_1 = HEAP32[$3_1 + 4 >> 2];
   $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
   $5_1 = $19_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $25_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $7_1 + $15_1 | 0;
   $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
   $5_1 = $4_1;
   $4_1 = $4_1 + $9_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $14_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $14_1 = $8_1;
   $9_1 = $4_1 << 12 | $8_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 2960 >> 2];
   $4_1 = HEAP32[$6_1 + 2896 >> 2];
   $15_1 = $31_1 + $4_1 | 0;
   $40_1 = HEAP32[$6_1 + 2964 >> 2];
   $3_1 = $40_1 + HEAP32[$6_1 + 2900 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 2800 >> 2];
   $11_1 = $4_1 + $15_1 | 0;
   $19_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 2804 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 2816 >> 2];
   $8_1 = $4_1 + $11_1 | 0;
   $18_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 2820 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $7_1 | 0;
   $37_1 = $6_1 + 2768 | 0;
   $9_1 = $8_1 + $9_1 | 0;
   $7_1 = $9_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
   $3_1 = $23_1 + 8 | 0;
   $29_1 = HEAP32[$3_1 >> 2];
   $27_1 = HEAP32[$3_1 + 4 >> 2];
   $25_1 = ($18_1 | 0) == ($19_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
   $3_1 = $33_1 + 8 | 0;
   $23_1 = HEAP32[$3_1 >> 2];
   $18_1 = HEAP32[$3_1 + 4 >> 2];
   $11_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
   $8_1 = $39_1 + 8 | 0;
   $4_1 = HEAP32[$8_1 >> 2];
   $3_1 = $34_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $11_1 + $15_1 | 0;
   $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + $23_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $4_1;
   $4_1 = $4_1 + $25_1 | 0;
   $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + $29_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $4_1 + $32_1 | 0;
   $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $30_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $7_1;
   $11_1 = $4_1 << 12 | $5_1 >>> 20;
   $8_1 = $3_1;
   $18_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 2788 >> 2];
   $3_1 = $31_1 + HEAP32[$6_1 + 2868 >> 2] | 0;
   $25_1 = HEAP32[$6_1 + 2784 >> 2];
   $4_1 = HEAP32[$6_1 + 2864 >> 2];
   $7_1 = $25_1 + $4_1 | 0;
   $15_1 = $7_1;
   $11_1 = $7_1 + $11_1 | 0;
   $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $18_1 | 0;
   $23_1 = $11_1 << 4 & -16;
   $7_1 = $11_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $19_1 = ($7_1 << 4 | $11_1 >>> 28) & 16777215;
   $18_1 = $5_1;
   $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
   $30_1 = $6_1 + 2944 | 0;
   $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
   $32_1 = $6_1 + 2752 | 0;
   $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
   $29_1 = $6_1 + 2976 | 0;
   $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
   $27_1 = $6_1 + 2736 | 0;
   $23_1 = $27_1;
   $19_1 = ($4_1 | 0) == ($7_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $11_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
   $5_1 = $36_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $35_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $11_1 + $15_1 | 0;
   $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $8_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $19_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $4_1 << 12 | $7_1 >>> 20;
   $5_1 = $3_1;
   $19_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 2756 >> 2];
   $3_1 = $31_1 + HEAP32[$6_1 + 2980 >> 2] | 0;
   $15_1 = HEAP32[$6_1 + 2752 >> 2];
   $4_1 = HEAP32[$6_1 + 2976 >> 2];
   $8_1 = $15_1 + $4_1 | 0;
   $11_1 = $8_1;
   $7_1 = $8_1 + $7_1 | 0;
   $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $19_1 | 0;
   $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($23_1, $7_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
   $25_1 = $6_1 + 2880 | 0;
   $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
   $23_1 = $6_1 + 2928 | 0;
   $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
   $13_1 = $6_1 + 2720 | 0;
   $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
   $26_1 = $6_1 + 2704 | 0;
   $12_1 = $26_1;
   $10_1 = ($4_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $8_1 >>> 0;
   $11_1 = ($4_1 | 0) == ($31_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
   $7_1 = $29_1 + 8 | 0;
   $4_1 = HEAP32[$7_1 >> 2];
   $3_1 = $32_1 + 8 | 0;
   $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $11_1 + $16_1 | 0;
   $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $7_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $4_1 << 12 | $8_1 >>> 20;
   $8_1 = HEAP32[$6_1 + 2720 >> 2];
   $10_1 = $7_1 + $8_1 | 0;
   $5_1 = $3_1;
   $4_1 = $3_1 << 12 | $4_1 >>> 20;
   $3_1 = $4_1 + HEAP32[$6_1 + 2724 >> 2] | 0;
   $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
   $19_1 = $6_1 + 2688 | 0;
   $11_1 = $19_1;
   $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
   $3_1 = $13_1 + 8 | 0;
   $8_1 = HEAP32[$3_1 >> 2];
   $3_1 = HEAP32[$3_1 + 4 >> 2];
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $7_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($11_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
   $5_1 = HEAP32[$6_1 + 2768 >> 2];
   $4_1 = HEAP32[$6_1 + 3008 >> 2];
   $12_1 = $5_1 + $4_1 | 0;
   $7_1 = HEAP32[$6_1 + 2772 >> 2];
   $3_1 = $7_1 + HEAP32[$6_1 + 3012 >> 2] | 0;
   $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
   $5_1 = $38_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $37_1 + 8 | 0;
   $11_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $7_1 + $11_1 | 0;
   $3_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $15_1 = $8_1;
   $7_1 = $4_1 << 12 | $8_1 >>> 20;
   $5_1 = $3_1;
   $8_1 = $3_1 << 12 | $4_1 >>> 20;
   $10_1 = HEAP32[$6_1 + 2736 >> 2];
   $4_1 = HEAP32[$6_1 + 2944 >> 2];
   $11_1 = $10_1 + $4_1 | 0;
   $16_1 = HEAP32[$6_1 + 2740 >> 2];
   $3_1 = $16_1 + HEAP32[$6_1 + 2948 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $8_1 | 0;
   $8_1 = $7_1 + $11_1 | 0;
   $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $10_1 = ($4_1 | 0) == ($16_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
   $11_1 = $30_1 + 8 | 0;
   $4_1 = HEAP32[$11_1 >> 2];
   $3_1 = $27_1 + 8 | 0;
   $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$11_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $11_1 = $10_1 + $16_1 | 0;
   $3_1 = $11_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $11_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $13_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $16_1 = $7_1;
   $11_1 = $4_1 << 12 | $7_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $22_1 = HEAP32[$6_1 + 2880 >> 2];
   $4_1 = HEAP32[$6_1 + 2928 >> 2];
   $13_1 = $22_1 + $4_1 | 0;
   $27_1 = HEAP32[$6_1 + 2884 >> 2];
   $3_1 = $27_1 + HEAP32[$6_1 + 2932 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 2704 >> 2];
   $10_1 = $4_1 + $13_1 | 0;
   $21_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 2708 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $7_1 | 0;
   $7_1 = $10_1 + $11_1 | 0;
   $11_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $28_1 = ($4_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
   $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
   $3_1 = $26_1 + 8 | 0;
   $24_1 = HEAP32[$3_1 >> 2];
   $26_1 = HEAP32[$3_1 + 4 >> 2];
   $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
   $10_1 = $23_1 + 8 | 0;
   $4_1 = HEAP32[$10_1 >> 2];
   $3_1 = $25_1 + 8 | 0;
   $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $13_1 + $21_1 | 0;
   $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
   $13_1 = $4_1;
   $4_1 = $4_1 + $24_1 | 0;
   $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $4_1 + $20_1 | 0;
   $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $28_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $13_1 = $11_1;
   $21_1 = $4_1 << 12 | $11_1 >>> 20;
   $5_1 = $3_1;
   $10_1 = $3_1 << 12 | $4_1 >>> 20;
   $24_1 = HEAP32[$6_1 + 2688 >> 2];
   $11_1 = $24_1 + ($17_1 & -2) | 0;
   $26_1 = HEAP32[$6_1 + 2692 >> 2];
   $3_1 = $26_1 + ($14_1 & 1048575) | 0;
   $3_1 = $11_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $17_1 = $11_1;
   $11_1 = $11_1 + $21_1 | 0;
   $4_1 = $3_1;
   $3_1 = $3_1 + $10_1 | 0;
   $14_1 = $9_1;
   $21_1 = $18_1 & 65535;
   $10_1 = $11_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $18_1 = ($4_1 | 0) == ($10_1 | 0) & $11_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $10_1 >>> 0;
   $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
   $3_1 = $19_1 + 8 | 0;
   $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2];
   $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $9_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $18_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $9_1 = $4_1 << 12 | $10_1 >>> 20;
   $5_1 = $9_1 + $14_1 | 0;
   $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
   $4_1 = $5_1;
   $9_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $10_1 & 1048575;
   $13_1 = $13_1 & 1048575;
   $14_1 = $16_1 & 1048575;
   $5_1 = $12_1;
   $12_1 = $15_1 & 1048575;
   $1_1 = $1_1 - 1 | 0;
   if ($1_1) {
    continue
   }
   break;
  };
  $1_1 = $6_1 + 7296 | 0;
  $17_1 = $1_1 + 32 | 0;
  HEAP32[$17_1 >> 2] = $4_1;
  HEAP32[$17_1 + 4 >> 2] = $9_1;
  $18_1 = $1_1 + 24 | 0;
  HEAP32[$18_1 >> 2] = $11_1;
  HEAP32[$18_1 + 4 >> 2] = $10_1;
  $15_1 = $1_1 + 16 | 0;
  HEAP32[$15_1 >> 2] = $7_1;
  HEAP32[$15_1 + 4 >> 2] = $13_1;
  $16_1 = $1_1 + 8 | 0;
  HEAP32[$16_1 >> 2] = $8_1;
  HEAP32[$16_1 + 4 >> 2] = $14_1;
  HEAP32[$6_1 + 7296 >> 2] = $5_1;
  HEAP32[$6_1 + 7300 >> 2] = $12_1;
  $34($1_1, $1_1, $6_1 + 7336 | 0);
  $9_1 = HEAP32[$17_1 + 4 >> 2];
  $3_1 = $6_1 + 7256 | 0;
  $1_1 = $3_1 + 32 | 0;
  $4_1 = HEAP32[$17_1 >> 2];
  HEAP32[$1_1 >> 2] = $4_1;
  HEAP32[$1_1 + 4 >> 2] = $9_1;
  $10_1 = HEAP32[$18_1 + 4 >> 2];
  $1_1 = $3_1 + 24 | 0;
  $11_1 = HEAP32[$18_1 >> 2];
  HEAP32[$1_1 >> 2] = $11_1;
  HEAP32[$1_1 + 4 >> 2] = $10_1;
  $13_1 = HEAP32[$15_1 + 4 >> 2];
  $1_1 = $3_1 + 16 | 0;
  $7_1 = HEAP32[$15_1 >> 2];
  HEAP32[$1_1 >> 2] = $7_1;
  HEAP32[$1_1 + 4 >> 2] = $13_1;
  $14_1 = HEAP32[$16_1 + 4 >> 2];
  $1_1 = $3_1 + 8 | 0;
  $8_1 = HEAP32[$16_1 >> 2];
  HEAP32[$1_1 >> 2] = $8_1;
  HEAP32[$1_1 + 4 >> 2] = $14_1;
  $12_1 = HEAP32[$6_1 + 7300 >> 2];
  $5_1 = HEAP32[$6_1 + 7296 >> 2];
  HEAP32[$6_1 + 7256 >> 2] = $5_1;
  HEAP32[$6_1 + 7260 >> 2] = $12_1;
  $1_1 = 88;
  while (1) {
   $15_1 = $5_1;
   $3_1 = $12_1 << 1 | $5_1 >>> 31;
   $25_1 = $6_1 + 2656 | 0;
   $20_1 = $5_1 << 1;
   $28_1 = $3_1;
   $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
   $19_1 = $6_1 + 2576 | 0;
   $5_1 = $8_1 << 1;
   $16_1 = $14_1;
   $24_1 = $8_1;
   $8_1 = $14_1 << 1 | $8_1 >>> 31;
   $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
   $17_1 = $6_1 + 2512 | 0;
   $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
   $18_1 = $6_1 + 2496 | 0;
   $69($18_1, HEAP32[$6_1 + 2512 >> 2], HEAP32[$6_1 + 2516 >> 2], 0, 0, 15632, 16, 0, 0);
   $3_1 = $9_1 << 1 | $4_1 >>> 31;
   $33_1 = $6_1 + 2464 | 0;
   $22_1 = $4_1 << 1;
   $26_1 = $3_1;
   $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
   $34_1 = $6_1 + 2624 | 0;
   $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
   $39_1 = $6_1 + 2560 | 0;
   $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
   $23_1 = $6_1 + 2480 | 0;
   $3_1 = $17_1 + 8 | 0;
   $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
   $38_1 = $6_1 + 2672 | 0;
   $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
   $35_1 = $6_1 + 2448 | 0;
   $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
   $36_1 = $6_1 + 2528 | 0;
   $12_1 = $11_1;
   $21_1 = $7_1;
   $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
   $15_1 = HEAP32[$6_1 + 2660 >> 2];
   $3_1 = $15_1 + HEAP32[$6_1 + 2580 >> 2] | 0;
   $7_1 = HEAP32[$6_1 + 2656 >> 2];
   $5_1 = HEAP32[$6_1 + 2576 >> 2];
   $4_1 = $7_1 + $5_1 | 0;
   $8_1 = HEAP32[$6_1 + 2496 >> 2];
   $17_1 = $4_1 + $8_1 | 0;
   $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $5_1 + HEAP32[$6_1 + 2500 >> 2] | 0;
   $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
   $3_1 = $18_1 + 8 | 0;
   $9_1 = HEAP32[$3_1 >> 2];
   $11_1 = HEAP32[$3_1 + 4 >> 2];
   $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
   $5_1 = $19_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $25_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $7_1 + $15_1 | 0;
   $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
   $5_1 = $4_1;
   $4_1 = $4_1 + $9_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $14_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $14_1 = $8_1;
   $11_1 = $4_1 << 12 | $8_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 2624 >> 2];
   $4_1 = HEAP32[$6_1 + 2560 >> 2];
   $15_1 = $31_1 + $4_1 | 0;
   $40_1 = HEAP32[$6_1 + 2628 >> 2];
   $3_1 = $40_1 + HEAP32[$6_1 + 2564 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 2464 >> 2];
   $9_1 = $4_1 + $15_1 | 0;
   $19_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 2468 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 2480 >> 2];
   $8_1 = $4_1 + $9_1 | 0;
   $18_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 2484 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $7_1 | 0;
   $37_1 = $6_1 + 2432 | 0;
   $11_1 = $8_1 + $11_1 | 0;
   $7_1 = $11_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
   $3_1 = $23_1 + 8 | 0;
   $29_1 = HEAP32[$3_1 >> 2];
   $27_1 = HEAP32[$3_1 + 4 >> 2];
   $25_1 = ($18_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
   $3_1 = $33_1 + 8 | 0;
   $23_1 = HEAP32[$3_1 >> 2];
   $18_1 = HEAP32[$3_1 + 4 >> 2];
   $9_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
   $8_1 = $39_1 + 8 | 0;
   $4_1 = HEAP32[$8_1 >> 2];
   $3_1 = $34_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $9_1 + $15_1 | 0;
   $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + $23_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $4_1;
   $4_1 = $4_1 + $25_1 | 0;
   $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + $29_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $4_1 + $32_1 | 0;
   $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $30_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $7_1;
   $9_1 = $4_1 << 12 | $5_1 >>> 20;
   $8_1 = $3_1;
   $18_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 2452 >> 2];
   $3_1 = $31_1 + HEAP32[$6_1 + 2532 >> 2] | 0;
   $25_1 = HEAP32[$6_1 + 2448 >> 2];
   $4_1 = HEAP32[$6_1 + 2528 >> 2];
   $7_1 = $25_1 + $4_1 | 0;
   $15_1 = $7_1;
   $9_1 = $7_1 + $9_1 | 0;
   $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $18_1 | 0;
   $23_1 = $9_1 << 4 & -16;
   $7_1 = $9_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $19_1 = ($7_1 << 4 | $9_1 >>> 28) & 16777215;
   $18_1 = $5_1;
   $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
   $30_1 = $6_1 + 2608 | 0;
   $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
   $32_1 = $6_1 + 2416 | 0;
   $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
   $29_1 = $6_1 + 2640 | 0;
   $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
   $27_1 = $6_1 + 2400 | 0;
   $23_1 = $27_1;
   $19_1 = ($4_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $9_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
   $5_1 = $36_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $35_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $9_1 + $15_1 | 0;
   $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $8_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $19_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $4_1 << 12 | $7_1 >>> 20;
   $5_1 = $3_1;
   $19_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 2420 >> 2];
   $3_1 = $31_1 + HEAP32[$6_1 + 2644 >> 2] | 0;
   $15_1 = HEAP32[$6_1 + 2416 >> 2];
   $4_1 = HEAP32[$6_1 + 2640 >> 2];
   $8_1 = $15_1 + $4_1 | 0;
   $9_1 = $8_1;
   $7_1 = $8_1 + $7_1 | 0;
   $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $19_1 | 0;
   $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($23_1, $7_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
   $25_1 = $6_1 + 2544 | 0;
   $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
   $23_1 = $6_1 + 2592 | 0;
   $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
   $13_1 = $6_1 + 2384 | 0;
   $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
   $26_1 = $6_1 + 2368 | 0;
   $12_1 = $26_1;
   $10_1 = ($4_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $8_1 >>> 0;
   $9_1 = ($4_1 | 0) == ($31_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
   $7_1 = $29_1 + 8 | 0;
   $4_1 = HEAP32[$7_1 >> 2];
   $3_1 = $32_1 + 8 | 0;
   $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $9_1 + $16_1 | 0;
   $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $7_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $4_1 << 12 | $8_1 >>> 20;
   $8_1 = HEAP32[$6_1 + 2384 >> 2];
   $10_1 = $7_1 + $8_1 | 0;
   $5_1 = $3_1;
   $4_1 = $3_1 << 12 | $4_1 >>> 20;
   $3_1 = $4_1 + HEAP32[$6_1 + 2388 >> 2] | 0;
   $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
   $19_1 = $6_1 + 2352 | 0;
   $9_1 = $19_1;
   $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
   $3_1 = $13_1 + 8 | 0;
   $8_1 = HEAP32[$3_1 >> 2];
   $3_1 = HEAP32[$3_1 + 4 >> 2];
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $7_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($9_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
   $5_1 = HEAP32[$6_1 + 2432 >> 2];
   $4_1 = HEAP32[$6_1 + 2672 >> 2];
   $12_1 = $5_1 + $4_1 | 0;
   $7_1 = HEAP32[$6_1 + 2436 >> 2];
   $3_1 = $7_1 + HEAP32[$6_1 + 2676 >> 2] | 0;
   $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
   $5_1 = $38_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $37_1 + 8 | 0;
   $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $7_1 + $9_1 | 0;
   $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $15_1 = $8_1;
   $9_1 = $4_1 << 12 | $8_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $10_1 = HEAP32[$6_1 + 2400 >> 2];
   $4_1 = HEAP32[$6_1 + 2608 >> 2];
   $8_1 = $10_1 + $4_1 | 0;
   $16_1 = HEAP32[$6_1 + 2404 >> 2];
   $3_1 = $16_1 + HEAP32[$6_1 + 2612 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $9_1;
   $9_1 = $8_1;
   $8_1 = $4_1 + $8_1 | 0;
   $4_1 = $3_1;
   $3_1 = $3_1 + $7_1 | 0;
   $7_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $10_1 = ($4_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
   $9_1 = $30_1 + 8 | 0;
   $4_1 = HEAP32[$9_1 >> 2];
   $3_1 = $27_1 + 8 | 0;
   $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$9_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $9_1 = $10_1 + $16_1 | 0;
   $3_1 = $9_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $9_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $13_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $16_1 = $7_1;
   $9_1 = $4_1 << 12 | $7_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $22_1 = HEAP32[$6_1 + 2544 >> 2];
   $4_1 = HEAP32[$6_1 + 2592 >> 2];
   $13_1 = $22_1 + $4_1 | 0;
   $27_1 = HEAP32[$6_1 + 2548 >> 2];
   $3_1 = $27_1 + HEAP32[$6_1 + 2596 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 2368 >> 2];
   $10_1 = $4_1 + $13_1 | 0;
   $21_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 2372 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $7_1 | 0;
   $7_1 = $9_1 + $10_1 | 0;
   $9_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $28_1 = ($4_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
   $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
   $3_1 = $26_1 + 8 | 0;
   $24_1 = HEAP32[$3_1 >> 2];
   $26_1 = HEAP32[$3_1 + 4 >> 2];
   $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
   $10_1 = $23_1 + 8 | 0;
   $4_1 = HEAP32[$10_1 >> 2];
   $3_1 = $25_1 + 8 | 0;
   $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $13_1 + $21_1 | 0;
   $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
   $13_1 = $4_1;
   $4_1 = $4_1 + $24_1 | 0;
   $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $4_1 + $20_1 | 0;
   $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $28_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $13_1 = $9_1;
   $10_1 = $4_1 << 12 | $9_1 >>> 20;
   $5_1 = $3_1;
   $9_1 = $3_1 << 12 | $4_1 >>> 20;
   $24_1 = HEAP32[$6_1 + 2352 >> 2];
   $17_1 = $24_1 + ($17_1 & -2) | 0;
   $26_1 = HEAP32[$6_1 + 2356 >> 2];
   $3_1 = $26_1 + ($14_1 & 1048575) | 0;
   $4_1 = $17_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $9_1 | 0;
   $14_1 = $11_1;
   $21_1 = $18_1 & 65535;
   $10_1 = $10_1 + $17_1 | 0;
   $9_1 = $10_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $11_1 = $10_1;
   $18_1 = ($4_1 | 0) == ($9_1 | 0) & $10_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
   $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
   $3_1 = $19_1 + 8 | 0;
   $10_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2];
   $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $18_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $9_1;
   $10_1 = $4_1 << 12 | $5_1 >>> 20;
   $9_1 = $10_1 + $14_1 | 0;
   $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
   $4_1 = $9_1;
   $9_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $5_1 & 1048575;
   $13_1 = $13_1 & 1048575;
   $14_1 = $16_1 & 1048575;
   $5_1 = $12_1;
   $12_1 = $15_1 & 1048575;
   $1_1 = $1_1 - 1 | 0;
   if ($1_1) {
    continue
   }
   break;
  };
  $1_1 = $6_1 + 7256 | 0;
  $17_1 = $1_1 + 32 | 0;
  HEAP32[$17_1 >> 2] = $4_1;
  HEAP32[$17_1 + 4 >> 2] = $9_1;
  $18_1 = $1_1 + 24 | 0;
  HEAP32[$18_1 >> 2] = $11_1;
  HEAP32[$18_1 + 4 >> 2] = $10_1;
  $15_1 = $1_1 + 16 | 0;
  HEAP32[$15_1 >> 2] = $7_1;
  HEAP32[$15_1 + 4 >> 2] = $13_1;
  $16_1 = $1_1 + 8 | 0;
  HEAP32[$16_1 >> 2] = $8_1;
  HEAP32[$16_1 + 4 >> 2] = $14_1;
  HEAP32[$6_1 + 7256 >> 2] = $5_1;
  HEAP32[$6_1 + 7260 >> 2] = $12_1;
  $34($1_1, $1_1, $6_1 + 7296 | 0);
  $9_1 = HEAP32[$17_1 + 4 >> 2];
  $3_1 = $6_1 + 7216 | 0;
  $1_1 = $3_1 + 32 | 0;
  $4_1 = HEAP32[$17_1 >> 2];
  HEAP32[$1_1 >> 2] = $4_1;
  HEAP32[$1_1 + 4 >> 2] = $9_1;
  $10_1 = HEAP32[$18_1 + 4 >> 2];
  $1_1 = $3_1 + 24 | 0;
  $11_1 = HEAP32[$18_1 >> 2];
  HEAP32[$1_1 >> 2] = $11_1;
  HEAP32[$1_1 + 4 >> 2] = $10_1;
  $13_1 = HEAP32[$15_1 + 4 >> 2];
  $1_1 = $3_1 + 16 | 0;
  $7_1 = HEAP32[$15_1 >> 2];
  HEAP32[$1_1 >> 2] = $7_1;
  HEAP32[$1_1 + 4 >> 2] = $13_1;
  $14_1 = HEAP32[$16_1 + 4 >> 2];
  $1_1 = $3_1 + 8 | 0;
  $8_1 = HEAP32[$16_1 >> 2];
  HEAP32[$1_1 >> 2] = $8_1;
  HEAP32[$1_1 + 4 >> 2] = $14_1;
  $12_1 = HEAP32[$6_1 + 7260 >> 2];
  $5_1 = HEAP32[$6_1 + 7256 >> 2];
  HEAP32[$6_1 + 7216 >> 2] = $5_1;
  HEAP32[$6_1 + 7220 >> 2] = $12_1;
  $1_1 = 44;
  while (1) {
   $15_1 = $5_1;
   $3_1 = $12_1 << 1 | $5_1 >>> 31;
   $25_1 = $6_1 + 2320 | 0;
   $20_1 = $5_1 << 1;
   $28_1 = $3_1;
   $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
   $19_1 = $6_1 + 2240 | 0;
   $5_1 = $8_1 << 1;
   $16_1 = $14_1;
   $24_1 = $8_1;
   $8_1 = $14_1 << 1 | $8_1 >>> 31;
   $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
   $17_1 = $6_1 + 2176 | 0;
   $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
   $18_1 = $6_1 + 2160 | 0;
   $69($18_1, HEAP32[$6_1 + 2176 >> 2], HEAP32[$6_1 + 2180 >> 2], 0, 0, 15632, 16, 0, 0);
   $3_1 = $9_1 << 1 | $4_1 >>> 31;
   $33_1 = $6_1 + 2128 | 0;
   $22_1 = $4_1 << 1;
   $26_1 = $3_1;
   $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
   $34_1 = $6_1 + 2288 | 0;
   $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
   $39_1 = $6_1 + 2224 | 0;
   $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
   $23_1 = $6_1 + 2144 | 0;
   $3_1 = $17_1 + 8 | 0;
   $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
   $38_1 = $6_1 + 2336 | 0;
   $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
   $35_1 = $6_1 + 2112 | 0;
   $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
   $36_1 = $6_1 + 2192 | 0;
   $12_1 = $11_1;
   $21_1 = $7_1;
   $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
   $15_1 = HEAP32[$6_1 + 2324 >> 2];
   $3_1 = $15_1 + HEAP32[$6_1 + 2244 >> 2] | 0;
   $7_1 = HEAP32[$6_1 + 2320 >> 2];
   $5_1 = HEAP32[$6_1 + 2240 >> 2];
   $4_1 = $7_1 + $5_1 | 0;
   $8_1 = HEAP32[$6_1 + 2160 >> 2];
   $17_1 = $4_1 + $8_1 | 0;
   $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $5_1 + HEAP32[$6_1 + 2164 >> 2] | 0;
   $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
   $3_1 = $18_1 + 8 | 0;
   $9_1 = HEAP32[$3_1 >> 2];
   $11_1 = HEAP32[$3_1 + 4 >> 2];
   $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
   $5_1 = $19_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $25_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $7_1 + $15_1 | 0;
   $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
   $5_1 = $4_1;
   $4_1 = $4_1 + $9_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $14_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $14_1 = $8_1;
   $9_1 = $4_1 << 12 | $8_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 2288 >> 2];
   $4_1 = HEAP32[$6_1 + 2224 >> 2];
   $15_1 = $31_1 + $4_1 | 0;
   $40_1 = HEAP32[$6_1 + 2292 >> 2];
   $3_1 = $40_1 + HEAP32[$6_1 + 2228 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 2128 >> 2];
   $11_1 = $4_1 + $15_1 | 0;
   $19_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 2132 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 2144 >> 2];
   $8_1 = $4_1 + $11_1 | 0;
   $18_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 2148 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $7_1 | 0;
   $37_1 = $6_1 + 2096 | 0;
   $9_1 = $8_1 + $9_1 | 0;
   $7_1 = $9_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
   $3_1 = $23_1 + 8 | 0;
   $29_1 = HEAP32[$3_1 >> 2];
   $27_1 = HEAP32[$3_1 + 4 >> 2];
   $25_1 = ($18_1 | 0) == ($19_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
   $3_1 = $33_1 + 8 | 0;
   $23_1 = HEAP32[$3_1 >> 2];
   $18_1 = HEAP32[$3_1 + 4 >> 2];
   $11_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
   $8_1 = $39_1 + 8 | 0;
   $4_1 = HEAP32[$8_1 >> 2];
   $3_1 = $34_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $11_1 + $15_1 | 0;
   $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + $23_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $4_1;
   $4_1 = $4_1 + $25_1 | 0;
   $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + $29_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $4_1 + $32_1 | 0;
   $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $30_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $7_1;
   $11_1 = $4_1 << 12 | $5_1 >>> 20;
   $8_1 = $3_1;
   $18_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 2116 >> 2];
   $3_1 = $31_1 + HEAP32[$6_1 + 2196 >> 2] | 0;
   $25_1 = HEAP32[$6_1 + 2112 >> 2];
   $4_1 = HEAP32[$6_1 + 2192 >> 2];
   $7_1 = $25_1 + $4_1 | 0;
   $15_1 = $7_1;
   $11_1 = $7_1 + $11_1 | 0;
   $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $18_1 | 0;
   $23_1 = $11_1 << 4 & -16;
   $7_1 = $11_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $19_1 = ($7_1 << 4 | $11_1 >>> 28) & 16777215;
   $18_1 = $5_1;
   $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
   $30_1 = $6_1 + 2272 | 0;
   $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
   $32_1 = $6_1 + 2080 | 0;
   $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
   $29_1 = $6_1 + 2304 | 0;
   $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
   $27_1 = $6_1 + 2064 | 0;
   $23_1 = $27_1;
   $19_1 = ($4_1 | 0) == ($7_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $11_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
   $5_1 = $36_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $35_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $11_1 + $15_1 | 0;
   $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $8_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $19_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $4_1 << 12 | $7_1 >>> 20;
   $5_1 = $3_1;
   $19_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 2084 >> 2];
   $3_1 = $31_1 + HEAP32[$6_1 + 2308 >> 2] | 0;
   $15_1 = HEAP32[$6_1 + 2080 >> 2];
   $4_1 = HEAP32[$6_1 + 2304 >> 2];
   $8_1 = $15_1 + $4_1 | 0;
   $11_1 = $8_1;
   $7_1 = $8_1 + $7_1 | 0;
   $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $19_1 | 0;
   $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($23_1, $7_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
   $25_1 = $6_1 + 2208 | 0;
   $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
   $23_1 = $6_1 + 2256 | 0;
   $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
   $13_1 = $6_1 + 2048 | 0;
   $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
   $26_1 = $6_1 + 2032 | 0;
   $12_1 = $26_1;
   $10_1 = ($4_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $8_1 >>> 0;
   $11_1 = ($4_1 | 0) == ($31_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
   $7_1 = $29_1 + 8 | 0;
   $4_1 = HEAP32[$7_1 >> 2];
   $3_1 = $32_1 + 8 | 0;
   $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $11_1 + $16_1 | 0;
   $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $7_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $4_1 << 12 | $8_1 >>> 20;
   $8_1 = HEAP32[$6_1 + 2048 >> 2];
   $10_1 = $7_1 + $8_1 | 0;
   $5_1 = $3_1;
   $4_1 = $3_1 << 12 | $4_1 >>> 20;
   $3_1 = $4_1 + HEAP32[$6_1 + 2052 >> 2] | 0;
   $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
   $19_1 = $6_1 + 2016 | 0;
   $11_1 = $19_1;
   $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
   $3_1 = $13_1 + 8 | 0;
   $8_1 = HEAP32[$3_1 >> 2];
   $3_1 = HEAP32[$3_1 + 4 >> 2];
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $7_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($11_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
   $5_1 = HEAP32[$6_1 + 2096 >> 2];
   $4_1 = HEAP32[$6_1 + 2336 >> 2];
   $12_1 = $5_1 + $4_1 | 0;
   $7_1 = HEAP32[$6_1 + 2100 >> 2];
   $3_1 = $7_1 + HEAP32[$6_1 + 2340 >> 2] | 0;
   $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
   $5_1 = $38_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $37_1 + 8 | 0;
   $11_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $7_1 + $11_1 | 0;
   $3_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $15_1 = $8_1;
   $7_1 = $4_1 << 12 | $8_1 >>> 20;
   $5_1 = $3_1;
   $8_1 = $3_1 << 12 | $4_1 >>> 20;
   $10_1 = HEAP32[$6_1 + 2064 >> 2];
   $4_1 = HEAP32[$6_1 + 2272 >> 2];
   $11_1 = $10_1 + $4_1 | 0;
   $16_1 = HEAP32[$6_1 + 2068 >> 2];
   $3_1 = $16_1 + HEAP32[$6_1 + 2276 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $8_1 | 0;
   $8_1 = $7_1 + $11_1 | 0;
   $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $10_1 = ($4_1 | 0) == ($16_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
   $11_1 = $30_1 + 8 | 0;
   $4_1 = HEAP32[$11_1 >> 2];
   $3_1 = $27_1 + 8 | 0;
   $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$11_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $11_1 = $10_1 + $16_1 | 0;
   $3_1 = $11_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $11_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $13_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $16_1 = $7_1;
   $11_1 = $4_1 << 12 | $7_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $22_1 = HEAP32[$6_1 + 2208 >> 2];
   $4_1 = HEAP32[$6_1 + 2256 >> 2];
   $13_1 = $22_1 + $4_1 | 0;
   $27_1 = HEAP32[$6_1 + 2212 >> 2];
   $3_1 = $27_1 + HEAP32[$6_1 + 2260 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 2032 >> 2];
   $10_1 = $4_1 + $13_1 | 0;
   $21_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 2036 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $7_1 | 0;
   $7_1 = $10_1 + $11_1 | 0;
   $11_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $28_1 = ($4_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
   $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
   $3_1 = $26_1 + 8 | 0;
   $24_1 = HEAP32[$3_1 >> 2];
   $26_1 = HEAP32[$3_1 + 4 >> 2];
   $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
   $10_1 = $23_1 + 8 | 0;
   $4_1 = HEAP32[$10_1 >> 2];
   $3_1 = $25_1 + 8 | 0;
   $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $13_1 + $21_1 | 0;
   $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
   $13_1 = $4_1;
   $4_1 = $4_1 + $24_1 | 0;
   $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $4_1 + $20_1 | 0;
   $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $28_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $13_1 = $11_1;
   $21_1 = $4_1 << 12 | $11_1 >>> 20;
   $5_1 = $3_1;
   $10_1 = $3_1 << 12 | $4_1 >>> 20;
   $24_1 = HEAP32[$6_1 + 2016 >> 2];
   $11_1 = $24_1 + ($17_1 & -2) | 0;
   $26_1 = HEAP32[$6_1 + 2020 >> 2];
   $3_1 = $26_1 + ($14_1 & 1048575) | 0;
   $3_1 = $11_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $17_1 = $11_1;
   $11_1 = $11_1 + $21_1 | 0;
   $4_1 = $3_1;
   $3_1 = $3_1 + $10_1 | 0;
   $14_1 = $9_1;
   $21_1 = $18_1 & 65535;
   $10_1 = $11_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $18_1 = ($4_1 | 0) == ($10_1 | 0) & $11_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $10_1 >>> 0;
   $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
   $3_1 = $19_1 + 8 | 0;
   $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2];
   $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $9_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $18_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $9_1 = $4_1 << 12 | $10_1 >>> 20;
   $5_1 = $9_1 + $14_1 | 0;
   $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
   $4_1 = $5_1;
   $9_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $10_1 & 1048575;
   $13_1 = $13_1 & 1048575;
   $14_1 = $16_1 & 1048575;
   $5_1 = $12_1;
   $12_1 = $15_1 & 1048575;
   $1_1 = $1_1 - 1 | 0;
   if ($1_1) {
    continue
   }
   break;
  };
  $3_1 = $6_1 + 7216 | 0;
  $24_1 = $3_1 + 32 | 0;
  HEAP32[$24_1 >> 2] = $4_1;
  HEAP32[$24_1 + 4 >> 2] = $9_1;
  $1_1 = $3_1 + 24 | 0;
  HEAP32[$1_1 >> 2] = $11_1;
  HEAP32[$1_1 + 4 >> 2] = $10_1;
  $9_1 = $3_1 + 16 | 0;
  HEAP32[$9_1 >> 2] = $7_1;
  HEAP32[$9_1 + 4 >> 2] = $13_1;
  $17_1 = $3_1 + 8 | 0;
  HEAP32[$17_1 >> 2] = $8_1;
  HEAP32[$17_1 + 4 >> 2] = $14_1;
  HEAP32[$6_1 + 7216 >> 2] = $5_1;
  HEAP32[$6_1 + 7220 >> 2] = $12_1;
  $34($3_1, $3_1, $6_1 + 7336 | 0);
  $12_1 = HEAP32[$1_1 >> 2];
  $5_1 = $12_1;
  $10_1 = HEAP32[$1_1 + 4 >> 2];
  $4_1 = $10_1;
  $1_1 = HEAP32[$6_1 + 7220 >> 2];
  $20_1 = $1_1;
  $18_1 = HEAP32[$6_1 + 7216 >> 2];
  $7_1 = $18_1;
  $3_1 = $1_1 << 1 | $7_1 >>> 31;
  $15_1 = $6_1 + 1856 | 0;
  $21_1 = $7_1 << 1;
  $26_1 = $3_1;
  $69($15_1, $5_1, $4_1, 0, 0, $21_1, $3_1, 0, 0);
  $1_1 = HEAP32[$17_1 + 4 >> 2];
  $40_1 = $1_1;
  $33_1 = HEAP32[$17_1 >> 2];
  $4_1 = $33_1;
  $3_1 = $1_1 << 1 | $4_1 >>> 31;
  $16_1 = $6_1 + 1952 | 0;
  $13_1 = HEAP32[$9_1 >> 2];
  $9_1 = HEAP32[$9_1 + 4 >> 2];
  $4_1 = $4_1 << 1;
  $5_1 = $3_1;
  $69($16_1, $13_1, $9_1, 0, 0, $4_1, $3_1, 0, 0);
  $14_1 = $6_1 + 1840 | 0;
  $8_1 = HEAP32[$24_1 >> 2];
  $1_1 = HEAP32[$24_1 + 4 >> 2];
  $69($14_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
  $11_1 = $6_1 + 1824 | 0;
  $69($11_1, HEAP32[$6_1 + 1840 >> 2], HEAP32[$6_1 + 1844 >> 2], 0, 0, 15632, 16, 0, 0);
  $3_1 = $1_1 << 1 | $8_1 >>> 31;
  $39_1 = $6_1 + 1792 | 0;
  $24_1 = $8_1 << 1;
  $17_1 = $3_1;
  $69($39_1, $24_1, $3_1, 0, 0, $7_1, $20_1, 0, 0);
  $38_1 = $6_1 + 1872 | 0;
  $69($38_1, $12_1, $10_1, 0, 0, $4_1, $5_1, 0, 0);
  $35_1 = $6_1 + 1936 | 0;
  $69($35_1, $13_1, $9_1, 0, 0, $13_1, $9_1, 0, 0);
  $28_1 = $6_1 + 1808 | 0;
  $1_1 = $14_1 + 8 | 0;
  $69($28_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $36_1 = $6_1 + 2e3 | 0;
  $69($36_1, $7_1, $20_1, 0, 0, $7_1, $20_1, 0, 0);
  $31_1 = $6_1 + 1776 | 0;
  $69($31_1, $24_1, $3_1, 0, 0, $33_1, $40_1, 0, 0);
  $37_1 = $6_1 + 1888 | 0;
  $69($37_1, $12_1, $10_1, 0, 0, $13_1 << 1, $9_1 << 1 | $13_1 >>> 31, 0, 0);
  $20_1 = HEAP32[$6_1 + 1860 >> 2];
  $3_1 = $20_1 + HEAP32[$6_1 + 1956 >> 2] | 0;
  $8_1 = HEAP32[$6_1 + 1856 >> 2];
  $4_1 = HEAP32[$6_1 + 1952 >> 2];
  $1_1 = $8_1 + $4_1 | 0;
  $5_1 = HEAP32[$6_1 + 1824 >> 2];
  $18_1 = $1_1 + $5_1 | 0;
  $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1 + HEAP32[$6_1 + 1828 >> 2] | 0;
  $5_1 = $5_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
  $3_1 = $11_1 + 8 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $7_1 = HEAP32[$3_1 + 4 >> 2];
  $8_1 = ($4_1 | 0) == ($20_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $20_1 >>> 0;
  $3_1 = $16_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $15_1 + 8 | 0;
  $16_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $16_1 | 0;
  $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $11_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $14_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $15_1 = $5_1;
  $11_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $30_1 = HEAP32[$6_1 + 1872 >> 2];
  $1_1 = HEAP32[$6_1 + 1936 >> 2];
  $14_1 = $30_1 + $1_1 | 0;
  $34_1 = HEAP32[$6_1 + 1876 >> 2];
  $3_1 = $34_1 + HEAP32[$6_1 + 1940 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 1792 >> 2];
  $7_1 = $1_1 + $14_1 | 0;
  $20_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 1796 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 1808 >> 2];
  $5_1 = $1_1 + $7_1 | 0;
  $16_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 1812 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $32_1 = $6_1 + 1760 | 0;
  $29_1 = $32_1;
  $11_1 = $5_1 + $11_1 | 0;
  $8_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $27_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
  $25_1 = ($1_1 | 0) == ($16_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
  $1_1 = $28_1 + 8 | 0;
  $23_1 = HEAP32[$1_1 >> 2];
  $19_1 = HEAP32[$1_1 + 4 >> 2];
  $22_1 = ($16_1 | 0) == ($20_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $16_1 >>> 0 < $20_1 >>> 0;
  $1_1 = $39_1 + 8 | 0;
  $28_1 = HEAP32[$1_1 >> 2];
  $16_1 = HEAP32[$1_1 + 4 >> 2];
  $7_1 = ($20_1 | 0) == ($34_1 | 0) & $14_1 >>> 0 < $30_1 >>> 0 | $20_1 >>> 0 < $34_1 >>> 0;
  $3_1 = $35_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $38_1 + 8 | 0;
  $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $7_1 + $14_1 | 0;
  $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $28_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $22_1 | 0;
  $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $23_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1 + $25_1 | 0;
  $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $27_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $8_1;
  $7_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $19_1 = HEAP32[$6_1 + 1776 >> 2];
  $1_1 = HEAP32[$6_1 + 1888 >> 2];
  $14_1 = $19_1 + $1_1 | 0;
  $23_1 = HEAP32[$6_1 + 1780 >> 2];
  $3_1 = $23_1 + HEAP32[$6_1 + 1892 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $7_1 = $7_1 + $14_1 | 0;
  $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $28_1 = $7_1 << 4 & -16;
  $8_1 = $3_1;
  $20_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
  $16_1 = $4_1;
  $69($29_1, $28_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
  $29_1 = $6_1 + 1984 | 0;
  $69($29_1, $33_1, $40_1, 0, 0, $21_1, $26_1, 0, 0);
  $25_1 = $6_1 + 1728 | 0;
  $69($25_1, $24_1, $17_1, 0, 0, $13_1, $9_1, 0, 0);
  $22_1 = $6_1 + 1904 | 0;
  $69($22_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
  $28_1 = $6_1 + 1712 | 0;
  $20_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
  $3_1 = $37_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $31_1 + 8 | 0;
  $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $7_1 + $14_1 | 0;
  $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $8_1 >>> 20;
  $4_1 = $3_1;
  $14_1 = $3_1 << 12 | $1_1 >>> 20;
  $27_1 = HEAP32[$6_1 + 1732 >> 2];
  $3_1 = $27_1 + HEAP32[$6_1 + 1908 >> 2] | 0;
  $20_1 = HEAP32[$6_1 + 1728 >> 2];
  $1_1 = HEAP32[$6_1 + 1904 >> 2];
  $5_1 = $20_1 + $1_1 | 0;
  $7_1 = $5_1;
  $8_1 = $5_1 + $8_1 | 0;
  $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $14_1 | 0;
  $5_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($28_1, $8_1, $5_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $23_1 = $6_1 + 1920 | 0;
  $69($23_1, $13_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
  $19_1 = $6_1 + 1968 | 0;
  $69($19_1, $33_1, $40_1, 0, 0, $33_1, $40_1, 0, 0);
  $14_1 = $6_1 + 1664 | 0;
  $69($14_1, $24_1, $17_1, 0, 0, $12_1, $10_1, 0, 0);
  $21_1 = $6_1 + 1648 | 0;
  $10_1 = $21_1;
  $9_1 = ($1_1 | 0) == ($5_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
  $7_1 = ($1_1 | 0) == ($27_1 | 0) & $7_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $27_1 >>> 0;
  $3_1 = $22_1 + 8 | 0;
  $8_1 = HEAP32[$3_1 >> 2];
  $1_1 = $25_1 + 8 | 0;
  $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $7_1 + $12_1 | 0;
  $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $5_1 >>> 20;
  $5_1 = HEAP32[$6_1 + 1664 >> 2];
  $9_1 = $8_1 + $5_1 | 0;
  $4_1 = $3_1;
  $1_1 = $3_1 << 12 | $1_1 >>> 20;
  $3_1 = $1_1 + HEAP32[$6_1 + 1668 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
  $27_1 = $6_1 + 1584 | 0;
  $7_1 = $27_1;
  $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $1_1 = $14_1 + 8 | 0;
  $5_1 = HEAP32[$1_1 >> 2];
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
  $4_1 = HEAP32[$6_1 + 1760 >> 2];
  $1_1 = HEAP32[$6_1 + 2e3 >> 2];
  $7_1 = $4_1 + $1_1 | 0;
  $8_1 = HEAP32[$6_1 + 1764 >> 2];
  $3_1 = $8_1 + HEAP32[$6_1 + 2004 >> 2] | 0;
  $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
  $3_1 = $36_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $32_1 + 8 | 0;
  $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $9_1 | 0;
  $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $5_1;
  $8_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $12_1 = $3_1 << 12 | $1_1 >>> 20;
  $14_1 = HEAP32[$6_1 + 1716 >> 2];
  $3_1 = $14_1 + HEAP32[$6_1 + 1988 >> 2] | 0;
  $10_1 = HEAP32[$6_1 + 1712 >> 2];
  $1_1 = HEAP32[$6_1 + 1984 >> 2];
  $5_1 = $10_1 + $1_1 | 0;
  $9_1 = $5_1;
  $8_1 = $5_1 + $8_1 | 0;
  $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $12_1 | 0;
  $5_1 = $8_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
  $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
  $3_1 = $29_1 + 8 | 0;
  $9_1 = HEAP32[$3_1 >> 2];
  $1_1 = $28_1 + 8 | 0;
  $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = $10_1 + $14_1 | 0;
  $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $12_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = $5_1;
  $9_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $22_1 = HEAP32[$6_1 + 1920 >> 2];
  $1_1 = HEAP32[$6_1 + 1968 >> 2];
  $12_1 = $22_1 + $1_1 | 0;
  $29_1 = HEAP32[$6_1 + 1924 >> 2];
  $3_1 = $29_1 + HEAP32[$6_1 + 1972 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 1648 >> 2];
  $10_1 = $1_1 + $12_1 | 0;
  $17_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 1652 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $25_1 = $6_1 + 1568 | 0;
  $5_1 = $9_1 + $10_1 | 0;
  $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
  $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
  $1_1 = $21_1 + 8 | 0;
  $26_1 = HEAP32[$1_1 >> 2];
  $21_1 = HEAP32[$1_1 + 4 >> 2];
  $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
  $3_1 = $19_1 + 8 | 0;
  $10_1 = HEAP32[$3_1 >> 2];
  $1_1 = $23_1 + 8 | 0;
  $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $12_1 + $17_1 | 0;
  $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
  $12_1 = $1_1;
  $1_1 = $1_1 + $26_1 | 0;
  $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $1_1 + $24_1 | 0;
  $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $10_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $9_1;
  $17_1 = $1_1 << 12 | $9_1 >>> 20;
  $4_1 = $3_1;
  $12_1 = $3_1 << 12 | $1_1 >>> 20;
  $29_1 = HEAP32[$6_1 + 1588 >> 2];
  $3_1 = $29_1 + ($15_1 & 1048575) | 0;
  $22_1 = HEAP32[$6_1 + 1584 >> 2];
  $9_1 = $18_1 & -2;
  $1_1 = $22_1 + $9_1 | 0;
  $15_1 = $1_1;
  $1_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $12_1 | 0;
  $12_1 = $15_1 + $17_1 | 0;
  $9_1 = $12_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $17_1 = $9_1 & 1048575;
  $3_1 = $13_1 & 1048575;
  $32_1 = $3_1;
  $13_1 = $7_1;
  $3_1 = $3_1 << 1 | $7_1 >>> 31;
  $26_1 = $7_1 << 1;
  $24_1 = $3_1;
  $69($25_1, $12_1, $17_1, 0, 0, $26_1, $3_1, 0, 0);
  $3_1 = $14_1 & 1048575;
  $33_1 = $3_1;
  $23_1 = $6_1 + 1600 | 0;
  $18_1 = $10_1 & 1048575;
  $7_1 = $8_1 << 1;
  $28_1 = $8_1;
  $10_1 = $3_1 << 1 | $8_1 >>> 31;
  $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
  $19_1 = $6_1 + 1504 | 0;
  $21_1 = $16_1 & 65535;
  $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
  $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
  $1_1 = $27_1 + 8 | 0;
  $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $16_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $9_1 >>> 20;
  $4_1 = $8_1 + $11_1 | 0;
  $3_1 = $21_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
  $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($19_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
  $11_1 = $6_1 + 1488 | 0;
  $69($11_1, HEAP32[$6_1 + 1504 >> 2], HEAP32[$6_1 + 1508 >> 2], 0, 0, 15632, 16, 0, 0);
  $1_1 = $4_1;
  $3_1 = $3_1 << 1 | $1_1 >>> 31;
  $39_1 = $6_1 + 1456 | 0;
  $20_1 = $1_1 << 1;
  $21_1 = $3_1;
  $69($39_1, $20_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
  $38_1 = $6_1 + 1552 | 0;
  $69($38_1, $12_1, $17_1, 0, 0, $7_1, $10_1, 0, 0);
  $35_1 = $6_1 + 1616 | 0;
  $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
  $22_1 = $6_1 + 1472 | 0;
  $1_1 = $19_1 + 8 | 0;
  $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $36_1 = $6_1 + 1744 | 0;
  $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
  $31_1 = $6_1 + 1440 | 0;
  $69($31_1, $20_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
  $37_1 = $6_1 + 1520 | 0;
  $10_1 = $17_1;
  $9_1 = $18_1;
  $17_1 = $5_1;
  $69($37_1, $12_1, $10_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
  $8_1 = HEAP32[$6_1 + 1568 >> 2];
  $4_1 = HEAP32[$6_1 + 1600 >> 2];
  $1_1 = $8_1 + $4_1 | 0;
  $13_1 = HEAP32[$6_1 + 1572 >> 2];
  $3_1 = $13_1 + HEAP32[$6_1 + 1604 >> 2] | 0;
  $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = HEAP32[$6_1 + 1488 >> 2];
  $18_1 = $4_1 + $1_1 | 0;
  $5_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 1492 >> 2] | 0;
  $4_1 = $4_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
  $3_1 = $11_1 + 8 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $7_1 = HEAP32[$3_1 + 4 >> 2];
  $8_1 = ($5_1 | 0) == ($13_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $13_1 >>> 0;
  $3_1 = $23_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $25_1 + 8 | 0;
  $13_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $13_1 | 0;
  $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $11_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $14_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $15_1 = $4_1;
  $11_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $30_1 = HEAP32[$6_1 + 1552 >> 2];
  $1_1 = HEAP32[$6_1 + 1616 >> 2];
  $13_1 = $30_1 + $1_1 | 0;
  $34_1 = HEAP32[$6_1 + 1556 >> 2];
  $3_1 = $34_1 + HEAP32[$6_1 + 1620 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 1456 >> 2];
  $14_1 = $1_1 + $13_1 | 0;
  $4_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 1460 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 1472 >> 2];
  $7_1 = $1_1 + $14_1 | 0;
  $16_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 1476 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $32_1 = $6_1 + 1344 | 0;
  $29_1 = $32_1;
  $11_1 = $7_1 + $11_1 | 0;
  $8_1 = $11_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $27_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
  $25_1 = ($1_1 | 0) == ($16_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
  $1_1 = $22_1 + 8 | 0;
  $23_1 = HEAP32[$1_1 >> 2];
  $19_1 = HEAP32[$1_1 + 4 >> 2];
  $22_1 = ($4_1 | 0) == ($16_1 | 0) & $13_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 > $16_1 >>> 0;
  $1_1 = $39_1 + 8 | 0;
  $16_1 = HEAP32[$1_1 >> 2];
  $14_1 = HEAP32[$1_1 + 4 >> 2];
  $7_1 = ($4_1 | 0) == ($34_1 | 0) & $13_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
  $3_1 = $35_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $38_1 + 8 | 0;
  $13_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $7_1 + $13_1 | 0;
  $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $14_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $16_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $22_1 | 0;
  $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $23_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1 + $25_1 | 0;
  $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $27_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $8_1;
  $7_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $19_1 = HEAP32[$6_1 + 1440 >> 2];
  $1_1 = HEAP32[$6_1 + 1520 >> 2];
  $14_1 = $19_1 + $1_1 | 0;
  $23_1 = HEAP32[$6_1 + 1444 >> 2];
  $3_1 = $23_1 + HEAP32[$6_1 + 1524 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $7_1 = $7_1 + $14_1 | 0;
  $3_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $22_1 = $7_1 << 4 & -16;
  $8_1 = $3_1;
  $13_1 = ($3_1 << 4 | $7_1 >>> 28) & 16777215;
  $16_1 = $4_1;
  $69($29_1, $22_1 | $4_1 >>> 16 & 15, $13_1, 0, 0, 977, 1, 0, 0);
  $29_1 = $6_1 + 1680 | 0;
  $69($29_1, $28_1, $33_1, 0, 0, $26_1, $24_1, 0, 0);
  $27_1 = $6_1 + 1424 | 0;
  $69($27_1, $20_1, $21_1, 0, 0, $17_1, $9_1, 0, 0);
  $25_1 = $6_1 + 1536 | 0;
  $69($25_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
  $22_1 = $6_1 + 1408 | 0;
  $13_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $7_1 = ($1_1 | 0) == ($23_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $23_1 >>> 0;
  $3_1 = $37_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $31_1 + 8 | 0;
  $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $7_1 + $14_1 | 0;
  $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $13_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $8_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $13_1 = HEAP32[$6_1 + 1424 >> 2];
  $1_1 = HEAP32[$6_1 + 1536 >> 2];
  $7_1 = $13_1 + $1_1 | 0;
  $30_1 = HEAP32[$6_1 + 1428 >> 2];
  $3_1 = $30_1 + HEAP32[$6_1 + 1540 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $8_1 = $7_1 + $8_1 | 0;
  $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $3_1;
  $69($22_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $23_1 = $6_1 + 1632 | 0;
  $69($23_1, $17_1, $9_1, 0, 0, $26_1, $24_1, 0, 0);
  $19_1 = $6_1 + 1696 | 0;
  $69($19_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
  $14_1 = $6_1 + 1392 | 0;
  $69($14_1, $12_1, $10_1, 0, 0, $20_1, $21_1, 0, 0);
  $21_1 = $6_1 + 1376 | 0;
  $10_1 = $21_1;
  $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $7_1 = ($1_1 | 0) == ($30_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
  $3_1 = $25_1 + 8 | 0;
  $8_1 = HEAP32[$3_1 >> 2];
  $1_1 = $27_1 + 8 | 0;
  $12_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $7_1 + $12_1 | 0;
  $3_1 = $8_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $5_1 >>> 20;
  $5_1 = HEAP32[$6_1 + 1392 >> 2];
  $9_1 = $8_1 + $5_1 | 0;
  $4_1 = $3_1;
  $1_1 = $3_1 << 12 | $1_1 >>> 20;
  $3_1 = $1_1 + HEAP32[$6_1 + 1396 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($10_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
  $27_1 = $6_1 + 1360 | 0;
  $7_1 = $27_1;
  $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $1_1 = $14_1 + 8 | 0;
  $5_1 = HEAP32[$1_1 >> 2];
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
  $4_1 = HEAP32[$6_1 + 1344 >> 2];
  $1_1 = HEAP32[$6_1 + 1744 >> 2];
  $7_1 = $4_1 + $1_1 | 0;
  $8_1 = HEAP32[$6_1 + 1348 >> 2];
  $3_1 = $8_1 + HEAP32[$6_1 + 1748 >> 2] | 0;
  $5_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = ($8_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $7_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
  $3_1 = $36_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $32_1 + 8 | 0;
  $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $9_1 | 0;
  $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $5_1;
  $8_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $10_1 = HEAP32[$6_1 + 1408 >> 2];
  $1_1 = HEAP32[$6_1 + 1680 >> 2];
  $9_1 = $10_1 + $1_1 | 0;
  $14_1 = HEAP32[$6_1 + 1412 >> 2];
  $3_1 = $14_1 + HEAP32[$6_1 + 1684 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $8_1 = $8_1 + $9_1 | 0;
  $5_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = ($1_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
  $10_1 = ($1_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
  $3_1 = $29_1 + 8 | 0;
  $9_1 = HEAP32[$3_1 >> 2];
  $1_1 = $22_1 + 8 | 0;
  $14_1 = $9_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = $10_1 + $14_1 | 0;
  $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $12_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = $5_1;
  $9_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $22_1 = HEAP32[$6_1 + 1632 >> 2];
  $1_1 = HEAP32[$6_1 + 1696 >> 2];
  $12_1 = $22_1 + $1_1 | 0;
  $29_1 = HEAP32[$6_1 + 1636 >> 2];
  $3_1 = $29_1 + HEAP32[$6_1 + 1700 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 1376 >> 2];
  $10_1 = $1_1 + $12_1 | 0;
  $17_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 1380 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $25_1 = $6_1 + 1264 | 0;
  $5_1 = $9_1 + $10_1 | 0;
  $9_1 = $5_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $20_1 = ($1_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
  $24_1 = ($1_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $17_1 >>> 0;
  $1_1 = $21_1 + 8 | 0;
  $26_1 = HEAP32[$1_1 >> 2];
  $21_1 = HEAP32[$1_1 + 4 >> 2];
  $12_1 = ($17_1 | 0) == ($29_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $17_1 >>> 0 < $29_1 >>> 0;
  $3_1 = $19_1 + 8 | 0;
  $10_1 = HEAP32[$3_1 >> 2];
  $1_1 = $23_1 + 8 | 0;
  $17_1 = $10_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $10_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $12_1 + $17_1 | 0;
  $3_1 = ($1_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $21_1 | 0;
  $12_1 = $1_1;
  $1_1 = $1_1 + $26_1 | 0;
  $3_1 = $12_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $1_1 + $24_1 | 0;
  $3_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $10_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $9_1;
  $12_1 = $1_1 << 12 | $9_1 >>> 20;
  $4_1 = $3_1;
  $17_1 = $3_1 << 12 | $1_1 >>> 20;
  $29_1 = HEAP32[$6_1 + 1364 >> 2];
  $3_1 = $29_1 + ($15_1 & 1048575) | 0;
  $22_1 = HEAP32[$6_1 + 1360 >> 2];
  $1_1 = $18_1 & -2;
  $9_1 = $22_1 + $1_1 | 0;
  $15_1 = $9_1;
  $12_1 = $9_1 + $12_1 | 0;
  $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $17_1 | 0;
  $9_1 = $12_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $20_1 = $9_1 & 1048575;
  $18_1 = $20_1;
  $3_1 = $13_1 & 1048575;
  $32_1 = $3_1;
  $13_1 = $7_1;
  $3_1 = $3_1 << 1 | $7_1 >>> 31;
  $21_1 = $7_1 << 1;
  $26_1 = $3_1;
  $69($25_1, $12_1, $18_1, 0, 0, $21_1, $3_1, 0, 0);
  $3_1 = $14_1 & 1048575;
  $33_1 = $3_1;
  $23_1 = $6_1 + 1216 | 0;
  $18_1 = $10_1 & 1048575;
  $7_1 = $8_1 << 1;
  $28_1 = $8_1;
  $10_1 = $3_1 << 1 | $8_1 >>> 31;
  $69($23_1, $5_1, $18_1, 0, 0, $7_1, $10_1, 0, 0);
  $19_1 = $6_1 + 1168 | 0;
  $17_1 = $16_1 & 65535;
  $16_1 = ($1_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
  $14_1 = ($1_1 | 0) == ($29_1 | 0) & $15_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $29_1 >>> 0;
  $1_1 = $27_1 + 8 | 0;
  $8_1 = $14_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  $3_1 = $8_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $8_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $16_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $1_1 << 12 | $9_1 >>> 20;
  $4_1 = $8_1 + $11_1 | 0;
  $3_1 = $17_1 + ($3_1 << 12 | $1_1 >>> 20) | 0;
  $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($19_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
  $11_1 = $6_1 + 1152 | 0;
  $69($11_1, HEAP32[$6_1 + 1168 >> 2], HEAP32[$6_1 + 1172 >> 2], 0, 0, 15632, 16, 0, 0);
  $1_1 = $4_1;
  $3_1 = $3_1 << 1 | $1_1 >>> 31;
  $39_1 = $6_1 + 1120 | 0;
  $24_1 = $1_1 << 1;
  $17_1 = $3_1;
  $69($39_1, $24_1, $3_1, 0, 0, $13_1, $32_1, 0, 0);
  $38_1 = $6_1 + 1200 | 0;
  $69($38_1, $12_1, $20_1, 0, 0, $7_1, $10_1, 0, 0);
  $35_1 = $6_1 + 1312 | 0;
  $69($35_1, $5_1, $18_1, 0, 0, $5_1, $18_1, 0, 0);
  $22_1 = $6_1 + 1136 | 0;
  $1_1 = $19_1 + 8 | 0;
  $69($22_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $36_1 = $6_1 + 1280 | 0;
  $69($36_1, $13_1, $32_1, 0, 0, $13_1, $32_1, 0, 0);
  $31_1 = $6_1 + 1104 | 0;
  $69($31_1, $24_1, $3_1, 0, 0, $28_1, $33_1, 0, 0);
  $37_1 = $6_1 + 1184 | 0;
  $16_1 = $12_1;
  $13_1 = $20_1;
  $9_1 = $18_1;
  $18_1 = $5_1;
  $69($37_1, $12_1, $13_1, 0, 0, $5_1 << 1, $9_1 << 1 | $5_1 >>> 31, 0, 0);
  $8_1 = HEAP32[$6_1 + 1264 >> 2];
  $4_1 = HEAP32[$6_1 + 1216 >> 2];
  $1_1 = $8_1 + $4_1 | 0;
  $12_1 = HEAP32[$6_1 + 1268 >> 2];
  $3_1 = $12_1 + HEAP32[$6_1 + 1220 >> 2] | 0;
  $3_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = HEAP32[$6_1 + 1152 >> 2];
  $14_1 = $4_1 + $1_1 | 0;
  $5_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 1156 >> 2] | 0;
  $4_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = ($5_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
  $3_1 = $11_1 + 8 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $7_1 = HEAP32[$3_1 + 4 >> 2];
  $8_1 = ($5_1 | 0) == ($12_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $12_1 >>> 0;
  $3_1 = $23_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $25_1 + 8 | 0;
  $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $12_1 | 0;
  $3_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $11_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $10_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $4_1;
  $7_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $30_1 = HEAP32[$6_1 + 1200 >> 2];
  $1_1 = HEAP32[$6_1 + 1312 >> 2];
  $15_1 = $30_1 + $1_1 | 0;
  $34_1 = HEAP32[$6_1 + 1204 >> 2];
  $3_1 = $34_1 + HEAP32[$6_1 + 1316 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 1120 >> 2];
  $10_1 = $1_1 + $15_1 | 0;
  $4_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 1124 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 1136 >> 2];
  $11_1 = $1_1 + $10_1 | 0;
  $20_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 1140 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $32_1 = $6_1 + 1008 | 0;
  $29_1 = $32_1;
  $8_1 = $7_1 + $11_1 | 0;
  $7_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $27_1 = ($1_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
  $25_1 = ($1_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 < $20_1 >>> 0;
  $1_1 = $22_1 + 8 | 0;
  $23_1 = HEAP32[$1_1 >> 2];
  $19_1 = HEAP32[$1_1 + 4 >> 2];
  $22_1 = ($4_1 | 0) == ($20_1 | 0) & $10_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $20_1 >>> 0;
  $1_1 = $39_1 + 8 | 0;
  $20_1 = HEAP32[$1_1 >> 2];
  $10_1 = HEAP32[$1_1 + 4 >> 2];
  $11_1 = ($4_1 | 0) == ($34_1 | 0) & $15_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 < $34_1 >>> 0;
  $3_1 = $35_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $38_1 + 8 | 0;
  $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $11_1 + $15_1 | 0;
  $3_1 = ($1_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $22_1 | 0;
  $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $19_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $23_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1 + $25_1 | 0;
  $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $27_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $7_1;
  $11_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $7_1 = $3_1 << 12 | $1_1 >>> 20;
  $19_1 = HEAP32[$6_1 + 1104 >> 2];
  $1_1 = HEAP32[$6_1 + 1184 >> 2];
  $15_1 = $19_1 + $1_1 | 0;
  $30_1 = HEAP32[$6_1 + 1108 >> 2];
  $3_1 = $30_1 + HEAP32[$6_1 + 1188 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $7_1 | 0;
  $11_1 = $11_1 + $15_1 | 0;
  $3_1 = $11_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $22_1 = $11_1 << 4 & -16;
  $7_1 = $3_1;
  $20_1 = ($3_1 << 4 | $11_1 >>> 28) & 16777215;
  $10_1 = $4_1;
  $69($29_1, $22_1 | $4_1 >>> 16 & 15, $20_1, 0, 0, 977, 1, 0, 0);
  $29_1 = $6_1 + 1248 | 0;
  $69($29_1, $28_1, $33_1, 0, 0, $21_1, $26_1, 0, 0);
  $27_1 = $6_1 + 1088 | 0;
  $69($27_1, $24_1, $17_1, 0, 0, $18_1, $9_1, 0, 0);
  $25_1 = $6_1 + 1328 | 0;
  $69($25_1, $16_1, $13_1, 0, 0, $16_1, $13_1, 0, 0);
  $23_1 = $6_1 + 1072 | 0;
  $22_1 = $23_1;
  $20_1 = ($1_1 | 0) == ($3_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $11_1 = ($1_1 | 0) == ($30_1 | 0) & $15_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
  $3_1 = $37_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $31_1 + 8 | 0;
  $15_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $11_1 + $15_1 | 0;
  $3_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $20_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 << 12 | $7_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $20_1 = HEAP32[$6_1 + 1088 >> 2];
  $1_1 = HEAP32[$6_1 + 1328 >> 2];
  $11_1 = $20_1 + $1_1 | 0;
  $30_1 = HEAP32[$6_1 + 1092 >> 2];
  $3_1 = $30_1 + HEAP32[$6_1 + 1332 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $7_1 = $7_1 + $11_1 | 0;
  $3_1 = $7_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $3_1;
  $69($22_1, $7_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $19_1 = $6_1 + 1232 | 0;
  $69($19_1, $18_1, $9_1, 0, 0, $21_1, $26_1, 0, 0);
  $22_1 = $6_1 + 1296 | 0;
  $69($22_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
  $15_1 = $6_1 + 1056 | 0;
  $69($15_1, $16_1, $13_1, 0, 0, $24_1, $17_1, 0, 0);
  $18_1 = $6_1 + 1040 | 0;
  $13_1 = $18_1;
  $9_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $11_1 = ($1_1 | 0) == ($30_1 | 0) & $11_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $30_1 >>> 0;
  $3_1 = $25_1 + 8 | 0;
  $7_1 = HEAP32[$3_1 >> 2];
  $1_1 = $27_1 + 8 | 0;
  $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $11_1 + $16_1 | 0;
  $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $7_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 << 12 | $5_1 >>> 20;
  $5_1 = HEAP32[$6_1 + 1056 >> 2];
  $9_1 = $7_1 + $5_1 | 0;
  $4_1 = $3_1;
  $1_1 = $3_1 << 12 | $1_1 >>> 20;
  $3_1 = $1_1 + HEAP32[$6_1 + 1060 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($13_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
  $20_1 = $6_1 + 1024 | 0;
  $11_1 = $20_1;
  $7_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $1_1 = $15_1 + 8 | 0;
  $5_1 = HEAP32[$1_1 >> 2];
  $3_1 = HEAP32[$1_1 + 4 >> 2];
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $7_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($11_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
  $4_1 = HEAP32[$6_1 + 1008 >> 2];
  $1_1 = HEAP32[$6_1 + 1280 >> 2];
  $9_1 = $4_1 + $1_1 | 0;
  $7_1 = HEAP32[$6_1 + 1012 >> 2];
  $3_1 = $7_1 + HEAP32[$6_1 + 1284 >> 2] | 0;
  $30_1 = $6_1 + 7176 | 0;
  $27_1 = $30_1 + 8 | 0;
  $16_1 = $27_1;
  $5_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = ($7_1 | 0) == ($5_1 | 0) & $4_1 >>> 0 > $9_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
  $3_1 = $36_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $32_1 + 8 | 0;
  $11_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $7_1 + $11_1 | 0;
  $3_1 = $1_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $11_1 = $5_1;
  $7_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $15_1 = HEAP32[$6_1 + 1072 >> 2];
  $1_1 = HEAP32[$6_1 + 1248 >> 2];
  $13_1 = $15_1 + $1_1 | 0;
  $21_1 = HEAP32[$6_1 + 1076 >> 2];
  $3_1 = $21_1 + HEAP32[$6_1 + 1252 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $7_1 = $7_1 + $13_1 | 0;
  $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$16_1 >> 2] = $7_1;
  $5_1 = $3_1;
  HEAP32[$16_1 + 4 >> 2] = $3_1 & 1048575;
  $25_1 = $30_1 + 16 | 0;
  $17_1 = $25_1;
  $16_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $13_1 = ($1_1 | 0) == ($21_1 | 0) & $13_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 < $21_1 >>> 0;
  $3_1 = $29_1 + 8 | 0;
  $7_1 = HEAP32[$3_1 >> 2];
  $1_1 = $23_1 + 8 | 0;
  $15_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $7_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $13_1 + $15_1 | 0;
  $3_1 = $7_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $7_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $16_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $5_1 = $3_1 << 12 | $1_1 >>> 20;
  $24_1 = HEAP32[$6_1 + 1232 >> 2];
  $1_1 = HEAP32[$6_1 + 1296 >> 2];
  $16_1 = $24_1 + $1_1 | 0;
  $23_1 = HEAP32[$6_1 + 1236 >> 2];
  $3_1 = $23_1 + HEAP32[$6_1 + 1300 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 1040 >> 2];
  $13_1 = $1_1 + $16_1 | 0;
  $15_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 1044 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $5_1 | 0;
  $7_1 = $7_1 + $13_1 | 0;
  $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$17_1 >> 2] = $7_1;
  $5_1 = $3_1;
  HEAP32[$17_1 + 4 >> 2] = $3_1 & 1048575;
  $28_1 = $30_1 + 24 | 0;
  $26_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $21_1 = ($1_1 | 0) == ($15_1 | 0) & $13_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 < $15_1 >>> 0;
  $1_1 = $18_1 + 8 | 0;
  $17_1 = HEAP32[$1_1 >> 2];
  $18_1 = HEAP32[$1_1 + 4 >> 2];
  $13_1 = ($15_1 | 0) == ($23_1 | 0) & $16_1 >>> 0 < $24_1 >>> 0 | $15_1 >>> 0 < $23_1 >>> 0;
  $3_1 = $22_1 + 8 | 0;
  $7_1 = HEAP32[$3_1 >> 2];
  $1_1 = $19_1 + 8 | 0;
  $16_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $13_1 + $16_1 | 0;
  $3_1 = ($1_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
  $7_1 = $1_1;
  $1_1 = $1_1 + $17_1 | 0;
  $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 + $21_1 | 0;
  $3_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $7_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $26_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $7_1 = $3_1 << 12 | $1_1 >>> 20;
  $16_1 = HEAP32[$6_1 + 1024 >> 2];
  $5_1 = $14_1 & -2;
  $1_1 = $16_1 + $5_1 | 0;
  $18_1 = HEAP32[$6_1 + 1028 >> 2];
  $3_1 = $18_1 + ($12_1 & 1048575) | 0;
  $14_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $14_1 + $7_1 | 0;
  $12_1 = $1_1;
  $5_1 = $1_1 + $13_1 | 0;
  $3_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$28_1 >> 2] = $5_1;
  $1_1 = $3_1;
  HEAP32[$28_1 + 4 >> 2] = $3_1 & 1048575;
  $15_1 = $30_1 + 32 | 0;
  $7_1 = $8_1;
  $13_1 = $10_1 & 65535;
  $10_1 = ($3_1 | 0) == ($14_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $3_1 >>> 0 < $14_1 >>> 0;
  $5_1 = ($14_1 | 0) == ($18_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $14_1 >>> 0 < $18_1 >>> 0;
  $3_1 = $20_1 + 8 | 0;
  $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
  $3_1 = HEAP32[$3_1 + 4 >> 2];
  $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $5_1 = $4_1;
  $4_1 = $4_1 + $8_1 | 0;
  $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $4_1;
  $4_1 = $4_1 + $10_1 | 0;
  $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $4_1 << 12 | $1_1 >>> 20;
  $5_1 = $1_1 + $7_1 | 0;
  $3_1 = $13_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
  HEAP32[$15_1 >> 2] = $5_1;
  HEAP32[$15_1 + 4 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$6_1 + 7176 >> 2] = $9_1;
  HEAP32[$6_1 + 7180 >> 2] = $11_1 & 1048575;
  $34($30_1, $30_1, $6_1 + 7536 | 0);
  $9_1 = HEAP32[$15_1 + 4 >> 2];
  $3_1 = $6_1 + 7136 | 0;
  $1_1 = $3_1 + 32 | 0;
  $4_1 = HEAP32[$15_1 >> 2];
  HEAP32[$1_1 >> 2] = $4_1;
  HEAP32[$1_1 + 4 >> 2] = $9_1;
  $10_1 = HEAP32[$28_1 + 4 >> 2];
  $1_1 = $3_1 + 24 | 0;
  $11_1 = HEAP32[$28_1 >> 2];
  HEAP32[$1_1 >> 2] = $11_1;
  HEAP32[$1_1 + 4 >> 2] = $10_1;
  $13_1 = HEAP32[$25_1 + 4 >> 2];
  $1_1 = $3_1 + 16 | 0;
  $7_1 = HEAP32[$25_1 >> 2];
  HEAP32[$1_1 >> 2] = $7_1;
  HEAP32[$1_1 + 4 >> 2] = $13_1;
  $14_1 = HEAP32[$27_1 + 4 >> 2];
  $1_1 = $3_1 + 8 | 0;
  $8_1 = HEAP32[$27_1 >> 2];
  HEAP32[$1_1 >> 2] = $8_1;
  HEAP32[$1_1 + 4 >> 2] = $14_1;
  $12_1 = HEAP32[$6_1 + 7180 >> 2];
  $5_1 = HEAP32[$6_1 + 7176 >> 2];
  HEAP32[$6_1 + 7136 >> 2] = $5_1;
  HEAP32[$6_1 + 7140 >> 2] = $12_1;
  $1_1 = 23;
  while (1) {
   $15_1 = $5_1;
   $3_1 = $12_1 << 1 | $5_1 >>> 31;
   $25_1 = $6_1 + 976 | 0;
   $20_1 = $5_1 << 1;
   $28_1 = $3_1;
   $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
   $19_1 = $6_1 + 896 | 0;
   $5_1 = $8_1 << 1;
   $16_1 = $14_1;
   $24_1 = $8_1;
   $8_1 = $14_1 << 1 | $8_1 >>> 31;
   $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
   $17_1 = $6_1 + 832 | 0;
   $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
   $18_1 = $6_1 + 816 | 0;
   $69($18_1, HEAP32[$6_1 + 832 >> 2], HEAP32[$6_1 + 836 >> 2], 0, 0, 15632, 16, 0, 0);
   $3_1 = $9_1 << 1 | $4_1 >>> 31;
   $33_1 = $6_1 + 784 | 0;
   $22_1 = $4_1 << 1;
   $26_1 = $3_1;
   $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
   $34_1 = $6_1 + 944 | 0;
   $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
   $39_1 = $6_1 + 880 | 0;
   $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
   $23_1 = $6_1 + 800 | 0;
   $3_1 = $17_1 + 8 | 0;
   $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
   $38_1 = $6_1 + 992 | 0;
   $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
   $35_1 = $6_1 + 768 | 0;
   $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
   $36_1 = $6_1 + 848 | 0;
   $12_1 = $11_1;
   $21_1 = $7_1;
   $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
   $15_1 = HEAP32[$6_1 + 980 >> 2];
   $3_1 = $15_1 + HEAP32[$6_1 + 900 >> 2] | 0;
   $7_1 = HEAP32[$6_1 + 976 >> 2];
   $5_1 = HEAP32[$6_1 + 896 >> 2];
   $4_1 = $7_1 + $5_1 | 0;
   $8_1 = HEAP32[$6_1 + 816 >> 2];
   $17_1 = $4_1 + $8_1 | 0;
   $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $5_1 + HEAP32[$6_1 + 820 >> 2] | 0;
   $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
   $3_1 = $18_1 + 8 | 0;
   $9_1 = HEAP32[$3_1 >> 2];
   $11_1 = HEAP32[$3_1 + 4 >> 2];
   $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
   $5_1 = $19_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $25_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $7_1 + $15_1 | 0;
   $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
   $5_1 = $4_1;
   $4_1 = $4_1 + $9_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $14_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $14_1 = $8_1;
   $11_1 = $4_1 << 12 | $8_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 944 >> 2];
   $4_1 = HEAP32[$6_1 + 880 >> 2];
   $15_1 = $31_1 + $4_1 | 0;
   $40_1 = HEAP32[$6_1 + 948 >> 2];
   $3_1 = $40_1 + HEAP32[$6_1 + 884 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 784 >> 2];
   $9_1 = $4_1 + $15_1 | 0;
   $19_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 788 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 800 >> 2];
   $8_1 = $4_1 + $9_1 | 0;
   $18_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 804 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $7_1 | 0;
   $37_1 = $6_1 + 752 | 0;
   $11_1 = $8_1 + $11_1 | 0;
   $7_1 = $11_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
   $3_1 = $23_1 + 8 | 0;
   $29_1 = HEAP32[$3_1 >> 2];
   $27_1 = HEAP32[$3_1 + 4 >> 2];
   $25_1 = ($18_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
   $3_1 = $33_1 + 8 | 0;
   $23_1 = HEAP32[$3_1 >> 2];
   $18_1 = HEAP32[$3_1 + 4 >> 2];
   $9_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
   $8_1 = $39_1 + 8 | 0;
   $4_1 = HEAP32[$8_1 >> 2];
   $3_1 = $34_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $9_1 + $15_1 | 0;
   $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + $23_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $4_1;
   $4_1 = $4_1 + $25_1 | 0;
   $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + $29_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $4_1 + $32_1 | 0;
   $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $30_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $7_1;
   $9_1 = $4_1 << 12 | $5_1 >>> 20;
   $8_1 = $3_1;
   $18_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 772 >> 2];
   $3_1 = $31_1 + HEAP32[$6_1 + 852 >> 2] | 0;
   $25_1 = HEAP32[$6_1 + 768 >> 2];
   $4_1 = HEAP32[$6_1 + 848 >> 2];
   $7_1 = $25_1 + $4_1 | 0;
   $15_1 = $7_1;
   $9_1 = $7_1 + $9_1 | 0;
   $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $18_1 | 0;
   $23_1 = $9_1 << 4 & -16;
   $7_1 = $9_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $19_1 = ($7_1 << 4 | $9_1 >>> 28) & 16777215;
   $18_1 = $5_1;
   $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
   $30_1 = $6_1 + 928 | 0;
   $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
   $32_1 = $6_1 + 736 | 0;
   $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
   $29_1 = $6_1 + 960 | 0;
   $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
   $27_1 = $6_1 + 720 | 0;
   $23_1 = $27_1;
   $19_1 = ($4_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $9_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
   $5_1 = $36_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $35_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $9_1 + $15_1 | 0;
   $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $8_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $19_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $4_1 << 12 | $7_1 >>> 20;
   $5_1 = $3_1;
   $8_1 = $3_1 << 12 | $4_1 >>> 20;
   $15_1 = HEAP32[$6_1 + 736 >> 2];
   $4_1 = HEAP32[$6_1 + 960 >> 2];
   $9_1 = $15_1 + $4_1 | 0;
   $19_1 = HEAP32[$6_1 + 740 >> 2];
   $3_1 = $19_1 + HEAP32[$6_1 + 964 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $8_1 | 0;
   $7_1 = $7_1 + $9_1 | 0;
   $3_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $3_1;
   $69($23_1, $7_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
   $25_1 = $6_1 + 864 | 0;
   $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
   $23_1 = $6_1 + 912 | 0;
   $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
   $13_1 = $6_1 + 704 | 0;
   $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
   $26_1 = $6_1 + 688 | 0;
   $12_1 = $26_1;
   $10_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
   $9_1 = ($4_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $19_1 >>> 0;
   $7_1 = $29_1 + 8 | 0;
   $4_1 = HEAP32[$7_1 >> 2];
   $3_1 = $32_1 + 8 | 0;
   $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $9_1 + $16_1 | 0;
   $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $7_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $4_1 << 12 | $8_1 >>> 20;
   $8_1 = HEAP32[$6_1 + 704 >> 2];
   $10_1 = $7_1 + $8_1 | 0;
   $5_1 = $3_1;
   $4_1 = $3_1 << 12 | $4_1 >>> 20;
   $3_1 = $4_1 + HEAP32[$6_1 + 708 >> 2] | 0;
   $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
   $19_1 = $6_1 + 672 | 0;
   $9_1 = $19_1;
   $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
   $3_1 = $13_1 + 8 | 0;
   $8_1 = HEAP32[$3_1 >> 2];
   $3_1 = HEAP32[$3_1 + 4 >> 2];
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $7_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($9_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
   $5_1 = HEAP32[$6_1 + 752 >> 2];
   $4_1 = HEAP32[$6_1 + 992 >> 2];
   $12_1 = $5_1 + $4_1 | 0;
   $7_1 = HEAP32[$6_1 + 756 >> 2];
   $3_1 = $7_1 + HEAP32[$6_1 + 996 >> 2] | 0;
   $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
   $5_1 = $38_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $37_1 + 8 | 0;
   $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $7_1 + $9_1 | 0;
   $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $15_1 = $8_1;
   $9_1 = $4_1 << 12 | $8_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $10_1 = HEAP32[$6_1 + 720 >> 2];
   $4_1 = HEAP32[$6_1 + 928 >> 2];
   $8_1 = $10_1 + $4_1 | 0;
   $16_1 = HEAP32[$6_1 + 724 >> 2];
   $3_1 = $16_1 + HEAP32[$6_1 + 932 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $9_1;
   $9_1 = $8_1;
   $8_1 = $4_1 + $8_1 | 0;
   $4_1 = $3_1;
   $3_1 = $3_1 + $7_1 | 0;
   $7_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $10_1 = ($4_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
   $9_1 = $30_1 + 8 | 0;
   $4_1 = HEAP32[$9_1 >> 2];
   $3_1 = $27_1 + 8 | 0;
   $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$9_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $9_1 = $10_1 + $16_1 | 0;
   $3_1 = $9_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $9_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $13_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $16_1 = $7_1;
   $9_1 = $4_1 << 12 | $7_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $22_1 = HEAP32[$6_1 + 864 >> 2];
   $4_1 = HEAP32[$6_1 + 912 >> 2];
   $13_1 = $22_1 + $4_1 | 0;
   $27_1 = HEAP32[$6_1 + 868 >> 2];
   $3_1 = $27_1 + HEAP32[$6_1 + 916 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 688 >> 2];
   $10_1 = $4_1 + $13_1 | 0;
   $21_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 692 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $7_1 | 0;
   $7_1 = $9_1 + $10_1 | 0;
   $9_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $28_1 = ($4_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
   $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
   $3_1 = $26_1 + 8 | 0;
   $24_1 = HEAP32[$3_1 >> 2];
   $26_1 = HEAP32[$3_1 + 4 >> 2];
   $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
   $10_1 = $23_1 + 8 | 0;
   $4_1 = HEAP32[$10_1 >> 2];
   $3_1 = $25_1 + 8 | 0;
   $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $13_1 + $21_1 | 0;
   $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
   $13_1 = $4_1;
   $4_1 = $4_1 + $24_1 | 0;
   $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $4_1 + $20_1 | 0;
   $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $28_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $13_1 = $9_1;
   $10_1 = $4_1 << 12 | $9_1 >>> 20;
   $5_1 = $3_1;
   $9_1 = $3_1 << 12 | $4_1 >>> 20;
   $24_1 = HEAP32[$6_1 + 672 >> 2];
   $17_1 = $24_1 + ($17_1 & -2) | 0;
   $26_1 = HEAP32[$6_1 + 676 >> 2];
   $3_1 = $26_1 + ($14_1 & 1048575) | 0;
   $4_1 = $17_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $9_1 | 0;
   $14_1 = $11_1;
   $21_1 = $18_1 & 65535;
   $10_1 = $10_1 + $17_1 | 0;
   $9_1 = $10_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $11_1 = $10_1;
   $18_1 = ($4_1 | 0) == ($9_1 | 0) & $10_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
   $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
   $3_1 = $19_1 + 8 | 0;
   $10_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2];
   $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $18_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $9_1;
   $10_1 = $4_1 << 12 | $5_1 >>> 20;
   $9_1 = $10_1 + $14_1 | 0;
   $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
   $4_1 = $9_1;
   $9_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $5_1 & 1048575;
   $13_1 = $13_1 & 1048575;
   $14_1 = $16_1 & 1048575;
   $5_1 = $12_1;
   $12_1 = $15_1 & 1048575;
   $1_1 = $1_1 - 1 | 0;
   if ($1_1) {
    continue
   }
   break;
  };
  HEAP32[$6_1 + 7168 >> 2] = $4_1;
  HEAP32[$6_1 + 7172 >> 2] = $9_1;
  HEAP32[$6_1 + 7160 >> 2] = $11_1;
  HEAP32[$6_1 + 7164 >> 2] = $10_1;
  HEAP32[$6_1 + 7152 >> 2] = $7_1;
  HEAP32[$6_1 + 7156 >> 2] = $13_1;
  HEAP32[$6_1 + 7144 >> 2] = $8_1;
  HEAP32[$6_1 + 7148 >> 2] = $14_1;
  HEAP32[$6_1 + 7136 >> 2] = $5_1;
  HEAP32[$6_1 + 7140 >> 2] = $12_1;
  $1_1 = $6_1 + 7136 | 0;
  $34($1_1, $1_1, $6_1 + 7376 | 0);
  $1_1 = 6;
  $4_1 = HEAP32[$6_1 + 7168 >> 2];
  $9_1 = HEAP32[$6_1 + 7172 >> 2];
  $11_1 = HEAP32[$6_1 + 7160 >> 2];
  $10_1 = HEAP32[$6_1 + 7164 >> 2];
  $7_1 = HEAP32[$6_1 + 7152 >> 2];
  $13_1 = HEAP32[$6_1 + 7156 >> 2];
  $8_1 = HEAP32[$6_1 + 7144 >> 2];
  $14_1 = HEAP32[$6_1 + 7148 >> 2];
  $5_1 = HEAP32[$6_1 + 7136 >> 2];
  $12_1 = HEAP32[$6_1 + 7140 >> 2];
  while (1) {
   $15_1 = $5_1;
   $3_1 = $12_1 << 1 | $5_1 >>> 31;
   $25_1 = $6_1 + 640 | 0;
   $20_1 = $5_1 << 1;
   $28_1 = $3_1;
   $69($25_1, $11_1, $10_1, 0, 0, $20_1, $3_1, 0, 0);
   $19_1 = $6_1 + 560 | 0;
   $5_1 = $8_1 << 1;
   $16_1 = $14_1;
   $24_1 = $8_1;
   $8_1 = $14_1 << 1 | $8_1 >>> 31;
   $69($19_1, $7_1, $13_1, 0, 0, $5_1, $8_1, 0, 0);
   $17_1 = $6_1 + 496 | 0;
   $69($17_1, $4_1, $9_1, 0, 0, $4_1, $9_1, 0, 0);
   $18_1 = $6_1 + 480 | 0;
   $69($18_1, HEAP32[$6_1 + 496 >> 2], HEAP32[$6_1 + 500 >> 2], 0, 0, 15632, 16, 0, 0);
   $3_1 = $9_1 << 1 | $4_1 >>> 31;
   $33_1 = $6_1 + 448 | 0;
   $22_1 = $4_1 << 1;
   $26_1 = $3_1;
   $69($33_1, $22_1, $3_1, 0, 0, $15_1, $12_1, 0, 0);
   $34_1 = $6_1 + 608 | 0;
   $69($34_1, $11_1, $10_1, 0, 0, $5_1, $8_1, 0, 0);
   $39_1 = $6_1 + 544 | 0;
   $69($39_1, $7_1, $13_1, 0, 0, $7_1, $13_1, 0, 0);
   $23_1 = $6_1 + 464 | 0;
   $3_1 = $17_1 + 8 | 0;
   $69($23_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
   $38_1 = $6_1 + 656 | 0;
   $69($38_1, $15_1, $12_1, 0, 0, $15_1, $12_1, 0, 0);
   $35_1 = $6_1 + 432 | 0;
   $69($35_1, $22_1, $26_1, 0, 0, $24_1, $14_1, 0, 0);
   $36_1 = $6_1 + 512 | 0;
   $12_1 = $11_1;
   $21_1 = $7_1;
   $69($36_1, $11_1, $10_1, 0, 0, $7_1 << 1, $13_1 << 1 | $7_1 >>> 31, 0, 0);
   $15_1 = HEAP32[$6_1 + 644 >> 2];
   $3_1 = $15_1 + HEAP32[$6_1 + 564 >> 2] | 0;
   $7_1 = HEAP32[$6_1 + 640 >> 2];
   $5_1 = HEAP32[$6_1 + 560 >> 2];
   $4_1 = $7_1 + $5_1 | 0;
   $8_1 = HEAP32[$6_1 + 480 >> 2];
   $17_1 = $4_1 + $8_1 | 0;
   $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $5_1 + HEAP32[$6_1 + 484 >> 2] | 0;
   $8_1 = $8_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $14_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $17_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
   $3_1 = $18_1 + 8 | 0;
   $9_1 = HEAP32[$3_1 >> 2];
   $11_1 = HEAP32[$3_1 + 4 >> 2];
   $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
   $5_1 = $19_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $25_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $7_1 + $15_1 | 0;
   $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $11_1 | 0;
   $5_1 = $4_1;
   $4_1 = $4_1 + $9_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $14_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $14_1 = $8_1;
   $11_1 = $4_1 << 12 | $8_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 608 >> 2];
   $4_1 = HEAP32[$6_1 + 544 >> 2];
   $15_1 = $31_1 + $4_1 | 0;
   $40_1 = HEAP32[$6_1 + 612 >> 2];
   $3_1 = $40_1 + HEAP32[$6_1 + 548 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 448 >> 2];
   $9_1 = $4_1 + $15_1 | 0;
   $19_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 452 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 464 >> 2];
   $8_1 = $4_1 + $9_1 | 0;
   $18_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 468 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $7_1 | 0;
   $37_1 = $6_1 + 416 | 0;
   $11_1 = $8_1 + $11_1 | 0;
   $7_1 = $11_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $30_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $32_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
   $3_1 = $23_1 + 8 | 0;
   $29_1 = HEAP32[$3_1 >> 2];
   $27_1 = HEAP32[$3_1 + 4 >> 2];
   $25_1 = ($18_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $18_1 >>> 0 < $19_1 >>> 0;
   $3_1 = $33_1 + 8 | 0;
   $23_1 = HEAP32[$3_1 >> 2];
   $18_1 = HEAP32[$3_1 + 4 >> 2];
   $9_1 = ($19_1 | 0) == ($40_1 | 0) & $15_1 >>> 0 < $31_1 >>> 0 | $19_1 >>> 0 < $40_1 >>> 0;
   $8_1 = $39_1 + 8 | 0;
   $4_1 = HEAP32[$8_1 >> 2];
   $3_1 = $34_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $9_1 + $15_1 | 0;
   $3_1 = ($4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + $23_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $4_1;
   $4_1 = $4_1 + $25_1 | 0;
   $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $27_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + $29_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $4_1 + $32_1 | 0;
   $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $30_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $7_1;
   $9_1 = $4_1 << 12 | $5_1 >>> 20;
   $8_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $25_1 = HEAP32[$6_1 + 432 >> 2];
   $4_1 = HEAP32[$6_1 + 512 >> 2];
   $15_1 = $25_1 + $4_1 | 0;
   $31_1 = HEAP32[$6_1 + 436 >> 2];
   $3_1 = $31_1 + HEAP32[$6_1 + 516 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $7_1 | 0;
   $9_1 = $9_1 + $15_1 | 0;
   $3_1 = $9_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $23_1 = $9_1 << 4 & -16;
   $7_1 = $3_1;
   $19_1 = ($3_1 << 4 | $9_1 >>> 28) & 16777215;
   $18_1 = $5_1;
   $69($37_1, $23_1 | $5_1 >>> 16 & 15, $19_1, 0, 0, 977, 1, 0, 0);
   $30_1 = $6_1 + 592 | 0;
   $69($30_1, $24_1, $16_1, 0, 0, $20_1, $28_1, 0, 0);
   $32_1 = $6_1 + 400 | 0;
   $69($32_1, $22_1, $26_1, 0, 0, $21_1, $13_1, 0, 0);
   $29_1 = $6_1 + 624 | 0;
   $69($29_1, $12_1, $10_1, 0, 0, $12_1, $10_1, 0, 0);
   $27_1 = $6_1 + 384 | 0;
   $23_1 = $27_1;
   $19_1 = ($4_1 | 0) == ($3_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 > $3_1 >>> 0;
   $9_1 = ($4_1 | 0) == ($31_1 | 0) & $15_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
   $5_1 = $36_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $35_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $9_1 + $15_1 | 0;
   $3_1 = $5_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $8_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $19_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $4_1 << 12 | $7_1 >>> 20;
   $5_1 = $3_1;
   $19_1 = $3_1 << 12 | $4_1 >>> 20;
   $31_1 = HEAP32[$6_1 + 404 >> 2];
   $3_1 = $31_1 + HEAP32[$6_1 + 628 >> 2] | 0;
   $15_1 = HEAP32[$6_1 + 400 >> 2];
   $4_1 = HEAP32[$6_1 + 624 >> 2];
   $8_1 = $15_1 + $4_1 | 0;
   $9_1 = $8_1;
   $7_1 = $8_1 + $7_1 | 0;
   $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $19_1 | 0;
   $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($23_1, $7_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
   $25_1 = $6_1 + 528 | 0;
   $69($25_1, $21_1, $13_1, 0, 0, $20_1, $28_1, 0, 0);
   $23_1 = $6_1 + 576 | 0;
   $69($23_1, $24_1, $16_1, 0, 0, $24_1, $16_1, 0, 0);
   $13_1 = $6_1 + 368 | 0;
   $69($13_1, $22_1, $26_1, 0, 0, $12_1, $10_1, 0, 0);
   $26_1 = $6_1 + 352 | 0;
   $12_1 = $26_1;
   $10_1 = ($4_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $8_1 >>> 0;
   $9_1 = ($4_1 | 0) == ($31_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $31_1 >>> 0;
   $7_1 = $29_1 + 8 | 0;
   $4_1 = HEAP32[$7_1 >> 2];
   $3_1 = $32_1 + 8 | 0;
   $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $9_1 + $16_1 | 0;
   $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $7_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $4_1 << 12 | $8_1 >>> 20;
   $8_1 = HEAP32[$6_1 + 368 >> 2];
   $10_1 = $7_1 + $8_1 | 0;
   $5_1 = $3_1;
   $4_1 = $3_1 << 12 | $4_1 >>> 20;
   $3_1 = $4_1 + HEAP32[$6_1 + 372 >> 2] | 0;
   $3_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($12_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
   $19_1 = $6_1 + 336 | 0;
   $9_1 = $19_1;
   $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
   $3_1 = $13_1 + 8 | 0;
   $8_1 = HEAP32[$3_1 >> 2];
   $3_1 = HEAP32[$3_1 + 4 >> 2];
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $7_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($9_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
   $5_1 = HEAP32[$6_1 + 416 >> 2];
   $4_1 = HEAP32[$6_1 + 656 >> 2];
   $12_1 = $5_1 + $4_1 | 0;
   $7_1 = HEAP32[$6_1 + 420 >> 2];
   $3_1 = $7_1 + HEAP32[$6_1 + 660 >> 2] | 0;
   $8_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = ($7_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 > $12_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
   $5_1 = $38_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $37_1 + 8 | 0;
   $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $7_1 + $9_1 | 0;
   $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $15_1 = $8_1;
   $9_1 = $4_1 << 12 | $8_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $10_1 = HEAP32[$6_1 + 384 >> 2];
   $4_1 = HEAP32[$6_1 + 592 >> 2];
   $8_1 = $10_1 + $4_1 | 0;
   $16_1 = HEAP32[$6_1 + 388 >> 2];
   $3_1 = $16_1 + HEAP32[$6_1 + 596 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $9_1;
   $9_1 = $8_1;
   $8_1 = $4_1 + $8_1 | 0;
   $4_1 = $3_1;
   $3_1 = $3_1 + $7_1 | 0;
   $7_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $13_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $9_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $10_1 = ($4_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
   $9_1 = $30_1 + 8 | 0;
   $4_1 = HEAP32[$9_1 >> 2];
   $3_1 = $27_1 + 8 | 0;
   $16_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$9_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $9_1 = $10_1 + $16_1 | 0;
   $3_1 = $9_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $9_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $13_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $16_1 = $7_1;
   $9_1 = $4_1 << 12 | $7_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $22_1 = HEAP32[$6_1 + 528 >> 2];
   $4_1 = HEAP32[$6_1 + 576 >> 2];
   $13_1 = $22_1 + $4_1 | 0;
   $27_1 = HEAP32[$6_1 + 532 >> 2];
   $3_1 = $27_1 + HEAP32[$6_1 + 580 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 352 >> 2];
   $10_1 = $4_1 + $13_1 | 0;
   $21_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 356 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $7_1 | 0;
   $7_1 = $9_1 + $10_1 | 0;
   $9_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $28_1 = ($4_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
   $20_1 = ($4_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
   $3_1 = $26_1 + 8 | 0;
   $24_1 = HEAP32[$3_1 >> 2];
   $26_1 = HEAP32[$3_1 + 4 >> 2];
   $13_1 = ($21_1 | 0) == ($27_1 | 0) & $13_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
   $10_1 = $23_1 + 8 | 0;
   $4_1 = HEAP32[$10_1 >> 2];
   $3_1 = $25_1 + 8 | 0;
   $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $13_1 + $21_1 | 0;
   $3_1 = ($4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
   $13_1 = $4_1;
   $4_1 = $4_1 + $24_1 | 0;
   $3_1 = $13_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $4_1 + $20_1 | 0;
   $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $28_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $13_1 = $9_1;
   $10_1 = $4_1 << 12 | $9_1 >>> 20;
   $5_1 = $3_1;
   $9_1 = $3_1 << 12 | $4_1 >>> 20;
   $24_1 = HEAP32[$6_1 + 336 >> 2];
   $17_1 = $24_1 + ($17_1 & -2) | 0;
   $26_1 = HEAP32[$6_1 + 340 >> 2];
   $3_1 = $26_1 + ($14_1 & 1048575) | 0;
   $4_1 = $17_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $9_1 | 0;
   $14_1 = $11_1;
   $21_1 = $18_1 & 65535;
   $10_1 = $10_1 + $17_1 | 0;
   $9_1 = $10_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $11_1 = $10_1;
   $18_1 = ($4_1 | 0) == ($9_1 | 0) & $10_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
   $4_1 = ($4_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $24_1 >>> 0 | $4_1 >>> 0 < $26_1 >>> 0;
   $3_1 = $19_1 + 8 | 0;
   $10_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2];
   $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $18_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $9_1;
   $10_1 = $4_1 << 12 | $5_1 >>> 20;
   $9_1 = $10_1 + $14_1 | 0;
   $3_1 = $21_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
   $4_1 = $9_1;
   $9_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $5_1 & 1048575;
   $13_1 = $13_1 & 1048575;
   $14_1 = $16_1 & 1048575;
   $5_1 = $12_1;
   $12_1 = $15_1 & 1048575;
   $1_1 = $1_1 - 1 | 0;
   if ($1_1) {
    continue
   }
   break;
  };
  HEAP32[$6_1 + 7168 >> 2] = $4_1;
  HEAP32[$6_1 + 7172 >> 2] = $9_1;
  HEAP32[$6_1 + 7160 >> 2] = $11_1;
  HEAP32[$6_1 + 7164 >> 2] = $10_1;
  HEAP32[$6_1 + 7152 >> 2] = $7_1;
  HEAP32[$6_1 + 7156 >> 2] = $13_1;
  HEAP32[$6_1 + 7144 >> 2] = $8_1;
  HEAP32[$6_1 + 7148 >> 2] = $14_1;
  HEAP32[$6_1 + 7136 >> 2] = $5_1;
  HEAP32[$6_1 + 7140 >> 2] = $12_1;
  $39_1 = $6_1 + 7136 | 0;
  $34($39_1, $39_1, $6_1 + 7576 | 0);
  $1_1 = HEAP32[$6_1 + 7140 >> 2];
  $16_1 = $1_1;
  $14_1 = HEAP32[$6_1 + 7136 >> 2];
  $7_1 = $14_1;
  $3_1 = $1_1 << 1 | $7_1 >>> 31;
  $12_1 = $6_1 - -64 | 0;
  $21_1 = HEAP32[$6_1 + 7160 >> 2];
  $17_1 = HEAP32[$6_1 + 7164 >> 2];
  $28_1 = $7_1 << 1;
  $22_1 = $3_1;
  $69($12_1, $21_1, $17_1, 0, 0, $28_1, $3_1, 0, 0);
  $1_1 = HEAP32[$6_1 + 7148 >> 2];
  $33_1 = $1_1;
  $34_1 = HEAP32[$6_1 + 7144 >> 2];
  $4_1 = $34_1;
  $3_1 = $1_1 << 1 | $4_1 >>> 31;
  $10_1 = $6_1 + 272 | 0;
  $24_1 = HEAP32[$6_1 + 7152 >> 2];
  $18_1 = HEAP32[$6_1 + 7156 >> 2];
  $4_1 = $4_1 << 1;
  $5_1 = $3_1;
  $69($10_1, $24_1, $18_1, 0, 0, $4_1, $3_1, 0, 0);
  $9_1 = $6_1 + 224 | 0;
  $8_1 = HEAP32[$6_1 + 7168 >> 2];
  $1_1 = HEAP32[$6_1 + 7172 >> 2];
  $69($9_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
  $11_1 = $6_1 + 208 | 0;
  $69($11_1, HEAP32[$6_1 + 224 >> 2], HEAP32[$6_1 + 228 >> 2], 0, 0, 15632, 16, 0, 0);
  $3_1 = $1_1 << 1 | $8_1 >>> 31;
  $37_1 = $6_1 + 176 | 0;
  $23_1 = $8_1 << 1;
  $20_1 = $3_1;
  $69($37_1, $23_1, $3_1, 0, 0, $7_1, $16_1, 0, 0);
  $30_1 = $6_1 + 80 | 0;
  $69($30_1, $21_1, $17_1, 0, 0, $4_1, $5_1, 0, 0);
  $32_1 = $6_1 + 256 | 0;
  $69($32_1, $24_1, $18_1, 0, 0, $24_1, $18_1, 0, 0);
  $13_1 = $6_1 + 192 | 0;
  $1_1 = $9_1 + 8 | 0;
  $69($13_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $38_1 = $6_1 + 320 | 0;
  $69($38_1, $7_1, $16_1, 0, 0, $7_1, $16_1, 0, 0);
  $35_1 = $6_1 + 160 | 0;
  $69($35_1, $23_1, $3_1, 0, 0, $34_1, $33_1, 0, 0);
  $36_1 = $6_1 + 96 | 0;
  $69($36_1, $21_1, $17_1, 0, 0, $24_1 << 1, $18_1 << 1 | $24_1 >>> 31, 0, 0);
  $14_1 = HEAP32[$6_1 + 68 >> 2];
  $3_1 = $14_1 + HEAP32[$6_1 + 276 >> 2] | 0;
  $8_1 = HEAP32[$6_1 + 64 >> 2];
  $4_1 = HEAP32[$6_1 + 272 >> 2];
  $1_1 = $8_1 + $4_1 | 0;
  $5_1 = HEAP32[$6_1 + 208 >> 2];
  $15_1 = $1_1 + $5_1 | 0;
  $4_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1 + HEAP32[$6_1 + 212 >> 2] | 0;
  $5_1 = $5_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = ($4_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $15_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
  $3_1 = $11_1 + 8 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $7_1 = HEAP32[$3_1 + 4 >> 2];
  $8_1 = ($4_1 | 0) == ($14_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $14_1 >>> 0;
  $3_1 = $10_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $12_1 + 8 | 0;
  $10_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $8_1 + $10_1 | 0;
  $3_1 = ($1_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + $11_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $16_1 = $5_1;
  $7_1 = $1_1 << 12 | $5_1 >>> 20;
  $4_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $29_1 = HEAP32[$6_1 + 80 >> 2];
  $1_1 = HEAP32[$6_1 + 256 >> 2];
  $10_1 = $29_1 + $1_1 | 0;
  $31_1 = HEAP32[$6_1 + 84 >> 2];
  $3_1 = $31_1 + HEAP32[$6_1 + 260 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 176 >> 2];
  $9_1 = $1_1 + $10_1 | 0;
  $14_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 180 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$6_1 + 192 >> 2];
  $5_1 = $1_1 + $9_1 | 0;
  $12_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$6_1 + 196 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $8_1 = $6_1;
  $11_1 = $5_1 + $7_1 | 0;
  $7_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $27_1 = ($1_1 | 0) == ($7_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
  $25_1 = ($1_1 | 0) == ($12_1 | 0) & $5_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 < $12_1 >>> 0;
  $1_1 = $13_1 + 8 | 0;
  $19_1 = HEAP32[$1_1 >> 2];
  $26_1 = HEAP32[$1_1 + 4 >> 2];
  $6_1 = ($12_1 | 0) == ($14_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $12_1 >>> 0 < $14_1 >>> 0;
  $1_1 = $37_1 + 8 | 0;
  $13_1 = HEAP32[$1_1 >> 2];
  $12_1 = HEAP32[$1_1 + 4 >> 2];
  $9_1 = ($14_1 | 0) == ($31_1 | 0) & $10_1 >>> 0 < $29_1 >>> 0 | $14_1 >>> 0 < $31_1 >>> 0;
  $3_1 = $32_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $30_1 + 8 | 0;
  $10_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $9_1 + $10_1 | 0;
  $3_1 = ($1_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $12_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $13_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $6_1 | 0;
  $3_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $26_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $19_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1 + $25_1 | 0;
  $3_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $5_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $27_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $7_1;
  $10_1 = $1_1 << 12 | $4_1 >>> 20;
  $5_1 = $3_1;
  $9_1 = $3_1 << 12 | $1_1 >>> 20;
  $13_1 = HEAP32[$8_1 + 160 >> 2];
  $1_1 = HEAP32[$8_1 + 96 >> 2];
  $7_1 = $13_1 + $1_1 | 0;
  $19_1 = HEAP32[$8_1 + 164 >> 2];
  $3_1 = $19_1 + HEAP32[$8_1 + 100 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $9_1 | 0;
  $12_1 = $7_1;
  $7_1 = $7_1 + $10_1 | 0;
  $14_1 = $7_1 << 4 & -16;
  $9_1 = $7_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = ($9_1 << 4 | $7_1 >>> 28) & 16777215;
  $6_1 = $4_1;
  $69($8_1, $14_1 | $4_1 >>> 16 & 15, $10_1, 0, 0, 977, 1, 0, 0);
  $27_1 = HEAP32[$8_1 + 4 >> 2];
  $3_1 = $27_1 + HEAP32[$8_1 + 324 >> 2] | 0;
  $25_1 = HEAP32[$8_1 >> 2];
  $4_1 = HEAP32[$8_1 + 320 >> 2];
  $10_1 = $25_1 + $4_1 | 0;
  HEAP32[$8_1 + 7136 >> 2] = $10_1;
  $4_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$8_1 + 7140 >> 2] = $4_1 & 1048575;
  $31_1 = $8_1 + 304 | 0;
  $69($31_1, $34_1, $33_1, 0, 0, $28_1, $22_1, 0, 0);
  $37_1 = $8_1 + 144 | 0;
  $69($37_1, $23_1, $20_1, 0, 0, $24_1, $18_1, 0, 0);
  $30_1 = $8_1 + 112 | 0;
  $69($30_1, $21_1, $17_1, 0, 0, $21_1, $17_1, 0, 0);
  $32_1 = $8_1 + 48 | 0;
  $26_1 = $32_1;
  $14_1 = ($1_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
  $12_1 = ($1_1 | 0) == ($19_1 | 0) & $12_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $19_1 >>> 0;
  $3_1 = $36_1 + 8 | 0;
  $7_1 = HEAP32[$3_1 >> 2];
  $1_1 = $35_1 + 8 | 0;
  $13_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $7_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $12_1 + $13_1 | 0;
  $3_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $5_1 >>> 20 | 0;
  $1_1 = $5_1 + $7_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $14_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $1_1 << 12 | $9_1 >>> 20;
  $7_1 = $3_1;
  $9_1 = $3_1 << 12 | $1_1 >>> 20;
  $35_1 = HEAP32[$8_1 + 148 >> 2];
  $3_1 = $35_1 + HEAP32[$8_1 + 116 >> 2] | 0;
  $29_1 = HEAP32[$8_1 + 144 >> 2];
  $5_1 = HEAP32[$8_1 + 112 >> 2];
  $1_1 = $29_1 + $5_1 | 0;
  $19_1 = $1_1;
  $13_1 = $1_1 + $12_1 | 0;
  $5_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $5_1 + $9_1 | 0;
  $12_1 = $13_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($26_1, $13_1, $12_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $9_1 = $8_1;
  $10_1 = ($4_1 | 0) == ($27_1 | 0) & $10_1 >>> 0 < $25_1 >>> 0 | $4_1 >>> 0 < $27_1 >>> 0;
  $3_1 = $38_1 + 8 | 0;
  $8_1 = HEAP32[$3_1 >> 2];
  $1_1 = $9_1 + 8 | 0;
  $14_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $8_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $10_1 + $14_1 | 0;
  $3_1 = $1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = $1_1 << 12 | $4_1 >>> 20;
  $8_1 = $3_1;
  $10_1 = $3_1 << 12 | $1_1 >>> 20;
  $27_1 = HEAP32[$9_1 + 48 >> 2];
  $1_1 = HEAP32[$9_1 + 304 >> 2];
  $26_1 = $27_1 + $1_1 | 0;
  $36_1 = HEAP32[$9_1 + 52 >> 2];
  $3_1 = $36_1 + HEAP32[$9_1 + 308 >> 2] | 0;
  $4_1 = $1_1 >>> 0 > $26_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1 + $10_1 | 0;
  $14_1 = $14_1 + $26_1 | 0;
  $3_1 = $14_1 >>> 0 < $26_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$9_1 + 7144 >> 2] = $14_1;
  $10_1 = $3_1;
  HEAP32[$9_1 + 7148 >> 2] = $3_1 & 1048575;
  $25_1 = $9_1 + 240 | 0;
  $69($25_1, $24_1, $18_1, 0, 0, $28_1, $22_1, 0, 0);
  $22_1 = $9_1 + 288 | 0;
  $69($22_1, $34_1, $33_1, 0, 0, $34_1, $33_1, 0, 0);
  $28_1 = $9_1 + 128 | 0;
  $69($28_1, $23_1, $20_1, 0, 0, $21_1, $17_1, 0, 0);
  $24_1 = $9_1 + 32 | 0;
  $21_1 = $24_1;
  $18_1 = ($5_1 | 0) == ($12_1 | 0) & $13_1 >>> 0 < $19_1 >>> 0 | $5_1 >>> 0 > $12_1 >>> 0;
  $13_1 = ($5_1 | 0) == ($35_1 | 0) & $19_1 >>> 0 < $29_1 >>> 0 | $5_1 >>> 0 < $35_1 >>> 0;
  $3_1 = $30_1 + 8 | 0;
  $5_1 = HEAP32[$3_1 >> 2];
  $1_1 = $37_1 + 8 | 0;
  $17_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $13_1 + $17_1 | 0;
  $3_1 = $5_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $7_1 >>> 20 | 0;
  $1_1 = $5_1 + $7_1 | 0;
  $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $18_1 | 0;
  $3_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $17_1 = $1_1 << 12 | $12_1 >>> 20;
  $7_1 = HEAP32[$9_1 + 128 >> 2];
  $12_1 = $17_1 + $7_1 | 0;
  $5_1 = $3_1;
  $19_1 = $3_1 << 12 | $1_1 >>> 20;
  $3_1 = $19_1 + HEAP32[$9_1 + 132 >> 2] | 0;
  $13_1 = $7_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($21_1, $12_1, $13_1, 0, 0, 15632, 16, 0, 0);
  $7_1 = $9_1;
  $14_1 = ($4_1 | 0) == ($10_1 | 0) & $14_1 >>> 0 < $26_1 >>> 0 | $4_1 >>> 0 > $10_1 >>> 0;
  $9_1 = ($4_1 | 0) == ($36_1 | 0) & $26_1 >>> 0 < $27_1 >>> 0 | $4_1 >>> 0 < $36_1 >>> 0;
  $3_1 = $31_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $32_1 + 8 | 0;
  $18_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $9_1 + $18_1 | 0;
  $3_1 = $4_1 >>> 0 < $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $8_1 >>> 20 | 0;
  $1_1 = $4_1 + $8_1 | 0;
  $3_1 = $8_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $14_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = $1_1 << 12 | $10_1 >>> 20;
  $4_1 = $3_1;
  $8_1 = $3_1 << 12 | $1_1 >>> 20;
  $26_1 = HEAP32[$7_1 + 240 >> 2];
  $1_1 = HEAP32[$7_1 + 288 >> 2];
  $14_1 = $26_1 + $1_1 | 0;
  $20_1 = HEAP32[$7_1 + 244 >> 2];
  $3_1 = $20_1 + HEAP32[$7_1 + 292 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = HEAP32[$7_1 + 32 >> 2];
  $10_1 = $1_1 + $14_1 | 0;
  $18_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$7_1 + 36 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $1_1 + $8_1 | 0;
  $9_1 = $9_1 + $10_1 | 0;
  $3_1 = $9_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$7_1 + 7152 >> 2] = $9_1;
  $8_1 = $3_1;
  HEAP32[$7_1 + 7156 >> 2] = $3_1 & 1048575;
  $21_1 = $7_1 + 16 | 0;
  $17_1 = ($13_1 | 0) == ($19_1 | 0) & $12_1 >>> 0 < $17_1 >>> 0 | $13_1 >>> 0 < $19_1 >>> 0;
  $3_1 = $28_1 + 8 | 0;
  $13_1 = HEAP32[$3_1 >> 2];
  $3_1 = HEAP32[$3_1 + 4 >> 2];
  $5_1 = $5_1 >>> 20 | 0;
  $12_1 = $5_1;
  $5_1 = $5_1 + $13_1 | 0;
  $3_1 = $12_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $5_1;
  $5_1 = $5_1 + $17_1 | 0;
  $3_1 = $12_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($21_1, $5_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
  $5_1 = $7_1;
  $17_1 = ($1_1 | 0) == ($8_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
  $13_1 = ($1_1 | 0) == ($18_1 | 0) & $10_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 < $18_1 >>> 0;
  $1_1 = $24_1 + 8 | 0;
  $12_1 = HEAP32[$1_1 >> 2];
  $10_1 = HEAP32[$1_1 + 4 >> 2];
  $9_1 = ($18_1 | 0) == ($20_1 | 0) & $14_1 >>> 0 < $26_1 >>> 0 | $18_1 >>> 0 < $20_1 >>> 0;
  $3_1 = $22_1 + 8 | 0;
  $7_1 = HEAP32[$3_1 >> 2];
  $1_1 = $25_1 + 8 | 0;
  $14_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
  $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $7_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $9_1 + $14_1 | 0;
  $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
  $7_1 = $1_1;
  $1_1 = $1_1 + $12_1 | 0;
  $3_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 + $13_1 | 0;
  $3_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $1_1 = $4_1 + $7_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $1_1;
  $1_1 = $1_1 + $17_1 | 0;
  $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $1_1 << 12 | $8_1 >>> 20;
  $4_1 = $3_1;
  $10_1 = $3_1 << 12 | $1_1 >>> 20;
  $14_1 = HEAP32[$5_1 + 16 >> 2];
  $8_1 = $15_1 & -2;
  $1_1 = $14_1 + $8_1 | 0;
  $13_1 = HEAP32[$5_1 + 20 >> 2];
  $3_1 = $13_1 + ($16_1 & 1048575) | 0;
  $9_1 = $1_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $9_1 + $10_1 | 0;
  $8_1 = $7_1;
  $7_1 = $1_1;
  $8_1 = $8_1 + $1_1 | 0;
  HEAP32[$5_1 + 7160 >> 2] = $8_1;
  $1_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$5_1 + 7164 >> 2] = $1_1 & 1048575;
  $16_1 = $5_1;
  $12_1 = $6_1 & 65535;
  $10_1 = ($1_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 < $9_1 >>> 0;
  $5_1 = ($9_1 | 0) == ($13_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $9_1 >>> 0 < $13_1 >>> 0;
  $3_1 = $21_1 + 8 | 0;
  $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
  $3_1 = HEAP32[$3_1 + 4 >> 2];
  $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $5_1 = $4_1;
  $4_1 = $4_1 + $8_1 | 0;
  $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $5_1 = $4_1;
  $4_1 = $4_1 + $10_1 | 0;
  $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $4_1 << 12 | $1_1 >>> 20;
  $5_1 = $1_1 + $11_1 | 0;
  $3_1 = $12_1 + ($3_1 << 12 | $4_1 >>> 20) | 0;
  HEAP32[$16_1 + 7168 >> 2] = $5_1;
  HEAP32[$16_1 + 7172 >> 2] = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $1_1 = $0_1 + 40 | 0;
  $54($1_1, $39_1);
  $54($39_1, $1_1);
  $3_1 = HEAP32[$16_1 + 7080 >> 2];
  $1_1 = HEAP32[$16_1 + 7160 >> 2];
  $18_1 = $3_1 - $1_1 | 0;
  $15_1 = HEAP32[$16_1 + 7084 >> 2] - (HEAP32[$16_1 + 7164 >> 2] + ($1_1 >>> 0 > $3_1 >>> 0) | 0) | 0;
  $3_1 = HEAP32[$16_1 + 7072 >> 2];
  $1_1 = HEAP32[$16_1 + 7152 >> 2];
  $6_1 = $3_1 - $1_1 | 0;
  $13_1 = HEAP32[$16_1 + 7076 >> 2] - (HEAP32[$16_1 + 7156 >> 2] + ($1_1 >>> 0 > $3_1 >>> 0) | 0) | 0;
  $3_1 = HEAP32[$16_1 + 7064 >> 2];
  $1_1 = HEAP32[$16_1 + 7144 >> 2];
  $9_1 = $3_1 - $1_1 | 0;
  $11_1 = HEAP32[$16_1 + 7068 >> 2] - (HEAP32[$16_1 + 7148 >> 2] + ($1_1 >>> 0 > $3_1 >>> 0) | 0) | 0;
  $3_1 = HEAP32[$16_1 + 7056 >> 2];
  $1_1 = HEAP32[$16_1 + 7136 >> 2];
  $7_1 = $3_1 - $1_1 | 0;
  $5_1 = HEAP32[$16_1 + 7060 >> 2] - (HEAP32[$16_1 + 7140 >> 2] + ($1_1 >>> 0 > $3_1 >>> 0) | 0) | 0;
  $4_1 = HEAP32[$16_1 + 7088 >> 2];
  $3_1 = HEAP32[$16_1 + 7168 >> 2];
  $1_1 = ($4_1 - $3_1 | 0) - 4 | 0;
  $3_1 = (HEAP32[$16_1 + 7092 >> 2] - (HEAP32[$16_1 + 7172 >> 2] + ($3_1 >>> 0 > $4_1 >>> 0) | 0) | 0) + 262143 | 0;
  $8_1 = $1_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = __wasm_i64_mul($8_1 >>> 16 | 0, 0, 977, 1);
  $7_1 = $4_1 + $7_1 | 0;
  $3_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
  $3_1 = ($4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + 4194299 | 0;
  $4_1 = $7_1 - 3908 | 0;
  $3_1 = $4_1 >>> 0 < 4294963388 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = $4_1;
  $12_1 = $3_1;
  $3_1 = $11_1;
  $4_1 = $12_1 >>> 20 | 0;
  $5_1 = $4_1;
  $4_1 = $4_1 + $9_1 | 0;
  $3_1 = ($5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + 4194303 | 0;
  $4_1 = $4_1 - 4 | 0;
  $3_1 = $4_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $4_1;
  $9_1 = $3_1;
  $3_1 = $13_1;
  $4_1 = $9_1 >>> 20 | 0;
  $5_1 = $4_1;
  $4_1 = $4_1 + $6_1 | 0;
  $3_1 = ($5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + 4194303 | 0;
  $4_1 = $4_1 - 4 | 0;
  $3_1 = $4_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
  $11_1 = $4_1;
  $7_1 = $3_1;
  $3_1 = $15_1;
  $4_1 = $7_1 >>> 20 | 0;
  $5_1 = $4_1;
  $4_1 = $4_1 + $18_1 | 0;
  $3_1 = ($5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + 4194303 | 0;
  $5_1 = $4_1 - 4 | 0;
  $4_1 = $5_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $8_1 & 65535;
  $8_1 = $5_1;
  $3_1 = $13_1;
  $5_1 = $4_1 >>> 20 | 0;
  $15_1 = $5_1;
  $5_1 = $1_1 + $5_1 | 0;
  $3_1 = $15_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  label$8 : {
   if ($5_1 | ($8_1 | ($10_1 | $14_1 | $11_1)) | ($3_1 | ($9_1 | $12_1 | $7_1 | $4_1) & 1048575)) {
    $1_1 = 0;
    if (($10_1 & ($14_1 ^ 976) & $11_1 & $8_1 & $5_1) != -1) {
     $3_1 = 1
    } else {
     $3_1 = ($9_1 & ($12_1 ^ 1) & $7_1 & $4_1 & ($3_1 ^ 983040)) != 1048575
    }
    if ($3_1) {
     break label$8
    }
   }
   $1_1 = $0_1 + 48 | 0;
   $11_1 = HEAP32[$1_1 >> 2];
   $8_1 = HEAP32[$1_1 + 4 >> 2];
   $4_1 = HEAP32[$0_1 + 44 >> 2];
   $1_1 = $0_1 + 72 | 0;
   $10_1 = HEAP32[$1_1 >> 2];
   $1_1 = HEAP32[$1_1 + 4 >> 2];
   $15_1 = $1_1;
   $3_1 = HEAP32[$0_1 + 40 >> 2];
   $1_1 = __wasm_i64_mul($1_1 >>> 16 | 0, 0, 977, 1);
   $7_1 = $3_1 + $1_1 | 0;
   $3_1 = $4_1 + i64toi32_i32$HIGH_BITS | 0;
   $13_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $8_1;
   $1_1 = $13_1 >>> 20 | 0;
   $8_1 = $1_1 + $11_1 | 0;
   $1_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $14_1 = $1_1 & 1048575;
   $3_1 = $0_1 - -64 | 0;
   $12_1 = HEAP32[$3_1 >> 2];
   $9_1 = HEAP32[$3_1 + 4 >> 2];
   $3_1 = $0_1 + 56 | 0;
   $5_1 = HEAP32[$3_1 >> 2];
   $3_1 = HEAP32[$3_1 + 4 >> 2];
   $11_1 = $1_1 >>> 20 | 0;
   $4_1 = $5_1 + $11_1 | 0;
   $11_1 = $11_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $9_1;
   $5_1 = $11_1 >>> 20 | 0;
   $9_1 = $5_1;
   $5_1 = $5_1 + $12_1 | 0;
   $3_1 = $9_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $12_1 = $3_1 & 1048575;
   $9_1 = $11_1 & 1048575;
   $6_1 = ($4_1 & $8_1 & $5_1) == -1 & ($1_1 & $9_1 & $3_1) == 1048575;
   $1_1 = $3_1;
   $3_1 = $15_1 & 65535;
   $1_1 = $1_1 >>> 20 | 0;
   $11_1 = $1_1 + $10_1 | 0;
   $3_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $3_1;
   $13_1 = $13_1 & 1048575;
   if ($6_1 & (($11_1 | 0) == -1 & ($3_1 | 0) == 65535) & (($13_1 | 0) == 1048574 & $7_1 >>> 0 > 4294966318 | $13_1 >>> 0 > 1048574) | $3_1 >>> 16) {
    $3_1 = $13_1 + 1 | 0;
    $7_1 = $7_1 + 977 | 0;
    $3_1 = $7_1 >>> 0 < 977 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $3_1 & 1048575;
    $1_1 = $3_1;
    $3_1 = $14_1;
    $1_1 = $1_1 >>> 20 | 0;
    $8_1 = $1_1 + $8_1 | 0;
    $3_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = $3_1 & 1048575;
    $1_1 = $3_1;
    $3_1 = $9_1;
    $1_1 = $1_1 >>> 20 | 0;
    $4_1 = $1_1 + $4_1 | 0;
    $3_1 = $1_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $9_1 = $3_1 & 1048575;
    $1_1 = $3_1;
    $3_1 = $12_1;
    $1_1 = $1_1 >>> 20 | 0;
    $5_1 = $1_1 + $5_1 | 0;
    $3_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $12_1 = $3_1 & 1048575;
    $1_1 = $3_1;
    $3_1 = $10_1;
    $15_1 = $11_1;
    $11_1 = ($1_1 >>> 20 | 0) + $11_1 | 0;
    $10_1 = ($15_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) & 65535;
   }
   HEAP32[$0_1 + 72 >> 2] = $11_1;
   HEAP32[$0_1 + 76 >> 2] = $10_1;
   HEAP32[$0_1 + 64 >> 2] = $5_1;
   HEAP32[$0_1 + 68 >> 2] = $12_1;
   HEAP32[$0_1 + 56 >> 2] = $4_1;
   HEAP32[$0_1 + 60 >> 2] = $9_1;
   HEAP32[$0_1 + 48 >> 2] = $8_1;
   HEAP32[$0_1 + 52 >> 2] = $14_1;
   HEAP32[$0_1 + 40 >> 2] = $7_1;
   HEAP32[$0_1 + 44 >> 2] = $13_1;
   $1_1 = 1;
   if (($7_1 & 1) == ($2_1 | 0)) {
    break label$8
   }
   HEAP32[$0_1 + 72 >> 2] = -4 - $11_1;
   HEAP32[$0_1 + 76 >> 2] = 262143 - (($11_1 >>> 0 > 4294967292) + $10_1 | 0);
   HEAP32[$0_1 + 64 >> 2] = -4 - $5_1;
   HEAP32[$0_1 + 68 >> 2] = 4194303 - (($5_1 >>> 0 > 4294967292) + $12_1 | 0);
   HEAP32[$0_1 + 56 >> 2] = -4 - $4_1;
   HEAP32[$0_1 + 60 >> 2] = 4194303 - (($4_1 >>> 0 > 4294967292) + $9_1 | 0);
   HEAP32[$0_1 + 48 >> 2] = -4 - $8_1;
   HEAP32[$0_1 + 52 >> 2] = 4194303 - (($8_1 >>> 0 > 4294967292) + $14_1 | 0);
   HEAP32[$0_1 + 40 >> 2] = -3908 - $7_1;
   HEAP32[$0_1 + 44 >> 2] = 4194299 - (($7_1 >>> 0 > 4294963388) + $13_1 | 0);
  }
  global$0 = $16_1 + 7616 | 0;
  return $1_1;
 }
 
 function $34($0_1, $1_1, $2_1) {
  var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0, $51_1 = 0, $52_1 = 0, $53_1 = 0, $54_1 = 0, $55_1 = 0, $56_1 = 0, $57_1 = 0, $58_1 = 0, $59_1 = 0, $60_1 = 0, $61_1 = 0, $62_1 = 0, $63_1 = 0, $64_1 = 0;
  $3_1 = global$0 - 496 | 0;
  global$0 = $3_1;
  $19_1 = $3_1 - -64 | 0;
  $31_1 = HEAP32[$2_1 + 24 >> 2];
  $32_1 = HEAP32[$2_1 + 28 >> 2];
  $33_1 = HEAP32[$1_1 >> 2];
  $34_1 = HEAP32[$1_1 + 4 >> 2];
  $69($19_1, $31_1, $32_1, 0, 0, $33_1, $34_1, 0, 0);
  $21_1 = $3_1 + 208 | 0;
  $35_1 = HEAP32[$2_1 + 16 >> 2];
  $36_1 = HEAP32[$2_1 + 20 >> 2];
  $37_1 = HEAP32[$1_1 + 8 >> 2];
  $38_1 = HEAP32[$1_1 + 12 >> 2];
  $69($21_1, $35_1, $36_1, 0, 0, $37_1, $38_1, 0, 0);
  $16_1 = $3_1 + 320 | 0;
  $39_1 = HEAP32[$2_1 + 8 >> 2];
  $40_1 = HEAP32[$2_1 + 12 >> 2];
  $41_1 = HEAP32[$1_1 + 16 >> 2];
  $42_1 = HEAP32[$1_1 + 20 >> 2];
  $69($16_1, $39_1, $40_1, 0, 0, $41_1, $42_1, 0, 0);
  $10_1 = $3_1 + 400 | 0;
  $43_1 = HEAP32[$2_1 >> 2];
  $44_1 = HEAP32[$2_1 + 4 >> 2];
  $45_1 = HEAP32[$1_1 + 24 >> 2];
  $46_1 = HEAP32[$1_1 + 28 >> 2];
  $69($10_1, $43_1, $44_1, 0, 0, $45_1, $46_1, 0, 0);
  $4_1 = $3_1 + 480 | 0;
  $47_1 = HEAP32[$2_1 + 32 >> 2];
  $48_1 = HEAP32[$2_1 + 36 >> 2];
  $49_1 = HEAP32[$1_1 + 32 >> 2];
  $24_1 = HEAP32[$1_1 + 36 >> 2];
  $69($4_1, $47_1, $48_1, 0, 0, $49_1, $24_1, 0, 0);
  $9_1 = $3_1 + 464 | 0;
  $69($9_1, HEAP32[$3_1 + 480 >> 2], HEAP32[$3_1 + 484 >> 2], 0, 0, 15632, 16, 0, 0);
  $20_1 = $3_1 + 80 | 0;
  $69($20_1, $47_1, $48_1, 0, 0, $33_1, $34_1, 0, 0);
  $50_1 = $3_1 + 144 | 0;
  $69($50_1, $31_1, $32_1, 0, 0, $37_1, $38_1, 0, 0);
  $51_1 = $3_1 + 272 | 0;
  $69($51_1, $35_1, $36_1, 0, 0, $41_1, $42_1, 0, 0);
  $52_1 = $3_1 + 368 | 0;
  $69($52_1, $39_1, $40_1, 0, 0, $45_1, $46_1, 0, 0);
  $26_1 = $3_1 + 432 | 0;
  $69($26_1, $43_1, $44_1, 0, 0, $49_1, $24_1, 0, 0);
  $15_1 = $3_1 + 448 | 0;
  $1_1 = $4_1 + 8 | 0;
  $69($15_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $53_1 = $3_1 + 96 | 0;
  $69($53_1, $43_1, $44_1, 0, 0, $33_1, $34_1, 0, 0);
  $54_1 = $3_1 + 224 | 0;
  $69($54_1, $47_1, $48_1, 0, 0, $37_1, $38_1, 0, 0);
  $55_1 = $3_1 + 160 | 0;
  $69($55_1, $31_1, $32_1, 0, 0, $41_1, $42_1, 0, 0);
  $56_1 = $3_1 + 288 | 0;
  $69($56_1, $35_1, $36_1, 0, 0, $45_1, $46_1, 0, 0);
  $28_1 = $3_1 + 384 | 0;
  $69($28_1, $39_1, $40_1, 0, 0, $49_1, $24_1, 0, 0);
  $14_1 = HEAP32[$3_1 + 208 >> 2];
  $2_1 = HEAP32[$3_1 + 64 >> 2];
  $18_1 = $14_1 + $2_1 | 0;
  $17_1 = HEAP32[$3_1 + 212 >> 2];
  $1_1 = $17_1 + HEAP32[$3_1 + 68 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $18_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = HEAP32[$3_1 + 320 >> 2];
  $8_1 = $2_1 + $18_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + HEAP32[$3_1 + 324 >> 2] | 0;
  $7_1 = $2_1 >>> 0 > $8_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $7_1 + HEAP32[$3_1 + 404 >> 2] | 0;
  $2_1 = HEAP32[$3_1 + 400 >> 2];
  $6_1 = $2_1 + $8_1 | 0;
  $5_1 = HEAP32[$3_1 + 464 >> 2];
  $57_1 = $6_1 + $5_1 | 0;
  $2_1 = $2_1 >>> 0 > $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $2_1 + HEAP32[$3_1 + 468 >> 2] | 0;
  $5_1 = $5_1 >>> 0 > $57_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $12_1 = ($2_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 > $57_1 >>> 0 | $2_1 >>> 0 > $5_1 >>> 0;
  $1_1 = $9_1 + 8 | 0;
  $58_1 = HEAP32[$1_1 >> 2];
  $27_1 = HEAP32[$1_1 + 4 >> 2];
  $11_1 = ($2_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $6_1 >>> 0 | $2_1 >>> 0 < $7_1 >>> 0;
  $1_1 = $10_1 + 8 | 0;
  $13_1 = HEAP32[$1_1 >> 2];
  $10_1 = HEAP32[$1_1 + 4 >> 2];
  $9_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $18_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
  $1_1 = $16_1 + 8 | 0;
  $7_1 = HEAP32[$1_1 >> 2];
  $8_1 = HEAP32[$1_1 + 4 >> 2];
  $6_1 = ($4_1 | 0) == ($17_1 | 0) & $14_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 < $17_1 >>> 0;
  $4_1 = $19_1 + 8 | 0;
  $2_1 = HEAP32[$4_1 >> 2];
  $1_1 = $21_1 + 8 | 0;
  $18_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
  $1_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $18_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = $6_1 + $18_1 | 0;
  $1_1 = ($2_1 >>> 0 < $18_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $8_1 | 0;
  $4_1 = $2_1;
  $2_1 = $2_1 + $7_1 | 0;
  $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $4_1 = $2_1;
  $2_1 = $2_1 + $9_1 | 0;
  $1_1 = ($4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $10_1 | 0;
  $4_1 = $2_1;
  $2_1 = $2_1 + $13_1 | 0;
  $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $4_1 = $2_1;
  $2_1 = $2_1 + $11_1 | 0;
  $1_1 = ($4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $27_1 | 0;
  $4_1 = $2_1;
  $2_1 = $2_1 + $58_1 | 0;
  $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $4_1 = $2_1;
  $2_1 = $2_1 + $12_1 | 0;
  $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $58_1 = $5_1;
  $18_1 = $2_1 << 12 | $5_1 >>> 20;
  $4_1 = $1_1;
  $6_1 = $1_1 << 12 | $2_1 >>> 20;
  $22_1 = HEAP32[$3_1 + 272 >> 2];
  $2_1 = HEAP32[$3_1 + 144 >> 2];
  $10_1 = $22_1 + $2_1 | 0;
  $29_1 = HEAP32[$3_1 + 276 >> 2];
  $1_1 = $29_1 + HEAP32[$3_1 + 148 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = HEAP32[$3_1 + 368 >> 2];
  $9_1 = $2_1 + $10_1 | 0;
  $12_1 = $1_1;
  $1_1 = $1_1 + HEAP32[$3_1 + 372 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = HEAP32[$3_1 + 432 >> 2];
  $7_1 = $2_1 + $9_1 | 0;
  $27_1 = $1_1;
  $1_1 = $1_1 + HEAP32[$3_1 + 436 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $7_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = HEAP32[$3_1 + 80 >> 2];
  $8_1 = $2_1 + $7_1 | 0;
  $11_1 = $1_1;
  $1_1 = $1_1 + HEAP32[$3_1 + 84 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $8_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = HEAP32[$3_1 + 448 >> 2];
  $5_1 = $2_1 + $8_1 | 0;
  $13_1 = $1_1;
  $1_1 = $1_1 + HEAP32[$3_1 + 452 >> 2] | 0;
  $2_1 = $2_1 >>> 0 > $5_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $2_1 + $6_1 | 0;
  $18_1 = $5_1 + $18_1 | 0;
  $6_1 = $18_1 >>> 0 < $5_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $25_1 = ($2_1 | 0) == ($6_1 | 0) & $5_1 >>> 0 > $18_1 >>> 0 | $2_1 >>> 0 > $6_1 >>> 0;
  $23_1 = ($2_1 | 0) == ($13_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $2_1 >>> 0 < $13_1 >>> 0;
  $1_1 = $15_1 + 8 | 0;
  $17_1 = HEAP32[$1_1 >> 2];
  $19_1 = HEAP32[$1_1 + 4 >> 2];
  $21_1 = ($11_1 | 0) == ($13_1 | 0) & $8_1 >>> 0 < $7_1 >>> 0 | $11_1 >>> 0 > $13_1 >>> 0;
  $1_1 = $20_1 + 8 | 0;
  $16_1 = HEAP32[$1_1 >> 2];
  $20_1 = HEAP32[$1_1 + 4 >> 2];
  $15_1 = ($11_1 | 0) == ($27_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $11_1 >>> 0 < $27_1 >>> 0;
  $1_1 = $26_1 + 8 | 0;
  $14_1 = HEAP32[$1_1 >> 2];
  $11_1 = HEAP32[$1_1 + 4 >> 2];
  $13_1 = ($12_1 | 0) == ($27_1 | 0) & $10_1 >>> 0 > $9_1 >>> 0 | $12_1 >>> 0 > $27_1 >>> 0;
  $1_1 = $52_1 + 8 | 0;
  $9_1 = HEAP32[$1_1 >> 2];
  $7_1 = HEAP32[$1_1 + 4 >> 2];
  $8_1 = ($12_1 | 0) == ($29_1 | 0) & $10_1 >>> 0 < $22_1 >>> 0 | $12_1 >>> 0 < $29_1 >>> 0;
  $5_1 = $50_1 + 8 | 0;
  $2_1 = HEAP32[$5_1 >> 2];
  $1_1 = $51_1 + 8 | 0;
  $10_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
  $1_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = $8_1 + $10_1 | 0;
  $1_1 = ($2_1 >>> 0 < $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $7_1 | 0;
  $5_1 = $2_1;
  $2_1 = $2_1 + $9_1 | 0;
  $1_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $5_1 = $2_1;
  $2_1 = $2_1 + $13_1 | 0;
  $1_1 = ($5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $11_1 | 0;
  $5_1 = $2_1;
  $2_1 = $2_1 + $14_1 | 0;
  $1_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $5_1 = $2_1;
  $2_1 = $2_1 + $15_1 | 0;
  $1_1 = ($5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $20_1 | 0;
  $5_1 = $2_1;
  $2_1 = $2_1 + $16_1 | 0;
  $1_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $5_1 = $2_1;
  $2_1 = $2_1 + $21_1 | 0;
  $1_1 = ($5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $19_1 | 0;
  $5_1 = $2_1;
  $2_1 = $2_1 + $17_1 | 0;
  $1_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $5_1 = $2_1 + $23_1 | 0;
  $1_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $4_1 = $4_1 >>> 20 | 0;
  $2_1 = $4_1 + $5_1 | 0;
  $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $4_1 = $2_1;
  $2_1 = $2_1 + $25_1 | 0;
  $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $4_1 = $6_1;
  $8_1 = $2_1 << 12 | $4_1 >>> 20;
  $5_1 = $1_1;
  $6_1 = $1_1 << 12 | $2_1 >>> 20;
  $23_1 = HEAP32[$3_1 + 288 >> 2];
  $2_1 = HEAP32[$3_1 + 160 >> 2];
  $11_1 = $23_1 + $2_1 | 0;
  $22_1 = HEAP32[$3_1 + 292 >> 2];
  $1_1 = $22_1 + HEAP32[$3_1 + 164 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = HEAP32[$3_1 + 384 >> 2];
  $13_1 = $2_1 + $11_1 | 0;
  $14_1 = $1_1;
  $1_1 = $1_1 + HEAP32[$3_1 + 388 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = HEAP32[$3_1 + 224 >> 2];
  $10_1 = $2_1 + $13_1 | 0;
  $12_1 = $1_1;
  $1_1 = $1_1 + HEAP32[$3_1 + 228 >> 2] | 0;
  $2_1 = $2_1 >>> 0 > $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $2_1 + $6_1 | 0;
  $8_1 = $8_1 + $10_1 | 0;
  $1_1 = $8_1 >>> 0 < $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $9_1 = $8_1 << 4 & -16;
  $6_1 = $1_1;
  $7_1 = ($1_1 << 4 | $8_1 >>> 28) & 16777215;
  $27_1 = $4_1;
  $69($3_1, $9_1 | $4_1 >>> 16 & 15, $7_1, 0, 0, 977, 1, 0, 0);
  $25_1 = HEAP32[$3_1 + 4 >> 2];
  $1_1 = $25_1 + HEAP32[$3_1 + 100 >> 2] | 0;
  $7_1 = $0_1;
  $17_1 = HEAP32[$3_1 >> 2];
  $0_1 = HEAP32[$3_1 + 96 >> 2];
  $9_1 = $17_1 + $0_1 | 0;
  HEAP32[$7_1 >> 2] = $9_1;
  $4_1 = $0_1 >>> 0 > $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  HEAP32[$7_1 + 4 >> 2] = $4_1 & 1048575;
  $61_1 = $3_1 + 112 | 0;
  $69($61_1, $39_1, $40_1, 0, 0, $33_1, $34_1, 0, 0);
  $62_1 = $3_1 + 240 | 0;
  $69($62_1, $43_1, $44_1, 0, 0, $37_1, $38_1, 0, 0);
  $63_1 = $3_1 + 336 | 0;
  $69($63_1, $47_1, $48_1, 0, 0, $41_1, $42_1, 0, 0);
  $30_1 = $3_1 + 176 | 0;
  $69($30_1, $31_1, $32_1, 0, 0, $45_1, $46_1, 0, 0);
  $26_1 = $3_1 + 304 | 0;
  $69($26_1, $35_1, $36_1, 0, 0, $49_1, $24_1, 0, 0);
  $64_1 = $3_1 + 48 | 0;
  $19_1 = $64_1;
  $21_1 = ($2_1 | 0) == ($6_1 | 0) & $8_1 >>> 0 < $10_1 >>> 0 | $2_1 >>> 0 > $6_1 >>> 0;
  $16_1 = ($2_1 | 0) == ($12_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $2_1 >>> 0 < $12_1 >>> 0;
  $0_1 = $54_1 + 8 | 0;
  $20_1 = HEAP32[$0_1 >> 2];
  $15_1 = HEAP32[$0_1 + 4 >> 2];
  $12_1 = ($12_1 | 0) == ($14_1 | 0) & $11_1 >>> 0 > $13_1 >>> 0 | $12_1 >>> 0 < $14_1 >>> 0;
  $0_1 = $28_1 + 8 | 0;
  $13_1 = HEAP32[$0_1 >> 2];
  $10_1 = HEAP32[$0_1 + 4 >> 2];
  $8_1 = ($14_1 | 0) == ($22_1 | 0) & $11_1 >>> 0 < $23_1 >>> 0 | $14_1 >>> 0 < $22_1 >>> 0;
  $1_1 = $55_1 + 8 | 0;
  $2_1 = HEAP32[$1_1 >> 2];
  $0_1 = $56_1 + 8 | 0;
  $11_1 = $2_1 + HEAP32[$0_1 >> 2] | 0;
  $1_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$1_1 + 4 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $0_1 = $8_1 + $11_1 | 0;
  $1_1 = ($0_1 >>> 0 < $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $10_1 | 0;
  $2_1 = $0_1;
  $0_1 = $0_1 + $13_1 | 0;
  $1_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = $0_1;
  $0_1 = $0_1 + $12_1 | 0;
  $1_1 = ($2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $15_1 | 0;
  $2_1 = $0_1;
  $0_1 = $0_1 + $20_1 | 0;
  $1_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = $0_1 + $16_1 | 0;
  $1_1 = $2_1 >>> 0 < $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $5_1 = $5_1 >>> 20 | 0;
  $0_1 = $2_1 + $5_1 | 0;
  $1_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = $0_1;
  $0_1 = $0_1 + $21_1 | 0;
  $1_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $5_1 = $0_1 << 12 | $6_1 >>> 20;
  $8_1 = $1_1;
  $2_1 = $1_1 << 12 | $0_1 >>> 20;
  $28_1 = HEAP32[$3_1 + 304 >> 2];
  $0_1 = HEAP32[$3_1 + 176 >> 2];
  $14_1 = $28_1 + $0_1 | 0;
  $59_1 = HEAP32[$3_1 + 308 >> 2];
  $1_1 = $59_1 + HEAP32[$3_1 + 180 >> 2] | 0;
  $1_1 = $0_1 >>> 0 > $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $0_1 = HEAP32[$3_1 + 336 >> 2];
  $12_1 = $0_1 + $14_1 | 0;
  $15_1 = $1_1;
  $1_1 = $1_1 + HEAP32[$3_1 + 340 >> 2] | 0;
  $6_1 = $0_1 >>> 0 > $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $6_1 + $2_1 | 0;
  $11_1 = $5_1 + $12_1 | 0;
  $1_1 = $11_1 >>> 0 < $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $10_1 = $1_1;
  $69($19_1, $11_1, $1_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $5_1 = ($4_1 | 0) == ($25_1 | 0) & $9_1 >>> 0 < $17_1 >>> 0 | $4_1 >>> 0 < $25_1 >>> 0;
  $1_1 = $53_1 + 8 | 0;
  $2_1 = HEAP32[$1_1 >> 2];
  $0_1 = $3_1 + 8 | 0;
  $9_1 = $2_1 + HEAP32[$0_1 >> 2] | 0;
  $1_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$1_1 + 4 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $0_1 = $5_1 + $9_1 | 0;
  $1_1 = $0_1 >>> 0 < $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $13_1 = $0_1 << 12 | $4_1 >>> 20;
  $5_1 = $1_1;
  $9_1 = $1_1 << 12 | $0_1 >>> 20;
  $29_1 = HEAP32[$3_1 + 240 >> 2];
  $0_1 = HEAP32[$3_1 + 112 >> 2];
  $16_1 = $29_1 + $0_1 | 0;
  $60_1 = HEAP32[$3_1 + 244 >> 2];
  $1_1 = $60_1 + HEAP32[$3_1 + 116 >> 2] | 0;
  $23_1 = $0_1 >>> 0 > $16_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $23_1 + HEAP32[$3_1 + 52 >> 2] | 0;
  $2_1 = HEAP32[$3_1 + 48 >> 2];
  $0_1 = $2_1 + $16_1 | 0;
  $21_1 = $0_1;
  $13_1 = $0_1 + $13_1 | 0;
  $4_1 = $0_1 >>> 0 < $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $4_1 + $9_1 | 0;
  HEAP32[$7_1 + 8 >> 2] = $13_1;
  $9_1 = $13_1 >>> 0 < $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  HEAP32[$7_1 + 12 >> 2] = $9_1 & 1048575;
  $50_1 = $3_1 + 128 | 0;
  $69($50_1, $35_1, $36_1, 0, 0, $33_1, $34_1, 0, 0);
  $51_1 = $3_1 + 256 | 0;
  $69($51_1, $39_1, $40_1, 0, 0, $37_1, $38_1, 0, 0);
  $52_1 = $3_1 + 352 | 0;
  $69($52_1, $43_1, $44_1, 0, 0, $41_1, $42_1, 0, 0);
  $53_1 = $3_1 + 416 | 0;
  $69($53_1, $47_1, $48_1, 0, 0, $45_1, $46_1, 0, 0);
  $54_1 = $3_1 + 192 | 0;
  $69($54_1, $31_1, $32_1, 0, 0, $49_1, $24_1, 0, 0);
  $55_1 = $3_1 + 32 | 0;
  $22_1 = $55_1;
  $56_1 = HEAP32[$3_1 + 416 >> 2];
  $0_1 = HEAP32[$3_1 + 192 >> 2];
  $20_1 = $56_1 + $0_1 | 0;
  $24_1 = HEAP32[$3_1 + 420 >> 2];
  $1_1 = $24_1 + HEAP32[$3_1 + 196 >> 2] | 0;
  $2_1 = $0_1 >>> 0 > $20_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $25_1 = ($6_1 | 0) == ($10_1 | 0) & $11_1 >>> 0 < $12_1 >>> 0 | $6_1 >>> 0 > $10_1 >>> 0;
  $17_1 = ($6_1 | 0) == ($15_1 | 0) & $12_1 >>> 0 < $14_1 >>> 0 | $6_1 >>> 0 < $15_1 >>> 0;
  $0_1 = $63_1 + 8 | 0;
  $19_1 = HEAP32[$0_1 >> 2];
  $12_1 = HEAP32[$0_1 + 4 >> 2];
  $11_1 = ($15_1 | 0) == ($59_1 | 0) & $14_1 >>> 0 < $28_1 >>> 0 | $15_1 >>> 0 < $59_1 >>> 0;
  $1_1 = $30_1 + 8 | 0;
  $6_1 = HEAP32[$1_1 >> 2];
  $0_1 = $26_1 + 8 | 0;
  $14_1 = $6_1 + HEAP32[$0_1 >> 2] | 0;
  $1_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$1_1 + 4 >> 2] | 0;
  $1_1 = $6_1 >>> 0 > $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $0_1 = $11_1 + $14_1 | 0;
  $1_1 = ($0_1 >>> 0 < $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $12_1 | 0;
  $6_1 = $0_1;
  $0_1 = $0_1 + $19_1 | 0;
  $1_1 = $6_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $6_1 = $0_1 + $17_1 | 0;
  $1_1 = $6_1 >>> 0 < $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $8_1 = $8_1 >>> 20 | 0;
  $0_1 = $8_1 + $6_1 | 0;
  $1_1 = $8_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $6_1 = $0_1;
  $0_1 = $0_1 + $25_1 | 0;
  $1_1 = $6_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $8_1 = $0_1 << 12 | $10_1 >>> 20;
  $10_1 = $8_1 + $20_1 | 0;
  $6_1 = $1_1;
  $1_1 = $2_1 + ($1_1 << 12 | $0_1 >>> 20) | 0;
  $15_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $69($22_1, $10_1, $15_1, 0, 0, 15632, 16, 0, 0);
  $8_1 = $7_1;
  $26_1 = HEAP32[$3_1 + 256 >> 2];
  $0_1 = HEAP32[$3_1 + 128 >> 2];
  $14_1 = $26_1 + $0_1 | 0;
  $30_1 = HEAP32[$3_1 + 260 >> 2];
  $1_1 = $30_1 + HEAP32[$3_1 + 132 >> 2] | 0;
  $1_1 = $0_1 >>> 0 > $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $0_1 = HEAP32[$3_1 + 352 >> 2];
  $12_1 = $0_1 + $14_1 | 0;
  $17_1 = $1_1;
  $1_1 = $1_1 + HEAP32[$3_1 + 356 >> 2] | 0;
  $1_1 = $0_1 >>> 0 > $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $0_1 = HEAP32[$3_1 + 32 >> 2];
  $11_1 = $0_1 + $12_1 | 0;
  $19_1 = $1_1;
  $1_1 = $1_1 + HEAP32[$3_1 + 36 >> 2] | 0;
  $0_1 = $0_1 >>> 0 > $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $28_1 = ($4_1 | 0) == ($9_1 | 0) & $13_1 >>> 0 < $21_1 >>> 0 | $4_1 >>> 0 > $9_1 >>> 0;
  $22_1 = ($4_1 | 0) == ($23_1 | 0) & $16_1 >>> 0 > $21_1 >>> 0 | $4_1 >>> 0 < $23_1 >>> 0;
  $1_1 = $64_1 + 8 | 0;
  $25_1 = HEAP32[$1_1 >> 2];
  $21_1 = HEAP32[$1_1 + 4 >> 2];
  $13_1 = ($23_1 | 0) == ($60_1 | 0) & $16_1 >>> 0 < $29_1 >>> 0 | $23_1 >>> 0 < $60_1 >>> 0;
  $7_1 = $61_1 + 8 | 0;
  $4_1 = HEAP32[$7_1 >> 2];
  $1_1 = $62_1 + 8 | 0;
  $16_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $1_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
  $1_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $4_1 = $13_1 + $16_1 | 0;
  $1_1 = ($4_1 >>> 0 < $16_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $21_1 | 0;
  $7_1 = $4_1;
  $4_1 = $4_1 + $25_1 | 0;
  $1_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $7_1 = $4_1 + $22_1 | 0;
  $1_1 = $7_1 >>> 0 < $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $5_1 = $5_1 >>> 20 | 0;
  $4_1 = $5_1 + $7_1 | 0;
  $1_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $5_1 = $4_1;
  $4_1 = $4_1 + $28_1 | 0;
  $1_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $7_1 = $4_1 << 12 | $9_1 >>> 20;
  $9_1 = $7_1 + $11_1 | 0;
  $5_1 = $1_1;
  $1_1 = $0_1 + ($1_1 << 12 | $4_1 >>> 20) | 0;
  HEAP32[$8_1 + 16 >> 2] = $9_1;
  $7_1 = $7_1 >>> 0 > $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  HEAP32[$8_1 + 20 >> 2] = $7_1 & 1048575;
  $16_1 = $3_1 + 16 | 0;
  $13_1 = ($2_1 | 0) == ($15_1 | 0) & $10_1 >>> 0 < $20_1 >>> 0 | $2_1 >>> 0 > $15_1 >>> 0;
  $10_1 = ($2_1 | 0) == ($24_1 | 0) & $20_1 >>> 0 < $56_1 >>> 0 | $2_1 >>> 0 < $24_1 >>> 0;
  $4_1 = $54_1 + 8 | 0;
  $2_1 = HEAP32[$4_1 >> 2];
  $1_1 = $53_1 + 8 | 0;
  $15_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
  $1_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $15_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $4_1 = $10_1 + $15_1 | 0;
  $1_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $6_1 = $6_1 >>> 20 | 0;
  $2_1 = $4_1 + $6_1 | 0;
  $1_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $4_1 = $2_1;
  $2_1 = $2_1 + $13_1 | 0;
  $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $69($16_1, $2_1, $1_1, 0, 0, 64028672, 65536, 0, 0);
  $4_1 = $8_1;
  $20_1 = ($0_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 < $11_1 >>> 0 | $0_1 >>> 0 > $7_1 >>> 0;
  $15_1 = ($0_1 | 0) == ($19_1 | 0) & $11_1 >>> 0 < $12_1 >>> 0 | $0_1 >>> 0 < $19_1 >>> 0;
  $0_1 = $55_1 + 8 | 0;
  $11_1 = HEAP32[$0_1 >> 2];
  $13_1 = HEAP32[$0_1 + 4 >> 2];
  $10_1 = ($17_1 | 0) == ($19_1 | 0) & $12_1 >>> 0 < $14_1 >>> 0 | $17_1 >>> 0 > $19_1 >>> 0;
  $0_1 = $52_1 + 8 | 0;
  $9_1 = HEAP32[$0_1 >> 2];
  $8_1 = HEAP32[$0_1 + 4 >> 2];
  $6_1 = ($17_1 | 0) == ($30_1 | 0) & $14_1 >>> 0 < $26_1 >>> 0 | $17_1 >>> 0 < $30_1 >>> 0;
  $1_1 = $50_1 + 8 | 0;
  $2_1 = HEAP32[$1_1 >> 2];
  $0_1 = $51_1 + 8 | 0;
  $12_1 = $2_1 + HEAP32[$0_1 >> 2] | 0;
  $1_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$1_1 + 4 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $0_1 = $6_1 + $12_1 | 0;
  $1_1 = ($0_1 >>> 0 < $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $8_1 | 0;
  $2_1 = $0_1;
  $0_1 = $0_1 + $9_1 | 0;
  $1_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = $0_1;
  $0_1 = $0_1 + $10_1 | 0;
  $1_1 = ($2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $13_1 | 0;
  $2_1 = $0_1;
  $0_1 = $0_1 + $11_1 | 0;
  $1_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = $0_1 + $15_1 | 0;
  $1_1 = $2_1 >>> 0 < $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $5_1 = $5_1 >>> 20 | 0;
  $0_1 = $2_1 + $5_1 | 0;
  $1_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = $0_1;
  $0_1 = $0_1 + $20_1 | 0;
  $1_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $5_1 = $0_1 << 12 | $7_1 >>> 20;
  $2_1 = $1_1;
  $6_1 = $1_1 << 12 | $0_1 >>> 20;
  $11_1 = HEAP32[$3_1 + 20 >> 2];
  $1_1 = $11_1 + ($58_1 & 1048575) | 0;
  $13_1 = HEAP32[$3_1 + 16 >> 2];
  $0_1 = $57_1 + $13_1 | 0;
  $7_1 = $0_1 >>> 0 < $57_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $7_1 + $6_1 | 0;
  $8_1 = $0_1;
  $5_1 = $0_1 + $5_1 | 0;
  HEAP32[$4_1 + 24 >> 2] = $5_1;
  $0_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  HEAP32[$4_1 + 28 >> 2] = $0_1 & 1048575;
  $6_1 = $4_1;
  $10_1 = $27_1 & 65535;
  $9_1 = ($0_1 | 0) == ($7_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $0_1 >>> 0 < $7_1 >>> 0;
  $4_1 = ($7_1 | 0) == ($11_1 | 0) & $8_1 >>> 0 < $13_1 >>> 0 | $7_1 >>> 0 < $11_1 >>> 0;
  $1_1 = $16_1 + 8 | 0;
  $5_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $1_1 = HEAP32[$1_1 + 4 >> 2];
  $1_1 = $4_1 >>> 0 > $5_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = $2_1 >>> 20 | 0;
  $4_1 = $2_1;
  $2_1 = $2_1 + $5_1 | 0;
  $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $4_1 = $2_1;
  $2_1 = $2_1 + $9_1 | 0;
  $1_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $0_1 = $2_1 << 12 | $0_1 >>> 20;
  $4_1 = $0_1 + $18_1 | 0;
  $1_1 = $10_1 + ($1_1 << 12 | $2_1 >>> 20) | 0;
  HEAP32[$6_1 + 32 >> 2] = $4_1;
  HEAP32[$6_1 + 36 >> 2] = $0_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  global$0 = $3_1 + 496 | 0;
 }
 
 function $35($0_1, $1_1) {
  var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0;
  $3_1 = $1_1 - -64 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $8_1 = HEAP32[$3_1 + 4 >> 2];
  $3_1 = $1_1 + 56 | 0;
  $6_1 = HEAP32[$3_1 >> 2];
  $17_1 = HEAP32[$3_1 + 4 >> 2];
  $3_1 = $1_1 + 48 | 0;
  $18_1 = HEAP32[$3_1 >> 2];
  $12_1 = HEAP32[$3_1 + 4 >> 2];
  $3_1 = $1_1 + 72 | 0;
  $14_1 = HEAP32[$3_1 >> 2];
  $5_1 = HEAP32[$3_1 + 4 >> 2];
  $20_1 = HEAP32[$1_1 + 40 >> 2];
  $22_1 = HEAP32[$1_1 + 44 >> 2];
  $19_1 = HEAP32[$1_1 + 24 >> 2];
  $13_1 = HEAP32[$1_1 + 28 >> 2];
  $7_1 = HEAP32[$1_1 + 16 >> 2];
  $16_1 = HEAP32[$1_1 + 20 >> 2];
  $2_1 = HEAP32[$1_1 + 8 >> 2];
  $9_1 = HEAP32[$1_1 + 12 >> 2];
  $10_1 = HEAP32[$1_1 + 4 >> 2];
  $21_1 = HEAP32[$1_1 + 32 >> 2];
  $4_1 = HEAP32[$1_1 + 36 >> 2];
  $24_1 = $4_1;
  $1_1 = HEAP32[$1_1 >> 2];
  $3_1 = __wasm_i64_mul($4_1 >>> 16 | 0, 0, 977, 1);
  $4_1 = $1_1 + $3_1 | 0;
  $1_1 = $10_1 + i64toi32_i32$HIGH_BITS | 0;
  $10_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $9_1;
  $3_1 = $10_1 >>> 20 | 0;
  $9_1 = $3_1;
  $3_1 = $2_1 + $3_1 | 0;
  $9_1 = $9_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $16_1;
  $2_1 = $9_1 >>> 20 | 0;
  $15_1 = $2_1;
  $2_1 = $2_1 + $7_1 | 0;
  $16_1 = $15_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $13_1;
  $7_1 = $16_1 >>> 20 | 0;
  $13_1 = $7_1;
  $7_1 = $7_1 + $19_1 | 0;
  $19_1 = $13_1 >>> 0 > $7_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $25_1 = $9_1 & 1048575;
  $1_1 = $10_1 & 1048575;
  $15_1 = $1_1;
  $13_1 = $3_1;
  $10_1 = $2_1;
  $23_1 = $16_1 & 1048575;
  $2_1 = ($3_1 & $2_1 & $7_1) == -1 & ($23_1 & $9_1 & $19_1) == 1048575;
  $1_1 = $24_1 & 65535;
  $3_1 = $19_1 >>> 20 | 0;
  $9_1 = $3_1;
  $3_1 = $3_1 + $21_1 | 0;
  $1_1 = $9_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $21_1 = $3_1;
  $9_1 = $1_1;
  $3_1 = __wasm_i64_mul($2_1 & (($3_1 | 0) == -1 & ($1_1 | 0) == 65535) & (($15_1 | 0) == 1048574 & $4_1 >>> 0 > 4294966318 | $15_1 >>> 0 > 1048574) | $1_1 >>> 16, 0, 977, 1);
  $4_1 = $3_1 + $4_1 | 0;
  $1_1 = $15_1 + i64toi32_i32$HIGH_BITS | 0;
  $2_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $25_1;
  $3_1 = $2_1 >>> 20 | 0;
  $16_1 = $3_1 + $13_1 | 0;
  $3_1 = $3_1 >>> 0 > $16_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  HEAP8[$0_1 | 0] = $4_1;
  HEAP8[$0_1 + 1 | 0] = $4_1 >>> 8;
  HEAP8[$0_1 + 2 | 0] = $4_1 >>> 16;
  HEAP8[$0_1 + 3 | 0] = $4_1 >>> 24;
  $1_1 = $2_1 & 1048575 | $16_1 << 20;
  HEAP8[$0_1 + 4 | 0] = $1_1;
  HEAP8[$0_1 + 5 | 0] = $1_1 >>> 8;
  HEAP8[$0_1 + 6 | 0] = $1_1 >>> 16;
  HEAP8[$0_1 + 7 | 0] = $1_1 >>> 24;
  $13_1 = $14_1;
  $15_1 = $5_1 & 65535;
  $14_1 = $11_1;
  $11_1 = $6_1;
  $2_1 = __wasm_i64_mul($5_1 >>> 16 | 0, 0, 977, 1);
  $4_1 = $2_1 + $20_1 | 0;
  $1_1 = $22_1 + i64toi32_i32$HIGH_BITS | 0;
  $20_1 = $2_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $12_1;
  $2_1 = $20_1 >>> 20 | 0;
  $5_1 = $2_1;
  $2_1 = $2_1 + $18_1 | 0;
  $6_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $17_1;
  $5_1 = $6_1 >>> 20 | 0;
  $11_1 = $5_1 + $11_1 | 0;
  $12_1 = $5_1 >>> 0 > $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $8_1;
  $5_1 = $12_1 >>> 20 | 0;
  $8_1 = $5_1;
  $5_1 = $5_1 + $14_1 | 0;
  $17_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $15_1;
  $8_1 = $17_1 >>> 20 | 0;
  $14_1 = $8_1;
  $8_1 = $8_1 + $13_1 | 0;
  $1_1 = $14_1 >>> 0 > $8_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $18_1 = $8_1;
  $8_1 = $1_1;
  $22_1 = $6_1 & 1048575;
  $1_1 = $20_1 & 1048575;
  $15_1 = $4_1;
  $14_1 = $2_1;
  $13_1 = $12_1 & 1048575;
  $4_1 = __wasm_i64_mul(($11_1 & $2_1 & $5_1) == -1 & ($13_1 & $6_1 & $17_1) == 1048575 & (($18_1 | 0) == -1 & ($8_1 | 0) == 65535) & (($1_1 | 0) == 1048574 & $4_1 >>> 0 > 4294966318 | $1_1 >>> 0 > 1048574) | $8_1 >>> 16, 0, 977, 1);
  $2_1 = $15_1 + $4_1 | 0;
  $1_1 = $1_1 + i64toi32_i32$HIGH_BITS | 0;
  $6_1 = $2_1 >>> 0 < $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $22_1;
  $4_1 = $6_1 >>> 20 | 0;
  $12_1 = $4_1 + $14_1 | 0;
  $4_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  HEAP8[$0_1 + 32 | 0] = $2_1;
  HEAP8[$0_1 + 33 | 0] = $2_1 >>> 8;
  HEAP8[$0_1 + 34 | 0] = $2_1 >>> 16;
  HEAP8[$0_1 + 35 | 0] = $2_1 >>> 24;
  $1_1 = $6_1 & 1048575 | $12_1 << 20;
  HEAP8[$0_1 + 36 | 0] = $1_1;
  HEAP8[$0_1 + 37 | 0] = $1_1 >>> 8;
  HEAP8[$0_1 + 38 | 0] = $1_1 >>> 16;
  HEAP8[$0_1 + 39 | 0] = $1_1 >>> 24;
  $6_1 = ($3_1 & 4095) << 20 | $16_1 >>> 12;
  $14_1 = $3_1 >>> 12 & 255;
  $1_1 = $23_1;
  $2_1 = ($3_1 >>> 20 | 0) + $10_1 | 0;
  $3_1 = $2_1 >>> 0 < $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $10_1 = $2_1;
  $1_1 = $2_1 << 8;
  $2_1 = $0_1;
  HEAP8[$2_1 + 8 | 0] = $6_1;
  HEAP8[$2_1 + 9 | 0] = $6_1 >>> 8;
  HEAP8[$2_1 + 10 | 0] = $6_1 >>> 16;
  HEAP8[$2_1 + 11 | 0] = $6_1 >>> 24;
  $1_1 = $1_1 | $14_1;
  HEAP8[$2_1 + 12 | 0] = $1_1;
  HEAP8[$2_1 + 13 | 0] = $1_1 >>> 8;
  HEAP8[$2_1 + 14 | 0] = $1_1 >>> 16;
  HEAP8[$2_1 + 15 | 0] = $1_1 >>> 24;
  $6_1 = ($4_1 & 4095) << 20 | $12_1 >>> 12;
  $12_1 = $4_1 >>> 12 & 255;
  $1_1 = $13_1;
  $2_1 = ($4_1 >>> 20 | 0) + $11_1 | 0;
  $4_1 = $2_1 >>> 0 < $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $11_1 = $2_1;
  $1_1 = $2_1 << 8;
  $2_1 = $0_1;
  HEAP8[$2_1 + 40 | 0] = $6_1;
  HEAP8[$2_1 + 41 | 0] = $6_1 >>> 8;
  HEAP8[$2_1 + 42 | 0] = $6_1 >>> 16;
  HEAP8[$2_1 + 43 | 0] = $6_1 >>> 24;
  $1_1 = $1_1 | $12_1;
  HEAP8[$2_1 + 44 | 0] = $1_1;
  HEAP8[$2_1 + 45 | 0] = $1_1 >>> 8;
  HEAP8[$2_1 + 46 | 0] = $1_1 >>> 16;
  HEAP8[$2_1 + 47 | 0] = $1_1 >>> 24;
  $10_1 = (($3_1 & 16777215) << 8 | $10_1 >>> 24) & 268435455;
  $1_1 = $19_1 & 1048575;
  $3_1 = $3_1 >>> 20 | 0;
  $2_1 = $3_1 + $7_1 | 0;
  $3_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $3_1 << 28 | $2_1 >>> 4;
  $7_1 = $2_1 << 28;
  $2_1 = $0_1;
  $7_1 = $7_1 | $10_1;
  HEAP8[$2_1 + 16 | 0] = $7_1;
  HEAP8[$2_1 + 17 | 0] = $7_1 >>> 8;
  HEAP8[$2_1 + 18 | 0] = $7_1 >>> 16;
  HEAP8[$2_1 + 19 | 0] = $7_1 >>> 24;
  HEAP8[$2_1 + 20 | 0] = $1_1;
  HEAP8[$2_1 + 21 | 0] = $1_1 >>> 8;
  HEAP8[$2_1 + 22 | 0] = $1_1 >>> 16;
  HEAP8[$2_1 + 23 | 0] = $1_1 >>> 24;
  $7_1 = (($4_1 & 16777215) << 8 | $11_1 >>> 24) & 268435455;
  $1_1 = $17_1 & 1048575;
  $4_1 = $4_1 >>> 20 | 0;
  $2_1 = $4_1 + $5_1 | 0;
  $4_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $4_1 << 28 | $2_1 >>> 4;
  $5_1 = $2_1 << 28;
  $2_1 = $0_1;
  $5_1 = $5_1 | $7_1;
  HEAP8[$2_1 + 48 | 0] = $5_1;
  HEAP8[$2_1 + 49 | 0] = $5_1 >>> 8;
  HEAP8[$2_1 + 50 | 0] = $5_1 >>> 16;
  HEAP8[$2_1 + 51 | 0] = $5_1 >>> 24;
  HEAP8[$2_1 + 52 | 0] = $1_1;
  HEAP8[$2_1 + 53 | 0] = $1_1 >>> 8;
  HEAP8[$2_1 + 54 | 0] = $1_1 >>> 16;
  HEAP8[$2_1 + 55 | 0] = $1_1 >>> 24;
  $2_1 = $3_1 >>> 4 & 65535;
  $1_1 = $9_1;
  $3_1 = ($3_1 >>> 20 | 0) + $21_1 | 0;
  $1_1 = ($3_1 >>> 0 < $21_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) << 16 | $3_1 >>> 16;
  $5_1 = $3_1 << 16;
  $3_1 = $0_1;
  $2_1 = $2_1 | $5_1;
  HEAP8[$3_1 + 24 | 0] = $2_1;
  HEAP8[$3_1 + 25 | 0] = $2_1 >>> 8;
  HEAP8[$3_1 + 26 | 0] = $2_1 >>> 16;
  HEAP8[$3_1 + 27 | 0] = $2_1 >>> 24;
  HEAP8[$3_1 + 28 | 0] = $1_1;
  HEAP8[$3_1 + 29 | 0] = $1_1 >>> 8;
  HEAP8[$3_1 + 30 | 0] = $1_1 >>> 16;
  HEAP8[$3_1 + 31 | 0] = $1_1 >>> 24;
  $2_1 = $4_1 >>> 4 & 65535;
  $1_1 = $8_1;
  $3_1 = ($4_1 >>> 20 | 0) + $18_1 | 0;
  $1_1 = ($3_1 >>> 0 < $18_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) << 16 | $3_1 >>> 16;
  $3_1 = $3_1 << 16 | $2_1;
  HEAP8[$0_1 + 56 | 0] = $3_1;
  HEAP8[$0_1 + 57 | 0] = $3_1 >>> 8;
  HEAP8[$0_1 + 58 | 0] = $3_1 >>> 16;
  HEAP8[$0_1 + 59 | 0] = $3_1 >>> 24;
  HEAP8[$0_1 + 60 | 0] = $1_1;
  HEAP8[$0_1 + 61 | 0] = $1_1 >>> 8;
  HEAP8[$0_1 + 62 | 0] = $1_1 >>> 16;
  HEAP8[$0_1 + 63 | 0] = $1_1 >>> 24;
 }
 
 function $36($0_1, $1_1, $2_1, $3_1) {
  var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0;
  $8_1 = global$0 - 96 | 0;
  global$0 = $8_1;
  label$1 : {
   if (!$1_1) {
    FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689730, HEAP32[$0_1 + 172 >> 2]);
    break label$1;
   }
   $5_1 = HEAP32[$1_1 >> 2];
   $26_1 = $3_1 & 256;
   if ($5_1 >>> 0 < ($26_1 ? 33 : 65) >>> 0) {
    FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](690157, HEAP32[$0_1 + 172 >> 2]);
    break label$1;
   }
   HEAP32[$1_1 >> 2] = 0;
   $22_1 = $68(690820, $5_1);
   if (!$2_1) {
    FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689638, HEAP32[$0_1 + 172 >> 2]);
    break label$1;
   }
   if (($3_1 & 255) != 2) {
    FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689499, HEAP32[$0_1 + 172 >> 2]);
    break label$1;
   }
   HEAP32[$8_1 + 88 >> 2] = 0;
   $3_1 = HEAPU8[$2_1 + 12 | 0] | HEAPU8[$2_1 + 13 | 0] << 8 | (HEAPU8[$2_1 + 14 | 0] << 16 | HEAPU8[$2_1 + 15 | 0] << 24);
   $6_1 = $3_1;
   $5_1 = HEAPU8[$2_1 + 8 | 0] | HEAPU8[$2_1 + 9 | 0] << 8 | (HEAPU8[$2_1 + 10 | 0] << 16 | HEAPU8[$2_1 + 11 | 0] << 24);
   $7_1 = ($3_1 << 12 | $5_1 >>> 20) & 1048575;
   $9_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
   $4_1 = $9_1;
   $5_1 = $5_1 << 12 & -4096 | $4_1 >>> 20;
   $20_1 = $7_1;
   $7_1 = HEAPU8[$2_1 + 16 | 0] | HEAPU8[$2_1 + 17 | 0] << 8 | (HEAPU8[$2_1 + 18 | 0] << 16 | HEAPU8[$2_1 + 19 | 0] << 24);
   $11_1 = $7_1;
   $3_1 = HEAPU8[$2_1 + 20 | 0] | HEAPU8[$2_1 + 21 | 0] << 8 | (HEAPU8[$2_1 + 22 | 0] << 16 | HEAPU8[$2_1 + 23 | 0] << 24);
   $9_1 = $3_1;
   $12_1 = ($3_1 << 24 | $7_1 >>> 8) & 1048575;
   $16_1 = $7_1 << 24 & -16777216 | $6_1 >>> 8;
   $23_1 = $12_1;
   $10_1 = $12_1;
   $7_1 = HEAPU8[$2_1 + 28 | 0] | HEAPU8[$2_1 + 29 | 0] << 8 | (HEAPU8[$2_1 + 30 | 0] << 16 | HEAPU8[$2_1 + 31 | 0] << 24);
   $3_1 = $7_1 >>> 16 | 0;
   $6_1 = HEAPU8[$2_1 + 24 | 0] | HEAPU8[$2_1 + 25 | 0] << 8 | (HEAPU8[$2_1 + 26 | 0] << 16 | HEAPU8[$2_1 + 27 | 0] << 24);
   $7_1 = ($7_1 & 65535) << 16 | $6_1 >>> 16;
   $17_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
   $15_1 = $16_1 | ($7_1 | ($17_1 | $5_1));
   $24_1 = $3_1;
   $18_1 = $4_1 & 1048575;
   $4_1 = $10_1 | ($3_1 | ($18_1 | $20_1));
   $10_1 = $6_1 << 4 & 1048560;
   $6_1 = $9_1;
   $3_1 = $6_1 >>> 28 | 0;
   $12_1 = ($6_1 & 268435455) << 4 | $11_1 >>> 28;
   $9_1 = $15_1 | $12_1;
   $15_1 = $3_1 | $10_1;
   if (!($9_1 | ($4_1 | $15_1))) {
    FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](690116, HEAP32[$0_1 + 172 >> 2]);
    break label$1;
   }
   $6_1 = HEAPU8[$2_1 + 52 | 0] | HEAPU8[$2_1 + 53 | 0] << 8 | (HEAPU8[$2_1 + 54 | 0] << 16 | HEAPU8[$2_1 + 55 | 0] << 24);
   $3_1 = $6_1 >>> 28 | 0;
   $0_1 = HEAPU8[$2_1 + 48 | 0] | HEAPU8[$2_1 + 49 | 0] << 8 | (HEAPU8[$2_1 + 50 | 0] << 16 | HEAPU8[$2_1 + 51 | 0] << 24);
   $9_1 = ($6_1 & 268435455) << 4 | $0_1 >>> 28;
   $11_1 = $3_1;
   $3_1 = HEAPU8[$2_1 + 56 | 0] | HEAPU8[$2_1 + 57 | 0] << 8 | (HEAPU8[$2_1 + 58 | 0] << 16 | HEAPU8[$2_1 + 59 | 0] << 24);
   $27_1 = $3_1;
   $13_1 = HEAPU8[$2_1 + 60 | 0] | HEAPU8[$2_1 + 61 | 0] << 8 | (HEAPU8[$2_1 + 62 | 0] << 16 | HEAPU8[$2_1 + 63 | 0] << 24);
   $28_1 = $3_1 << 4 & 1048560;
   $4_1 = HEAPU8[$2_1 + 40 | 0] | HEAPU8[$2_1 + 41 | 0] << 8 | (HEAPU8[$2_1 + 42 | 0] << 16 | HEAPU8[$2_1 + 43 | 0] << 24);
   $10_1 = HEAPU8[$2_1 + 44 | 0] | HEAPU8[$2_1 + 45 | 0] << 8 | (HEAPU8[$2_1 + 46 | 0] << 16 | HEAPU8[$2_1 + 47 | 0] << 24);
   $19_1 = $10_1 >>> 8 | 0;
   $3_1 = $6_1 << 24 | $0_1 >>> 8;
   $29_1 = $0_1 << 24 & -16777216;
   $30_1 = $3_1 & 1048575;
   $6_1 = HEAPU8[$2_1 + 32 | 0] | HEAPU8[$2_1 + 33 | 0] << 8 | (HEAPU8[$2_1 + 34 | 0] << 16 | HEAPU8[$2_1 + 35 | 0] << 24);
   $0_1 = HEAPU8[$2_1 + 36 | 0] | HEAPU8[$2_1 + 37 | 0] << 8 | (HEAPU8[$2_1 + 38 | 0] << 16 | HEAPU8[$2_1 + 39 | 0] << 24);
   $14_1 = $0_1;
   $2_1 = $0_1 >>> 20 | 0;
   $0_1 = $4_1;
   $3_1 = $10_1 << 12 | $0_1 >>> 20;
   $10_1 = $0_1 << 12 & -4096;
   $25_1 = $3_1 & 1048575;
   $21_1 = $14_1 & 1048575;
   label$7 : {
    if (($18_1 | 0) == 1048574 & $17_1 >>> 0 < 4294966319 | $18_1 >>> 0 < 1048574) {
     break label$7
    }
    if (($5_1 & $16_1 & $12_1) != -1 | ($20_1 & $23_1 & $15_1) != 1048575) {
     break label$7
    }
    if (($7_1 | 0) != -1 | ($24_1 | 0) != 65535) {
     break label$7
    }
    $0_1 = $18_1 + 1 | 0;
    $17_1 = $17_1 + 977 | 0;
    $0_1 = $17_1 >>> 0 < 977 ? $0_1 + 1 | 0 : $0_1;
    $18_1 = $0_1 & 1048575;
    $4_1 = $0_1 >>> 20 | 0;
    $0_1 = $20_1;
    $5_1 = $4_1 + $5_1 | 0;
    $0_1 = $5_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $20_1 = $0_1 & 1048575;
    $3_1 = $23_1;
    $0_1 = $0_1 >>> 20 | 0;
    $16_1 = $0_1 + $16_1 | 0;
    $3_1 = $0_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $23_1 = $3_1 & 1048575;
    $4_1 = $3_1 >>> 20 | 0;
    $0_1 = $15_1;
    $12_1 = $4_1 + $12_1 | 0;
    $0_1 = $12_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $15_1 = $0_1 & 1048575;
    $4_1 = $0_1 >>> 20 | 0;
    $0_1 = $24_1;
    $3_1 = $7_1;
    $7_1 = $4_1 + $7_1 | 0;
    $24_1 = ($3_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) & 65535;
   }
   $4_1 = $9_1;
   $14_1 = $11_1 | $28_1;
   $11_1 = $19_1 | $29_1;
   $19_1 = $30_1;
   $10_1 = $2_1 | $10_1;
   $0_1 = $13_1;
   $3_1 = $0_1 >>> 16 | 0;
   $9_1 = ($0_1 & 65535) << 16 | $27_1 >>> 16;
   $13_1 = $3_1;
   $2_1 = $8_1;
   HEAP32[$2_1 + 40 >> 2] = $7_1;
   HEAP32[$2_1 + 44 >> 2] = $24_1;
   HEAP32[$2_1 + 32 >> 2] = $12_1;
   HEAP32[$2_1 + 36 >> 2] = $15_1;
   HEAP32[$2_1 + 24 >> 2] = $16_1;
   HEAP32[$2_1 + 28 >> 2] = $23_1;
   HEAP32[$2_1 + 16 >> 2] = $5_1;
   HEAP32[$2_1 + 20 >> 2] = $20_1;
   HEAP32[$2_1 + 8 >> 2] = $17_1;
   HEAP32[$2_1 + 12 >> 2] = $18_1;
   label$8 : {
    if (($21_1 | 0) == 1048574 & $6_1 >>> 0 < 4294966319 | $21_1 >>> 0 < 1048574) {
     break label$8
    }
    if (($10_1 & $11_1 & $4_1) != -1 | ($25_1 & $19_1 & $14_1) != 1048575) {
     break label$8
    }
    if (($9_1 | 0) != -1 | ($13_1 | 0) != 65535) {
     break label$8
    }
    $3_1 = $21_1 + 1 | 0;
    $6_1 = $6_1 + 977 | 0;
    $3_1 = $6_1 >>> 0 < 977 ? $3_1 + 1 | 0 : $3_1;
    $21_1 = $3_1 & 1048575;
    $0_1 = $25_1;
    $3_1 = $3_1 >>> 20 | 0;
    $10_1 = $3_1 + $10_1 | 0;
    $0_1 = $3_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $25_1 = $0_1 & 1048575;
    $5_1 = $0_1 >>> 20 | 0;
    $3_1 = $19_1;
    $11_1 = $5_1 + $11_1 | 0;
    $3_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $19_1 = $3_1 & 1048575;
    $5_1 = $3_1 >>> 20 | 0;
    $3_1 = $14_1;
    $4_1 = $4_1 + $5_1 | 0;
    $3_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = $3_1 & 1048575;
    $0_1 = $13_1;
    $13_1 = $9_1;
    $9_1 = ($3_1 >>> 20 | 0) + $9_1 | 0;
    $13_1 = ($13_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) & 65535;
   }
   HEAP32[$2_1 + 80 >> 2] = $9_1;
   HEAP32[$8_1 + 84 >> 2] = $13_1;
   HEAP32[$8_1 + 72 >> 2] = $4_1;
   HEAP32[$8_1 + 76 >> 2] = $14_1;
   HEAP32[$8_1 + 64 >> 2] = $11_1;
   HEAP32[$8_1 + 68 >> 2] = $19_1;
   HEAP32[$8_1 + 56 >> 2] = $10_1;
   HEAP32[$8_1 + 60 >> 2] = $25_1;
   HEAP32[$8_1 + 48 >> 2] = $6_1;
   HEAP32[$8_1 + 52 >> 2] = $21_1;
   $37($22_1 + 1 | 0, $8_1 + 8 | 0);
   label$9 : {
    if ($26_1) {
     HEAP8[$22_1 | 0] = $6_1 & 1 ? 3 : 2;
     $0_1 = 33;
     break label$9;
    }
    HEAP8[$22_1 | 0] = 4;
    $37($22_1 + 33 | 0, $8_1 + 48 | 0);
    $0_1 = 65;
   }
   HEAP32[$1_1 >> 2] = $0_1;
   $14_1 = 1;
  }
  global$0 = $8_1 + 96 | 0;
  return $14_1;
 }
 
 function $37($0_1, $1_1) {
  HEAP8[$0_1 | 0] = HEAP32[$1_1 + 36 >> 2] >>> 8;
  HEAP8[$0_1 + 1 | 0] = HEAP32[$1_1 + 36 >> 2];
  HEAP8[$0_1 + 2 | 0] = (HEAP32[$1_1 + 36 >> 2] & 16777215) << 8 | HEAP32[$1_1 + 32 >> 2] >>> 24;
  HEAP8[$0_1 + 3 | 0] = (HEAP32[$1_1 + 36 >> 2] & 65535) << 16 | HEAP32[$1_1 + 32 >> 2] >>> 16;
  HEAP8[$0_1 + 4 | 0] = (HEAP32[$1_1 + 36 >> 2] & 255) << 24 | HEAP32[$1_1 + 32 >> 2] >>> 8;
  HEAP8[$0_1 + 5 | 0] = HEAP32[$1_1 + 32 >> 2];
  HEAP8[$0_1 + 6 | 0] = HEAP32[$1_1 + 28 >> 2] >>> 12;
  HEAP8[$0_1 + 7 | 0] = HEAP32[$1_1 + 28 >> 2] >>> 4;
  HEAP8[$0_1 + 8 | 0] = (HEAP32[$1_1 + 28 >> 2] & 268435455) << 4 | HEAP32[$1_1 + 24 >> 2] >>> 28;
  HEAP8[$0_1 + 9 | 0] = (HEAP32[$1_1 + 28 >> 2] & 1048575) << 12 | HEAP32[$1_1 + 24 >> 2] >>> 20;
  HEAP8[$0_1 + 10 | 0] = (HEAP32[$1_1 + 28 >> 2] & 4095) << 20 | HEAP32[$1_1 + 24 >> 2] >>> 12;
  HEAP8[$0_1 + 11 | 0] = (HEAP32[$1_1 + 28 >> 2] & 15) << 28 | HEAP32[$1_1 + 24 >> 2] >>> 4;
  HEAP8[$0_1 + 12 | 0] = HEAPU16[$1_1 + 22 >> 1] & 15 | HEAP32[$1_1 + 24 >> 2] << 4;
  HEAP8[$0_1 + 13 | 0] = HEAP32[$1_1 + 20 >> 2] >>> 8;
  HEAP8[$0_1 + 14 | 0] = HEAP32[$1_1 + 20 >> 2];
  HEAP8[$0_1 + 15 | 0] = (HEAP32[$1_1 + 20 >> 2] & 16777215) << 8 | HEAP32[$1_1 + 16 >> 2] >>> 24;
  HEAP8[$0_1 + 16 | 0] = (HEAP32[$1_1 + 20 >> 2] & 65535) << 16 | HEAP32[$1_1 + 16 >> 2] >>> 16;
  HEAP8[$0_1 + 17 | 0] = (HEAP32[$1_1 + 20 >> 2] & 255) << 24 | HEAP32[$1_1 + 16 >> 2] >>> 8;
  HEAP8[$0_1 + 18 | 0] = HEAP32[$1_1 + 16 >> 2];
  HEAP8[$0_1 + 19 | 0] = HEAP32[$1_1 + 12 >> 2] >>> 12;
  HEAP8[$0_1 + 20 | 0] = HEAP32[$1_1 + 12 >> 2] >>> 4;
  HEAP8[$0_1 + 21 | 0] = (HEAP32[$1_1 + 12 >> 2] & 268435455) << 4 | HEAP32[$1_1 + 8 >> 2] >>> 28;
  HEAP8[$0_1 + 22 | 0] = (HEAP32[$1_1 + 12 >> 2] & 1048575) << 12 | HEAP32[$1_1 + 8 >> 2] >>> 20;
  HEAP8[$0_1 + 23 | 0] = (HEAP32[$1_1 + 12 >> 2] & 4095) << 20 | HEAP32[$1_1 + 8 >> 2] >>> 12;
  HEAP8[$0_1 + 24 | 0] = (HEAP32[$1_1 + 12 >> 2] & 15) << 28 | HEAP32[$1_1 + 8 >> 2] >>> 4;
  HEAP8[$0_1 + 25 | 0] = HEAPU16[$1_1 + 6 >> 1] & 15 | HEAP32[$1_1 + 8 >> 2] << 4;
  HEAP8[$0_1 + 26 | 0] = HEAP32[$1_1 + 4 >> 2] >>> 8;
  HEAP8[$0_1 + 27 | 0] = HEAP32[$1_1 + 4 >> 2];
  HEAP8[$0_1 + 28 | 0] = (HEAP32[$1_1 + 4 >> 2] & 16777215) << 8 | HEAP32[$1_1 >> 2] >>> 24;
  HEAP8[$0_1 + 29 | 0] = (HEAP32[$1_1 + 4 >> 2] & 65535) << 16 | HEAP32[$1_1 >> 2] >>> 16;
  HEAP8[$0_1 + 30 | 0] = (HEAP32[$1_1 + 4 >> 2] & 255) << 24 | HEAP32[$1_1 >> 2] >>> 8;
  HEAP8[$0_1 + 31 | 0] = HEAP32[$1_1 >> 2];
 }
 
 function $38($0_1, $1_1, $2_1) {
  var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0;
  $6_1 = $0_1;
  $3_1 = $1_1;
  $1_1 = HEAPU8[$3_1 + 24 | 0] | HEAPU8[$3_1 + 25 | 0] << 8 | (HEAPU8[$3_1 + 26 | 0] << 16 | HEAPU8[$3_1 + 27 | 0] << 24);
  $5_1 = $1_1 << 8 & 16711680;
  $12_1 = $1_1 << 24 | $5_1;
  $4_1 = $1_1 >>> 8 | 0;
  $0_1 = HEAPU8[$3_1 + 28 | 0] | HEAPU8[$3_1 + 29 | 0] << 8 | (HEAPU8[$3_1 + 30 | 0] << 16 | HEAPU8[$3_1 + 31 | 0] << 24);
  $5_1 = ($4_1 | $0_1 << 24) & 65280;
  $1_1 = $1_1 >>> 24 | 0;
  $5_1 = $12_1 | ($5_1 | ($1_1 | $0_1 << 8) & 255);
  $4_1 = ($1_1 | ($0_1 & 16777215) << 8) & 16711680 | ($4_1 | ($0_1 & 255) << 24) & -16777216;
  $8_1 = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $4_1;
  HEAP32[$6_1 >> 2] = $8_1;
  HEAP32[$6_1 + 4 >> 2] = $5_1;
  $1_1 = HEAPU8[$3_1 + 16 | 0] | HEAPU8[$3_1 + 17 | 0] << 8 | (HEAPU8[$3_1 + 18 | 0] << 16 | HEAPU8[$3_1 + 19 | 0] << 24);
  $7_1 = $1_1 << 8 & 16711680 | $1_1 << 24;
  $0_1 = HEAPU8[$3_1 + 20 | 0] | HEAPU8[$3_1 + 21 | 0] << 8 | (HEAPU8[$3_1 + 22 | 0] << 16 | HEAPU8[$3_1 + 23 | 0] << 24);
  $4_1 = ($0_1 << 24 | $1_1 >>> 8) & 65280;
  $12_1 = $7_1 | ($4_1 | ($0_1 << 8 | $1_1 >>> 24) & 255);
  $4_1 = (($0_1 & 255) << 24 | $1_1 >>> 8) & -16777216;
  $7_1 = $4_1 | (($0_1 & 16777215) << 8 | $1_1 >>> 24) & 16711680;
  $15_1 = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $7_1;
  HEAP32[$6_1 + 8 >> 2] = $15_1;
  $9_1 = $12_1;
  HEAP32[$6_1 + 12 >> 2] = $9_1;
  $1_1 = HEAPU8[$3_1 + 8 | 0] | HEAPU8[$3_1 + 9 | 0] << 8 | (HEAPU8[$3_1 + 10 | 0] << 16 | HEAPU8[$3_1 + 11 | 0] << 24);
  $7_1 = $1_1 << 8 & 16711680;
  $13_1 = $1_1 << 24 | $7_1;
  $0_1 = HEAPU8[$3_1 + 12 | 0] | HEAPU8[$3_1 + 13 | 0] << 8 | (HEAPU8[$3_1 + 14 | 0] << 16 | HEAPU8[$3_1 + 15 | 0] << 24);
  $7_1 = ($0_1 << 24 | $1_1 >>> 8) & 65280;
  $7_1 = $13_1 | ($7_1 | ($0_1 << 8 | $1_1 >>> 24) & 255);
  $4_1 = (($0_1 & 255) << 24 | $1_1 >>> 8) & -16777216;
  $4_1 = $4_1 | (($0_1 & 16777215) << 8 | $1_1 >>> 24) & 16711680;
  $14_1 = $0_1 >>> 8 & 65280 | $0_1 >>> 24 | $4_1;
  HEAP32[$6_1 + 16 >> 2] = $14_1;
  $13_1 = $7_1;
  HEAP32[$6_1 + 20 >> 2] = $7_1;
  $0_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
  $1_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
  $7_1 = $1_1 << 8 & 16711680 | $1_1 << 24;
  $12_1 = $7_1 | (($0_1 << 8 | $1_1 >>> 24) & 255 | ($0_1 << 24 | $1_1 >>> 8) & 65280);
  $3_1 = (($0_1 & 255) << 24 | $1_1 >>> 8) & -16777216;
  $10_1 = $3_1 | (($0_1 & 16777215) << 8 | $1_1 >>> 24) & 16711680;
  $7_1 = $0_1 >>> 8 & 65280;
  $1_1 = $0_1 >>> 24 | 0;
  $0_1 = $12_1;
  $3_1 = ($13_1 | 0) == -1;
  $7_1 = $1_1 | $7_1 | $10_1;
  $1_1 = $3_1 & $14_1 >>> 0 < 4294967294 | ($13_1 | 0) != -1 | ($0_1 & $7_1) != -1;
  $4_1 = ($9_1 | 0) == -1162945306;
  $0_1 = ($1_1 | ($4_1 & $15_1 >>> 0 < 2940772411 | $9_1 >>> 0 < 3132021990)) ^ -1;
  $10_1 = $0_1 & (($5_1 | 0) == -1076732276 & $8_1 >>> 0 > 3493216576 | $5_1 >>> 0 > 3218235020) | ($0_1 & ($4_1 & $15_1 >>> 0 > 2940772411 | $9_1 >>> 0 > 3132021990) | ($14_1 | 0) == -1 & $3_1 & ($1_1 ^ -1));
  $11_1 = __wasm_i64_mul($10_1, 0, 801750719, 1076732275);
  $4_1 = i64toi32_i32$HIGH_BITS;
  $3_1 = $4_1 + $5_1 | 0;
  $0_1 = $8_1 + $11_1 | 0;
  $3_1 = $0_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$6_1 >> 2] = $0_1;
  HEAP32[$6_1 + 4 >> 2] = $3_1;
  $1_1 = $6_1;
  $3_1 = ($3_1 | 0) == ($4_1 | 0) & $0_1 >>> 0 < $11_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
  $11_1 = __wasm_i64_mul($10_1, 0, 1354194884, 1162945305);
  $5_1 = i64toi32_i32$HIGH_BITS;
  $8_1 = $5_1 + $9_1 | 0;
  $6_1 = $11_1 + $15_1 | 0;
  $0_1 = $6_1 >>> 0 < $11_1 >>> 0 ? $8_1 + 1 | 0 : $8_1;
  $3_1 = $3_1 + $6_1 | 0;
  $4_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  HEAP32[$1_1 + 8 >> 2] = $3_1;
  HEAP32[$1_1 + 12 >> 2] = $4_1;
  $9_1 = ($0_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 < $11_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
  $0_1 = ($0_1 | 0) == ($4_1 | 0) & $3_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 > $4_1 >>> 0;
  $5_1 = $9_1 + $0_1 | 0;
  $4_1 = $13_1;
  $3_1 = $0_1 >>> 0 > $5_1 >>> 0;
  $6_1 = $10_1 + $14_1 | 0;
  $0_1 = $6_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $8_1 = $3_1 + $0_1 | 0;
  $4_1 = $6_1;
  $5_1 = $4_1 + $5_1 | 0;
  $8_1 = $4_1 >>> 0 > $5_1 >>> 0 ? $8_1 + 1 | 0 : $8_1;
  HEAP32[$1_1 + 16 >> 2] = $5_1;
  HEAP32[$1_1 + 20 >> 2] = $8_1;
  $3_1 = $1_1;
  $6_1 = $7_1;
  $1_1 = !$0_1 & $4_1 >>> 0 < $10_1 >>> 0;
  $0_1 = ($0_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $5_1 >>> 0 | $0_1 >>> 0 > $8_1 >>> 0;
  $5_1 = $1_1 + $0_1 | 0;
  $1_1 = ($0_1 >>> 0 > $5_1 >>> 0) + $12_1 | 0;
  $0_1 = $5_1 + $6_1 | 0;
  $1_1 = $0_1 >>> 0 < $5_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  HEAP32[$3_1 + 24 >> 2] = $0_1;
  HEAP32[$3_1 + 28 >> 2] = $1_1;
  if ($2_1) {
   HEAP32[$2_1 >> 2] = $10_1
  }
 }
 
 function $39($0_1, $1_1) {
  HEAP8[$0_1 | 0] = HEAPU8[$1_1 + 31 | 0];
  HEAP8[$0_1 + 1 | 0] = HEAPU16[$1_1 + 30 >> 1];
  HEAP8[$0_1 + 2 | 0] = HEAP32[$1_1 + 28 >> 2] >>> 8;
  HEAP8[$0_1 + 3 | 0] = HEAP32[$1_1 + 28 >> 2];
  HEAP8[$0_1 + 4 | 0] = (HEAP32[$1_1 + 28 >> 2] & 16777215) << 8 | HEAP32[$1_1 + 24 >> 2] >>> 24;
  HEAP8[$0_1 + 5 | 0] = (HEAP32[$1_1 + 28 >> 2] & 65535) << 16 | HEAP32[$1_1 + 24 >> 2] >>> 16;
  HEAP8[$0_1 + 6 | 0] = (HEAP32[$1_1 + 28 >> 2] & 255) << 24 | HEAP32[$1_1 + 24 >> 2] >>> 8;
  HEAP8[$0_1 + 7 | 0] = HEAP32[$1_1 + 24 >> 2];
  HEAP8[$0_1 + 8 | 0] = HEAPU8[$1_1 + 23 | 0];
  HEAP8[$0_1 + 9 | 0] = HEAPU16[$1_1 + 22 >> 1];
  HEAP8[$0_1 + 10 | 0] = HEAP32[$1_1 + 20 >> 2] >>> 8;
  HEAP8[$0_1 + 11 | 0] = HEAP32[$1_1 + 20 >> 2];
  HEAP8[$0_1 + 12 | 0] = (HEAP32[$1_1 + 20 >> 2] & 16777215) << 8 | HEAP32[$1_1 + 16 >> 2] >>> 24;
  HEAP8[$0_1 + 13 | 0] = (HEAP32[$1_1 + 20 >> 2] & 65535) << 16 | HEAP32[$1_1 + 16 >> 2] >>> 16;
  HEAP8[$0_1 + 14 | 0] = (HEAP32[$1_1 + 20 >> 2] & 255) << 24 | HEAP32[$1_1 + 16 >> 2] >>> 8;
  HEAP8[$0_1 + 15 | 0] = HEAP32[$1_1 + 16 >> 2];
  HEAP8[$0_1 + 16 | 0] = HEAPU8[$1_1 + 15 | 0];
  HEAP8[$0_1 + 17 | 0] = HEAPU16[$1_1 + 14 >> 1];
  HEAP8[$0_1 + 18 | 0] = HEAP32[$1_1 + 12 >> 2] >>> 8;
  HEAP8[$0_1 + 19 | 0] = HEAP32[$1_1 + 12 >> 2];
  HEAP8[$0_1 + 20 | 0] = (HEAP32[$1_1 + 12 >> 2] & 16777215) << 8 | HEAP32[$1_1 + 8 >> 2] >>> 24;
  HEAP8[$0_1 + 21 | 0] = (HEAP32[$1_1 + 12 >> 2] & 65535) << 16 | HEAP32[$1_1 + 8 >> 2] >>> 16;
  HEAP8[$0_1 + 22 | 0] = (HEAP32[$1_1 + 12 >> 2] & 255) << 24 | HEAP32[$1_1 + 8 >> 2] >>> 8;
  HEAP8[$0_1 + 23 | 0] = HEAP32[$1_1 + 8 >> 2];
  HEAP8[$0_1 + 24 | 0] = HEAPU8[$1_1 + 7 | 0];
  HEAP8[$0_1 + 25 | 0] = HEAPU16[$1_1 + 6 >> 1];
  HEAP8[$0_1 + 26 | 0] = HEAP32[$1_1 + 4 >> 2] >>> 8;
  HEAP8[$0_1 + 27 | 0] = HEAP32[$1_1 + 4 >> 2];
  HEAP8[$0_1 + 28 | 0] = (HEAP32[$1_1 + 4 >> 2] & 16777215) << 8 | HEAP32[$1_1 >> 2] >>> 24;
  HEAP8[$0_1 + 29 | 0] = (HEAP32[$1_1 + 4 >> 2] & 65535) << 16 | HEAP32[$1_1 >> 2] >>> 16;
  HEAP8[$0_1 + 30 | 0] = (HEAP32[$1_1 + 4 >> 2] & 255) << 24 | HEAP32[$1_1 >> 2] >>> 8;
  HEAP8[$0_1 + 31 | 0] = HEAP32[$1_1 >> 2];
 }
 
 function $40($0_1, $1_1) {
  var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0;
  $6_1 = global$0 - 320 | 0;
  global$0 = $6_1;
  $2_1 = $6_1 + 280 | 0;
  $3_1 = $2_1 + 32 | 0;
  HEAP32[$3_1 >> 2] = 0;
  HEAP32[$3_1 + 4 >> 2] = 0;
  $3_1 = $2_1 + 24 | 0;
  HEAP32[$3_1 >> 2] = 0;
  HEAP32[$3_1 + 4 >> 2] = 0;
  $3_1 = $2_1 + 16 | 0;
  HEAP32[$3_1 >> 2] = 0;
  HEAP32[$3_1 + 4 >> 2] = 0;
  $2_1 = $2_1 + 8 | 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  HEAP32[$6_1 + 280 >> 2] = 0;
  HEAP32[$6_1 + 284 >> 2] = 0;
  $2_1 = $6_1 + 240 | 0;
  $3_1 = $2_1 + 32 | 0;
  HEAP32[$3_1 >> 2] = 0;
  HEAP32[$3_1 + 4 >> 2] = 0;
  $3_1 = $2_1 + 24 | 0;
  HEAP32[$3_1 >> 2] = 0;
  HEAP32[$3_1 + 4 >> 2] = 0;
  $2_1 = $2_1 + 16 | 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  HEAP32[$6_1 + 248 >> 2] = 0;
  HEAP32[$6_1 + 252 >> 2] = 0;
  HEAP32[$6_1 + 240 >> 2] = 1;
  HEAP32[$6_1 + 244 >> 2] = 0;
  $3_1 = $1_1 + 32 | 0;
  $4_1 = HEAP32[$3_1 + 4 >> 2];
  $2_1 = $6_1 + 200 | 0;
  $5_1 = $2_1 + 32 | 0;
  HEAP32[$5_1 >> 2] = HEAP32[$3_1 >> 2];
  HEAP32[$5_1 + 4 >> 2] = $4_1;
  $3_1 = $1_1 + 24 | 0;
  $4_1 = HEAP32[$3_1 + 4 >> 2];
  $5_1 = $2_1 + 24 | 0;
  HEAP32[$5_1 >> 2] = HEAP32[$3_1 >> 2];
  HEAP32[$5_1 + 4 >> 2] = $4_1;
  $3_1 = $1_1 + 16 | 0;
  $4_1 = HEAP32[$3_1 + 4 >> 2];
  $5_1 = $2_1 + 16 | 0;
  HEAP32[$5_1 >> 2] = HEAP32[$3_1 >> 2];
  HEAP32[$5_1 + 4 >> 2] = $4_1;
  $3_1 = $1_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 + 4 >> 2];
  $2_1 = $2_1 + 8 | 0;
  HEAP32[$2_1 >> 2] = HEAP32[$3_1 >> 2];
  HEAP32[$2_1 + 4 >> 2] = $4_1;
  $2_1 = HEAP32[$1_1 + 4 >> 2];
  HEAP32[$6_1 + 200 >> 2] = HEAP32[$1_1 >> 2];
  HEAP32[$6_1 + 204 >> 2] = $2_1;
  $3_1 = $0_1 + 32 | 0;
  $4_1 = HEAP32[$3_1 + 4 >> 2];
  $2_1 = $6_1 + 160 | 0;
  $30_1 = $2_1 + 32 | 0;
  HEAP32[$30_1 >> 2] = HEAP32[$3_1 >> 2];
  HEAP32[$30_1 + 4 >> 2] = $4_1;
  $3_1 = $0_1 + 24 | 0;
  $4_1 = HEAP32[$3_1 + 4 >> 2];
  $5_1 = $2_1 + 24 | 0;
  HEAP32[$5_1 >> 2] = HEAP32[$3_1 >> 2];
  HEAP32[$5_1 + 4 >> 2] = $4_1;
  $3_1 = $0_1 + 16 | 0;
  $4_1 = HEAP32[$3_1 + 4 >> 2];
  $5_1 = $2_1 + 16 | 0;
  HEAP32[$5_1 >> 2] = HEAP32[$3_1 >> 2];
  HEAP32[$5_1 + 4 >> 2] = $4_1;
  $3_1 = $0_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 + 4 >> 2];
  $2_1 = $2_1 + 8 | 0;
  HEAP32[$2_1 >> 2] = HEAP32[$3_1 >> 2];
  HEAP32[$2_1 + 4 >> 2] = $4_1;
  $2_1 = HEAP32[$0_1 + 4 >> 2];
  HEAP32[$6_1 + 160 >> 2] = HEAP32[$0_1 >> 2];
  HEAP32[$6_1 + 164 >> 2] = $2_1;
  $24_1 = 5;
  $22_1 = -1;
  $25_1 = -1;
  while (1) {
   $2_1 = $22_1;
   $20_1 = HEAP32[$6_1 + 160 >> 2];
   $16_1 = HEAP32[$6_1 + 164 >> 2];
   $3_1 = __wasm_ctz_i64($20_1, $16_1 | -1073741824);
   $22_1 = $2_1 - $3_1 | 0;
   $25_1 = $25_1 - (i64toi32_i32$HIGH_BITS + ($2_1 >>> 0 < $3_1 >>> 0) | 0) | 0;
   $2_1 = $3_1 & 31;
   if (($3_1 & 63) >>> 0 >= 32) {
    $8_1 = 0;
    $14_1 = 1 << $2_1;
   } else {
    $8_1 = 1 << $2_1;
    $14_1 = $8_1 - 1 & 1 >>> 32 - $2_1;
   }
   $28_1 = HEAP32[$6_1 + 200 >> 2];
   $26_1 = HEAP32[$6_1 + 204 >> 2];
   $5_1 = $3_1;
   label$2 : {
    if (($3_1 | 0) == 62) {
     $7_1 = 0;
     $5_1 = 0;
     $13_1 = 1;
     $11_1 = 0;
     $21_1 = 0;
     $18_1 = 0;
     break label$2;
    }
    $3_1 = $5_1 & 31;
    if (($5_1 & 63) >>> 0 >= 32) {
     $4_1 = $16_1 >>> $3_1 | 0;
     $3_1 = 0;
    } else {
     $4_1 = ((1 << $3_1) - 1 & $16_1) << 32 - $3_1 | $20_1 >>> $3_1;
     $3_1 = $16_1 >>> $3_1 | 0;
    }
    $12_1 = 62 - $5_1 | 0;
    $13_1 = 1;
    $11_1 = 0;
    $21_1 = 0;
    $18_1 = 0;
    $10_1 = $28_1;
    $9_1 = $26_1;
    $7_1 = 0;
    $5_1 = 0;
    while (1) {
     label$5 : {
      if (($25_1 | 0) < 0) {
       $2_1 = __wasm_i64_mul($4_1, $3_1, $4_1, $3_1);
       $17_1 = $2_1 - 2 | 0;
       $23_1 = i64toi32_i32$HIGH_BITS - ($2_1 >>> 0 < 2) | 0;
       $19_1 = 0 - $10_1 | 0;
       $2_1 = 0 - ((($10_1 | 0) != 0) + $9_1 | 0) | 0;
       $10_1 = __wasm_i64_mul($17_1, $23_1, __wasm_i64_mul($19_1, $2_1, $4_1, $3_1), i64toi32_i32$HIGH_BITS);
       $25_1 = 0 - ((($22_1 | 0) != 0) + $25_1 | 0) | 0;
       $22_1 = 0 - $22_1 | 0;
       $9_1 = $22_1 + 1 | 0;
       $15_1 = 64 - (($9_1 | 0) > ($12_1 | 0) ? $12_1 : $9_1) | 0;
       $9_1 = $15_1 & 31;
       if (($15_1 & 63) >>> 0 >= 32) {
        $9_1 = -1 >>> $9_1 | 0
       } else {
        $9_1 = (1 << $9_1) - 1 << 32 - $9_1 | -1 >>> $9_1
       }
       $31_1 = $9_1 & $10_1 & 63;
       $15_1 = 0 - $21_1 | 0;
       $17_1 = 0 - ((($21_1 | 0) != 0) + $18_1 | 0) | 0;
       $23_1 = 0 - $8_1 | 0;
       $33_1 = 0 - ((($8_1 | 0) != 0) + $14_1 | 0) | 0;
       $10_1 = $4_1;
       $9_1 = $3_1;
       break label$5;
      }
      $15_1 = ($10_1 << 1) + 2 | 0;
      $2_1 = $9_1;
      $17_1 = $15_1 & 8;
      $15_1 = $17_1 + $10_1 | 0;
      $15_1 = 0 - __wasm_i64_mul($15_1, $15_1 >>> 0 < $17_1 >>> 0 ? $2_1 + 1 | 0 : $2_1, $4_1, $3_1) | 0;
      $2_1 = $22_1 + 1 | 0;
      $17_1 = 64 - (($2_1 | 0) > ($12_1 | 0) ? $12_1 : $2_1) | 0;
      $2_1 = $17_1 & 31;
      if (($17_1 & 63) >>> 0 >= 32) {
       $2_1 = -1 >>> $2_1 | 0
      } else {
       $2_1 = (1 << $2_1) - 1 << 32 - $2_1 | -1 >>> $2_1
      }
      $31_1 = $2_1 & $15_1 & 15;
      $23_1 = $7_1;
      $33_1 = $5_1;
      $15_1 = $13_1;
      $17_1 = $11_1;
      $19_1 = $4_1;
      $2_1 = $3_1;
      $7_1 = $8_1;
      $5_1 = $14_1;
      $13_1 = $21_1;
      $11_1 = $18_1;
     }
     $8_1 = $22_1;
     $3_1 = __wasm_i64_mul($10_1, $9_1, $31_1, 0) + $19_1 | 0;
     $2_1 = i64toi32_i32$HIGH_BITS + $2_1 | 0;
     $4_1 = $3_1 >>> 0 < $19_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
     $2_1 = $12_1 & 31;
     if (($12_1 & 63) >>> 0 >= 32) {
      $14_1 = 0;
      $2_1 = -1 << $2_1;
     } else {
      $14_1 = -1 << $2_1;
      $2_1 = $14_1 | (1 << $2_1) - 1 & -1 >>> 32 - $2_1;
     }
     $19_1 = __wasm_ctz_i64($3_1 | $14_1, $2_1 | $4_1);
     $22_1 = $8_1 - $19_1 | 0;
     $25_1 = $25_1 - (i64toi32_i32$HIGH_BITS + ($8_1 >>> 0 < $19_1 >>> 0) | 0) | 0;
     $8_1 = $19_1 & 31;
     if (($19_1 & 63) >>> 0 >= 32) {
      $21_1 = 0;
      $18_1 = $13_1 << $8_1;
     } else {
      $21_1 = $13_1 << $8_1;
      $18_1 = (1 << $8_1) - 1 & $13_1 >>> 32 - $8_1 | $11_1 << $8_1;
     }
     $8_1 = $19_1 & 31;
     if (($19_1 & 63) >>> 0 >= 32) {
      $2_1 = $7_1 << $8_1;
      $8_1 = 0;
     } else {
      $2_1 = (1 << $8_1) - 1 & $7_1 >>> 32 - $8_1 | $5_1 << $8_1;
      $8_1 = $7_1 << $8_1;
     }
     $14_1 = $2_1;
     $29_1 = $19_1 & 31;
     if (($19_1 & 63) >>> 0 >= 32) {
      $2_1 = 0;
      $4_1 = $4_1 >>> $29_1 | 0;
     } else {
      $2_1 = $4_1 >>> $29_1 | 0;
      $4_1 = ((1 << $29_1) - 1 & $4_1) << 32 - $29_1 | $3_1 >>> $29_1;
     }
     $3_1 = $2_1;
     $13_1 = __wasm_i64_mul($13_1, $11_1, $31_1, 0) + $15_1 | 0;
     $2_1 = i64toi32_i32$HIGH_BITS + $17_1 | 0;
     $11_1 = $13_1 >>> 0 < $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
     $7_1 = __wasm_i64_mul($7_1, $5_1, $31_1, 0) + $23_1 | 0;
     $2_1 = i64toi32_i32$HIGH_BITS + $33_1 | 0;
     $5_1 = $7_1 >>> 0 < $23_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
     $12_1 = $12_1 - $19_1 | 0;
     if ($12_1) {
      continue
     }
     break;
    };
   }
   HEAP32[$6_1 + 152 >> 2] = $13_1;
   HEAP32[$6_1 + 156 >> 2] = $11_1;
   HEAP32[$6_1 + 144 >> 2] = $7_1;
   HEAP32[$6_1 + 148 >> 2] = $5_1;
   HEAP32[$6_1 + 136 >> 2] = $21_1;
   HEAP32[$6_1 + 140 >> 2] = $18_1;
   HEAP32[$6_1 + 128 >> 2] = $8_1;
   HEAP32[$6_1 + 132 >> 2] = $14_1;
   $67($6_1 + 280 | 0, $6_1 + 240 | 0, $6_1 + 128 | 0, $1_1);
   $23_1 = $14_1;
   $2_1 = $14_1 >> 31;
   $14_1 = $2_1;
   $10_1 = $2_1;
   $2_1 = $26_1 >> 31;
   $9_1 = $6_1 + 112 | 0;
   $19_1 = $8_1;
   $3_1 = $2_1;
   $69($9_1, $8_1, $23_1, $10_1, $10_1, $28_1, $26_1, $2_1, $2_1);
   $33_1 = $21_1;
   $2_1 = $18_1 >> 31;
   $21_1 = $2_1;
   $8_1 = $2_1;
   $2_1 = $16_1 >> 31;
   $10_1 = $6_1 + 80 | 0;
   $29_1 = $18_1;
   $4_1 = $2_1;
   $69($10_1, $33_1, $18_1, $8_1, $8_1, $20_1, $16_1, $2_1, $2_1);
   $2_1 = $5_1 >> 31;
   $8_1 = $6_1 + 96 | 0;
   $31_1 = $7_1;
   $42_1 = $5_1;
   $36_1 = $2_1;
   $69($8_1, $7_1, $5_1, $2_1, $2_1, $28_1, $26_1, $3_1, $3_1);
   $2_1 = $11_1 >> 31;
   $12_1 = $6_1 - -64 | 0;
   $28_1 = $13_1;
   $26_1 = $11_1;
   $37_1 = $2_1;
   $69($12_1, $13_1, $11_1, $2_1, $2_1, $20_1, $16_1, $4_1, $4_1);
   $7_1 = HEAP32[$6_1 + 80 >> 2];
   $4_1 = HEAP32[$6_1 + 112 >> 2];
   $3_1 = $7_1 + $4_1 | 0;
   $5_1 = HEAP32[$6_1 + 84 >> 2];
   $2_1 = $5_1 + HEAP32[$6_1 + 116 >> 2] | 0;
   $2_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
   $4_1 = $3_1;
   $3_1 = $2_1;
   $5_1 = ($5_1 | 0) == ($2_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $5_1 >>> 0;
   $2_1 = $9_1 + 8 | 0;
   $7_1 = HEAP32[$2_1 >> 2];
   $9_1 = $10_1 + 8 | 0;
   $4_1 = $7_1 + HEAP32[$9_1 >> 2] | 0;
   $2_1 = HEAP32[$9_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
   $2_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
   $7_1 = $4_1;
   $4_1 = $4_1 + $5_1 | 0;
   $5_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
   $7_1 = $5_1 << 2 | $4_1 >>> 30;
   $4_1 = $4_1 << 2 | $3_1 >>> 30;
   $3_1 = $7_1;
   $11_1 = HEAP32[$6_1 + 64 >> 2];
   $9_1 = HEAP32[$6_1 + 96 >> 2];
   $7_1 = $11_1 + $9_1 | 0;
   $10_1 = HEAP32[$6_1 + 68 >> 2];
   $2_1 = $10_1 + HEAP32[$6_1 + 100 >> 2] | 0;
   $2_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
   $9_1 = $7_1;
   $7_1 = $2_1;
   $10_1 = ($10_1 | 0) == ($2_1 | 0) & $9_1 >>> 0 < $11_1 >>> 0 | $2_1 >>> 0 < $10_1 >>> 0;
   $2_1 = $8_1 + 8 | 0;
   $11_1 = HEAP32[$2_1 >> 2];
   $8_1 = $12_1 + 8 | 0;
   $9_1 = $11_1 + HEAP32[$8_1 >> 2] | 0;
   $2_1 = HEAP32[$8_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
   $2_1 = $9_1 >>> 0 < $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
   $8_1 = $9_1;
   $9_1 = $10_1 + $9_1 | 0;
   $11_1 = $8_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
   $8_1 = $11_1 << 2 | $9_1 >>> 30;
   $10_1 = $9_1 << 2 | $7_1 >>> 30;
   $9_1 = $8_1;
   $38_1 = ($24_1 | 0) < 2;
   if (!$38_1) {
    $2_1 = $5_1 >> 31;
    $5_1 = $5_1 >> 30;
    $8_1 = $2_1;
    $15_1 = $11_1 >> 30;
    $17_1 = $11_1 >> 31;
    $27_1 = $24_1 - 1 | 0;
    $12_1 = $6_1 + 160 | 0;
    $11_1 = $6_1 + 200 | 0;
    while (1) {
     $13_1 = $11_1 + 8 | 0;
     $16_1 = HEAP32[$13_1 >> 2];
     $2_1 = HEAP32[$13_1 + 4 >> 2];
     $20_1 = $2_1;
     $2_1 = $2_1 >> 31;
     $7_1 = $2_1;
     $69($6_1, $16_1, $20_1, $2_1, $2_1, $19_1, $23_1, $14_1, $14_1);
     $39_1 = $6_1 + 32 | 0;
     $18_1 = $12_1 + 8 | 0;
     $34_1 = HEAP32[$18_1 >> 2];
     $2_1 = HEAP32[$18_1 + 4 >> 2];
     $32_1 = $2_1;
     $2_1 = $2_1 >> 31;
     $69($39_1, $34_1, $32_1, $2_1, $2_1, $33_1, $29_1, $21_1, $21_1);
     $40_1 = $6_1 + 16 | 0;
     $69($40_1, $16_1, $20_1, $7_1, $7_1, $31_1, $42_1, $36_1, $36_1);
     $41_1 = $6_1 + 48 | 0;
     $69($41_1, $34_1, $32_1, $2_1, $2_1, $28_1, $26_1, $37_1, $37_1);
     $7_1 = HEAP32[$6_1 >> 2];
     $43_1 = $7_1;
     $32_1 = HEAP32[$6_1 + 4 >> 2];
     $2_1 = $32_1 + $3_1 | 0;
     $16_1 = $4_1 + $7_1 | 0;
     $4_1 = $16_1 >>> 0 < $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
     $2_1 = $4_1 + HEAP32[$6_1 + 36 >> 2] | 0;
     $3_1 = HEAP32[$6_1 + 32 >> 2];
     $7_1 = $3_1 + $16_1 | 0;
     $20_1 = $7_1;
     HEAP32[$11_1 >> 2] = $7_1;
     $3_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
     HEAP32[$11_1 + 4 >> 2] = $3_1 & 1073741823;
     $7_1 = HEAP32[$6_1 + 16 >> 2];
     $44_1 = $7_1;
     $35_1 = HEAP32[$6_1 + 20 >> 2];
     $2_1 = $35_1 + $9_1 | 0;
     $11_1 = $7_1 + $10_1 | 0;
     $10_1 = $11_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
     $2_1 = $10_1 + HEAP32[$6_1 + 52 >> 2] | 0;
     $7_1 = HEAP32[$6_1 + 48 >> 2];
     $9_1 = $7_1 + $11_1 | 0;
     $34_1 = $9_1;
     HEAP32[$12_1 >> 2] = $9_1;
     $7_1 = $7_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
     HEAP32[$12_1 + 4 >> 2] = $7_1 & 1073741823;
     $9_1 = ($3_1 | 0) == ($4_1 | 0) & $16_1 >>> 0 > $20_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
     $2_1 = $39_1 + 8 | 0;
     $12_1 = HEAP32[$2_1 >> 2];
     $20_1 = HEAP32[$2_1 + 4 >> 2];
     $16_1 = ($4_1 | 0) == ($32_1 | 0) & $16_1 >>> 0 < $43_1 >>> 0 | $4_1 >>> 0 < $32_1 >>> 0;
     $2_1 = $6_1 + 8 | 0;
     $4_1 = HEAP32[$2_1 >> 2] + $5_1 | 0;
     $2_1 = HEAP32[$2_1 + 4 >> 2] + $8_1 | 0;
     $2_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
     $8_1 = $4_1;
     $4_1 = $4_1 + $16_1 | 0;
     $2_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $20_1 | 0;
     $8_1 = $4_1;
     $4_1 = $4_1 + $12_1 | 0;
     $2_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
     $8_1 = $4_1;
     $4_1 = $4_1 + $9_1 | 0;
     $9_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
     $2_1 = $9_1 >> 31;
     $5_1 = $9_1 >> 30;
     $8_1 = $2_1;
     $12_1 = ($7_1 | 0) == ($10_1 | 0) & $11_1 >>> 0 > $34_1 >>> 0 | $7_1 >>> 0 < $10_1 >>> 0;
     $2_1 = $41_1 + 8 | 0;
     $16_1 = HEAP32[$2_1 >> 2];
     $20_1 = HEAP32[$2_1 + 4 >> 2];
     $11_1 = ($10_1 | 0) == ($35_1 | 0) & $11_1 >>> 0 < $44_1 >>> 0 | $10_1 >>> 0 < $35_1 >>> 0;
     $2_1 = $40_1 + 8 | 0;
     $10_1 = HEAP32[$2_1 >> 2] + $15_1 | 0;
     $2_1 = HEAP32[$2_1 + 4 >> 2] + $17_1 | 0;
     $2_1 = $10_1 >>> 0 < $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
     $17_1 = $10_1;
     $10_1 = $10_1 + $11_1 | 0;
     $2_1 = ($17_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $20_1 | 0;
     $11_1 = $10_1;
     $10_1 = $10_1 + $16_1 | 0;
     $2_1 = $11_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
     $11_1 = $10_1;
     $10_1 = $10_1 + $12_1 | 0;
     $11_1 = $11_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
     $2_1 = $11_1 >> 31;
     $15_1 = $11_1 >> 30;
     $17_1 = $2_1;
     $9_1 = $9_1 << 2 | $4_1 >>> 30;
     $4_1 = $4_1 << 2 | $3_1 >>> 30;
     $3_1 = $9_1;
     $11_1 = $11_1 << 2 | $10_1 >>> 30;
     $10_1 = $10_1 << 2 | $7_1 >>> 30;
     $9_1 = $11_1;
     $11_1 = $13_1;
     $12_1 = $18_1;
     $27_1 = $27_1 - 1 | 0;
     if ($27_1) {
      continue
     }
     break;
    };
   }
   $8_1 = $24_1 - 1 | 0;
   $2_1 = $8_1 << 3;
   $5_1 = $2_1 + ($6_1 + 160 | 0) | 0;
   HEAP32[$5_1 >> 2] = $10_1;
   HEAP32[$5_1 + 4 >> 2] = $9_1;
   $2_1 = ($6_1 + 200 | 0) + $2_1 | 0;
   HEAP32[$2_1 >> 2] = $4_1;
   HEAP32[$2_1 + 4 >> 2] = $3_1;
   label$9 : {
    if (!(HEAP32[$6_1 + 164 >> 2] | HEAP32[$6_1 + 160 >> 2])) {
     if ($38_1) {
      break label$9
     }
     $11_1 = $8_1 & 3;
     label$11 : {
      if ($24_1 - 2 >>> 0 < 3) {
       $7_1 = 0;
       $5_1 = 0;
       $2_1 = 1;
       break label$11;
      }
      $2_1 = $8_1 & -4;
      $27_1 = 0;
      $7_1 = 0;
      $5_1 = 0;
      $12_1 = $30_1;
      while (1) {
       $14_1 = $12_1 - 8 | 0;
       $13_1 = $12_1 - 16 | 0;
       $21_1 = $12_1 - 24 | 0;
       $7_1 = HEAP32[$12_1 >> 2] | (HEAP32[$14_1 >> 2] | (HEAP32[$13_1 >> 2] | (HEAP32[$21_1 >> 2] | $7_1)));
       $5_1 = HEAP32[$12_1 + 4 >> 2] | (HEAP32[$14_1 + 4 >> 2] | (HEAP32[$13_1 + 4 >> 2] | (HEAP32[$21_1 + 4 >> 2] | $5_1)));
       $12_1 = $12_1 + 32 | 0;
       $27_1 = $27_1 + 4 | 0;
       if (($2_1 | 0) != ($27_1 | 0)) {
        continue
       }
       break;
      };
      $2_1 = $27_1 + 1 | 0;
     }
     if ($11_1) {
      $12_1 = ($6_1 + 160 | 0) + ($2_1 << 3) | 0;
      while (1) {
       $7_1 = HEAP32[$12_1 >> 2] | $7_1;
       $5_1 = HEAP32[$12_1 + 4 >> 2] | $5_1;
       $12_1 = $12_1 + 8 | 0;
       $11_1 = $11_1 - 1 | 0;
       if ($11_1) {
        continue
       }
       break;
      };
     }
     if (!($5_1 | $7_1)) {
      break label$9
     }
    }
    $2_1 = $9_1 >> 31;
    $5_1 = $2_1 ^ $10_1;
    $7_1 = $2_1 ^ $9_1;
    $2_1 = ($24_1 >> 31) - ($24_1 >>> 0 < 2) >> 31;
    $5_1 = $2_1 | $5_1;
    $7_1 = $2_1 | $7_1;
    $2_1 = $3_1 >> 31;
    if ($5_1 | $2_1 ^ $4_1 | ($7_1 | $2_1 ^ $3_1)) {
     continue
    }
    $7_1 = ($24_1 << 3) - 16 | 0;
    $2_1 = $7_1 + ($6_1 + 200 | 0) | 0;
    $14_1 = HEAP32[$2_1 + 4 >> 2];
    HEAP32[$2_1 >> 2] = HEAP32[$2_1 >> 2];
    HEAP32[$2_1 + 4 >> 2] = $4_1 << 30 | $14_1;
    $2_1 = ($6_1 + 160 | 0) + $7_1 | 0;
    $5_1 = HEAP32[$2_1 + 4 >> 2];
    HEAP32[$2_1 >> 2] = HEAP32[$2_1 >> 2];
    HEAP32[$2_1 + 4 >> 2] = $10_1 << 30 | $5_1;
    $24_1 = $8_1;
    continue;
   }
   break;
  };
  $2_1 = $3_1 >> 31;
  $3_1 = $2_1;
  $11_1 = $6_1 + 280 | 0;
  $2_1 = $11_1 + 32 | 0;
  $8_1 = HEAP32[$2_1 >> 2];
  $2_1 = HEAP32[$2_1 + 4 >> 2];
  $14_1 = $2_1;
  $2_1 = $2_1 >> 31;
  $4_1 = $2_1;
  $9_1 = HEAP32[$1_1 >> 2];
  $13_1 = $2_1 & $9_1;
  $5_1 = $13_1 + HEAP32[$6_1 + 280 >> 2] | 0;
  $10_1 = HEAP32[$1_1 + 4 >> 2];
  $2_1 = HEAP32[$6_1 + 284 >> 2] + ($10_1 & $2_1) | 0;
  $2_1 = $5_1 >>> 0 < $13_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $5_1 = $3_1 ^ $5_1;
  $25_1 = $5_1 - $3_1 | 0;
  $5_1 = ($2_1 ^ $3_1) - (($3_1 >>> 0 > $5_1 >>> 0) + $3_1 | 0) | 0;
  $7_1 = $0_1;
  $12_1 = $9_1;
  $21_1 = $10_1;
  $0_1 = HEAP32[$1_1 + 32 >> 2];
  $16_1 = $0_1;
  $9_1 = $0_1 & $4_1;
  $0_1 = $9_1 + $8_1 | 0;
  $20_1 = HEAP32[$1_1 + 36 >> 2];
  $2_1 = $14_1 + ($20_1 & $4_1) | 0;
  $2_1 = $0_1 >>> 0 < $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = $0_1 ^ $3_1;
  $13_1 = $0_1 - $3_1 | 0;
  $22_1 = ($2_1 ^ $3_1) - (($0_1 >>> 0 < $3_1 >>> 0) + $3_1 | 0) | 0;
  $0_1 = HEAP32[$1_1 + 24 >> 2];
  $28_1 = $0_1;
  $10_1 = $0_1 & $4_1;
  $9_1 = $11_1 + 24 | 0;
  $0_1 = $10_1 + HEAP32[$9_1 >> 2] | 0;
  $26_1 = HEAP32[$1_1 + 28 >> 2];
  $2_1 = HEAP32[$9_1 + 4 >> 2] + ($26_1 & $4_1) | 0;
  $2_1 = $0_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = $0_1 ^ $3_1;
  $14_1 = $0_1 - $3_1 | 0;
  $17_1 = ($2_1 ^ $3_1) - (($0_1 >>> 0 < $3_1 >>> 0) + $3_1 | 0) | 0;
  $0_1 = HEAP32[$1_1 + 16 >> 2];
  $24_1 = $0_1;
  $8_1 = $0_1 & $4_1;
  $10_1 = $11_1 + 16 | 0;
  $0_1 = $8_1 + HEAP32[$10_1 >> 2] | 0;
  $19_1 = HEAP32[$1_1 + 20 >> 2];
  $2_1 = HEAP32[$10_1 + 4 >> 2] + ($19_1 & $4_1) | 0;
  $2_1 = $0_1 >>> 0 < $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = $0_1 ^ $3_1;
  $8_1 = $0_1 - $3_1 | 0;
  $15_1 = ($2_1 ^ $3_1) - (($0_1 >>> 0 < $3_1 >>> 0) + $3_1 | 0) | 0;
  $23_1 = HEAP32[$1_1 + 8 >> 2];
  $18_1 = $23_1 & $4_1;
  $11_1 = $11_1 + 8 | 0;
  $0_1 = $18_1 + HEAP32[$11_1 >> 2] | 0;
  $30_1 = HEAP32[$1_1 + 12 >> 2];
  $2_1 = HEAP32[$11_1 + 4 >> 2] + ($30_1 & $4_1) | 0;
  $2_1 = $0_1 >>> 0 < $18_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = $0_1 ^ $3_1;
  $1_1 = $0_1 - $3_1 | 0;
  $2_1 = (($2_1 ^ $3_1) - (($0_1 >>> 0 < $3_1 >>> 0) + $3_1 | 0) | 0) + ($5_1 >> 31) | 0;
  $0_1 = $5_1 >> 30;
  $4_1 = $0_1 + $1_1 | 0;
  $18_1 = $0_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = ($18_1 >> 31) + $15_1 | 0;
  $0_1 = $18_1 >> 30;
  $8_1 = $0_1 + $8_1 | 0;
  $15_1 = $0_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = ($15_1 >> 31) + $17_1 | 0;
  $0_1 = $15_1 >> 30;
  $14_1 = $0_1 + $14_1 | 0;
  $17_1 = $0_1 >>> 0 > $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = ($17_1 >> 31) + $22_1 | 0;
  $0_1 = $17_1 >> 30;
  $13_1 = $0_1 + $13_1 | 0;
  $22_1 = $0_1 >>> 0 > $13_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = $22_1 >> 31;
  $2_1 = ($0_1 & $21_1) + ($5_1 & 1073741823) | 0;
  $3_1 = $0_1;
  $1_1 = ($3_1 & $12_1) + $25_1 | 0;
  $0_1 = $1_1 >>> 0 < $25_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $0_1 & 1073741823;
  $12_1 = $2_1;
  HEAP32[$7_1 >> 2] = $1_1;
  HEAP32[$7_1 + 4 >> 2] = $2_1;
  $2_1 = ($3_1 & $30_1) + ($18_1 & 1073741823) | 0;
  $5_1 = $4_1;
  $4_1 = ($3_1 & $23_1) + $4_1 | 0;
  $2_1 = ($0_1 >> 31) + ($5_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) | 0;
  $0_1 = $0_1 >> 30;
  $5_1 = $0_1;
  $0_1 = $0_1 + $4_1 | 0;
  $2_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $4_1 = $0_1;
  HEAP32[$11_1 >> 2] = $4_1;
  $0_1 = $2_1;
  $2_1 = $2_1 & 1073741823;
  HEAP32[$11_1 + 4 >> 2] = $2_1;
  $5_1 = $7_1 + 8 | 0;
  HEAP32[$5_1 >> 2] = $4_1;
  HEAP32[$5_1 + 4 >> 2] = $2_1;
  $2_1 = ($3_1 & $19_1) + ($15_1 & 1073741823) | 0;
  $4_1 = ($3_1 & $24_1) + $8_1 | 0;
  $2_1 = ($0_1 >> 31) + ($4_1 >>> 0 < $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) | 0;
  $0_1 = $0_1 >> 30;
  $8_1 = $0_1;
  $0_1 = $0_1 + $4_1 | 0;
  $2_1 = $8_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $4_1 = $0_1;
  HEAP32[$10_1 >> 2] = $4_1;
  $0_1 = $2_1;
  $2_1 = $2_1 & 1073741823;
  HEAP32[$10_1 + 4 >> 2] = $2_1;
  $5_1 = $7_1 + 16 | 0;
  HEAP32[$5_1 >> 2] = $4_1;
  HEAP32[$5_1 + 4 >> 2] = $2_1;
  $2_1 = ($3_1 & $26_1) + ($17_1 & 1073741823) | 0;
  $4_1 = ($3_1 & $28_1) + $14_1 | 0;
  $2_1 = ($0_1 >> 31) + ($4_1 >>> 0 < $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) | 0;
  $0_1 = $0_1 >> 30;
  $8_1 = $0_1;
  $0_1 = $0_1 + $4_1 | 0;
  $2_1 = $8_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $4_1 = $0_1;
  HEAP32[$9_1 >> 2] = $4_1;
  $0_1 = $2_1;
  $2_1 = $2_1 & 1073741823;
  HEAP32[$9_1 + 4 >> 2] = $2_1;
  $5_1 = $7_1 + 24 | 0;
  HEAP32[$5_1 >> 2] = $4_1;
  HEAP32[$5_1 + 4 >> 2] = $2_1;
  $5_1 = $7_1 + 32 | 0;
  $2_1 = ($3_1 & $20_1) + $22_1 | 0;
  $3_1 = ($3_1 & $16_1) + $13_1 | 0;
  $2_1 = ($0_1 >> 31) + ($3_1 >>> 0 < $13_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) | 0;
  $0_1 = $0_1 >> 30;
  $4_1 = $0_1;
  $0_1 = $0_1 + $3_1 | 0;
  $2_1 = $4_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$5_1 >> 2] = $0_1;
  HEAP32[$5_1 + 4 >> 2] = $2_1;
  HEAP32[$6_1 + 280 >> 2] = $1_1;
  HEAP32[$6_1 + 284 >> 2] = $12_1;
  global$0 = $6_1 + 320 | 0;
 }
 
 function $41($0_1, $1_1, $2_1) {
  var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0;
  $5_1 = global$0 - 288 | 0;
  global$0 = $5_1;
  $66($5_1 + 224 | 0, $1_1, $2_1);
  $3_1 = $5_1 + 208 | 0;
  $22_1 = HEAP32[$5_1 + 256 >> 2];
  $17_1 = HEAP32[$5_1 + 260 >> 2];
  $69($3_1, $22_1, $17_1, 0, 0, 801750719, 1076732275, 0, 0);
  $18_1 = $5_1 + 176 | 0;
  $29_1 = HEAP32[$5_1 + 264 >> 2];
  $24_1 = HEAP32[$5_1 + 268 >> 2];
  $69($18_1, $29_1, $24_1, 0, 0, 801750719, 1076732275, 0, 0);
  $11_1 = $5_1 + 192 | 0;
  $69($11_1, $22_1, $17_1, 0, 0, 1354194884, 1162945305, 0, 0);
  $21_1 = $5_1 + 144 | 0;
  $30_1 = HEAP32[$5_1 + 272 >> 2];
  $26_1 = HEAP32[$5_1 + 276 >> 2];
  $69($21_1, $30_1, $26_1, 0, 0, 801750719, 1076732275, 0, 0);
  $16_1 = $5_1 + 160 | 0;
  $69($16_1, $29_1, $24_1, 0, 0, 1354194884, 1162945305, 0, 0);
  $27_1 = $5_1 + 112 | 0;
  $23_1 = HEAP32[$5_1 + 280 >> 2];
  $28_1 = HEAP32[$5_1 + 284 >> 2];
  $69($27_1, $23_1, $28_1, 0, 0, 801750719, 1076732275, 0, 0);
  $25_1 = $5_1 + 128 | 0;
  $69($25_1, $30_1, $26_1, 0, 0, 1354194884, 1162945305, 0, 0);
  $31_1 = $5_1 + 96 | 0;
  $69($31_1, $23_1, $28_1, 0, 0, 1354194884, 1162945305, 0, 0);
  $4_1 = HEAP32[$5_1 + 224 >> 2];
  $2_1 = HEAP32[$5_1 + 208 >> 2];
  $13_1 = $4_1 + $2_1 | 0;
  $8_1 = HEAP32[$5_1 + 228 >> 2];
  $1_1 = $8_1 + HEAP32[$5_1 + 212 >> 2] | 0;
  $19_1 = $2_1 >>> 0 > $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $4_1 = ($8_1 | 0) == ($19_1 | 0) & $4_1 >>> 0 > $13_1 >>> 0 | $8_1 >>> 0 > $19_1 >>> 0;
  $10_1 = HEAP32[$5_1 + 232 >> 2];
  $1_1 = $3_1 + 8 | 0;
  $2_1 = HEAP32[$1_1 >> 2];
  $3_1 = $10_1 + $2_1 | 0;
  $12_1 = HEAP32[$5_1 + 236 >> 2];
  $1_1 = $12_1 + HEAP32[$1_1 + 4 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = $3_1 + $4_1 | 0;
  $4_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $4_1 + HEAP32[$5_1 + 180 >> 2] | 0;
  $8_1 = $2_1;
  $2_1 = HEAP32[$5_1 + 176 >> 2];
  $3_1 = $8_1 + $2_1 | 0;
  $6_1 = HEAP32[$5_1 + 192 >> 2];
  $14_1 = $3_1 + $6_1 | 0;
  $2_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $2_1 + HEAP32[$5_1 + 196 >> 2] | 0;
  $15_1 = $6_1 >>> 0 > $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $9_1 = ($2_1 | 0) == ($15_1 | 0) & $3_1 >>> 0 > $14_1 >>> 0 | $2_1 >>> 0 > $15_1 >>> 0;
  $7_1 = ($2_1 | 0) == ($4_1 | 0) & $3_1 >>> 0 < $8_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
  $6_1 = ($4_1 | 0) == ($12_1 | 0) & $8_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $12_1 >>> 0;
  $2_1 = HEAP32[$5_1 + 240 >> 2];
  $12_1 = $2_1;
  $3_1 = $11_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $18_1 + 8 | 0;
  $10_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $1_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $20_1 = HEAP32[$5_1 + 244 >> 2];
  $1_1 = $20_1 + ($4_1 >>> 0 > $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) | 0;
  $2_1 = $2_1 + $10_1 | 0;
  $1_1 = $2_1 >>> 0 < $10_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $3_1 = $2_1;
  $2_1 = $2_1 + $6_1 | 0;
  $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $3_1 = $2_1;
  $2_1 = $2_1 + $7_1 | 0;
  $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $3_1 = $2_1;
  $2_1 = $2_1 + $9_1 | 0;
  $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $9_1 = $2_1;
  $2_1 = HEAP32[$5_1 + 144 >> 2];
  $7_1 = $9_1 + $2_1 | 0;
  $3_1 = $1_1;
  $1_1 = $1_1 + HEAP32[$5_1 + 148 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $7_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = HEAP32[$5_1 + 160 >> 2];
  $6_1 = $2_1 + $7_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + HEAP32[$5_1 + 164 >> 2] | 0;
  $2_1 = $2_1 >>> 0 > $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $17_1 + $2_1 | 0;
  $8_1 = $6_1 + $22_1 | 0;
  $17_1 = $8_1 >>> 0 < $22_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $18_1 = $8_1;
  $11_1 = ($2_1 | 0) == ($17_1 | 0) & $8_1 >>> 0 < $6_1 >>> 0 | $2_1 >>> 0 > $17_1 >>> 0;
  $10_1 = ($2_1 | 0) == ($4_1 | 0) & $6_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
  $7_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 > $4_1 >>> 0;
  $6_1 = ($3_1 | 0) == ($20_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $3_1 >>> 0 < $20_1 >>> 0;
  $2_1 = HEAP32[$5_1 + 248 >> 2];
  $20_1 = $2_1;
  $3_1 = $16_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $1_1 = $21_1 + 8 | 0;
  $9_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
  $1_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $22_1 = HEAP32[$5_1 + 252 >> 2];
  $1_1 = $22_1 + ($4_1 >>> 0 > $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) | 0;
  $2_1 = $2_1 + $9_1 | 0;
  $1_1 = $2_1 >>> 0 < $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $3_1 = $2_1;
  $2_1 = $2_1 + $6_1 | 0;
  $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $3_1 = $2_1;
  $2_1 = $2_1 + $7_1 | 0;
  $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $3_1 = $2_1;
  $2_1 = $2_1 + $10_1 | 0;
  $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $3_1 = $2_1;
  $2_1 = $2_1 + $11_1 | 0;
  $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $9_1 = $2_1;
  $2_1 = HEAP32[$5_1 + 112 >> 2];
  $7_1 = $9_1 + $2_1 | 0;
  $3_1 = $1_1;
  $1_1 = $1_1 + HEAP32[$5_1 + 116 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $7_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = HEAP32[$5_1 + 128 >> 2];
  $6_1 = $2_1 + $7_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + HEAP32[$5_1 + 132 >> 2] | 0;
  $2_1 = $2_1 >>> 0 > $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $24_1 + $2_1 | 0;
  $24_1 = $5_1 + 80 | 0;
  $16_1 = $24_1;
  $8_1 = $6_1 + $29_1 | 0;
  $21_1 = $8_1 >>> 0 < $29_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $11_1 = $8_1;
  $12_1 = ($2_1 | 0) == ($21_1 | 0) & $8_1 >>> 0 < $6_1 >>> 0 | $2_1 >>> 0 > $21_1 >>> 0;
  $10_1 = ($2_1 | 0) == ($4_1 | 0) & $6_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
  $6_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $3_1 >>> 0 > $4_1 >>> 0;
  $8_1 = ($3_1 | 0) == ($22_1 | 0) & $9_1 >>> 0 < $20_1 >>> 0 | $3_1 >>> 0 < $22_1 >>> 0;
  $1_1 = $27_1 + 8 | 0;
  $3_1 = HEAP32[$1_1 >> 2];
  $4_1 = HEAP32[$1_1 + 4 >> 2];
  $7_1 = HEAP32[$5_1 + 96 >> 2];
  $1_1 = $25_1 + 8 | 0;
  $2_1 = HEAP32[$1_1 >> 2];
  $20_1 = $7_1 + $2_1 | 0;
  $9_1 = HEAP32[$5_1 + 100 >> 2];
  $1_1 = $9_1 + HEAP32[$1_1 + 4 >> 2] | 0;
  $1_1 = ($2_1 >>> 0 > $20_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $4_1 | 0;
  $2_1 = $3_1 + $20_1 | 0;
  $1_1 = $2_1 >>> 0 < $20_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $3_1 = $2_1;
  $2_1 = $2_1 + $8_1 | 0;
  $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $3_1 = $2_1;
  $2_1 = $2_1 + $6_1 | 0;
  $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $3_1 = $2_1;
  $2_1 = $2_1 + $10_1 | 0;
  $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $4_1 = $2_1 + $12_1 | 0;
  $2_1 = $4_1 >>> 0 < $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $26_1 + $2_1 | 0;
  $3_1 = $4_1;
  $4_1 = $3_1 + $30_1 | 0;
  $1_1 = $4_1 >>> 0 < $30_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $25_1 = $4_1;
  $10_1 = $1_1;
  $69($16_1, $4_1, $1_1, 0, 0, 801750719, 1076732275, 0, 0);
  $26_1 = $5_1 + 48 | 0;
  $6_1 = $26_1;
  $8_1 = ($1_1 | 0) == ($2_1 | 0) & $3_1 >>> 0 > $4_1 >>> 0 | $1_1 >>> 0 < $2_1 >>> 0;
  $4_1 = ($2_1 | 0) == ($9_1 | 0) & $3_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $9_1 >>> 0;
  $1_1 = $31_1 + 8 | 0;
  $2_1 = HEAP32[$1_1 >> 2];
  $3_1 = $2_1 + $23_1 | 0;
  $1_1 = $28_1 + HEAP32[$1_1 + 4 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = $3_1 + $4_1 | 0;
  $1_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $3_1 = $2_1;
  $2_1 = $2_1 + $8_1 | 0;
  $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $20_1 = $2_1;
  $16_1 = $1_1;
  $69($6_1, $2_1, $1_1, 0, 0, 801750719, 1076732275, 0, 0);
  $22_1 = $5_1 - -64 | 0;
  $69($22_1, $25_1, $10_1, 0, 0, 1354194884, 1162945305, 0, 0);
  $27_1 = $5_1 + 32 | 0;
  $69($27_1, $2_1, $1_1, 0, 0, 1354194884, 1162945305, 0, 0);
  $2_1 = HEAP32[$5_1 + 80 >> 2];
  $12_1 = $2_1 + $13_1 | 0;
  $1_1 = $19_1 + HEAP32[$5_1 + 84 >> 2] | 0;
  $8_1 = $2_1 >>> 0 > $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $4_1 = ($19_1 | 0) == ($8_1 | 0) & $12_1 >>> 0 < $13_1 >>> 0 | $8_1 >>> 0 < $19_1 >>> 0;
  $1_1 = $24_1 + 8 | 0;
  $2_1 = HEAP32[$1_1 >> 2];
  $3_1 = $2_1 + $14_1 | 0;
  $1_1 = $15_1 + HEAP32[$1_1 + 4 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = $3_1 + $4_1 | 0;
  $4_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $4_1 + HEAP32[$5_1 + 52 >> 2] | 0;
  $7_1 = $2_1;
  $2_1 = HEAP32[$5_1 + 48 >> 2];
  $3_1 = $7_1 + $2_1 | 0;
  $6_1 = HEAP32[$5_1 + 64 >> 2];
  $13_1 = $3_1 + $6_1 | 0;
  $2_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $2_1 + HEAP32[$5_1 + 68 >> 2] | 0;
  $23_1 = ($16_1 | 0) == ($28_1 | 0) & $20_1 >>> 0 < $23_1 >>> 0 | $16_1 >>> 0 < $28_1 >>> 0;
  $31_1 = $23_1 ? 801750719 : 0;
  $24_1 = $23_1 ? 1076732275 : 0;
  $6_1 = $6_1 >>> 0 > $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $19_1 = ($2_1 | 0) == ($6_1 | 0) & $3_1 >>> 0 > $13_1 >>> 0 | $2_1 >>> 0 > $6_1 >>> 0;
  $9_1 = ($2_1 | 0) == ($4_1 | 0) & $3_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
  $7_1 = ($4_1 | 0) == ($15_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $4_1 >>> 0 < $15_1 >>> 0;
  $1_1 = $26_1 + 8 | 0;
  $3_1 = HEAP32[$1_1 >> 2];
  $4_1 = HEAP32[$1_1 + 4 >> 2];
  $1_1 = $22_1 + 8 | 0;
  $2_1 = HEAP32[$1_1 >> 2];
  $14_1 = $2_1 + $18_1 | 0;
  $1_1 = $17_1 + HEAP32[$1_1 + 4 >> 2] | 0;
  $1_1 = ($2_1 >>> 0 > $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $4_1 | 0;
  $2_1 = $3_1 + $14_1 | 0;
  $1_1 = $2_1 >>> 0 < $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $3_1 = $2_1;
  $2_1 = $2_1 + $7_1 | 0;
  $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $3_1 = $2_1;
  $2_1 = $2_1 + $9_1 | 0;
  $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $3_1 = $2_1;
  $2_1 = $2_1 + $19_1 | 0;
  $3_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $3_1 + $24_1 | 0;
  $15_1 = $2_1;
  $2_1 = $2_1 + $31_1 | 0;
  $1_1 = $15_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $9_1 = $2_1;
  $2_1 = HEAP32[$5_1 + 32 >> 2];
  $7_1 = $9_1 + $2_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + HEAP32[$5_1 + 36 >> 2] | 0;
  $2_1 = $2_1 >>> 0 > $7_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $10_1 + $2_1 | 0;
  $14_1 = $7_1 + $25_1 | 0;
  $10_1 = $14_1 >>> 0 < $25_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $25_1 = ($2_1 | 0) == ($10_1 | 0) & $7_1 >>> 0 > $14_1 >>> 0 | $2_1 >>> 0 > $10_1 >>> 0;
  $19_1 = ($2_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
  $7_1 = ($3_1 | 0) == ($4_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $3_1 >>> 0 > $4_1 >>> 0;
  $4_1 = ($3_1 | 0) == ($17_1 | 0) & $15_1 >>> 0 < $18_1 >>> 0 | $3_1 >>> 0 < $17_1 >>> 0;
  $1_1 = $27_1 + 8 | 0;
  $2_1 = HEAP32[$1_1 >> 2];
  $3_1 = $2_1 + $11_1 | 0;
  $1_1 = $21_1 + HEAP32[$1_1 + 4 >> 2] | 0;
  $1_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = $3_1 + $4_1 | 0;
  $1_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $3_1 = $2_1;
  $2_1 = $2_1 + $7_1 | 0;
  $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $3_1 = $2_1;
  $2_1 = $2_1 + $19_1 | 0;
  $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $3_1 = $2_1;
  $2_1 = $2_1 + $25_1 | 0;
  $1_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $7_1 = $2_1;
  $2_1 = $23_1 ? 1354194884 : 0;
  $3_1 = $7_1 + $2_1 | 0;
  $4_1 = $1_1;
  $1_1 = $1_1 + ($23_1 ? 1162945305 : 0) | 0;
  $2_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $16_1 + $2_1 | 0;
  $17_1 = $5_1 + 16 | 0;
  $18_1 = $3_1 + $20_1 | 0;
  $9_1 = $18_1 >>> 0 < $20_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $15_1 = ($2_1 | 0) == ($9_1 | 0) & $3_1 >>> 0 > $18_1 >>> 0 | $2_1 >>> 0 > $9_1 >>> 0;
  $2_1 = ($2_1 | 0) == ($4_1 | 0) & $3_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
  $4_1 = $23_1 + (($4_1 | 0) == ($21_1 | 0) & $7_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0) | 0;
  $1_1 = $23_1 >>> 0 > $4_1 >>> 0;
  $2_1 = $2_1 + $4_1 | 0;
  $1_1 = $2_1 >>> 0 < $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $11_1 = $2_1 + $15_1 | 0;
  $1_1 = $11_1 >>> 0 < $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $15_1 = $1_1;
  $69($17_1, $11_1, $1_1, 0, 0, 801750719, 1076732275, 0, 0);
  $69($5_1, $11_1, $1_1, 0, 0, 1354194884, 1162945305, 0, 0);
  $2_1 = HEAP32[$5_1 + 16 >> 2];
  $16_1 = $2_1;
  $19_1 = HEAP32[$5_1 + 20 >> 2];
  $1_1 = $19_1 + $8_1 | 0;
  $4_1 = $2_1 + $12_1 | 0;
  $8_1 = $4_1 >>> 0 < $12_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $2_1 = HEAP32[$5_1 >> 2];
  $7_1 = $2_1;
  $21_1 = HEAP32[$5_1 + 4 >> 2];
  $1_1 = $21_1 + $6_1 | 0;
  $3_1 = $2_1 + $13_1 | 0;
  $2_1 = $3_1 >>> 0 < $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $6_1 = $3_1;
  $3_1 = ($8_1 | 0) == ($19_1 | 0) & $4_1 >>> 0 < $16_1 >>> 0 | $8_1 >>> 0 < $19_1 >>> 0;
  $1_1 = $17_1 + 8 | 0;
  $13_1 = $3_1 + HEAP32[$1_1 >> 2] | 0;
  $1_1 = HEAP32[$1_1 + 4 >> 2];
  $1_1 = ($3_1 >>> 0 > $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1) + $2_1 | 0;
  $3_1 = $6_1 + $13_1 | 0;
  $12_1 = $3_1 >>> 0 < $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $13_1 = $3_1;
  $3_1 = ($2_1 | 0) == ($12_1 | 0) & $3_1 >>> 0 < $6_1 >>> 0 | $2_1 >>> 0 > $12_1 >>> 0;
  $2_1 = ($2_1 | 0) == ($21_1 | 0) & $6_1 >>> 0 < $7_1 >>> 0 | $2_1 >>> 0 < $21_1 >>> 0;
  $1_1 = $5_1 + 8 | 0;
  $6_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
  $1_1 = HEAP32[$1_1 + 4 >> 2];
  $1_1 = $2_1 >>> 0 > $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $7_1 = $3_1 + $6_1 | 0;
  $6_1 = $7_1 >>> 0 < $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $10_1 + $15_1 | 0;
  $3_1 = $11_1 + $14_1 | 0;
  $2_1 = $3_1 >>> 0 < $14_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $2_1 + $6_1 | 0;
  $16_1 = ($2_1 | 0) == ($15_1 | 0) & $3_1 >>> 0 < $11_1 >>> 0 | $2_1 >>> 0 < $15_1 >>> 0;
  $10_1 = $3_1;
  $7_1 = $3_1 + $7_1 | 0;
  $3_1 = $7_1 >>> 0 < $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $10_1;
  $10_1 = $7_1;
  $6_1 = ($2_1 | 0) == ($3_1 | 0) & $1_1 >>> 0 > $7_1 >>> 0 | $2_1 >>> 0 > $3_1 >>> 0;
  $2_1 = $16_1 + $6_1 | 0;
  $6_1 = $2_1 >>> 0 < $6_1 >>> 0;
  $1_1 = $9_1 + $6_1 | 0;
  $9_1 = $2_1 + $18_1 | 0;
  $1_1 = $9_1 >>> 0 < $18_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $18_1 = ($3_1 | 0) == -1;
  $7_1 = $1_1;
  $11_1 = $18_1 & $10_1 >>> 0 < 4294967294 | ($3_1 | 0) != -1 | ($1_1 & $9_1) != -1;
  $14_1 = ($12_1 | 0) == -1162945306;
  $1_1 = ($11_1 | ($14_1 & $13_1 >>> 0 < 2940772411 | $12_1 >>> 0 < 3132021990)) ^ -1;
  $11_1 = ($1_1 & (($8_1 | 0) == -1076732276 & $4_1 >>> 0 > 3493216576 | $8_1 >>> 0 > 3218235020) | ($1_1 & ($14_1 & $13_1 >>> 0 > 2940772411 | $12_1 >>> 0 > 3132021990) | ($10_1 | 0) == -1 & $18_1 & ($11_1 ^ -1))) + (($6_1 | 0) == ($7_1 | 0) & $2_1 >>> 0 > $9_1 >>> 0 | $6_1 >>> 0 > $7_1 >>> 0) | 0;
  $2_1 = __wasm_i64_mul($11_1, 0, 801750719, 1076732275);
  $6_1 = $2_1 + $4_1 | 0;
  $1_1 = $8_1 + i64toi32_i32$HIGH_BITS | 0;
  HEAP32[$0_1 >> 2] = $6_1;
  $1_1 = $2_1 >>> 0 > $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  HEAP32[$0_1 + 4 >> 2] = $1_1;
  $2_1 = $0_1;
  $8_1 = ($1_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $6_1 >>> 0 | $1_1 >>> 0 < $8_1 >>> 0;
  $0_1 = __wasm_i64_mul($11_1, 0, 1354194884, 1162945305);
  $4_1 = $0_1 + $13_1 | 0;
  $1_1 = $12_1 + i64toi32_i32$HIGH_BITS | 0;
  $1_1 = $0_1 >>> 0 > $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $0_1 = $1_1;
  $8_1 = $4_1 + $8_1 | 0;
  $1_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  HEAP32[$2_1 + 8 >> 2] = $8_1;
  HEAP32[$2_1 + 12 >> 2] = $1_1;
  $16_1 = ($0_1 | 0) == ($12_1 | 0) & $4_1 >>> 0 < $13_1 >>> 0 | $0_1 >>> 0 < $12_1 >>> 0;
  $0_1 = ($0_1 | 0) == ($1_1 | 0) & $4_1 >>> 0 > $8_1 >>> 0 | $0_1 >>> 0 > $1_1 >>> 0;
  $6_1 = $16_1 + $0_1 | 0;
  $8_1 = $0_1 >>> 0 > $6_1 >>> 0;
  $1_1 = $3_1;
  $4_1 = $10_1 + $11_1 | 0;
  $0_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $0_1 + $8_1 | 0;
  $8_1 = $4_1 + $6_1 | 0;
  $1_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  HEAP32[$2_1 + 16 >> 2] = $8_1;
  HEAP32[$2_1 + 20 >> 2] = $1_1;
  $3_1 = ($0_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 < $10_1 >>> 0 | $0_1 >>> 0 < $3_1 >>> 0;
  $0_1 = ($0_1 | 0) == ($1_1 | 0) & $4_1 >>> 0 > $8_1 >>> 0 | $0_1 >>> 0 > $1_1 >>> 0;
  $4_1 = $3_1 + $0_1 | 0;
  $1_1 = $7_1 + ($0_1 >>> 0 > $4_1 >>> 0) | 0;
  $0_1 = $4_1 + $9_1 | 0;
  $1_1 = $0_1 >>> 0 < $9_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  HEAP32[$2_1 + 24 >> 2] = $0_1;
  HEAP32[$2_1 + 28 >> 2] = $1_1;
  global$0 = $5_1 + 288 | 0;
 }
 
 function $42($0_1, $1_1, $2_1, $3_1) {
  var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0, $51_1 = 0, $52_1 = 0, $53_1 = 0, $54_1 = 0, $55_1 = 0, $56_1 = 0, $57_1 = 0, $58_1 = 0, $59_1 = 0, $60_1 = 0, $61_1 = 0, $62_1 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;
  $10_1 = global$0 - 3808 | 0;
  global$0 = $10_1;
  $4_1 = $10_1 + 3696 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $4_1 = $10_1 + 3704 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $4_1 = $10_1 + 3712 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  HEAP32[$10_1 + 3688 >> 2] = 0;
  HEAP32[$10_1 + 3692 >> 2] = 0;
  HEAP32[$10_1 + 3680 >> 2] = 1;
  HEAP32[$10_1 + 3684 >> 2] = 0;
  label$1 : {
   if (!(HEAP32[$1_1 + 120 >> 2] ? 0 : HEAP32[$2_1 + 24 >> 2] | (HEAP32[$2_1 + 16 >> 2] | (HEAP32[$2_1 + 8 >> 2] | HEAP32[$2_1 >> 2])) | (HEAP32[$2_1 + 28 >> 2] | (HEAP32[$2_1 + 20 >> 2] | (HEAP32[$2_1 + 12 >> 2] | HEAP32[$2_1 + 4 >> 2]))))) {
    $2_1 = 0;
    $1_1 = 0;
    break label$1;
   }
   $5_1 = global$0 - 128 | 0;
   global$0 = $5_1;
   $7_1 = $5_1 - -64 | 0;
   $66($7_1, $2_1, 690640);
   HEAP32[$5_1 + 56 >> 2] = 0;
   HEAP32[$5_1 + 60 >> 2] = 0;
   $8_1 = ((HEAP32[$5_1 + 108 >> 2] >>> 31 | 0) - 1 >>> 8 ^ -1) & 1;
   $6_1 = HEAP32[$5_1 + 112 >> 2];
   $13_1 = $8_1 + $6_1 | 0;
   $4_1 = HEAP32[$5_1 + 116 >> 2];
   HEAP32[$5_1 + 32 >> 2] = $13_1;
   $4_1 = $6_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$5_1 + 36 >> 2] = $4_1;
   $8_1 = !$4_1 & $8_1 >>> 0 > $13_1 >>> 0;
   $6_1 = HEAP32[$5_1 + 120 >> 2];
   $13_1 = $8_1 + $6_1 | 0;
   $4_1 = HEAP32[$5_1 + 124 >> 2];
   HEAP32[$5_1 + 40 >> 2] = $13_1;
   $4_1 = $6_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$5_1 + 44 >> 2] = $4_1;
   HEAP32[$5_1 + 48 >> 2] = !$4_1 & $8_1 >>> 0 > $13_1 >>> 0;
   HEAP32[$5_1 + 52 >> 2] = 0;
   $66($7_1, $2_1, 690672);
   HEAP32[$5_1 + 24 >> 2] = 0;
   HEAP32[$5_1 + 28 >> 2] = 0;
   $8_1 = ((HEAP32[$5_1 + 108 >> 2] >>> 31 | 0) - 1 >>> 8 ^ -1) & 1;
   $6_1 = HEAP32[$5_1 + 112 >> 2];
   $7_1 = $8_1 + $6_1 | 0;
   $4_1 = HEAP32[$5_1 + 116 >> 2];
   HEAP32[$5_1 >> 2] = $7_1;
   $4_1 = $6_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$5_1 + 4 >> 2] = $4_1;
   $6_1 = !$4_1 & $7_1 >>> 0 < $8_1 >>> 0;
   $18_1 = $5_1;
   $5_1 = HEAP32[$5_1 + 120 >> 2];
   $8_1 = $6_1 + $5_1 | 0;
   $4_1 = HEAP32[$18_1 + 124 >> 2];
   HEAP32[$18_1 + 8 >> 2] = $8_1;
   $4_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$18_1 + 12 >> 2] = $4_1;
   HEAP32[$18_1 + 16 >> 2] = !$4_1 & $6_1 >>> 0 > $8_1 >>> 0;
   HEAP32[$18_1 + 20 >> 2] = 0;
   $4_1 = $18_1 + 32 | 0;
   $41($4_1, $4_1, 690576);
   $41($18_1, $18_1, 690608);
   $8_1 = HEAP32[$18_1 >> 2];
   $6_1 = HEAP32[$18_1 + 32 >> 2];
   $5_1 = $8_1 + $6_1 | 0;
   $7_1 = HEAP32[$18_1 + 4 >> 2];
   $4_1 = $7_1 + HEAP32[$18_1 + 36 >> 2] | 0;
   $19_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $12_1 = $5_1;
   $13_1 = ($7_1 | 0) == ($19_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $7_1 >>> 0 > $19_1 >>> 0;
   $5_1 = HEAP32[$18_1 + 40 >> 2];
   $8_1 = $13_1 + $5_1 | 0;
   $4_1 = HEAP32[$18_1 + 44 >> 2];
   $7_1 = HEAP32[$18_1 + 8 >> 2];
   $6_1 = $7_1 + $8_1 | 0;
   $5_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $5_1 + HEAP32[$18_1 + 12 >> 2] | 0;
   $9_1 = !$5_1 & $8_1 >>> 0 < $13_1 >>> 0;
   $17_1 = $6_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $16_1 = $6_1;
   $5_1 = ($5_1 | 0) == ($17_1 | 0) & $8_1 >>> 0 > $6_1 >>> 0 | $5_1 >>> 0 > $17_1 >>> 0;
   $6_1 = $9_1 + $5_1 | 0;
   $9_1 = $5_1 >>> 0 > $6_1 >>> 0;
   $4_1 = $9_1 + HEAP32[$18_1 + 52 >> 2] | 0;
   $5_1 = HEAP32[$18_1 + 48 >> 2];
   $13_1 = $5_1 + $6_1 | 0;
   $7_1 = HEAP32[$18_1 + 16 >> 2];
   $8_1 = $13_1 + $7_1 | 0;
   $5_1 = $5_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $5_1 + HEAP32[$18_1 + 20 >> 2] | 0;
   $6_1 = ($5_1 | 0) == ($9_1 | 0) & $6_1 >>> 0 > $13_1 >>> 0 | $5_1 >>> 0 < $9_1 >>> 0;
   $7_1 = $7_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $20_1 = $8_1;
   $5_1 = ($5_1 | 0) == ($7_1 | 0) & $13_1 >>> 0 > $8_1 >>> 0 | $5_1 >>> 0 > $7_1 >>> 0;
   $6_1 = $6_1 + $5_1 | 0;
   $13_1 = $5_1 >>> 0 > $6_1 >>> 0;
   $4_1 = $13_1 + HEAP32[$18_1 + 60 >> 2] | 0;
   $5_1 = HEAP32[$18_1 + 56 >> 2];
   $8_1 = $5_1 + $6_1 | 0;
   $9_1 = HEAP32[$18_1 + 24 >> 2];
   $14_1 = $8_1 + $9_1 | 0;
   $5_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $5_1 + HEAP32[$18_1 + 28 >> 2] | 0;
   $15_1 = $9_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $9_1 = (($5_1 | 0) == ($13_1 | 0) & $6_1 >>> 0 > $8_1 >>> 0 | $5_1 >>> 0 < $13_1 >>> 0) + (($5_1 | 0) == ($15_1 | 0) & $8_1 >>> 0 > $14_1 >>> 0 | $5_1 >>> 0 > $15_1 >>> 0) | 0;
   $6_1 = ($7_1 | 0) == -1;
   $5_1 = $6_1 & $20_1 >>> 0 < 4294967294 | ($7_1 | 0) != -1 | ($14_1 & $15_1) != -1;
   $8_1 = ($17_1 | 0) == -1162945306;
   $4_1 = ($5_1 | ($8_1 & $16_1 >>> 0 < 2940772411 | $17_1 >>> 0 < 3132021990)) ^ -1;
   $23_1 = $9_1 + ($4_1 & (($19_1 | 0) == -1076732276 & $12_1 >>> 0 > 3493216576 | $19_1 >>> 0 > 3218235020) | ($4_1 & ($8_1 & $16_1 >>> 0 > 2940772411 | $17_1 >>> 0 > 3132021990) | ($20_1 | 0) == -1 & $6_1 & ($5_1 ^ -1))) | 0;
   $6_1 = __wasm_i64_mul($23_1, 0, 801750719, 1076732275);
   $5_1 = $6_1 + $12_1 | 0;
   $4_1 = $19_1 + i64toi32_i32$HIGH_BITS | 0;
   $9_1 = $10_1 + 3720 | 0;
   HEAP32[$9_1 >> 2] = $5_1;
   $13_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$9_1 + 4 >> 2] = $13_1;
   $8_1 = $9_1;
   $6_1 = __wasm_i64_mul($23_1, 0, 1354194884, 1162945305);
   $11_1 = $6_1 + $16_1 | 0;
   $4_1 = $17_1 + i64toi32_i32$HIGH_BITS | 0;
   $5_1 = ($13_1 | 0) == ($19_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $13_1 >>> 0 < $19_1 >>> 0;
   $9_1 = $11_1 + $5_1 | 0;
   $4_1 = $6_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $4_1;
   HEAP32[$8_1 + 8 >> 2] = $9_1;
   $12_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$8_1 + 12 >> 2] = $12_1;
   $4_1 = $7_1;
   $13_1 = $20_1 + $23_1 | 0;
   $5_1 = $13_1 >>> 0 < $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = ($6_1 | 0) == ($17_1 | 0) & $11_1 >>> 0 < $16_1 >>> 0 | $6_1 >>> 0 < $17_1 >>> 0;
   $6_1 = ($6_1 | 0) == ($12_1 | 0) & $9_1 >>> 0 < $11_1 >>> 0 | $6_1 >>> 0 > $12_1 >>> 0;
   $9_1 = $4_1 + $6_1 | 0;
   $4_1 = ($6_1 >>> 0 > $9_1 >>> 0) + $5_1 | 0;
   $6_1 = $9_1 + $13_1 | 0;
   $4_1 = $6_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$8_1 + 16 >> 2] = $6_1;
   HEAP32[$8_1 + 20 >> 2] = $4_1;
   $16_1 = $8_1;
   $7_1 = ($5_1 | 0) == ($7_1 | 0) & $13_1 >>> 0 < $20_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
   $5_1 = ($4_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
   $6_1 = $7_1 + $5_1 | 0;
   $4_1 = $15_1 + ($5_1 >>> 0 > $6_1 >>> 0) | 0;
   $5_1 = $6_1 + $14_1 | 0;
   $4_1 = $5_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$8_1 + 24 >> 2] = $5_1;
   HEAP32[$8_1 + 28 >> 2] = $4_1;
   $8_1 = $10_1 + 2560 | 0;
   $41($8_1, $16_1, 690704);
   $24_1 = HEAP32[$8_1 + 24 >> 2];
   $14_1 = HEAP32[$8_1 + 16 >> 2];
   $13_1 = HEAP32[$8_1 + 8 >> 2];
   $5_1 = HEAP32[$8_1 >> 2];
   $12_1 = HEAP32[$8_1 + 28 >> 2];
   $9_1 = HEAP32[$8_1 + 20 >> 2];
   $11_1 = HEAP32[$8_1 + 12 >> 2];
   $7_1 = HEAP32[$8_1 + 4 >> 2];
   $4_1 = $24_1 | ($14_1 | ($13_1 | $5_1)) | ($12_1 | ($9_1 | ($11_1 | $7_1))) ? -1 : 0;
   $20_1 = $5_1 ^ -1;
   $6_1 = $20_1 - 801750718 | 0;
   $23_1 = $4_1 & $6_1;
   HEAP32[$8_1 >> 2] = $23_1;
   $5_1 = $4_1;
   $7_1 = $7_1 ^ -1;
   $4_1 = $7_1 - (($20_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
   $15_1 = $5_1 & $4_1;
   HEAP32[$8_1 + 4 >> 2] = $15_1;
   $6_1 = ($4_1 | 0) == ($7_1 | 0) & $6_1 >>> 0 < $20_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0;
   $13_1 = $13_1 ^ -1;
   $19_1 = $6_1 + $13_1 | 0;
   $20_1 = $11_1 ^ -1;
   $4_1 = $20_1;
   $7_1 = $19_1 - 1354194885 | 0;
   $17_1 = $7_1 & $5_1;
   HEAP32[$8_1 + 8 >> 2] = $17_1;
   $4_1 = $6_1 >>> 0 > $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $11_1 = $4_1 - (($19_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
   $6_1 = $11_1 & $5_1;
   HEAP32[$8_1 + 12 >> 2] = $6_1;
   $7_1 = ($4_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 < $19_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
   $13_1 = $7_1 + (($4_1 | 0) == ($20_1 | 0) & $13_1 >>> 0 > $19_1 >>> 0 | $4_1 >>> 0 < $20_1 >>> 0) | 0;
   $20_1 = $14_1 ^ -1;
   $30_1 = $20_1 + $13_1 | 0;
   $14_1 = $9_1 ^ -1;
   $4_1 = $14_1 + ($7_1 >>> 0 > $13_1 >>> 0) | 0;
   $4_1 = $20_1 >>> 0 > $30_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $11_1 = $4_1 - ($30_1 >>> 0 < 2) | 0;
   $13_1 = $11_1 & $5_1;
   $19_1 = $13_1;
   $7_1 = $30_1 - 2 | 0;
   $9_1 = $7_1 & $5_1;
   HEAP32[$8_1 + 16 >> 2] = $9_1;
   HEAP32[$8_1 + 20 >> 2] = $13_1;
   $7_1 = ($4_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 < $30_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
   $13_1 = $7_1 + (($4_1 | 0) == ($14_1 | 0) & $20_1 >>> 0 > $30_1 >>> 0 | $4_1 >>> 0 < $14_1 >>> 0) | 0;
   $4_1 = $7_1 >>> 0 > $13_1 >>> 0;
   $7_1 = $13_1 - $24_1 | 0;
   $30_1 = $7_1 - 2 & $5_1;
   HEAP32[$8_1 + 24 >> 2] = $30_1;
   $11_1 = ($4_1 - (($13_1 >>> 0 < $24_1 >>> 0) + $12_1 | 0) | 0) - ($7_1 >>> 0 < 2) & $5_1;
   HEAP32[$8_1 + 28 >> 2] = $11_1;
   $5_1 = HEAP32[$2_1 >> 2];
   $7_1 = $5_1;
   $13_1 = HEAP32[$2_1 + 4 >> 2];
   $4_1 = $13_1 + $15_1 | 0;
   $5_1 = $5_1 + $23_1 | 0;
   $4_1 = $5_1 >>> 0 < $23_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $15_1 = $5_1;
   HEAP32[$8_1 >> 2] = $5_1;
   $20_1 = $4_1;
   HEAP32[$8_1 + 4 >> 2] = $4_1;
   $4_1 = $6_1;
   $12_1 = ($13_1 | 0) == ($20_1 | 0) & $5_1 >>> 0 < $7_1 >>> 0 | $13_1 >>> 0 > $20_1 >>> 0;
   $5_1 = $12_1 + $17_1 | 0;
   $6_1 = $5_1 >>> 0 < $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $6_1 + HEAP32[$2_1 + 12 >> 2] | 0;
   $7_1 = $5_1;
   $13_1 = HEAP32[$2_1 + 8 >> 2];
   $5_1 = $5_1 + $13_1 | 0;
   $14_1 = $5_1;
   HEAP32[$8_1 + 8 >> 2] = $5_1;
   $17_1 = $5_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$8_1 + 12 >> 2] = $17_1;
   $25_1 = HEAP32[$2_1 + 16 >> 2];
   $9_1 = $25_1 + $9_1 | 0;
   $24_1 = HEAP32[$2_1 + 20 >> 2];
   $4_1 = $24_1 + $19_1 | 0;
   $5_1 = $9_1 >>> 0 < $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = !$6_1 & $7_1 >>> 0 < $12_1 >>> 0;
   $6_1 = ($6_1 | 0) == ($17_1 | 0) & $7_1 >>> 0 > $14_1 >>> 0 | $6_1 >>> 0 > $17_1 >>> 0;
   $7_1 = $4_1 + $6_1 | 0;
   $4_1 = ($6_1 >>> 0 > $7_1 >>> 0) + $5_1 | 0;
   $6_1 = $7_1 + $9_1 | 0;
   $4_1 = $6_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $19_1 = $6_1;
   HEAP32[$8_1 + 16 >> 2] = $6_1;
   $7_1 = $4_1;
   HEAP32[$8_1 + 20 >> 2] = $4_1;
   $6_1 = HEAP32[$2_1 + 24 >> 2];
   $12_1 = $6_1;
   $23_1 = HEAP32[$2_1 + 28 >> 2];
   $4_1 = $23_1 + $11_1 | 0;
   $6_1 = $6_1 + $30_1 | 0;
   $2_1 = $6_1 >>> 0 < $30_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $13_1 = $6_1;
   $4_1 = ($5_1 | 0) == ($24_1 | 0) & $9_1 >>> 0 < $25_1 >>> 0 | $5_1 >>> 0 < $24_1 >>> 0;
   $5_1 = ($5_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 > $19_1 >>> 0 | $5_1 >>> 0 > $7_1 >>> 0;
   $9_1 = $4_1 + $5_1 | 0;
   $4_1 = ($5_1 >>> 0 > $9_1 >>> 0) + $2_1 | 0;
   $11_1 = $6_1 + $9_1 | 0;
   $4_1 = $11_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $8_1;
   $9_1 = $4_1;
   $13_1 = (($2_1 | 0) == ($23_1 | 0) & $12_1 >>> 0 > $13_1 >>> 0 | $2_1 >>> 0 < $23_1 >>> 0) + (($2_1 | 0) == ($4_1 | 0) & $11_1 >>> 0 < $13_1 >>> 0 | $2_1 >>> 0 > $4_1 >>> 0) | 0;
   $5_1 = ($7_1 | 0) == -1;
   $4_1 = $5_1 & $19_1 >>> 0 < 4294967294 | ($7_1 | 0) != -1 | ($4_1 & $11_1) != -1;
   $8_1 = ($17_1 | 0) == -1162945306;
   $2_1 = ($4_1 | ($8_1 & $14_1 >>> 0 < 2940772411 | $17_1 >>> 0 < 3132021990)) ^ -1;
   $23_1 = $13_1 + ($2_1 & (($20_1 | 0) == -1076732276 & $15_1 >>> 0 > 3493216576 | $20_1 >>> 0 > 3218235020) | ($2_1 & ($8_1 & $14_1 >>> 0 > 2940772411 | $17_1 >>> 0 > 3132021990) | ($19_1 | 0) == -1 & $5_1 & ($4_1 ^ -1))) | 0;
   $5_1 = __wasm_i64_mul($23_1, 0, 801750719, 1076732275);
   $2_1 = $5_1 + $15_1 | 0;
   $4_1 = $20_1 + i64toi32_i32$HIGH_BITS | 0;
   HEAP32[$6_1 >> 2] = $2_1;
   $8_1 = $2_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$6_1 + 4 >> 2] = $8_1;
   $5_1 = __wasm_i64_mul($23_1, 0, 1354194884, 1162945305);
   $12_1 = $5_1 + $14_1 | 0;
   $4_1 = $17_1 + i64toi32_i32$HIGH_BITS | 0;
   $2_1 = ($8_1 | 0) == ($20_1 | 0) & $2_1 >>> 0 < $15_1 >>> 0 | $8_1 >>> 0 < $20_1 >>> 0;
   $13_1 = $12_1 + $2_1 | 0;
   $4_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $4_1;
   HEAP32[$6_1 + 8 >> 2] = $13_1;
   $15_1 = $2_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$6_1 + 12 >> 2] = $15_1;
   $4_1 = $7_1;
   $8_1 = $19_1 + $23_1 | 0;
   $2_1 = $8_1 >>> 0 < $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = ($5_1 | 0) == ($17_1 | 0) & $14_1 >>> 0 > $12_1 >>> 0 | $5_1 >>> 0 < $17_1 >>> 0;
   $5_1 = ($5_1 | 0) == ($15_1 | 0) & $12_1 >>> 0 > $13_1 >>> 0 | $5_1 >>> 0 > $15_1 >>> 0;
   $13_1 = $4_1 + $5_1 | 0;
   $4_1 = ($5_1 >>> 0 > $13_1 >>> 0) + $2_1 | 0;
   $5_1 = $8_1 + $13_1 | 0;
   $4_1 = $5_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$6_1 + 16 >> 2] = $5_1;
   HEAP32[$6_1 + 20 >> 2] = $4_1;
   $7_1 = ($2_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $19_1 >>> 0 | $2_1 >>> 0 < $7_1 >>> 0;
   $2_1 = ($2_1 | 0) == ($4_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $2_1 >>> 0 > $4_1 >>> 0;
   $5_1 = $7_1 + $2_1 | 0;
   $4_1 = $9_1 + ($2_1 >>> 0 > $5_1 >>> 0) | 0;
   $2_1 = $5_1 + $11_1 | 0;
   $4_1 = $2_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$6_1 + 24 >> 2] = $2_1;
   HEAP32[$6_1 + 28 >> 2] = $4_1;
   global$0 = $18_1 + 128 | 0;
   (wasm2js_i32$0 = $10_1, wasm2js_i32$1 = $62($10_1 + 496 | 0, $6_1, 5)), HEAP32[wasm2js_i32$0 + 1528 >> 2] = wasm2js_i32$1;
   $62_1 = $62($10_1 + 1012 | 0, $16_1, 5);
   HEAP32[$10_1 + 1532 >> 2] = $62_1;
   $52_1 = HEAP32[$10_1 + 1528 >> 2];
   $39_1 = $10_1 + 3088 | 0;
   $70($39_1, $1_1, 128);
   $2_1 = $10_1 + 1536 | 0;
   $46_1 = $10_1 + 2240 | 0;
   $51_1 = $10_1 + 3680 | 0;
   $12_1 = 0;
   $15_1 = 0;
   $11_1 = 0;
   $7_1 = 0;
   $17_1 = global$0 - 720 | 0;
   global$0 = $17_1;
   label$4 : {
    if (HEAP32[$39_1 + 120 >> 2]) {
     HEAP32[$17_1 + 672 >> 2] = 1;
     $68($17_1 + 552 | 0, 120);
     $8_1 = 0;
     $6_1 = 0;
     break label$4;
    }
    $55($17_1 + 552 | 0, $39_1);
    $1_1 = $17_1 + 664 | 0;
    $11_1 = HEAP32[$1_1 >> 2];
    $7_1 = HEAP32[$1_1 + 4 >> 2];
    $1_1 = $17_1 + 648 | 0;
    $22_1 = HEAP32[$1_1 >> 2];
    $21_1 = HEAP32[$1_1 + 4 >> 2];
    $1_1 = $17_1 + 640 | 0;
    $27_1 = HEAP32[$1_1 >> 2];
    $26_1 = HEAP32[$1_1 + 4 >> 2];
    $12_1 = HEAP32[$17_1 + 632 >> 2];
    $15_1 = HEAP32[$17_1 + 636 >> 2];
    $1_1 = $17_1 + 656 | 0;
    $8_1 = HEAP32[$1_1 >> 2];
    $6_1 = HEAP32[$1_1 + 4 >> 2];
   }
   $32_1 = $17_1 + 552 | 0;
   $5_1 = $32_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $45_1 = $17_1 + 336 | 0;
   $1_1 = $45_1 + 8 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $32_1 + 16 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $45_1 + 16 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $32_1 + 24 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $45_1 + 24 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $32_1 + 32 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $45_1 + 32 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $32_1 + 48 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $45_1 + 48 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $32_1 + 56 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $45_1 + 56 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $32_1 - -64 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $45_1 - -64 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $32_1 + 72 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $45_1 + 72 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   HEAP32[$17_1 + 416 >> 2] = 0;
   $1_1 = HEAP32[$17_1 + 556 >> 2];
   HEAP32[$17_1 + 336 >> 2] = HEAP32[$17_1 + 552 >> 2];
   HEAP32[$17_1 + 340 >> 2] = $1_1;
   $1_1 = HEAP32[$17_1 + 596 >> 2];
   HEAP32[$17_1 + 376 >> 2] = HEAP32[$17_1 + 592 >> 2];
   HEAP32[$17_1 + 380 >> 2] = $1_1;
   $29_1 = $17_1 + 304 | 0;
   $31_1 = $12_1 << 1;
   $35_1 = $15_1 << 1 | $12_1 >>> 31;
   $69($29_1, $8_1, $6_1, 0, 0, $31_1, $35_1, 0, 0);
   $28_1 = $17_1 + 224 | 0;
   $5_1 = $22_1;
   $1_1 = $21_1;
   $13_1 = $27_1 << 1;
   $9_1 = $26_1 << 1 | $27_1 >>> 31;
   $69($28_1, $5_1, $1_1, 0, 0, $13_1, $9_1, 0, 0);
   $14_1 = $17_1 + 160 | 0;
   $4_1 = $7_1;
   $69($14_1, $11_1, $4_1, 0, 0, $11_1, $4_1, 0, 0);
   $20_1 = $17_1 + 144 | 0;
   $69($20_1, HEAP32[$17_1 + 160 >> 2], HEAP32[$17_1 + 164 >> 2], 0, 0, 15632, 16, 0, 0);
   $7_1 = $11_1;
   $4_1 = $4_1 << 1 | $7_1 >>> 31;
   $42_1 = $17_1 + 112 | 0;
   $43_1 = $7_1 << 1;
   $30_1 = $4_1;
   $69($42_1, $43_1, $4_1, 0, 0, $12_1, $15_1, 0, 0);
   $44_1 = $17_1 + 272 | 0;
   $69($44_1, $8_1, $6_1, 0, 0, $13_1, $9_1, 0, 0);
   $36_1 = $17_1 + 208 | 0;
   $69($36_1, $5_1, $1_1, 0, 0, $5_1, $1_1, 0, 0);
   $23_1 = $17_1 + 128 | 0;
   $4_1 = $14_1 + 8 | 0;
   $69($23_1, HEAP32[$4_1 >> 2], HEAP32[$4_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
   $50_1 = $17_1 + 320 | 0;
   $69($50_1, $12_1, $15_1, 0, 0, $12_1, $15_1, 0, 0);
   $47_1 = $17_1 + 96 | 0;
   $69($47_1, $43_1, $30_1, 0, 0, $27_1, $26_1, 0, 0);
   $19_1 = $1_1;
   $25_1 = $5_1;
   $4_1 = $1_1 << 1 | $5_1 >>> 31;
   $48_1 = $17_1 + 176 | 0;
   $22_1 = $8_1;
   $21_1 = $6_1;
   $69($48_1, $8_1, $6_1, 0, 0, $5_1 << 1, $4_1, 0, 0);
   $9_1 = HEAP32[$17_1 + 304 >> 2];
   $5_1 = HEAP32[$17_1 + 224 >> 2];
   $1_1 = $9_1 + $5_1 | 0;
   $33_1 = HEAP32[$17_1 + 308 >> 2];
   $4_1 = $33_1 + HEAP32[$17_1 + 228 >> 2] | 0;
   $4_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = HEAP32[$17_1 + 144 >> 2];
   $24_1 = $5_1 + $1_1 | 0;
   $6_1 = $4_1;
   $4_1 = $4_1 + HEAP32[$17_1 + 148 >> 2] | 0;
   $13_1 = $5_1 >>> 0 > $24_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $40_1 = HEAP32[$17_1 + 272 >> 2];
   $5_1 = HEAP32[$17_1 + 208 >> 2];
   $14_1 = $40_1 + $5_1 | 0;
   $41_1 = HEAP32[$17_1 + 276 >> 2];
   $4_1 = $41_1 + HEAP32[$17_1 + 212 >> 2] | 0;
   $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = HEAP32[$17_1 + 112 >> 2];
   $16_1 = $5_1 + $14_1 | 0;
   $7_1 = $4_1;
   $4_1 = $4_1 + HEAP32[$17_1 + 116 >> 2] | 0;
   $4_1 = $5_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = HEAP32[$17_1 + 128 >> 2];
   $12_1 = $5_1 + $16_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + HEAP32[$17_1 + 132 >> 2] | 0;
   $5_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $18_1 = ($6_1 | 0) == ($13_1 | 0) & $1_1 >>> 0 > $24_1 >>> 0 | $6_1 >>> 0 > $13_1 >>> 0;
   $4_1 = $20_1 + 8 | 0;
   $11_1 = HEAP32[$4_1 >> 2];
   $15_1 = HEAP32[$4_1 + 4 >> 2];
   $9_1 = ($6_1 | 0) == ($33_1 | 0) & $1_1 >>> 0 < $9_1 >>> 0 | $6_1 >>> 0 < $33_1 >>> 0;
   $4_1 = $28_1 + 8 | 0;
   $6_1 = HEAP32[$4_1 >> 2];
   $1_1 = $29_1 + 8 | 0;
   $20_1 = $6_1 + HEAP32[$1_1 >> 2] | 0;
   $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $6_1 >>> 0 > $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $1_1 = $9_1 + $20_1 | 0;
   $4_1 = ($1_1 >>> 0 < $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $15_1 | 0;
   $6_1 = $1_1;
   $1_1 = $1_1 + $11_1 | 0;
   $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $1_1;
   $1_1 = $1_1 + $18_1 | 0;
   $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $20_1 = $13_1;
   $13_1 = $1_1 << 12 | $13_1 >>> 20;
   $15_1 = $13_1 + $12_1 | 0;
   $6_1 = $4_1;
   $4_1 = $5_1 + ($4_1 << 12 | $1_1 >>> 20) | 0;
   $13_1 = $15_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $49_1 = $17_1 + 80 | 0;
   $33_1 = $49_1;
   $37_1 = HEAP32[$17_1 + 96 >> 2];
   $1_1 = HEAP32[$17_1 + 176 >> 2];
   $11_1 = $37_1 + $1_1 | 0;
   $34_1 = HEAP32[$17_1 + 100 >> 2];
   $4_1 = $34_1 + HEAP32[$17_1 + 180 >> 2] | 0;
   $1_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $29_1 = ($5_1 | 0) == ($13_1 | 0) & $12_1 >>> 0 > $15_1 >>> 0 | $5_1 >>> 0 > $13_1 >>> 0;
   $28_1 = ($5_1 | 0) == ($8_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
   $4_1 = $23_1 + 8 | 0;
   $23_1 = HEAP32[$4_1 >> 2];
   $18_1 = HEAP32[$4_1 + 4 >> 2];
   $16_1 = ($7_1 | 0) == ($8_1 | 0) & $14_1 >>> 0 > $16_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
   $4_1 = $42_1 + 8 | 0;
   $12_1 = HEAP32[$4_1 >> 2];
   $9_1 = HEAP32[$4_1 + 4 >> 2];
   $7_1 = ($7_1 | 0) == ($41_1 | 0) & $14_1 >>> 0 < $40_1 >>> 0 | $7_1 >>> 0 < $41_1 >>> 0;
   $8_1 = $36_1 + 8 | 0;
   $5_1 = HEAP32[$8_1 >> 2];
   $4_1 = $44_1 + 8 | 0;
   $14_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
   $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
   $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $7_1 + $14_1 | 0;
   $4_1 = ($5_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $9_1 | 0;
   $7_1 = $5_1;
   $5_1 = $5_1 + $12_1 | 0;
   $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $7_1 = $5_1;
   $5_1 = $5_1 + $16_1 | 0;
   $4_1 = ($7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $18_1 | 0;
   $7_1 = $5_1;
   $5_1 = $5_1 + $23_1 | 0;
   $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $8_1 = $5_1 + $28_1 | 0;
   $4_1 = $8_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $6_1 >>> 20 | 0;
   $5_1 = $6_1 + $8_1 | 0;
   $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $5_1;
   $5_1 = $5_1 + $29_1 | 0;
   $6_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $8_1 = $6_1 << 12 | $5_1 >>> 20;
   $4_1 = $5_1 << 12;
   $5_1 = $13_1;
   $13_1 = $4_1 | $5_1 >>> 20;
   $7_1 = $13_1 + $11_1 | 0;
   $4_1 = $1_1 + $8_1 | 0;
   $13_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $8_1 = $7_1;
   $4_1 = $13_1 << 4 | $8_1 >>> 28;
   $9_1 = $8_1 << 4 & -16;
   $7_1 = $4_1 & 16777215;
   $18_1 = $5_1;
   $69($33_1, $9_1 | $5_1 >>> 16 & 15, $7_1, 0, 0, 977, 1, 0, 0);
   $9_1 = $17_1;
   $28_1 = HEAP32[$9_1 + 80 >> 2];
   $5_1 = HEAP32[$9_1 + 320 >> 2];
   $12_1 = $28_1 + $5_1 | 0;
   $38_1 = HEAP32[$9_1 + 84 >> 2];
   $4_1 = $38_1 + HEAP32[$9_1 + 324 >> 2] | 0;
   HEAP32[$9_1 + 424 >> 2] = $12_1;
   $7_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$9_1 + 428 >> 2] = $7_1 & 1048575;
   $42_1 = $9_1 + 256 | 0;
   $69($42_1, $27_1, $26_1, 0, 0, $31_1, $35_1, 0, 0);
   $44_1 = $9_1 - -64 | 0;
   $69($44_1, $43_1, $30_1, 0, 0, $25_1, $19_1, 0, 0);
   $36_1 = $9_1 + 288 | 0;
   $69($36_1, $22_1, $21_1, 0, 0, $22_1, $21_1, 0, 0);
   $40_1 = $9_1 + 48 | 0;
   $17_1 = $40_1;
   $33_1 = HEAP32[$9_1 + 64 >> 2];
   $5_1 = HEAP32[$9_1 + 288 >> 2];
   $23_1 = $33_1 + $5_1 | 0;
   $41_1 = HEAP32[$9_1 + 68 >> 2];
   $4_1 = $41_1 + HEAP32[$9_1 + 292 >> 2] | 0;
   $5_1 = $5_1 >>> 0 > $23_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $14_1 = $23_1;
   $16_1 = ($1_1 | 0) == ($13_1 | 0) & $8_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $13_1 >>> 0;
   $11_1 = ($1_1 | 0) == ($34_1 | 0) & $11_1 >>> 0 < $37_1 >>> 0 | $1_1 >>> 0 < $34_1 >>> 0;
   $4_1 = $48_1 + 8 | 0;
   $8_1 = HEAP32[$4_1 >> 2];
   $1_1 = $47_1 + 8 | 0;
   $29_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
   $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $8_1 >>> 0 > $29_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $8_1 = $11_1 + $29_1 | 0;
   $4_1 = $8_1 >>> 0 < $29_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $6_1 >>> 20 | 0;
   $1_1 = $6_1 + $8_1 | 0;
   $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $1_1;
   $1_1 = $1_1 + $16_1 | 0;
   $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $1_1 << 12 | $13_1 >>> 20;
   $14_1 = $6_1 + $14_1 | 0;
   $8_1 = $4_1;
   $4_1 = $5_1 + ($4_1 << 12 | $1_1 >>> 20) | 0;
   $11_1 = $6_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $69($17_1, $14_1, $11_1 & 1048575, 0, 0, 15632, 16, 0, 0);
   $29_1 = HEAP32[$9_1 + 48 >> 2];
   $1_1 = HEAP32[$9_1 + 256 >> 2];
   $17_1 = $29_1 + $1_1 | 0;
   $37_1 = HEAP32[$9_1 + 52 >> 2];
   $4_1 = $37_1 + HEAP32[$9_1 + 260 >> 2] | 0;
   $1_1 = $1_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $16_1 = $17_1;
   $12_1 = ($7_1 | 0) == ($38_1 | 0) & $12_1 >>> 0 < $28_1 >>> 0 | $7_1 >>> 0 < $38_1 >>> 0;
   $13_1 = $50_1 + 8 | 0;
   $6_1 = HEAP32[$13_1 >> 2];
   $4_1 = $49_1 + 8 | 0;
   $28_1 = $6_1 + HEAP32[$4_1 >> 2] | 0;
   $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$13_1 + 4 >> 2] | 0;
   $4_1 = $6_1 >>> 0 > $28_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $12_1 + $28_1 | 0;
   $4_1 = $6_1 >>> 0 < $28_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $7_1 = $6_1 << 12 | $7_1 >>> 20;
   $16_1 = $7_1 + $16_1 | 0;
   $13_1 = $4_1;
   $4_1 = $1_1 + ($4_1 << 12 | $6_1 >>> 20) | 0;
   HEAP32[$9_1 + 432 >> 2] = $16_1;
   $12_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$9_1 + 436 >> 2] = $12_1 & 1048575;
   $28_1 = $9_1 + 192 | 0;
   $69($28_1, $25_1, $19_1, 0, 0, $31_1, $35_1, 0, 0);
   $31_1 = $9_1 + 240 | 0;
   $69($31_1, $27_1, $26_1, 0, 0, $27_1, $26_1, 0, 0);
   $27_1 = $9_1 + 32 | 0;
   $69($27_1, $43_1, $30_1, 0, 0, $22_1, $21_1, 0, 0);
   $25_1 = $9_1 + 16 | 0;
   $19_1 = $25_1;
   $14_1 = ($5_1 | 0) == ($11_1 | 0) & $14_1 >>> 0 < $23_1 >>> 0 | $5_1 >>> 0 > $11_1 >>> 0;
   $7_1 = ($5_1 | 0) == ($41_1 | 0) & $23_1 >>> 0 < $33_1 >>> 0 | $5_1 >>> 0 < $41_1 >>> 0;
   $6_1 = $36_1 + 8 | 0;
   $5_1 = HEAP32[$6_1 >> 2];
   $4_1 = $44_1 + 8 | 0;
   $21_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
   $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$6_1 + 4 >> 2] | 0;
   $4_1 = $5_1 >>> 0 > $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $7_1 + $21_1 | 0;
   $4_1 = $6_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $8_1 = $8_1 >>> 20 | 0;
   $5_1 = $6_1 + $8_1 | 0;
   $4_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $5_1;
   $5_1 = $5_1 + $14_1 | 0;
   $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $23_1 = $5_1 << 12 | $11_1 >>> 20;
   $6_1 = HEAP32[$9_1 + 32 >> 2];
   $11_1 = $23_1 + $6_1 | 0;
   $7_1 = $4_1;
   $35_1 = $4_1 << 12 | $5_1 >>> 20;
   $4_1 = $35_1 + HEAP32[$9_1 + 36 >> 2] | 0;
   $21_1 = $6_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $69($19_1, $11_1, $21_1, 0, 0, 15632, 16, 0, 0);
   $26_1 = HEAP32[$9_1 + 192 >> 2];
   $5_1 = HEAP32[$9_1 + 240 >> 2];
   $19_1 = $26_1 + $5_1 | 0;
   $30_1 = HEAP32[$9_1 + 196 >> 2];
   $4_1 = $30_1 + HEAP32[$9_1 + 244 >> 2] | 0;
   $4_1 = $5_1 >>> 0 > $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = HEAP32[$9_1 + 16 >> 2];
   $14_1 = $5_1 + $19_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + HEAP32[$9_1 + 20 >> 2] | 0;
   $5_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $22_1 = ($1_1 | 0) == ($12_1 | 0) & $16_1 >>> 0 < $17_1 >>> 0 | $1_1 >>> 0 > $12_1 >>> 0;
   $16_1 = ($1_1 | 0) == ($37_1 | 0) & $17_1 >>> 0 < $29_1 >>> 0 | $1_1 >>> 0 < $37_1 >>> 0;
   $4_1 = $42_1 + 8 | 0;
   $6_1 = HEAP32[$4_1 >> 2];
   $1_1 = $40_1 + 8 | 0;
   $17_1 = $6_1 + HEAP32[$1_1 >> 2] | 0;
   $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $6_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $16_1 + $17_1 | 0;
   $4_1 = $6_1 >>> 0 < $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $13_1 = $13_1 >>> 20 | 0;
   $1_1 = $6_1 + $13_1 | 0;
   $4_1 = $13_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $1_1;
   $1_1 = $1_1 + $22_1 | 0;
   $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $13_1 = $1_1 << 12 | $12_1 >>> 20;
   $12_1 = $13_1 + $14_1 | 0;
   $6_1 = $4_1;
   $4_1 = $5_1 + ($4_1 << 12 | $1_1 >>> 20) | 0;
   HEAP32[$9_1 + 440 >> 2] = $12_1;
   $13_1 = $12_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$9_1 + 444 >> 2] = $13_1 & 1048575;
   $1_1 = $9_1;
   $16_1 = ($21_1 | 0) == ($35_1 | 0) & $11_1 >>> 0 < $23_1 >>> 0 | $21_1 >>> 0 < $35_1 >>> 0;
   $4_1 = $27_1 + 8 | 0;
   $11_1 = HEAP32[$4_1 >> 2];
   $4_1 = HEAP32[$4_1 + 4 >> 2];
   $7_1 = $7_1 >>> 20 | 0;
   $9_1 = $7_1;
   $7_1 = $7_1 + $11_1 | 0;
   $4_1 = $9_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $9_1 = $7_1;
   $7_1 = $7_1 + $16_1 | 0;
   $4_1 = $9_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $69($1_1, $7_1, $4_1, 0, 0, 64028672, 65536, 0, 0);
   $7_1 = $1_1;
   $21_1 = HEAP32[$1_1 >> 2];
   $1_1 = $24_1 & -2;
   $9_1 = $21_1 + $1_1 | 0;
   $22_1 = HEAP32[$7_1 + 4 >> 2];
   $4_1 = $22_1 + ($20_1 & 1048575) | 0;
   $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $20_1 = ($5_1 | 0) == ($13_1 | 0) & $14_1 >>> 0 > $12_1 >>> 0 | $5_1 >>> 0 > $13_1 >>> 0;
   $14_1 = ($5_1 | 0) == ($8_1 | 0) & $14_1 >>> 0 < $19_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
   $4_1 = $25_1 + 8 | 0;
   $16_1 = HEAP32[$4_1 >> 2];
   $11_1 = HEAP32[$4_1 + 4 >> 2];
   $12_1 = ($8_1 | 0) == ($30_1 | 0) & $19_1 >>> 0 < $26_1 >>> 0 | $8_1 >>> 0 < $30_1 >>> 0;
   $8_1 = $31_1 + 8 | 0;
   $5_1 = HEAP32[$8_1 >> 2];
   $4_1 = $28_1 + 8 | 0;
   $19_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
   $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
   $4_1 = $5_1 >>> 0 > $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $12_1 + $19_1 | 0;
   $4_1 = ($5_1 >>> 0 < $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $11_1 | 0;
   $8_1 = $5_1;
   $5_1 = $5_1 + $16_1 | 0;
   $4_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $8_1 = $5_1 + $14_1 | 0;
   $4_1 = $8_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $6_1 >>> 20 | 0;
   $5_1 = $6_1 + $8_1 | 0;
   $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $5_1;
   $5_1 = $5_1 + $20_1 | 0;
   $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $13_1 = $5_1 << 12 | $13_1 >>> 20;
   $8_1 = $13_1 + $9_1 | 0;
   $6_1 = $4_1;
   $4_1 = $1_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
   HEAP32[$7_1 + 448 >> 2] = $8_1;
   $5_1 = $8_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$7_1 + 452 >> 2] = $5_1 & 1048575;
   $11_1 = $18_1 & 65535;
   $12_1 = ($1_1 | 0) == ($5_1 | 0) & $9_1 >>> 0 > $8_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
   $13_1 = ($1_1 | 0) == ($22_1 | 0) & $9_1 >>> 0 < $21_1 >>> 0 | $1_1 >>> 0 < $22_1 >>> 0;
   $1_1 = $7_1 + 8 | 0;
   $8_1 = $13_1 + HEAP32[$1_1 >> 2] | 0;
   $4_1 = HEAP32[$1_1 + 4 >> 2];
   $4_1 = $8_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $6_1 >>> 20 | 0;
   $1_1 = $6_1 + $8_1 | 0;
   $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $1_1;
   $1_1 = $1_1 + $12_1 | 0;
   $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $1_1 << 12 | $5_1 >>> 20;
   $6_1 = $5_1 + $15_1 | 0;
   $4_1 = $11_1 + ($4_1 << 12 | $1_1 >>> 20) | 0;
   HEAP32[$7_1 + 456 >> 2] = $6_1;
   HEAP32[$7_1 + 460 >> 2] = $5_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $1_1 = $7_1 + 680 | 0;
   $19_1 = $7_1 + 424 | 0;
   $13_1 = $32_1 + 80 | 0;
   $34($1_1, $19_1, $13_1);
   $34($2_1, $39_1, $19_1);
   $34($2_1 + 40 | 0, $39_1 + 40 | 0, $1_1);
   $5_1 = HEAP32[$39_1 + 120 >> 2];
   HEAP32[$2_1 + 80 >> 2] = $5_1;
   $4_1 = $2_1 + 8 | 0;
   $1_1 = HEAP32[$4_1 + 4 >> 2];
   $20_1 = $19_1 + 8 | 0;
   HEAP32[$20_1 >> 2] = HEAP32[$4_1 >> 2];
   HEAP32[$20_1 + 4 >> 2] = $1_1;
   $4_1 = $2_1 + 16 | 0;
   $1_1 = HEAP32[$4_1 + 4 >> 2];
   $18_1 = $19_1 + 16 | 0;
   HEAP32[$18_1 >> 2] = HEAP32[$4_1 >> 2];
   HEAP32[$18_1 + 4 >> 2] = $1_1;
   $4_1 = $2_1 + 24 | 0;
   $1_1 = HEAP32[$4_1 + 4 >> 2];
   $14_1 = $19_1 + 24 | 0;
   HEAP32[$14_1 >> 2] = HEAP32[$4_1 >> 2];
   HEAP32[$14_1 + 4 >> 2] = $1_1;
   $4_1 = $2_1 + 32 | 0;
   $1_1 = HEAP32[$4_1 + 4 >> 2];
   $16_1 = $19_1 + 32 | 0;
   HEAP32[$16_1 >> 2] = HEAP32[$4_1 >> 2];
   HEAP32[$16_1 + 4 >> 2] = $1_1;
   $4_1 = $2_1 + 48 | 0;
   $1_1 = HEAP32[$4_1 + 4 >> 2];
   $11_1 = $19_1 + 48 | 0;
   HEAP32[$11_1 >> 2] = HEAP32[$4_1 >> 2];
   HEAP32[$11_1 + 4 >> 2] = $1_1;
   $4_1 = $2_1 + 56 | 0;
   $1_1 = HEAP32[$4_1 + 4 >> 2];
   $12_1 = $19_1 + 56 | 0;
   HEAP32[$12_1 >> 2] = HEAP32[$4_1 >> 2];
   HEAP32[$12_1 + 4 >> 2] = $1_1;
   $4_1 = $2_1 - -64 | 0;
   $1_1 = HEAP32[$4_1 + 4 >> 2];
   $15_1 = $19_1 - -64 | 0;
   HEAP32[$15_1 >> 2] = HEAP32[$4_1 >> 2];
   HEAP32[$15_1 + 4 >> 2] = $1_1;
   $4_1 = $2_1 + 72 | 0;
   $1_1 = HEAP32[$4_1 + 4 >> 2];
   $9_1 = $19_1 + 72 | 0;
   HEAP32[$9_1 >> 2] = HEAP32[$4_1 >> 2];
   HEAP32[$9_1 + 4 >> 2] = $1_1;
   HEAP32[$7_1 + 544 >> 2] = $5_1;
   $1_1 = HEAP32[$2_1 + 4 >> 2];
   HEAP32[$7_1 + 424 >> 2] = HEAP32[$2_1 >> 2];
   HEAP32[$7_1 + 428 >> 2] = $1_1;
   $1_1 = HEAP32[$2_1 + 44 >> 2];
   HEAP32[$7_1 + 464 >> 2] = HEAP32[$2_1 + 40 >> 2];
   HEAP32[$7_1 + 468 >> 2] = $1_1;
   $5_1 = $39_1 + 112 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $19_1 + 112 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $39_1 + 104 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $19_1 + 104 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $39_1 + 96 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $19_1 + 96 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $39_1 + 88 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $19_1 + 88 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $8_1 = HEAP32[$39_1 + 80 >> 2];
   $6_1 = HEAP32[$39_1 + 84 >> 2];
   $1_1 = HEAP32[$7_1 + 636 >> 2];
   HEAP32[$46_1 >> 2] = HEAP32[$7_1 + 632 >> 2];
   HEAP32[$46_1 + 4 >> 2] = $1_1;
   $5_1 = $32_1 + 88 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $46_1 + 8 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $32_1 + 96 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $46_1 + 16 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $32_1 + 104 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $46_1 + 24 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $32_1 + 112 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $46_1 + 32 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   HEAP32[$7_1 + 504 >> 2] = $8_1;
   HEAP32[$7_1 + 508 >> 2] = $6_1;
   $65($19_1, $19_1, $45_1, $46_1 + 40 | 0);
   HEAP32[$2_1 + 168 >> 2] = 0;
   $1_1 = HEAP32[$7_1 + 428 >> 2];
   HEAP32[$2_1 + 88 >> 2] = HEAP32[$7_1 + 424 >> 2];
   HEAP32[$2_1 + 92 >> 2] = $1_1;
   $4_1 = HEAP32[$20_1 + 4 >> 2];
   $1_1 = $2_1 + 96 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$18_1 + 4 >> 2];
   $1_1 = $2_1 + 104 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$14_1 + 4 >> 2];
   $1_1 = $2_1 + 112 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$16_1 + 4 >> 2];
   $1_1 = $2_1 + 120 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$7_1 + 468 >> 2];
   $1_1 = $2_1 + 128 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$11_1 + 4 >> 2];
   $1_1 = $2_1 + 136 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$12_1 + 4 >> 2];
   $1_1 = $2_1 + 144 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$15_1 + 4 >> 2];
   $1_1 = $2_1 + 152 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$9_1 + 4 >> 2];
   $1_1 = $2_1 + 160 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $65($19_1, $19_1, $45_1, $46_1 + 80 | 0);
   HEAP32[$2_1 + 256 >> 2] = 0;
   $1_1 = HEAP32[$7_1 + 428 >> 2];
   HEAP32[$2_1 + 176 >> 2] = HEAP32[$7_1 + 424 >> 2];
   HEAP32[$2_1 + 180 >> 2] = $1_1;
   $4_1 = HEAP32[$20_1 + 4 >> 2];
   $1_1 = $2_1 + 184 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$18_1 + 4 >> 2];
   $1_1 = $2_1 + 192 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$14_1 + 4 >> 2];
   $1_1 = $2_1 + 200 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$16_1 + 4 >> 2];
   $1_1 = $2_1 + 208 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$7_1 + 468 >> 2];
   $1_1 = $2_1 + 216 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$11_1 + 4 >> 2];
   $1_1 = $2_1 + 224 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$12_1 + 4 >> 2];
   $1_1 = $2_1 + 232 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$15_1 + 4 >> 2];
   $1_1 = $2_1 + 240 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$9_1 + 4 >> 2];
   $1_1 = $2_1 + 248 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $65($19_1, $19_1, $45_1, $46_1 + 120 | 0);
   HEAP32[$2_1 + 344 >> 2] = 0;
   $1_1 = HEAP32[$7_1 + 428 >> 2];
   HEAP32[$2_1 + 264 >> 2] = HEAP32[$7_1 + 424 >> 2];
   HEAP32[$2_1 + 268 >> 2] = $1_1;
   $4_1 = HEAP32[$20_1 + 4 >> 2];
   $1_1 = $2_1 + 272 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$18_1 + 4 >> 2];
   $1_1 = $2_1 + 280 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$14_1 + 4 >> 2];
   $1_1 = $2_1 + 288 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$16_1 + 4 >> 2];
   $1_1 = $2_1 + 296 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$7_1 + 468 >> 2];
   $1_1 = $2_1 + 304 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$11_1 + 4 >> 2];
   $1_1 = $2_1 + 312 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$12_1 + 4 >> 2];
   $1_1 = $2_1 + 320 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$15_1 + 4 >> 2];
   $1_1 = $2_1 + 328 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$9_1 + 4 >> 2];
   $1_1 = $2_1 + 336 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $65($19_1, $19_1, $45_1, $46_1 + 160 | 0);
   HEAP32[$2_1 + 432 >> 2] = 0;
   $1_1 = HEAP32[$7_1 + 428 >> 2];
   HEAP32[$2_1 + 352 >> 2] = HEAP32[$7_1 + 424 >> 2];
   HEAP32[$2_1 + 356 >> 2] = $1_1;
   $4_1 = HEAP32[$20_1 + 4 >> 2];
   $1_1 = $2_1 + 360 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$18_1 + 4 >> 2];
   $1_1 = $2_1 + 368 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$14_1 + 4 >> 2];
   $1_1 = $2_1 + 376 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$16_1 + 4 >> 2];
   $1_1 = $2_1 + 384 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$7_1 + 468 >> 2];
   $1_1 = $2_1 + 392 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$11_1 + 4 >> 2];
   $1_1 = $2_1 + 400 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$12_1 + 4 >> 2];
   $1_1 = $2_1 + 408 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$15_1 + 4 >> 2];
   $1_1 = $2_1 + 416 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$9_1 + 4 >> 2];
   $1_1 = $2_1 + 424 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $65($19_1, $19_1, $45_1, $46_1 + 200 | 0);
   HEAP32[$2_1 + 520 >> 2] = 0;
   $1_1 = HEAP32[$7_1 + 428 >> 2];
   HEAP32[$2_1 + 440 >> 2] = HEAP32[$7_1 + 424 >> 2];
   HEAP32[$2_1 + 444 >> 2] = $1_1;
   $4_1 = HEAP32[$20_1 + 4 >> 2];
   $1_1 = $2_1 + 448 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$18_1 + 4 >> 2];
   $1_1 = $2_1 + 456 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$14_1 + 4 >> 2];
   $1_1 = $2_1 + 464 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$16_1 + 4 >> 2];
   $1_1 = $2_1 + 472 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$7_1 + 468 >> 2];
   $1_1 = $2_1 + 480 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$11_1 + 4 >> 2];
   $1_1 = $2_1 + 488 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$12_1 + 4 >> 2];
   $1_1 = $2_1 + 496 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$15_1 + 4 >> 2];
   $1_1 = $2_1 + 504 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$9_1 + 4 >> 2];
   $1_1 = $2_1 + 512 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $23_1 = $46_1 + 240 | 0;
   $65($19_1, $19_1, $45_1, $23_1);
   HEAP32[$2_1 + 608 >> 2] = 0;
   $1_1 = HEAP32[$7_1 + 428 >> 2];
   HEAP32[$2_1 + 528 >> 2] = HEAP32[$7_1 + 424 >> 2];
   HEAP32[$2_1 + 532 >> 2] = $1_1;
   $4_1 = HEAP32[$20_1 + 4 >> 2];
   $1_1 = $2_1 + 536 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$18_1 + 4 >> 2];
   $1_1 = $2_1 + 544 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$14_1 + 4 >> 2];
   $1_1 = $2_1 + 552 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$16_1 + 4 >> 2];
   $1_1 = $2_1 + 560 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$7_1 + 468 >> 2];
   $1_1 = $2_1 + 568 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$11_1 + 4 >> 2];
   $1_1 = $2_1 + 576 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$12_1 + 4 >> 2];
   $1_1 = $2_1 + 584 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$15_1 + 4 >> 2];
   $1_1 = $2_1 + 592 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$9_1 + 4 >> 2];
   $1_1 = $2_1 + 600 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $6_1 = $46_1 + 280 | 0;
   $65($19_1, $19_1, $45_1, $6_1);
   HEAP32[$2_1 + 696 >> 2] = 0;
   $1_1 = HEAP32[$7_1 + 428 >> 2];
   HEAP32[$2_1 + 616 >> 2] = HEAP32[$7_1 + 424 >> 2];
   HEAP32[$2_1 + 620 >> 2] = $1_1;
   $4_1 = HEAP32[$20_1 + 4 >> 2];
   $1_1 = $2_1 + 624 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$20_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$18_1 + 4 >> 2];
   $1_1 = $2_1 + 632 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$18_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$14_1 + 4 >> 2];
   $1_1 = $2_1 + 640 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$14_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$16_1 + 4 >> 2];
   $1_1 = $2_1 + 648 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$16_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$7_1 + 468 >> 2];
   $1_1 = $2_1 + 656 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$7_1 + 464 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$11_1 + 4 >> 2];
   $1_1 = $2_1 + 664 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$11_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$12_1 + 4 >> 2];
   $1_1 = $2_1 + 672 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$12_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$15_1 + 4 >> 2];
   $1_1 = $2_1 + 680 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$15_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $4_1 = HEAP32[$9_1 + 4 >> 2];
   $1_1 = $2_1 + 688 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$9_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $34($51_1, $19_1 + 80 | 0, $13_1);
   global$0 = $7_1 + 720 | 0;
   $11_1 = global$0 - 928 | 0;
   global$0 = $11_1;
   $8_1 = $2_1 + 616 | 0;
   $7_1 = $8_1 + 72 | 0;
   $5_1 = HEAP32[$7_1 >> 2];
   $13_1 = HEAP32[$8_1 + 44 >> 2];
   $4_1 = HEAP32[$8_1 + 40 >> 2];
   $15_1 = HEAP32[$7_1 + 4 >> 2];
   $1_1 = __wasm_i64_mul($15_1 >>> 16 | 0, 0, 977, 1);
   $9_1 = $4_1 + $1_1 | 0;
   $4_1 = $13_1 + i64toi32_i32$HIGH_BITS | 0;
   HEAP32[$8_1 + 40 >> 2] = $9_1;
   $4_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$8_1 + 44 >> 2] = $4_1 & 1048575;
   $12_1 = $8_1 + 48 | 0;
   $9_1 = HEAP32[$12_1 >> 2];
   $1_1 = $4_1;
   $4_1 = HEAP32[$12_1 + 4 >> 2];
   $1_1 = $1_1 >>> 20 | 0;
   $13_1 = $1_1;
   $1_1 = $1_1 + $9_1 | 0;
   $4_1 = $13_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$12_1 >> 2] = $1_1;
   HEAP32[$12_1 + 4 >> 2] = $4_1 & 1048575;
   $12_1 = $8_1 + 56 | 0;
   $9_1 = HEAP32[$12_1 >> 2];
   $1_1 = $4_1;
   $4_1 = HEAP32[$12_1 + 4 >> 2];
   $1_1 = $1_1 >>> 20 | 0;
   $13_1 = $1_1;
   $1_1 = $1_1 + $9_1 | 0;
   $4_1 = $13_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$12_1 >> 2] = $1_1;
   HEAP32[$12_1 + 4 >> 2] = $4_1 & 1048575;
   $9_1 = $8_1 - -64 | 0;
   $13_1 = HEAP32[$9_1 >> 2];
   $1_1 = $4_1;
   $4_1 = HEAP32[$9_1 + 4 >> 2];
   $1_1 = $1_1 >>> 20 | 0;
   $8_1 = $1_1;
   $1_1 = $1_1 + $13_1 | 0;
   $4_1 = $8_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$9_1 >> 2] = $1_1;
   HEAP32[$9_1 + 4 >> 2] = $4_1 & 1048575;
   $8_1 = $7_1;
   $1_1 = $4_1;
   $4_1 = $15_1 & 65535;
   $1_1 = $1_1 >>> 20 | 0;
   $7_1 = $1_1;
   $1_1 = $1_1 + $5_1 | 0;
   $4_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$8_1 >> 2] = $1_1;
   HEAP32[$8_1 + 4 >> 2] = $4_1;
   $5_1 = $6_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $41_1 = $11_1 + 808 | 0;
   $1_1 = $41_1 + 8 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $6_1 + 16 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $41_1 + 16 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $6_1 + 24 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $41_1 + 24 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $6_1 + 32 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $41_1 + 32 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $1_1 = HEAP32[$6_1 + 4 >> 2];
   HEAP32[$11_1 + 808 >> 2] = HEAP32[$6_1 >> 2];
   HEAP32[$11_1 + 812 >> 2] = $1_1;
   $51_1 = 6;
   $34_1 = $2_1 + 528 | 0;
   $5_1 = $34_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $38_1 = $11_1 + 680 | 0;
   $1_1 = $38_1 + 8 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $34_1 + 16 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $38_1 + 16 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $34_1 + 24 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $38_1 + 24 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $34_1 + 32 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $38_1 + 32 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $34_1 + 48 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $38_1 + 48 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $34_1 + 56 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $38_1 + 56 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $34_1 - -64 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $38_1 - -64 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $5_1 = $34_1 + 72 | 0;
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $38_1 + 72 | 0;
   HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$1_1 + 4 >> 2] = $4_1;
   $1_1 = HEAP32[$34_1 + 4 >> 2];
   HEAP32[$11_1 + 680 >> 2] = HEAP32[$34_1 >> 2];
   HEAP32[$11_1 + 684 >> 2] = $1_1;
   $1_1 = HEAP32[$34_1 + 44 >> 2];
   HEAP32[$11_1 + 720 >> 2] = HEAP32[$34_1 + 40 >> 2];
   HEAP32[$11_1 + 724 >> 2] = $1_1;
   $16_1 = HEAP32[$11_1 + 840 >> 2];
   $7_1 = HEAP32[$11_1 + 844 >> 2];
   $5_1 = HEAP32[$11_1 + 824 >> 2];
   $13_1 = HEAP32[$11_1 + 828 >> 2];
   $31_1 = HEAP32[$11_1 + 816 >> 2];
   $17_1 = HEAP32[$11_1 + 820 >> 2];
   $8_1 = HEAP32[$11_1 + 832 >> 2];
   $6_1 = HEAP32[$11_1 + 836 >> 2];
   $12_1 = HEAP32[$11_1 + 808 >> 2];
   $15_1 = HEAP32[$11_1 + 812 >> 2];
   HEAP32[$11_1 + 800 >> 2] = 0;
   $25_1 = $11_1 + 440 | 0;
   $35_1 = $12_1 << 1;
   $43_1 = $15_1 << 1 | $12_1 >>> 31;
   $69($25_1, $8_1, $6_1, 0, 0, $35_1, $43_1, 0, 0);
   $24_1 = $11_1 + 504 | 0;
   $1_1 = $13_1;
   $13_1 = $31_1 << 1;
   $9_1 = $17_1 << 1 | $31_1 >>> 31;
   $69($24_1, $5_1, $1_1, 0, 0, $13_1, $9_1, 0, 0);
   $20_1 = $11_1 + 632 | 0;
   $4_1 = $7_1;
   $69($20_1, $16_1, $4_1, 0, 0, $16_1, $4_1, 0, 0);
   $18_1 = $11_1 + 616 | 0;
   $69($18_1, HEAP32[$11_1 + 632 >> 2], HEAP32[$11_1 + 636 >> 2], 0, 0, 15632, 16, 0, 0);
   $7_1 = $16_1;
   $4_1 = $4_1 << 1 | $7_1 >>> 31;
   $42_1 = $11_1 + 472 | 0;
   $28_1 = $7_1 << 1;
   $27_1 = $4_1;
   $69($42_1, $28_1, $4_1, 0, 0, $12_1, $15_1, 0, 0);
   $44_1 = $11_1 + 488 | 0;
   $69($44_1, $8_1, $6_1, 0, 0, $13_1, $9_1, 0, 0);
   $36_1 = $11_1 + 568 | 0;
   $69($36_1, $5_1, $1_1, 0, 0, $5_1, $1_1, 0, 0);
   $16_1 = $11_1 + 600 | 0;
   $4_1 = $20_1 + 8 | 0;
   $69($16_1, HEAP32[$4_1 >> 2], HEAP32[$4_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
   $47_1 = $11_1 + 456 | 0;
   $69($47_1, $12_1, $15_1, 0, 0, $12_1, $15_1, 0, 0);
   $48_1 = $11_1 + 536 | 0;
   $69($48_1, $28_1, $27_1, 0, 0, $31_1, $17_1, 0, 0);
   $21_1 = $1_1;
   $30_1 = $5_1;
   $4_1 = $1_1 << 1 | $5_1 >>> 31;
   $49_1 = $11_1 + 584 | 0;
   $26_1 = $8_1;
   $22_1 = $6_1;
   $69($49_1, $8_1, $6_1, 0, 0, $5_1 << 1, $4_1, 0, 0);
   $8_1 = HEAP32[$11_1 + 440 >> 2];
   $5_1 = HEAP32[$11_1 + 504 >> 2];
   $1_1 = $8_1 + $5_1 | 0;
   $15_1 = HEAP32[$11_1 + 444 >> 2];
   $4_1 = $15_1 + HEAP32[$11_1 + 508 >> 2] | 0;
   $4_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = HEAP32[$11_1 + 616 >> 2];
   $19_1 = $5_1 + $1_1 | 0;
   $6_1 = $4_1;
   $4_1 = $4_1 + HEAP32[$11_1 + 620 >> 2] | 0;
   $5_1 = $5_1 >>> 0 > $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $9_1 = ($6_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $19_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
   $4_1 = $18_1 + 8 | 0;
   $13_1 = HEAP32[$4_1 >> 2];
   $7_1 = HEAP32[$4_1 + 4 >> 2];
   $8_1 = ($6_1 | 0) == ($15_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $6_1 >>> 0 < $15_1 >>> 0;
   $4_1 = $24_1 + 8 | 0;
   $6_1 = HEAP32[$4_1 >> 2];
   $1_1 = $25_1 + 8 | 0;
   $15_1 = $6_1 + HEAP32[$1_1 >> 2] | 0;
   $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $6_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $1_1 = $8_1 + $15_1 | 0;
   $4_1 = ($1_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $7_1 | 0;
   $6_1 = $1_1;
   $1_1 = $1_1 + $13_1 | 0;
   $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $1_1;
   $1_1 = $1_1 + $9_1 | 0;
   $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $20_1 = $5_1;
   $13_1 = $1_1 << 12 | $5_1 >>> 20;
   $8_1 = $4_1;
   $7_1 = $4_1 << 12 | $1_1 >>> 20;
   $40_1 = HEAP32[$11_1 + 488 >> 2];
   $1_1 = HEAP32[$11_1 + 568 >> 2];
   $12_1 = $40_1 + $1_1 | 0;
   $37_1 = HEAP32[$11_1 + 492 >> 2];
   $4_1 = $37_1 + HEAP32[$11_1 + 572 >> 2] | 0;
   $4_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $1_1 = HEAP32[$11_1 + 472 >> 2];
   $15_1 = $1_1 + $12_1 | 0;
   $6_1 = $4_1;
   $4_1 = $4_1 + HEAP32[$11_1 + 476 >> 2] | 0;
   $4_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $1_1 = HEAP32[$11_1 + 600 >> 2];
   $9_1 = $1_1 + $15_1 | 0;
   $5_1 = $4_1;
   $4_1 = $4_1 + HEAP32[$11_1 + 604 >> 2] | 0;
   $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $1_1 + $7_1 | 0;
   $33_1 = $11_1 + 376 | 0;
   $29_1 = $33_1;
   $13_1 = $9_1 + $13_1 | 0;
   $7_1 = $13_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $25_1 = ($1_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 > $13_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
   $24_1 = ($1_1 | 0) == ($5_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 < $5_1 >>> 0;
   $1_1 = $16_1 + 8 | 0;
   $18_1 = HEAP32[$1_1 >> 2];
   $14_1 = HEAP32[$1_1 + 4 >> 2];
   $16_1 = ($5_1 | 0) == ($6_1 | 0) & $12_1 >>> 0 > $15_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
   $1_1 = $42_1 + 8 | 0;
   $15_1 = HEAP32[$1_1 >> 2];
   $9_1 = HEAP32[$1_1 + 4 >> 2];
   $6_1 = ($6_1 | 0) == ($37_1 | 0) & $12_1 >>> 0 < $40_1 >>> 0 | $6_1 >>> 0 < $37_1 >>> 0;
   $4_1 = $36_1 + 8 | 0;
   $5_1 = HEAP32[$4_1 >> 2];
   $1_1 = $44_1 + 8 | 0;
   $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
   $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $1_1 = $6_1 + $12_1 | 0;
   $4_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $9_1 | 0;
   $5_1 = $1_1;
   $1_1 = $1_1 + $15_1 | 0;
   $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $1_1;
   $1_1 = $1_1 + $16_1 | 0;
   $4_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $14_1 | 0;
   $5_1 = $1_1;
   $1_1 = $1_1 + $18_1 | 0;
   $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $1_1 + $24_1 | 0;
   $4_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $8_1 >>> 20 | 0;
   $1_1 = $5_1 + $6_1 | 0;
   $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $1_1;
   $1_1 = $1_1 + $25_1 | 0;
   $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $7_1;
   $7_1 = $1_1 << 12 | $5_1 >>> 20;
   $6_1 = $4_1;
   $9_1 = $4_1 << 12 | $1_1 >>> 20;
   $25_1 = HEAP32[$11_1 + 540 >> 2];
   $4_1 = $25_1 + HEAP32[$11_1 + 588 >> 2] | 0;
   $14_1 = HEAP32[$11_1 + 536 >> 2];
   $1_1 = HEAP32[$11_1 + 584 >> 2];
   $8_1 = $14_1 + $1_1 | 0;
   $12_1 = $8_1;
   $7_1 = $8_1 + $7_1 | 0;
   $1_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $1_1 + $9_1 | 0;
   $15_1 = $7_1 << 4 & -16;
   $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $9_1 = ($8_1 << 4 | $7_1 >>> 28) & 16777215;
   $18_1 = $5_1;
   $69($29_1, $15_1 | $5_1 >>> 16 & 15, $9_1, 0, 0, 977, 1, 0, 0);
   $9_1 = $11_1;
   $29_1 = HEAP32[$9_1 + 376 >> 2];
   $5_1 = HEAP32[$9_1 + 456 >> 2];
   $15_1 = $29_1 + $5_1 | 0;
   $50_1 = HEAP32[$9_1 + 380 >> 2];
   $4_1 = $50_1 + HEAP32[$9_1 + 460 >> 2] | 0;
   HEAP32[$9_1 + 888 >> 2] = $15_1;
   $5_1 = $5_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$9_1 + 892 >> 2] = $5_1 & 1048575;
   $37_1 = $9_1 + 360 | 0;
   $69($37_1, $31_1, $17_1, 0, 0, $35_1, $43_1, 0, 0);
   $42_1 = $9_1 + 552 | 0;
   $69($42_1, $28_1, $27_1, 0, 0, $30_1, $21_1, 0, 0);
   $44_1 = $9_1 + 664 | 0;
   $69($44_1, $26_1, $22_1, 0, 0, $26_1, $22_1, 0, 0);
   $36_1 = $9_1 + 424 | 0;
   $24_1 = $36_1;
   $16_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
   $12_1 = ($1_1 | 0) == ($25_1 | 0) & $14_1 >>> 0 > $12_1 >>> 0 | $1_1 >>> 0 < $25_1 >>> 0;
   $4_1 = $49_1 + 8 | 0;
   $7_1 = HEAP32[$4_1 >> 2];
   $1_1 = $48_1 + 8 | 0;
   $14_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
   $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $7_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $7_1 = $14_1 + $12_1 | 0;
   $4_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $6_1 >>> 20 | 0;
   $1_1 = $6_1 + $7_1 | 0;
   $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $1_1;
   $1_1 = $1_1 + $16_1 | 0;
   $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $12_1 = $1_1 << 12 | $8_1 >>> 20;
   $7_1 = $4_1;
   $6_1 = $4_1 << 12 | $1_1 >>> 20;
   $40_1 = HEAP32[$9_1 + 552 >> 2];
   $1_1 = HEAP32[$9_1 + 664 >> 2];
   $25_1 = $40_1 + $1_1 | 0;
   $48_1 = HEAP32[$9_1 + 556 >> 2];
   $4_1 = $48_1 + HEAP32[$9_1 + 668 >> 2] | 0;
   $8_1 = $1_1 >>> 0 > $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $8_1 + $6_1 | 0;
   $14_1 = $12_1 + $25_1 | 0;
   $4_1 = $14_1 >>> 0 < $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $12_1 = $4_1;
   $69($24_1, $14_1, $4_1 & 1048575, 0, 0, 15632, 16, 0, 0);
   $15_1 = ($5_1 | 0) == ($50_1 | 0) & $15_1 >>> 0 < $29_1 >>> 0 | $5_1 >>> 0 < $50_1 >>> 0;
   $4_1 = $47_1 + 8 | 0;
   $6_1 = HEAP32[$4_1 >> 2];
   $1_1 = $33_1 + 8 | 0;
   $16_1 = $6_1 + HEAP32[$1_1 >> 2] | 0;
   $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $6_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $1_1 = $15_1 + $16_1 | 0;
   $4_1 = $1_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $16_1 = $1_1 << 12 | $5_1 >>> 20;
   $6_1 = $4_1;
   $15_1 = $4_1 << 12 | $1_1 >>> 20;
   $33_1 = HEAP32[$9_1 + 424 >> 2];
   $1_1 = HEAP32[$9_1 + 360 >> 2];
   $24_1 = $33_1 + $1_1 | 0;
   $49_1 = HEAP32[$9_1 + 428 >> 2];
   $4_1 = $49_1 + HEAP32[$9_1 + 364 >> 2] | 0;
   $5_1 = $1_1 >>> 0 > $24_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $5_1 + $15_1 | 0;
   $16_1 = $16_1 + $24_1 | 0;
   $4_1 = $16_1 >>> 0 < $24_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$9_1 + 896 >> 2] = $16_1;
   $15_1 = $4_1;
   HEAP32[$9_1 + 900 >> 2] = $4_1 & 1048575;
   $29_1 = $9_1 + 344 | 0;
   $69($29_1, $30_1, $21_1, 0, 0, $35_1, $43_1, 0, 0);
   $35_1 = $9_1 + 520 | 0;
   $69($35_1, $31_1, $17_1, 0, 0, $31_1, $17_1, 0, 0);
   $31_1 = $9_1 + 648 | 0;
   $69($31_1, $28_1, $27_1, 0, 0, $26_1, $22_1, 0, 0);
   $30_1 = $9_1 + 408 | 0;
   $26_1 = $30_1;
   $21_1 = ($8_1 | 0) == ($12_1 | 0) & $14_1 >>> 0 < $25_1 >>> 0 | $8_1 >>> 0 > $12_1 >>> 0;
   $14_1 = ($8_1 | 0) == ($48_1 | 0) & $25_1 >>> 0 < $40_1 >>> 0 | $8_1 >>> 0 < $48_1 >>> 0;
   $4_1 = $44_1 + 8 | 0;
   $8_1 = HEAP32[$4_1 >> 2];
   $1_1 = $42_1 + 8 | 0;
   $22_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
   $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $8_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $8_1 = $14_1 + $22_1 | 0;
   $4_1 = $8_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $7_1 = $7_1 >>> 20 | 0;
   $1_1 = $7_1 + $8_1 | 0;
   $4_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $7_1 = $1_1;
   $1_1 = $1_1 + $21_1 | 0;
   $4_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $22_1 = $1_1 << 12 | $12_1 >>> 20;
   $7_1 = HEAP32[$9_1 + 648 >> 2];
   $12_1 = $22_1 + $7_1 | 0;
   $8_1 = $4_1;
   $25_1 = $4_1 << 12 | $1_1 >>> 20;
   $4_1 = $25_1 + HEAP32[$9_1 + 652 >> 2] | 0;
   $21_1 = $7_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $69($26_1, $12_1, $21_1, 0, 0, 15632, 16, 0, 0);
   $7_1 = $9_1;
   $16_1 = ($5_1 | 0) == ($15_1 | 0) & $16_1 >>> 0 < $24_1 >>> 0 | $5_1 >>> 0 > $15_1 >>> 0;
   $9_1 = ($5_1 | 0) == ($49_1 | 0) & $24_1 >>> 0 < $33_1 >>> 0 | $5_1 >>> 0 < $49_1 >>> 0;
   $4_1 = $37_1 + 8 | 0;
   $5_1 = HEAP32[$4_1 >> 2];
   $1_1 = $36_1 + 8 | 0;
   $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
   $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $9_1 + $14_1 | 0;
   $4_1 = $5_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $6_1 >>> 20 | 0;
   $1_1 = $5_1 + $6_1 | 0;
   $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $1_1;
   $1_1 = $1_1 + $16_1 | 0;
   $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $15_1 = $1_1 << 12 | $15_1 >>> 20;
   $6_1 = $4_1;
   $9_1 = $4_1 << 12 | $1_1 >>> 20;
   $17_1 = HEAP32[$7_1 + 344 >> 2];
   $1_1 = HEAP32[$7_1 + 520 >> 2];
   $14_1 = $17_1 + $1_1 | 0;
   $24_1 = HEAP32[$7_1 + 348 >> 2];
   $4_1 = $24_1 + HEAP32[$7_1 + 524 >> 2] | 0;
   $4_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $1_1 = HEAP32[$7_1 + 408 >> 2];
   $16_1 = $1_1 + $14_1 | 0;
   $5_1 = $4_1;
   $4_1 = $4_1 + HEAP32[$7_1 + 412 >> 2] | 0;
   $1_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $1_1 + $9_1 | 0;
   $15_1 = $15_1 + $16_1 | 0;
   $4_1 = $15_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$7_1 + 904 >> 2] = $15_1;
   $9_1 = $4_1;
   HEAP32[$7_1 + 908 >> 2] = $4_1 & 1048575;
   $26_1 = $7_1 + 392 | 0;
   $22_1 = ($21_1 | 0) == ($25_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $25_1 >>> 0;
   $4_1 = $31_1 + 8 | 0;
   $21_1 = HEAP32[$4_1 >> 2];
   $4_1 = HEAP32[$4_1 + 4 >> 2];
   $8_1 = $8_1 >>> 20 | 0;
   $12_1 = $8_1;
   $8_1 = $8_1 + $21_1 | 0;
   $4_1 = $12_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $12_1 = $8_1;
   $8_1 = $8_1 + $22_1 | 0;
   $4_1 = $12_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $69($26_1, $8_1, $4_1, 0, 0, 64028672, 65536, 0, 0);
   $8_1 = $7_1;
   $21_1 = ($1_1 | 0) == ($9_1 | 0) & $15_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
   $16_1 = ($1_1 | 0) == ($5_1 | 0) & $14_1 >>> 0 > $16_1 >>> 0 | $1_1 >>> 0 < $5_1 >>> 0;
   $1_1 = $30_1 + 8 | 0;
   $12_1 = HEAP32[$1_1 >> 2];
   $15_1 = HEAP32[$1_1 + 4 >> 2];
   $7_1 = ($5_1 | 0) == ($24_1 | 0) & $14_1 >>> 0 < $17_1 >>> 0 | $5_1 >>> 0 < $24_1 >>> 0;
   $4_1 = $35_1 + 8 | 0;
   $5_1 = HEAP32[$4_1 >> 2];
   $1_1 = $29_1 + 8 | 0;
   $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
   $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $1_1 = $7_1 + $14_1 | 0;
   $4_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $15_1 | 0;
   $5_1 = $1_1;
   $1_1 = $1_1 + $12_1 | 0;
   $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $1_1 + $16_1 | 0;
   $4_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $6_1 >>> 20 | 0;
   $1_1 = $5_1 + $6_1 | 0;
   $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $1_1;
   $1_1 = $1_1 + $21_1 | 0;
   $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $7_1 = $1_1 << 12 | $9_1 >>> 20;
   $6_1 = $4_1;
   $15_1 = $4_1 << 12 | $1_1 >>> 20;
   $16_1 = HEAP32[$8_1 + 396 >> 2];
   $4_1 = $16_1 + ($20_1 & 1048575) | 0;
   $12_1 = HEAP32[$8_1 + 392 >> 2];
   $5_1 = $19_1 & -2;
   $1_1 = $12_1 + $5_1 | 0;
   $9_1 = $1_1;
   $7_1 = $1_1 + $7_1 | 0;
   $5_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $5_1 + $15_1 | 0;
   HEAP32[$8_1 + 912 >> 2] = $7_1;
   $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$8_1 + 916 >> 2] = $1_1 & 1048575;
   $15_1 = $18_1 & 65535;
   $7_1 = ($1_1 | 0) == ($5_1 | 0) & $9_1 >>> 0 > $7_1 >>> 0 | $1_1 >>> 0 < $5_1 >>> 0;
   $5_1 = ($5_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $5_1 >>> 0 < $16_1 >>> 0;
   $4_1 = $26_1 + 8 | 0;
   $8_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
   $4_1 = HEAP32[$4_1 + 4 >> 2];
   $4_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $6_1 >>> 20 | 0;
   $5_1 = $6_1 + $8_1 | 0;
   $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $5_1;
   $5_1 = $5_1 + $7_1 | 0;
   $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $1_1 = $5_1 << 12 | $1_1 >>> 20;
   $6_1 = $1_1 + $13_1 | 0;
   $4_1 = $15_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
   HEAP32[$11_1 + 920 >> 2] = $6_1;
   HEAP32[$11_1 + 924 >> 2] = $1_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $11_1 + 848 | 0;
   $1_1 = $11_1 + 888 | 0;
   $34($4_1, $1_1, $41_1);
   $34($34_1, $38_1, $1_1);
   $39_1 = $38_1 + 40 | 0;
   $34($34_1 + 40 | 0, $39_1, $4_1);
   HEAP32[$34_1 + 80 >> 2] = 0;
   $35_1 = $23_1;
   $32_1 = $2_1 + 440 | 0;
   while (1) {
    $50_1 = $11_1 + 808 | 0;
    $34($50_1, $50_1, $35_1);
    $5_1 = $32_1 + 32 | 0;
    $4_1 = HEAP32[$5_1 + 4 >> 2];
    $34_1 = $11_1 + 680 | 0;
    $1_1 = $34_1 + 32 | 0;
    HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
    HEAP32[$1_1 + 4 >> 2] = $4_1;
    $5_1 = $32_1 + 24 | 0;
    $4_1 = HEAP32[$5_1 + 4 >> 2];
    $1_1 = $34_1 + 24 | 0;
    HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
    HEAP32[$1_1 + 4 >> 2] = $4_1;
    $5_1 = $32_1 + 16 | 0;
    $4_1 = HEAP32[$5_1 + 4 >> 2];
    $1_1 = $34_1 + 16 | 0;
    HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
    HEAP32[$1_1 + 4 >> 2] = $4_1;
    $5_1 = $32_1 + 8 | 0;
    $4_1 = HEAP32[$5_1 + 4 >> 2];
    $1_1 = $34_1 + 8 | 0;
    HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
    HEAP32[$1_1 + 4 >> 2] = $4_1;
    $47_1 = $32_1 + 40 | 0;
    $1_1 = HEAP32[$47_1 + 4 >> 2];
    HEAP32[$39_1 >> 2] = HEAP32[$47_1 >> 2];
    HEAP32[$39_1 + 4 >> 2] = $1_1;
    $5_1 = $32_1 + 48 | 0;
    $4_1 = HEAP32[$5_1 + 4 >> 2];
    $1_1 = $39_1 + 8 | 0;
    HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
    HEAP32[$1_1 + 4 >> 2] = $4_1;
    $5_1 = $32_1 + 56 | 0;
    $4_1 = HEAP32[$5_1 + 4 >> 2];
    $1_1 = $39_1 + 16 | 0;
    HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
    HEAP32[$1_1 + 4 >> 2] = $4_1;
    $5_1 = $32_1 - -64 | 0;
    $4_1 = HEAP32[$5_1 + 4 >> 2];
    $1_1 = $39_1 + 24 | 0;
    HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
    HEAP32[$1_1 + 4 >> 2] = $4_1;
    $5_1 = $32_1 + 72 | 0;
    $4_1 = HEAP32[$5_1 + 4 >> 2];
    $1_1 = $39_1 + 32 | 0;
    HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
    HEAP32[$1_1 + 4 >> 2] = $4_1;
    $1_1 = HEAP32[$32_1 + 4 >> 2];
    HEAP32[$11_1 + 680 >> 2] = HEAP32[$32_1 >> 2];
    HEAP32[$11_1 + 684 >> 2] = $1_1;
    HEAP32[$11_1 + 800 >> 2] = 0;
    $1_1 = HEAP32[$11_1 + 812 >> 2];
    $18_1 = $1_1;
    $14_1 = HEAP32[$11_1 + 808 >> 2];
    $7_1 = $14_1;
    $4_1 = $1_1 << 1 | $7_1 >>> 31;
    $12_1 = $11_1 + 72 | 0;
    $26_1 = HEAP32[$11_1 + 832 >> 2];
    $22_1 = HEAP32[$11_1 + 836 >> 2];
    $25_1 = $7_1 << 1;
    $30_1 = $4_1;
    $69($12_1, $26_1, $22_1, 0, 0, $25_1, $4_1, 0, 0);
    $1_1 = HEAP32[$11_1 + 820 >> 2];
    $38_1 = $1_1;
    $41_1 = HEAP32[$11_1 + 816 >> 2];
    $5_1 = $41_1;
    $4_1 = $1_1 << 1 | $5_1 >>> 31;
    $15_1 = $11_1 + 280 | 0;
    $23_1 = HEAP32[$11_1 + 824 >> 2];
    $21_1 = HEAP32[$11_1 + 828 >> 2];
    $5_1 = $5_1 << 1;
    $6_1 = $4_1;
    $69($15_1, $23_1, $21_1, 0, 0, $5_1, $4_1, 0, 0);
    $9_1 = $11_1 + 232 | 0;
    $8_1 = HEAP32[$11_1 + 840 >> 2];
    $1_1 = HEAP32[$11_1 + 844 >> 2];
    $69($9_1, $8_1, $1_1, 0, 0, $8_1, $1_1, 0, 0);
    $13_1 = $11_1 + 216 | 0;
    $69($13_1, HEAP32[$11_1 + 232 >> 2], HEAP32[$11_1 + 236 >> 2], 0, 0, 15632, 16, 0, 0);
    $4_1 = $1_1 << 1 | $8_1 >>> 31;
    $36_1 = $11_1 + 184 | 0;
    $31_1 = $8_1 << 1;
    $24_1 = $4_1;
    $69($36_1, $31_1, $4_1, 0, 0, $7_1, $18_1, 0, 0);
    $40_1 = $11_1 + 88 | 0;
    $69($40_1, $26_1, $22_1, 0, 0, $5_1, $6_1, 0, 0);
    $33_1 = $11_1 + 264 | 0;
    $69($33_1, $23_1, $21_1, 0, 0, $23_1, $21_1, 0, 0);
    $16_1 = $11_1 + 200 | 0;
    $1_1 = $9_1 + 8 | 0;
    $69($16_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $49_1 = $11_1 + 328 | 0;
    $69($49_1, $7_1, $18_1, 0, 0, $7_1, $18_1, 0, 0);
    $37_1 = $11_1 + 168 | 0;
    $69($37_1, $31_1, $4_1, 0, 0, $41_1, $38_1, 0, 0);
    $42_1 = $11_1 + 104 | 0;
    $69($42_1, $26_1, $22_1, 0, 0, $23_1 << 1, $21_1 << 1 | $23_1 >>> 31, 0, 0);
    $8_1 = HEAP32[$11_1 + 72 >> 2];
    $5_1 = HEAP32[$11_1 + 280 >> 2];
    $1_1 = $8_1 + $5_1 | 0;
    $14_1 = HEAP32[$11_1 + 76 >> 2];
    $4_1 = $14_1 + HEAP32[$11_1 + 284 >> 2] | 0;
    $4_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = HEAP32[$11_1 + 216 >> 2];
    $19_1 = $5_1 + $1_1 | 0;
    $6_1 = $4_1;
    $4_1 = $4_1 + HEAP32[$11_1 + 220 >> 2] | 0;
    $5_1 = $5_1 >>> 0 > $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $9_1 = ($6_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 > $19_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
    $4_1 = $13_1 + 8 | 0;
    $13_1 = HEAP32[$4_1 >> 2];
    $7_1 = HEAP32[$4_1 + 4 >> 2];
    $8_1 = ($6_1 | 0) == ($14_1 | 0) & $1_1 >>> 0 < $8_1 >>> 0 | $6_1 >>> 0 < $14_1 >>> 0;
    $4_1 = $15_1 + 8 | 0;
    $6_1 = HEAP32[$4_1 >> 2];
    $1_1 = $12_1 + 8 | 0;
    $15_1 = $6_1 + HEAP32[$1_1 >> 2] | 0;
    $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $4_1 = $6_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $1_1 = $8_1 + $15_1 | 0;
    $4_1 = ($1_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $7_1 | 0;
    $6_1 = $1_1;
    $1_1 = $1_1 + $13_1 | 0;
    $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $1_1;
    $1_1 = $1_1 + $9_1 | 0;
    $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $20_1 = $5_1;
    $13_1 = $1_1 << 12 | $5_1 >>> 20;
    $8_1 = $4_1;
    $7_1 = $4_1 << 12 | $1_1 >>> 20;
    $29_1 = HEAP32[$11_1 + 88 >> 2];
    $1_1 = HEAP32[$11_1 + 264 >> 2];
    $12_1 = $29_1 + $1_1 | 0;
    $44_1 = HEAP32[$11_1 + 92 >> 2];
    $4_1 = $44_1 + HEAP32[$11_1 + 268 >> 2] | 0;
    $4_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $1_1 = HEAP32[$11_1 + 184 >> 2];
    $15_1 = $1_1 + $12_1 | 0;
    $6_1 = $4_1;
    $4_1 = $4_1 + HEAP32[$11_1 + 188 >> 2] | 0;
    $4_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $1_1 = HEAP32[$11_1 + 200 >> 2];
    $9_1 = $1_1 + $15_1 | 0;
    $5_1 = $4_1;
    $4_1 = $4_1 + HEAP32[$11_1 + 204 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $1_1 + $7_1 | 0;
    $28_1 = $11_1 + 8 | 0;
    $13_1 = $9_1 + $13_1 | 0;
    $7_1 = $13_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $27_1 = ($1_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 > $13_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
    $17_1 = ($1_1 | 0) == ($5_1 | 0) & $9_1 >>> 0 < $15_1 >>> 0 | $1_1 >>> 0 < $5_1 >>> 0;
    $1_1 = $16_1 + 8 | 0;
    $18_1 = HEAP32[$1_1 >> 2];
    $14_1 = HEAP32[$1_1 + 4 >> 2];
    $16_1 = ($5_1 | 0) == ($6_1 | 0) & $12_1 >>> 0 > $15_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
    $1_1 = $36_1 + 8 | 0;
    $15_1 = HEAP32[$1_1 >> 2];
    $9_1 = HEAP32[$1_1 + 4 >> 2];
    $6_1 = ($6_1 | 0) == ($44_1 | 0) & $12_1 >>> 0 < $29_1 >>> 0 | $6_1 >>> 0 < $44_1 >>> 0;
    $4_1 = $33_1 + 8 | 0;
    $5_1 = HEAP32[$4_1 >> 2];
    $1_1 = $40_1 + 8 | 0;
    $12_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $4_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $1_1 = $6_1 + $12_1 | 0;
    $4_1 = ($1_1 >>> 0 < $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $9_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $15_1 | 0;
    $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $16_1 | 0;
    $4_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $14_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $18_1 | 0;
    $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = $1_1 + $17_1 | 0;
    $4_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $8_1 >>> 20 | 0;
    $1_1 = $5_1 + $6_1 | 0;
    $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $27_1 | 0;
    $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = $7_1;
    $7_1 = $1_1 << 12 | $5_1 >>> 20;
    $6_1 = $4_1;
    $9_1 = $4_1 << 12 | $1_1 >>> 20;
    $27_1 = HEAP32[$11_1 + 172 >> 2];
    $4_1 = $27_1 + HEAP32[$11_1 + 108 >> 2] | 0;
    $14_1 = HEAP32[$11_1 + 168 >> 2];
    $1_1 = HEAP32[$11_1 + 104 >> 2];
    $8_1 = $14_1 + $1_1 | 0;
    $12_1 = $8_1;
    $7_1 = $8_1 + $7_1 | 0;
    $1_1 = $1_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $1_1 + $9_1 | 0;
    $15_1 = $7_1 << 4 & -16;
    $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $9_1 = ($8_1 << 4 | $7_1 >>> 28) & 16777215;
    $18_1 = $5_1;
    $69($28_1, $15_1 | $5_1 >>> 16 & 15, $9_1, 0, 0, 977, 1, 0, 0);
    $9_1 = $11_1;
    $43_1 = HEAP32[$9_1 + 8 >> 2];
    $5_1 = HEAP32[$9_1 + 328 >> 2];
    $15_1 = $43_1 + $5_1 | 0;
    $48_1 = HEAP32[$9_1 + 12 >> 2];
    $4_1 = $48_1 + HEAP32[$9_1 + 332 >> 2] | 0;
    HEAP32[$9_1 + 888 >> 2] = $15_1;
    $5_1 = $5_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    HEAP32[$9_1 + 892 >> 2] = $5_1 & 1048575;
    $44_1 = $9_1 + 312 | 0;
    $69($44_1, $41_1, $38_1, 0, 0, $25_1, $30_1, 0, 0);
    $36_1 = $9_1 + 152 | 0;
    $69($36_1, $31_1, $24_1, 0, 0, $23_1, $21_1, 0, 0);
    $40_1 = $9_1 + 120 | 0;
    $69($40_1, $26_1, $22_1, 0, 0, $26_1, $22_1, 0, 0);
    $33_1 = $9_1 + 56 | 0;
    $17_1 = $33_1;
    $16_1 = ($1_1 | 0) == ($8_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
    $12_1 = ($1_1 | 0) == ($27_1 | 0) & $14_1 >>> 0 > $12_1 >>> 0 | $1_1 >>> 0 < $27_1 >>> 0;
    $4_1 = $42_1 + 8 | 0;
    $7_1 = HEAP32[$4_1 >> 2];
    $1_1 = $37_1 + 8 | 0;
    $14_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
    $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $4_1 = $7_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $7_1 = $14_1 + $12_1 | 0;
    $4_1 = $7_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $6_1 >>> 20 | 0;
    $1_1 = $6_1 + $7_1 | 0;
    $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $1_1;
    $1_1 = $1_1 + $16_1 | 0;
    $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $16_1 = $1_1 << 12 | $8_1 >>> 20;
    $7_1 = $4_1;
    $12_1 = $4_1 << 12 | $1_1 >>> 20;
    $37_1 = HEAP32[$9_1 + 156 >> 2];
    $4_1 = $37_1 + HEAP32[$9_1 + 124 >> 2] | 0;
    $29_1 = HEAP32[$9_1 + 152 >> 2];
    $6_1 = HEAP32[$9_1 + 120 >> 2];
    $1_1 = $29_1 + $6_1 | 0;
    $27_1 = $1_1;
    $14_1 = $1_1 + $16_1 | 0;
    $8_1 = $1_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $8_1 + $12_1 | 0;
    $12_1 = $14_1 >>> 0 < $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $69($17_1, $14_1, $12_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $15_1 = ($5_1 | 0) == ($48_1 | 0) & $15_1 >>> 0 < $43_1 >>> 0 | $5_1 >>> 0 < $48_1 >>> 0;
    $4_1 = $49_1 + 8 | 0;
    $6_1 = HEAP32[$4_1 >> 2];
    $1_1 = $28_1 + 8 | 0;
    $16_1 = $6_1 + HEAP32[$1_1 >> 2] | 0;
    $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $4_1 = $6_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $1_1 = $15_1 + $16_1 | 0;
    $4_1 = $1_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $16_1 = $1_1 << 12 | $5_1 >>> 20;
    $6_1 = $4_1;
    $15_1 = $4_1 << 12 | $1_1 >>> 20;
    $28_1 = HEAP32[$9_1 + 56 >> 2];
    $1_1 = HEAP32[$9_1 + 312 >> 2];
    $17_1 = $28_1 + $1_1 | 0;
    $42_1 = HEAP32[$9_1 + 60 >> 2];
    $4_1 = $42_1 + HEAP32[$9_1 + 316 >> 2] | 0;
    $5_1 = $1_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $5_1 + $15_1 | 0;
    $16_1 = $16_1 + $17_1 | 0;
    $4_1 = $16_1 >>> 0 < $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    HEAP32[$9_1 + 896 >> 2] = $16_1;
    $15_1 = $4_1;
    HEAP32[$9_1 + 900 >> 2] = $4_1 & 1048575;
    $43_1 = $9_1 + 248 | 0;
    $69($43_1, $23_1, $21_1, 0, 0, $25_1, $30_1, 0, 0);
    $30_1 = $9_1 + 296 | 0;
    $69($30_1, $41_1, $38_1, 0, 0, $41_1, $38_1, 0, 0);
    $25_1 = $9_1 + 136 | 0;
    $69($25_1, $31_1, $24_1, 0, 0, $26_1, $22_1, 0, 0);
    $23_1 = $9_1 + 40 | 0;
    $21_1 = ($8_1 | 0) == ($12_1 | 0) & $14_1 >>> 0 < $27_1 >>> 0 | $8_1 >>> 0 > $12_1 >>> 0;
    $14_1 = ($8_1 | 0) == ($37_1 | 0) & $27_1 >>> 0 < $29_1 >>> 0 | $8_1 >>> 0 < $37_1 >>> 0;
    $4_1 = $40_1 + 8 | 0;
    $8_1 = HEAP32[$4_1 >> 2];
    $1_1 = $36_1 + 8 | 0;
    $22_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
    $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $4_1 = $8_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = $14_1 + $22_1 | 0;
    $4_1 = $8_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $7_1 = $7_1 >>> 20 | 0;
    $1_1 = $7_1 + $8_1 | 0;
    $4_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $7_1 = $1_1;
    $1_1 = $1_1 + $21_1 | 0;
    $4_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $22_1 = $1_1 << 12 | $12_1 >>> 20;
    $7_1 = HEAP32[$9_1 + 136 >> 2];
    $12_1 = $22_1 + $7_1 | 0;
    $8_1 = $4_1;
    $27_1 = $4_1 << 12 | $1_1 >>> 20;
    $4_1 = $27_1 + HEAP32[$9_1 + 140 >> 2] | 0;
    $21_1 = $7_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $69($23_1, $12_1, $21_1, 0, 0, 15632, 16, 0, 0);
    $7_1 = $9_1;
    $16_1 = ($5_1 | 0) == ($15_1 | 0) & $16_1 >>> 0 < $17_1 >>> 0 | $5_1 >>> 0 > $15_1 >>> 0;
    $9_1 = ($5_1 | 0) == ($42_1 | 0) & $17_1 >>> 0 < $28_1 >>> 0 | $5_1 >>> 0 < $42_1 >>> 0;
    $4_1 = $44_1 + 8 | 0;
    $5_1 = HEAP32[$4_1 >> 2];
    $1_1 = $33_1 + 8 | 0;
    $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = $9_1 + $14_1 | 0;
    $4_1 = $5_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $6_1 >>> 20 | 0;
    $1_1 = $5_1 + $6_1 | 0;
    $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $16_1 | 0;
    $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $15_1 = $1_1 << 12 | $15_1 >>> 20;
    $6_1 = $4_1;
    $9_1 = $4_1 << 12 | $1_1 >>> 20;
    $17_1 = HEAP32[$7_1 + 248 >> 2];
    $1_1 = HEAP32[$7_1 + 296 >> 2];
    $14_1 = $17_1 + $1_1 | 0;
    $24_1 = HEAP32[$7_1 + 252 >> 2];
    $4_1 = $24_1 + HEAP32[$7_1 + 300 >> 2] | 0;
    $4_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $1_1 = HEAP32[$7_1 + 40 >> 2];
    $16_1 = $1_1 + $14_1 | 0;
    $5_1 = $4_1;
    $4_1 = $4_1 + HEAP32[$7_1 + 44 >> 2] | 0;
    $1_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $1_1 + $9_1 | 0;
    $15_1 = $15_1 + $16_1 | 0;
    $4_1 = $15_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    HEAP32[$7_1 + 904 >> 2] = $15_1;
    $9_1 = $4_1;
    HEAP32[$7_1 + 908 >> 2] = $4_1 & 1048575;
    $26_1 = $7_1 + 24 | 0;
    $22_1 = ($21_1 | 0) == ($27_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $21_1 >>> 0 < $27_1 >>> 0;
    $4_1 = $25_1 + 8 | 0;
    $21_1 = HEAP32[$4_1 >> 2];
    $4_1 = HEAP32[$4_1 + 4 >> 2];
    $8_1 = $8_1 >>> 20 | 0;
    $12_1 = $8_1;
    $8_1 = $8_1 + $21_1 | 0;
    $4_1 = $12_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $12_1 = $8_1;
    $8_1 = $8_1 + $22_1 | 0;
    $4_1 = $12_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $69($26_1, $8_1, $4_1, 0, 0, 64028672, 65536, 0, 0);
    $8_1 = $7_1;
    $21_1 = ($1_1 | 0) == ($9_1 | 0) & $15_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
    $16_1 = ($1_1 | 0) == ($5_1 | 0) & $14_1 >>> 0 > $16_1 >>> 0 | $1_1 >>> 0 < $5_1 >>> 0;
    $1_1 = $23_1 + 8 | 0;
    $12_1 = HEAP32[$1_1 >> 2];
    $15_1 = HEAP32[$1_1 + 4 >> 2];
    $7_1 = ($5_1 | 0) == ($24_1 | 0) & $14_1 >>> 0 < $17_1 >>> 0 | $5_1 >>> 0 < $24_1 >>> 0;
    $4_1 = $30_1 + 8 | 0;
    $5_1 = HEAP32[$4_1 >> 2];
    $1_1 = $43_1 + 8 | 0;
    $14_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
    $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
    $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $1_1 = $7_1 + $14_1 | 0;
    $4_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $15_1 | 0;
    $5_1 = $1_1;
    $1_1 = $1_1 + $12_1 | 0;
    $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = $1_1 + $16_1 | 0;
    $4_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $6_1 >>> 20 | 0;
    $1_1 = $5_1 + $6_1 | 0;
    $4_1 = $6_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = $1_1;
    $1_1 = $1_1 + $21_1 | 0;
    $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $15_1 = $1_1 << 12 | $9_1 >>> 20;
    $6_1 = $4_1;
    $7_1 = $4_1 << 12 | $1_1 >>> 20;
    $12_1 = HEAP32[$8_1 + 24 >> 2];
    $1_1 = $19_1 & -2;
    $9_1 = $12_1 + $1_1 | 0;
    $16_1 = HEAP32[$8_1 + 28 >> 2];
    $4_1 = $16_1 + ($20_1 & 1048575) | 0;
    $5_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $5_1 + $7_1 | 0;
    $7_1 = $9_1 + $15_1 | 0;
    $4_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    HEAP32[$8_1 + 912 >> 2] = $7_1;
    $1_1 = $4_1;
    HEAP32[$8_1 + 916 >> 2] = $4_1 & 1048575;
    $15_1 = $18_1 & 65535;
    $7_1 = ($4_1 | 0) == ($5_1 | 0) & $9_1 >>> 0 > $7_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
    $5_1 = ($5_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $5_1 >>> 0 < $16_1 >>> 0;
    $4_1 = $26_1 + 8 | 0;
    $8_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
    $4_1 = HEAP32[$4_1 + 4 >> 2];
    $4_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $6_1 >>> 20 | 0;
    $5_1 = $6_1 + $8_1 | 0;
    $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $5_1;
    $5_1 = $5_1 + $7_1 | 0;
    $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $1_1 = $5_1 << 12 | $1_1 >>> 20;
    $6_1 = $1_1 + $13_1 | 0;
    $4_1 = $15_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
    HEAP32[$11_1 + 920 >> 2] = $6_1;
    HEAP32[$11_1 + 924 >> 2] = $1_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $11_1 + 848 | 0;
    $1_1 = $11_1 + 888 | 0;
    $34($4_1, $1_1, $50_1);
    $34($32_1, $34_1, $1_1);
    $34($47_1, $39_1, $4_1);
    HEAP32[$32_1 + 80 >> 2] = 0;
    $32_1 = $32_1 - 88 | 0;
    $35_1 = $35_1 - 40 | 0;
    $51_1 = $51_1 - 1 | 0;
    if ($51_1) {
     continue
    }
    break;
   };
   global$0 = $11_1 + 928 | 0;
   $1_1 = 0;
   $32_1 = ($52_1 | 0) > 0 ? $52_1 : 0;
   while (1) {
    $40_1 = $10_1 - -64 | 0;
    $53_1 = HEAP32[$2_1 >> 2];
    $54_1 = HEAP32[$2_1 + 4 >> 2];
    $69($40_1, $53_1, $54_1, 0, 0, -431719958, 28934, 0, 0);
    $33_1 = $10_1 + 416 | 0;
    $4_1 = $2_1 + 8 | 0;
    $55_1 = HEAP32[$4_1 >> 2];
    $56_1 = HEAP32[$4_1 + 4 >> 2];
    $69($33_1, $55_1, $56_1, 0, 0, -375590839, 799796, 0, 0);
    $29_1 = $10_1 + 336 | 0;
    $4_1 = $2_1 + 16 | 0;
    $57_1 = HEAP32[$4_1 >> 2];
    $58_1 = HEAP32[$4_1 + 4 >> 2];
    $69($29_1, $57_1, $58_1, 0, 0, 1486445587, 479535, 0, 0);
    $26_1 = $10_1 + 256 | 0;
    $4_1 = $2_1 + 24 | 0;
    $59_1 = HEAP32[$4_1 >> 2];
    $60_1 = HEAP32[$4_1 + 4 >> 2];
    $69($26_1, $59_1, $60_1, 0, 0, 1905590766, 617512, 0, 0);
    $5_1 = $10_1 + 176 | 0;
    $4_1 = $2_1 + 32 | 0;
    $61_1 = HEAP32[$4_1 >> 2];
    $45_1 = HEAP32[$4_1 + 4 >> 2];
    $69($5_1, $61_1, $45_1, 0, 0, 1781228924, 31465, 0, 0);
    $19_1 = $10_1 + 160 | 0;
    $69($19_1, HEAP32[$10_1 + 176 >> 2] & -4, HEAP32[$10_1 + 180 >> 2], 0, 0, 15632, 16, 0, 0);
    $34_1 = $10_1 + 80 | 0;
    $69($34_1, $53_1, $54_1, 0, 0, 1781228924, 31465, 0, 0);
    $51_1 = $10_1 + 432 | 0;
    $69($51_1, $55_1, $56_1, 0, 0, -431719958, 28934, 0, 0);
    $50_1 = $10_1 + 352 | 0;
    $69($50_1, $57_1, $58_1, 0, 0, -375590839, 799796, 0, 0);
    $47_1 = $10_1 + 272 | 0;
    $69($47_1, $59_1, $60_1, 0, 0, 1486445587, 479535, 0, 0);
    $48_1 = $10_1 + 192 | 0;
    $69($48_1, $61_1, $45_1, 0, 0, 1905590766, 617512, 0, 0);
    $28_1 = $10_1 + 144 | 0;
    $4_1 = $5_1 + 8 | 0;
    $69($28_1, HEAP32[$4_1 >> 2], HEAP32[$4_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
    $38_1 = $10_1 + 96 | 0;
    $69($38_1, $53_1, $54_1, 0, 0, 1905590766, 617512, 0, 0);
    $41_1 = $10_1 + 448 | 0;
    $69($41_1, $55_1, $56_1, 0, 0, 1781228924, 31465, 0, 0);
    $49_1 = $10_1 + 368 | 0;
    $69($49_1, $57_1, $58_1, 0, 0, -431719958, 28934, 0, 0);
    $37_1 = $10_1 + 288 | 0;
    $69($37_1, $59_1, $60_1, 0, 0, -375590839, 799796, 0, 0);
    $42_1 = $10_1 + 208 | 0;
    $69($42_1, $61_1, $45_1, 0, 0, 1486445587, 479535, 0, 0);
    $44_1 = HEAP32[$10_1 + 432 >> 2];
    $5_1 = HEAP32[$10_1 + 80 >> 2];
    $23_1 = $44_1 + $5_1 | 0;
    $52_1 = HEAP32[$10_1 + 436 >> 2];
    $4_1 = $52_1 + HEAP32[$10_1 + 84 >> 2] | 0;
    $4_1 = $5_1 >>> 0 > $23_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = HEAP32[$10_1 + 352 >> 2];
    $22_1 = $5_1 + $23_1 | 0;
    $24_1 = $4_1;
    $4_1 = $4_1 + HEAP32[$10_1 + 356 >> 2] | 0;
    $4_1 = $5_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = HEAP32[$10_1 + 272 >> 2];
    $21_1 = $5_1 + $22_1 | 0;
    $12_1 = $4_1;
    $4_1 = $4_1 + HEAP32[$10_1 + 276 >> 2] | 0;
    $4_1 = $5_1 >>> 0 > $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = HEAP32[$10_1 + 192 >> 2];
    $20_1 = $5_1 + $21_1 | 0;
    $15_1 = $4_1;
    $4_1 = $4_1 + HEAP32[$10_1 + 196 >> 2] | 0;
    $4_1 = $5_1 >>> 0 > $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = HEAP32[$10_1 + 144 >> 2];
    $18_1 = $5_1 + $20_1 | 0;
    $9_1 = $4_1;
    $4_1 = $4_1 + HEAP32[$10_1 + 148 >> 2] | 0;
    $6_1 = $5_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $43_1 = HEAP32[$10_1 + 416 >> 2];
    $5_1 = HEAP32[$10_1 + 64 >> 2];
    $14_1 = $43_1 + $5_1 | 0;
    $36_1 = HEAP32[$10_1 + 420 >> 2];
    $4_1 = $36_1 + HEAP32[$10_1 + 68 >> 2] | 0;
    $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = HEAP32[$10_1 + 336 >> 2];
    $16_1 = $5_1 + $14_1 | 0;
    $7_1 = $4_1;
    $4_1 = $4_1 + HEAP32[$10_1 + 340 >> 2] | 0;
    $8_1 = $5_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $8_1 + HEAP32[$10_1 + 260 >> 2] | 0;
    $5_1 = HEAP32[$10_1 + 256 >> 2];
    $11_1 = $5_1 + $16_1 | 0;
    $13_1 = HEAP32[$10_1 + 160 >> 2];
    $30_1 = $11_1 + $13_1 | 0;
    $5_1 = $5_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $5_1 + HEAP32[$10_1 + 164 >> 2] | 0;
    $13_1 = $13_1 >>> 0 > $30_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $35_1 = ($5_1 | 0) == ($13_1 | 0) & $11_1 >>> 0 > $30_1 >>> 0 | $5_1 >>> 0 > $13_1 >>> 0;
    $4_1 = $19_1 + 8 | 0;
    $31_1 = HEAP32[$4_1 >> 2];
    $27_1 = HEAP32[$4_1 + 4 >> 2];
    $25_1 = ($5_1 | 0) == ($8_1 | 0) & $11_1 >>> 0 < $16_1 >>> 0 | $5_1 >>> 0 < $8_1 >>> 0;
    $4_1 = $26_1 + 8 | 0;
    $17_1 = HEAP32[$4_1 >> 2];
    $26_1 = HEAP32[$4_1 + 4 >> 2];
    $19_1 = ($7_1 | 0) == ($8_1 | 0) & $14_1 >>> 0 > $16_1 >>> 0 | $7_1 >>> 0 > $8_1 >>> 0;
    $4_1 = $29_1 + 8 | 0;
    $16_1 = HEAP32[$4_1 >> 2];
    $11_1 = HEAP32[$4_1 + 4 >> 2];
    $7_1 = ($7_1 | 0) == ($36_1 | 0) & $14_1 >>> 0 < $43_1 >>> 0 | $7_1 >>> 0 < $36_1 >>> 0;
    $8_1 = $40_1 + 8 | 0;
    $5_1 = HEAP32[$8_1 >> 2];
    $4_1 = $33_1 + 8 | 0;
    $14_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
    $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
    $4_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = $7_1 + $14_1 | 0;
    $4_1 = ($5_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $11_1 | 0;
    $7_1 = $5_1;
    $5_1 = $5_1 + $16_1 | 0;
    $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $7_1 = $5_1;
    $5_1 = $5_1 + $19_1 | 0;
    $4_1 = ($7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $26_1 | 0;
    $7_1 = $5_1;
    $5_1 = $5_1 + $17_1 | 0;
    $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $7_1 = $5_1;
    $5_1 = $5_1 + $25_1 | 0;
    $4_1 = ($7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $27_1 | 0;
    $7_1 = $5_1;
    $5_1 = $5_1 + $31_1 | 0;
    $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $7_1 = $5_1;
    $5_1 = $5_1 + $35_1 | 0;
    $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $19_1 = $13_1;
    $7_1 = $5_1 << 12 | $13_1 >>> 20;
    $11_1 = $7_1 + $18_1 | 0;
    $8_1 = $4_1;
    $4_1 = $6_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
    $16_1 = $7_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $36_1 = HEAP32[$10_1 + 368 >> 2];
    $5_1 = HEAP32[$10_1 + 448 >> 2];
    $17_1 = $36_1 + $5_1 | 0;
    $39_1 = HEAP32[$10_1 + 372 >> 2];
    $4_1 = $39_1 + HEAP32[$10_1 + 452 >> 2] | 0;
    $4_1 = $5_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = HEAP32[$10_1 + 288 >> 2];
    $26_1 = $5_1 + $17_1 | 0;
    $13_1 = $4_1;
    $4_1 = $4_1 + HEAP32[$10_1 + 292 >> 2] | 0;
    $4_1 = $5_1 >>> 0 > $26_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = HEAP32[$10_1 + 208 >> 2];
    $14_1 = $5_1 + $26_1 | 0;
    $7_1 = $4_1;
    $4_1 = $4_1 + HEAP32[$10_1 + 212 >> 2] | 0;
    $5_1 = $5_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $40_1 = ($6_1 | 0) == ($16_1 | 0) & $11_1 >>> 0 < $18_1 >>> 0 | $6_1 >>> 0 > $16_1 >>> 0;
    $33_1 = ($6_1 | 0) == ($9_1 | 0) & $18_1 >>> 0 < $20_1 >>> 0 | $6_1 >>> 0 < $9_1 >>> 0;
    $4_1 = $28_1 + 8 | 0;
    $29_1 = HEAP32[$4_1 >> 2];
    $28_1 = HEAP32[$4_1 + 4 >> 2];
    $43_1 = ($9_1 | 0) == ($15_1 | 0) & $20_1 >>> 0 < $21_1 >>> 0 | $9_1 >>> 0 < $15_1 >>> 0;
    $4_1 = $48_1 + 8 | 0;
    $35_1 = HEAP32[$4_1 >> 2];
    $31_1 = HEAP32[$4_1 + 4 >> 2];
    $27_1 = ($12_1 | 0) == ($15_1 | 0) & $21_1 >>> 0 < $22_1 >>> 0 | $12_1 >>> 0 > $15_1 >>> 0;
    $4_1 = $47_1 + 8 | 0;
    $25_1 = HEAP32[$4_1 >> 2];
    $21_1 = HEAP32[$4_1 + 4 >> 2];
    $20_1 = ($12_1 | 0) == ($24_1 | 0) & $22_1 >>> 0 < $23_1 >>> 0 | $12_1 >>> 0 < $24_1 >>> 0;
    $4_1 = $50_1 + 8 | 0;
    $18_1 = HEAP32[$4_1 >> 2];
    $12_1 = HEAP32[$4_1 + 4 >> 2];
    $15_1 = ($24_1 | 0) == ($52_1 | 0) & $23_1 >>> 0 < $44_1 >>> 0 | $24_1 >>> 0 < $52_1 >>> 0;
    $9_1 = $34_1 + 8 | 0;
    $6_1 = HEAP32[$9_1 >> 2];
    $4_1 = $51_1 + 8 | 0;
    $22_1 = $6_1 + HEAP32[$4_1 >> 2] | 0;
    $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$9_1 + 4 >> 2] | 0;
    $4_1 = $6_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $15_1 + $22_1 | 0;
    $4_1 = ($6_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $12_1 | 0;
    $9_1 = $6_1;
    $6_1 = $6_1 + $18_1 | 0;
    $4_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $9_1 = $6_1;
    $6_1 = $6_1 + $20_1 | 0;
    $4_1 = ($9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $21_1 | 0;
    $9_1 = $6_1;
    $6_1 = $6_1 + $25_1 | 0;
    $4_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $9_1 = $6_1;
    $6_1 = $6_1 + $27_1 | 0;
    $4_1 = ($9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $31_1 | 0;
    $9_1 = $6_1;
    $6_1 = $6_1 + $35_1 | 0;
    $4_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $9_1 = $6_1;
    $6_1 = $6_1 + $43_1 | 0;
    $4_1 = ($9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $28_1 | 0;
    $9_1 = $6_1;
    $6_1 = $6_1 + $29_1 | 0;
    $4_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $9_1 = $6_1 + $33_1 | 0;
    $4_1 = $9_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = $8_1 >>> 20 | 0;
    $6_1 = $9_1 + $8_1 | 0;
    $4_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = $6_1;
    $6_1 = $6_1 + $40_1 | 0;
    $8_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $9_1 = $8_1 << 12 | $6_1 >>> 20;
    $4_1 = $6_1 << 12;
    $6_1 = $16_1;
    $15_1 = $4_1 | $6_1 >>> 20;
    $16_1 = $15_1 + $14_1 | 0;
    $4_1 = $5_1 + $9_1 | 0;
    $12_1 = $15_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $9_1 = $16_1;
    $4_1 = $12_1 << 4 | $9_1 >>> 28;
    $15_1 = $9_1 << 4 & -16;
    $9_1 = $4_1 & 16777215;
    $20_1 = $6_1;
    $69($10_1, $15_1 | $6_1 >>> 16 & 15, $9_1, 0, 0, 977, 1, 0, 0);
    $33_1 = HEAP32[$10_1 + 4 >> 2];
    $4_1 = $33_1 + HEAP32[$10_1 + 100 >> 2] | 0;
    $46_1 = ($10_1 + 2240 | 0) + $1_1 | 0;
    $9_1 = $46_1;
    $29_1 = HEAP32[$10_1 >> 2];
    $6_1 = HEAP32[$10_1 + 96 >> 2];
    $18_1 = $29_1 + $6_1 | 0;
    HEAP32[$9_1 >> 2] = $18_1;
    $15_1 = $6_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    HEAP32[$9_1 + 4 >> 2] = $15_1 & 1048575;
    $51_1 = $10_1 + 112 | 0;
    $69($51_1, $53_1, $54_1, 0, 0, 1486445587, 479535, 0, 0);
    $50_1 = $10_1 + 464 | 0;
    $69($50_1, $55_1, $56_1, 0, 0, 1905590766, 617512, 0, 0);
    $47_1 = $10_1 + 384 | 0;
    $69($47_1, $57_1, $58_1, 0, 0, 1781228924, 31465, 0, 0);
    $28_1 = $10_1 + 304 | 0;
    $69($28_1, $59_1, $60_1, 0, 0, -431719958, 28934, 0, 0);
    $43_1 = $10_1 + 224 | 0;
    $69($43_1, $61_1, $45_1, 0, 0, -375590839, 799796, 0, 0);
    $48_1 = $10_1 + 48 | 0;
    $31_1 = $48_1;
    $35_1 = HEAP32[$10_1 + 304 >> 2];
    $6_1 = HEAP32[$10_1 + 384 >> 2];
    $22_1 = $35_1 + $6_1 | 0;
    $52_1 = HEAP32[$10_1 + 308 >> 2];
    $4_1 = $52_1 + HEAP32[$10_1 + 388 >> 2] | 0;
    $4_1 = $6_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = HEAP32[$10_1 + 224 >> 2];
    $21_1 = $6_1 + $22_1 | 0;
    $9_1 = $4_1;
    $4_1 = $4_1 + HEAP32[$10_1 + 228 >> 2] | 0;
    $6_1 = $6_1 >>> 0 > $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $27_1 = ($5_1 | 0) == ($12_1 | 0) & $14_1 >>> 0 > $16_1 >>> 0 | $5_1 >>> 0 > $12_1 >>> 0;
    $25_1 = ($5_1 | 0) == ($7_1 | 0) & $14_1 >>> 0 < $26_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
    $4_1 = $42_1 + 8 | 0;
    $24_1 = HEAP32[$4_1 >> 2];
    $23_1 = HEAP32[$4_1 + 4 >> 2];
    $26_1 = ($7_1 | 0) == ($13_1 | 0) & $17_1 >>> 0 > $26_1 >>> 0 | $7_1 >>> 0 < $13_1 >>> 0;
    $4_1 = $37_1 + 8 | 0;
    $14_1 = HEAP32[$4_1 >> 2];
    $16_1 = HEAP32[$4_1 + 4 >> 2];
    $13_1 = ($13_1 | 0) == ($39_1 | 0) & $17_1 >>> 0 < $36_1 >>> 0 | $13_1 >>> 0 < $39_1 >>> 0;
    $7_1 = $41_1 + 8 | 0;
    $5_1 = HEAP32[$7_1 >> 2];
    $4_1 = $49_1 + 8 | 0;
    $17_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
    $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
    $4_1 = $5_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = $13_1 + $17_1 | 0;
    $4_1 = ($5_1 >>> 0 < $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $16_1 | 0;
    $7_1 = $5_1;
    $5_1 = $5_1 + $14_1 | 0;
    $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $7_1 = $5_1;
    $5_1 = $5_1 + $26_1 | 0;
    $4_1 = ($7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $23_1 | 0;
    $7_1 = $5_1;
    $5_1 = $5_1 + $24_1 | 0;
    $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $7_1 = $5_1 + $25_1 | 0;
    $4_1 = $7_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = $8_1 >>> 20 | 0;
    $5_1 = $7_1 + $8_1 | 0;
    $4_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $7_1 = $5_1;
    $5_1 = $5_1 + $27_1 | 0;
    $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = $5_1 << 12 | $12_1 >>> 20;
    $14_1 = $8_1 + $21_1 | 0;
    $13_1 = $4_1;
    $4_1 = $6_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
    $16_1 = $8_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $69($31_1, $14_1, $16_1 & 1048575, 0, 0, 15632, 16, 0, 0);
    $17_1 = $46_1 + 8 | 0;
    $49_1 = HEAP32[$10_1 + 464 >> 2];
    $5_1 = HEAP32[$10_1 + 112 >> 2];
    $25_1 = $49_1 + $5_1 | 0;
    $34_1 = HEAP32[$10_1 + 468 >> 2];
    $4_1 = $34_1 + HEAP32[$10_1 + 116 >> 2] | 0;
    $4_1 = $5_1 >>> 0 > $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = HEAP32[$10_1 + 48 >> 2];
    $24_1 = $5_1 + $25_1 | 0;
    $27_1 = $4_1;
    $4_1 = $4_1 + HEAP32[$10_1 + 52 >> 2] | 0;
    $8_1 = $5_1 >>> 0 > $24_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $12_1 = ($15_1 | 0) == ($33_1 | 0) & $18_1 >>> 0 < $29_1 >>> 0 | $15_1 >>> 0 < $33_1 >>> 0;
    $7_1 = $38_1 + 8 | 0;
    $5_1 = HEAP32[$7_1 >> 2];
    $4_1 = $10_1 + 8 | 0;
    $18_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
    $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
    $4_1 = $5_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = $12_1 + $18_1 | 0;
    $4_1 = $5_1 >>> 0 < $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $15_1 = $5_1 << 12 | $15_1 >>> 20;
    $18_1 = $15_1 + $24_1 | 0;
    $7_1 = $4_1;
    $4_1 = $8_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
    HEAP32[$17_1 >> 2] = $18_1;
    $12_1 = $15_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    HEAP32[$17_1 + 4 >> 2] = $12_1 & 1048575;
    $37_1 = $10_1 + 128 | 0;
    $69($37_1, $53_1, $54_1, 0, 0, -375590839, 799796, 0, 0);
    $42_1 = $10_1 + 480 | 0;
    $69($42_1, $55_1, $56_1, 0, 0, 1486445587, 479535, 0, 0);
    $44_1 = $10_1 + 400 | 0;
    $69($44_1, $57_1, $58_1, 0, 0, 1905590766, 617512, 0, 0);
    $36_1 = $10_1 + 320 | 0;
    $69($36_1, $59_1, $60_1, 0, 0, 1781228924, 31465, 0, 0);
    $40_1 = $10_1 + 240 | 0;
    $69($40_1, $61_1, $45_1, 0, 0, -431719958, 28934, 0, 0);
    $33_1 = $10_1 + 32 | 0;
    $31_1 = $33_1;
    $29_1 = HEAP32[$10_1 + 240 >> 2];
    $5_1 = HEAP32[$10_1 + 320 >> 2];
    $23_1 = $29_1 + $5_1 | 0;
    $38_1 = HEAP32[$10_1 + 244 >> 2];
    $4_1 = $38_1 + HEAP32[$10_1 + 324 >> 2] | 0;
    $5_1 = $5_1 >>> 0 > $23_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $17_1 = ($6_1 | 0) == ($16_1 | 0) & $14_1 >>> 0 < $21_1 >>> 0 | $6_1 >>> 0 > $16_1 >>> 0;
    $26_1 = ($6_1 | 0) == ($9_1 | 0) & $21_1 >>> 0 < $22_1 >>> 0 | $6_1 >>> 0 < $9_1 >>> 0;
    $4_1 = $43_1 + 8 | 0;
    $21_1 = HEAP32[$4_1 >> 2];
    $14_1 = HEAP32[$4_1 + 4 >> 2];
    $15_1 = ($9_1 | 0) == ($52_1 | 0) & $22_1 >>> 0 < $35_1 >>> 0 | $9_1 >>> 0 < $52_1 >>> 0;
    $9_1 = $47_1 + 8 | 0;
    $6_1 = HEAP32[$9_1 >> 2];
    $4_1 = $28_1 + 8 | 0;
    $22_1 = $6_1 + HEAP32[$4_1 >> 2] | 0;
    $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$9_1 + 4 >> 2] | 0;
    $4_1 = $6_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $15_1 + $22_1 | 0;
    $4_1 = ($6_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $14_1 | 0;
    $9_1 = $6_1;
    $6_1 = $6_1 + $21_1 | 0;
    $4_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $9_1 = $6_1 + $26_1 | 0;
    $4_1 = $9_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $13_1 = $13_1 >>> 20 | 0;
    $6_1 = $9_1 + $13_1 | 0;
    $4_1 = $13_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $9_1 = $6_1;
    $6_1 = $6_1 + $17_1 | 0;
    $4_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $13_1 = $6_1 << 12 | $16_1 >>> 20;
    $14_1 = $13_1 + $23_1 | 0;
    $15_1 = $4_1;
    $4_1 = $5_1 + ($4_1 << 12 | $6_1 >>> 20) | 0;
    $17_1 = $14_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $69($31_1, $14_1, $17_1, 0, 0, 15632, 16, 0, 0);
    $41_1 = $46_1 + 16 | 0;
    $28_1 = HEAP32[$10_1 + 480 >> 2];
    $6_1 = HEAP32[$10_1 + 128 >> 2];
    $26_1 = $28_1 + $6_1 | 0;
    $47_1 = HEAP32[$10_1 + 484 >> 2];
    $4_1 = $47_1 + HEAP32[$10_1 + 132 >> 2] | 0;
    $4_1 = $6_1 >>> 0 > $26_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = HEAP32[$10_1 + 400 >> 2];
    $22_1 = $6_1 + $26_1 | 0;
    $9_1 = $4_1;
    $4_1 = $4_1 + HEAP32[$10_1 + 404 >> 2] | 0;
    $4_1 = $6_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = HEAP32[$10_1 + 32 >> 2];
    $21_1 = $6_1 + $22_1 | 0;
    $13_1 = $4_1;
    $4_1 = $4_1 + HEAP32[$10_1 + 36 >> 2] | 0;
    $6_1 = $6_1 >>> 0 > $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $43_1 = ($8_1 | 0) == ($12_1 | 0) & $18_1 >>> 0 < $24_1 >>> 0 | $8_1 >>> 0 > $12_1 >>> 0;
    $35_1 = ($8_1 | 0) == ($27_1 | 0) & $25_1 >>> 0 > $24_1 >>> 0 | $8_1 >>> 0 < $27_1 >>> 0;
    $4_1 = $48_1 + 8 | 0;
    $31_1 = HEAP32[$4_1 >> 2];
    $24_1 = HEAP32[$4_1 + 4 >> 2];
    $18_1 = ($27_1 | 0) == ($34_1 | 0) & $25_1 >>> 0 < $49_1 >>> 0 | $27_1 >>> 0 < $34_1 >>> 0;
    $16_1 = $51_1 + 8 | 0;
    $8_1 = HEAP32[$16_1 >> 2];
    $4_1 = $50_1 + 8 | 0;
    $25_1 = $8_1 + HEAP32[$4_1 >> 2] | 0;
    $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$16_1 + 4 >> 2] | 0;
    $4_1 = $8_1 >>> 0 > $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = $18_1 + $25_1 | 0;
    $4_1 = ($8_1 >>> 0 < $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $24_1 | 0;
    $16_1 = $8_1;
    $8_1 = $8_1 + $31_1 | 0;
    $4_1 = $16_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $16_1 = $8_1 + $35_1 | 0;
    $4_1 = $16_1 >>> 0 < $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $7_1 = $7_1 >>> 20 | 0;
    $8_1 = $7_1 + $16_1 | 0;
    $4_1 = $7_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $7_1 = $8_1;
    $8_1 = $8_1 + $43_1 | 0;
    $4_1 = $7_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $12_1 = $8_1 << 12 | $12_1 >>> 20;
    $16_1 = $12_1 + $21_1 | 0;
    $7_1 = $4_1;
    $4_1 = $6_1 + ($4_1 << 12 | $8_1 >>> 20) | 0;
    HEAP32[$41_1 >> 2] = $16_1;
    $12_1 = $12_1 >>> 0 > $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    HEAP32[$41_1 + 4 >> 2] = $12_1 & 1048575;
    $25_1 = $10_1 + 16 | 0;
    $24_1 = $25_1;
    $18_1 = ($5_1 | 0) == ($17_1 | 0) & $14_1 >>> 0 < $23_1 >>> 0 | $5_1 >>> 0 > $17_1 >>> 0;
    $14_1 = ($5_1 | 0) == ($38_1 | 0) & $23_1 >>> 0 < $29_1 >>> 0 | $5_1 >>> 0 < $38_1 >>> 0;
    $8_1 = $36_1 + 8 | 0;
    $5_1 = HEAP32[$8_1 >> 2];
    $4_1 = $40_1 + 8 | 0;
    $17_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
    $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
    $4_1 = $5_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = $14_1 + $17_1 | 0;
    $4_1 = $8_1 >>> 0 < $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $15_1 = $15_1 >>> 20 | 0;
    $5_1 = $8_1 + $15_1 | 0;
    $4_1 = $15_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = $5_1;
    $5_1 = $5_1 + $18_1 | 0;
    $4_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $69($24_1, $5_1, $4_1, 0, 0, 64028672, 65536, 0, 0);
    $31_1 = $46_1 + 24 | 0;
    $27_1 = HEAP32[$10_1 + 20 >> 2];
    $4_1 = $27_1 + ($19_1 & 1048575) | 0;
    $24_1 = HEAP32[$10_1 + 16 >> 2];
    $8_1 = $30_1 + $24_1 | 0;
    $5_1 = $8_1 >>> 0 < $30_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $15_1 = $8_1;
    $23_1 = ($6_1 | 0) == ($12_1 | 0) & $16_1 >>> 0 < $21_1 >>> 0 | $6_1 >>> 0 > $12_1 >>> 0;
    $17_1 = ($6_1 | 0) == ($13_1 | 0) & $21_1 >>> 0 < $22_1 >>> 0 | $6_1 >>> 0 < $13_1 >>> 0;
    $4_1 = $33_1 + 8 | 0;
    $21_1 = HEAP32[$4_1 >> 2];
    $19_1 = HEAP32[$4_1 + 4 >> 2];
    $18_1 = ($9_1 | 0) == ($13_1 | 0) & $22_1 >>> 0 < $26_1 >>> 0 | $9_1 >>> 0 > $13_1 >>> 0;
    $4_1 = $44_1 + 8 | 0;
    $14_1 = HEAP32[$4_1 >> 2];
    $16_1 = HEAP32[$4_1 + 4 >> 2];
    $13_1 = ($9_1 | 0) == ($47_1 | 0) & $26_1 >>> 0 < $28_1 >>> 0 | $9_1 >>> 0 < $47_1 >>> 0;
    $8_1 = $37_1 + 8 | 0;
    $6_1 = HEAP32[$8_1 >> 2];
    $4_1 = $42_1 + 8 | 0;
    $9_1 = $6_1 + HEAP32[$4_1 >> 2] | 0;
    $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
    $4_1 = $6_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $9_1 + $13_1 | 0;
    $4_1 = ($6_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $16_1 | 0;
    $8_1 = $6_1;
    $6_1 = $6_1 + $14_1 | 0;
    $4_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = $6_1;
    $6_1 = $6_1 + $18_1 | 0;
    $4_1 = ($8_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $19_1 | 0;
    $8_1 = $6_1;
    $6_1 = $6_1 + $21_1 | 0;
    $4_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = $6_1 + $17_1 | 0;
    $4_1 = $8_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $7_1 = $7_1 >>> 20 | 0;
    $6_1 = $7_1 + $8_1 | 0;
    $4_1 = $7_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $7_1 = $6_1;
    $6_1 = $6_1 + $23_1 | 0;
    $4_1 = $7_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $13_1 = $6_1 << 12 | $12_1 >>> 20;
    $7_1 = $13_1 + $15_1 | 0;
    $8_1 = $4_1;
    $4_1 = $5_1 + ($4_1 << 12 | $6_1 >>> 20) | 0;
    HEAP32[$31_1 >> 2] = $7_1;
    $6_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    HEAP32[$31_1 + 4 >> 2] = $6_1 & 1048575;
    $12_1 = $46_1 + 32 | 0;
    $9_1 = $20_1 & 65535;
    $13_1 = ($5_1 | 0) == ($6_1 | 0) & $7_1 >>> 0 < $15_1 >>> 0 | $5_1 >>> 0 > $6_1 >>> 0;
    $5_1 = ($5_1 | 0) == ($27_1 | 0) & $15_1 >>> 0 < $24_1 >>> 0 | $5_1 >>> 0 < $27_1 >>> 0;
    $4_1 = $25_1 + 8 | 0;
    $7_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
    $4_1 = HEAP32[$4_1 + 4 >> 2];
    $4_1 = $5_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $8_1 = $8_1 >>> 20 | 0;
    $5_1 = $7_1 + $8_1 | 0;
    $4_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $7_1 = $5_1;
    $5_1 = $5_1 + $13_1 | 0;
    $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $6_1 = $5_1 << 12 | $6_1 >>> 20;
    $8_1 = $6_1 + $11_1 | 0;
    $4_1 = $9_1 + ($4_1 << 12 | $5_1 >>> 20) | 0;
    HEAP32[$12_1 >> 2] = $8_1;
    HEAP32[$12_1 + 4 >> 2] = $6_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $2_1 = $2_1 + 88 | 0;
    $1_1 = $1_1 + 40 | 0;
    if (($1_1 | 0) != 320) {
     continue
    }
    break;
   };
   $2_1 = ($32_1 | 0) < ($62_1 | 0) ? $62_1 : $32_1;
   $1_1 = 1;
  }
  label$8 : {
   if (!$3_1) {
    $12_1 = 0;
    $13_1 = 0;
    break label$8;
   }
   $6_1 = $10_1 + 3648 | 0;
   $4_1 = $6_1 + 24 | 0;
   HEAP32[$4_1 >> 2] = 0;
   HEAP32[$4_1 + 4 >> 2] = 0;
   $5_1 = $10_1 + 3616 | 0;
   $4_1 = $5_1 + 24 | 0;
   HEAP32[$4_1 >> 2] = 0;
   HEAP32[$4_1 + 4 >> 2] = 0;
   HEAP32[$10_1 + 3664 >> 2] = 0;
   HEAP32[$10_1 + 3668 >> 2] = 0;
   HEAP32[$10_1 + 3632 >> 2] = 0;
   HEAP32[$10_1 + 3636 >> 2] = 0;
   $4_1 = HEAP32[$3_1 + 4 >> 2];
   HEAP32[$10_1 + 3648 >> 2] = HEAP32[$3_1 >> 2];
   HEAP32[$10_1 + 3652 >> 2] = $4_1;
   $4_1 = HEAP32[$3_1 + 12 >> 2];
   HEAP32[$10_1 + 3656 >> 2] = HEAP32[$3_1 + 8 >> 2];
   HEAP32[$10_1 + 3660 >> 2] = $4_1;
   $4_1 = HEAP32[$3_1 + 20 >> 2];
   HEAP32[$10_1 + 3616 >> 2] = HEAP32[$3_1 + 16 >> 2];
   HEAP32[$10_1 + 3620 >> 2] = $4_1;
   $4_1 = HEAP32[$3_1 + 28 >> 2];
   HEAP32[$10_1 + 3624 >> 2] = HEAP32[$3_1 + 24 >> 2];
   HEAP32[$10_1 + 3628 >> 2] = $4_1;
   $12_1 = $62($10_1 + 3088 | 0, $6_1, 4);
   $13_1 = $62($10_1 + 2560 | 0, $5_1, 4);
   $2_1 = ($2_1 | 0) < ($12_1 | 0) ? $12_1 : $2_1;
   $2_1 = ($2_1 | 0) < ($13_1 | 0) ? $13_1 : $2_1;
  }
  HEAP32[$0_1 + 120 >> 2] = 1;
  $14_1 = $68($0_1, 120);
  label$10 : {
   if (($2_1 | 0) <= 0) {
    break label$10
   }
   $0_1 = $2_1 - 1 | 0;
   label$11 : {
    if (!$1_1) {
     $0_1 = $0_1 << 2;
     $3_1 = $0_1 + ($10_1 + 3088 | 0) | 0;
     $0_1 = ($10_1 + 2560 | 0) + $0_1 | 0;
     $11_1 = 1;
     while (1) {
      label$14 : {
       if ($11_1) {
        HEAP32[$14_1 + 120 >> 2] = 1;
        $68($14_1, 120);
        break label$14;
       }
       $55($14_1, $14_1);
      }
      label$16 : {
       if (($2_1 | 0) > ($12_1 | 0)) {
        break label$16
       }
       $4_1 = HEAP32[$3_1 >> 2];
       if (!$4_1) {
        break label$16
       }
       $1_1 = $10_1 + 3720 | 0;
       $63($1_1, 655920, $4_1);
       $64($14_1, $14_1, $1_1, $10_1 + 3680 | 0);
      }
      $1_1 = $2_1 - 1 | 0;
      label$17 : {
       if (($2_1 | 0) > ($13_1 | 0)) {
        break label$17
       }
       $4_1 = HEAP32[$0_1 >> 2];
       if (!$4_1) {
        break label$17
       }
       $2_1 = $10_1 + 3720 | 0;
       $63($2_1, 656176, $4_1);
       $64($14_1, $14_1, $2_1, $10_1 + 3680 | 0);
      }
      if (($1_1 | 0) <= 0) {
       break label$11
      }
      $3_1 = $3_1 - 4 | 0;
      $0_1 = $0_1 - 4 | 0;
      $11_1 = HEAP32[$14_1 + 120 >> 2];
      $2_1 = $1_1;
      continue;
     };
    }
    $16_1 = $10_1 + 3760 | 0;
    $3_1 = (($2_1 << 2) + $10_1 | 0) + 1008 | 0;
    $1_1 = $0_1 << 2;
    $0_1 = $1_1 + ($10_1 + 3088 | 0) | 0;
    $11_1 = ($10_1 + 2560 | 0) + $1_1 | 0;
    $7_1 = HEAP32[$10_1 + 1532 >> 2];
    $8_1 = HEAP32[$10_1 + 1528 >> 2];
    $4_1 = 1;
    while (1) {
     label$19 : {
      if ($4_1) {
       HEAP32[$14_1 + 120 >> 2] = 1;
       $68($14_1, 120);
       break label$19;
      }
      $55($14_1, $14_1);
     }
     label$21 : {
      if (($2_1 | 0) > ($8_1 | 0)) {
       break label$21
      }
      $1_1 = HEAP32[$3_1 - 516 >> 2];
      if (!$1_1) {
       break label$21
      }
      label$22 : {
       if (($1_1 | 0) <= 0) {
        $70($10_1 + 3720 | 0, ($10_1 + 1536 | 0) + Math_imul(($1_1 ^ -1) / 2 | 0, 88) | 0, 88);
        $1_1 = HEAP32[$10_1 + 3760 >> 2];
        $4_1 = -3908 - $1_1 | 0;
        $1_1 = 4194299 - (HEAP32[$10_1 + 3764 >> 2] + ($1_1 >>> 0 > 4294963388) | 0) | 0;
        HEAP32[$10_1 + 3760 >> 2] = $4_1;
        HEAP32[$10_1 + 3764 >> 2] = $1_1;
        $1_1 = HEAP32[$10_1 + 3768 >> 2];
        $4_1 = -4 - $1_1 | 0;
        $1_1 = 4194303 - (HEAP32[$10_1 + 3772 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
        HEAP32[$10_1 + 3768 >> 2] = $4_1;
        HEAP32[$10_1 + 3772 >> 2] = $1_1;
        $1_1 = HEAP32[$10_1 + 3776 >> 2];
        $4_1 = -4 - $1_1 | 0;
        $1_1 = 4194303 - (HEAP32[$10_1 + 3780 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
        HEAP32[$10_1 + 3776 >> 2] = $4_1;
        HEAP32[$10_1 + 3780 >> 2] = $1_1;
        $1_1 = HEAP32[$10_1 + 3784 >> 2];
        $4_1 = -4 - $1_1 | 0;
        $1_1 = 4194303 - (HEAP32[$10_1 + 3788 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
        HEAP32[$10_1 + 3784 >> 2] = $4_1;
        HEAP32[$10_1 + 3788 >> 2] = $1_1;
        $1_1 = HEAP32[$10_1 + 3792 >> 2];
        $4_1 = -4 - $1_1 | 0;
        $1_1 = 262143 - (HEAP32[$10_1 + 3796 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
        HEAP32[$10_1 + 3792 >> 2] = $4_1;
        HEAP32[$10_1 + 3796 >> 2] = $1_1;
        break label$22;
       }
       $70($10_1 + 3720 | 0, ($10_1 + 1536 | 0) + Math_imul($1_1 - 1 >>> 1 | 0, 88) | 0, 88);
      }
      $65($14_1, $14_1, $10_1 + 3720 | 0, 0);
     }
     label$24 : {
      if (($2_1 | 0) > ($7_1 | 0)) {
       break label$24
      }
      $1_1 = HEAP32[$3_1 >> 2];
      if (!$1_1) {
       break label$24
      }
      label$25 : {
       if (($1_1 | 0) <= 0) {
        $6_1 = ($1_1 ^ -1) / 2 | 0;
        $9_1 = ($10_1 + 1536 | 0) + Math_imul($6_1, 88) | 0;
        $1_1 = HEAP32[$9_1 + 44 >> 2];
        HEAP32[$16_1 >> 2] = HEAP32[$9_1 + 40 >> 2];
        HEAP32[$16_1 + 4 >> 2] = $1_1;
        $5_1 = $9_1 + 48 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $16_1 + 8 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $9_1 + 56 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $16_1 + 16 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $9_1 - -64 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $16_1 + 24 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $9_1 + 72 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $16_1 + 32 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $9_1 = ($10_1 + 2240 | 0) + Math_imul($6_1, 40) | 0;
        $5_1 = $9_1 + 8 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $6_1 = $10_1 + 3720 | 0;
        $1_1 = $6_1 + 8 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $9_1 + 16 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $6_1 + 16 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $9_1 + 24 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $6_1 + 24 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        $5_1 = $9_1 + 32 | 0;
        $4_1 = HEAP32[$5_1 + 4 >> 2];
        $1_1 = $6_1 + 32 | 0;
        HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
        HEAP32[$1_1 + 4 >> 2] = $4_1;
        HEAP32[$10_1 + 3800 >> 2] = 0;
        $1_1 = HEAP32[$9_1 + 4 >> 2];
        HEAP32[$10_1 + 3720 >> 2] = HEAP32[$9_1 >> 2];
        HEAP32[$10_1 + 3724 >> 2] = $1_1;
        $1_1 = HEAP32[$10_1 + 3760 >> 2];
        $4_1 = -3908 - $1_1 | 0;
        $1_1 = 4194299 - (HEAP32[$10_1 + 3764 >> 2] + ($1_1 >>> 0 > 4294963388) | 0) | 0;
        HEAP32[$10_1 + 3760 >> 2] = $4_1;
        HEAP32[$10_1 + 3764 >> 2] = $1_1;
        $1_1 = HEAP32[$10_1 + 3768 >> 2];
        $4_1 = -4 - $1_1 | 0;
        $1_1 = 4194303 - (HEAP32[$10_1 + 3772 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
        HEAP32[$10_1 + 3768 >> 2] = $4_1;
        HEAP32[$10_1 + 3772 >> 2] = $1_1;
        $1_1 = HEAP32[$10_1 + 3776 >> 2];
        $4_1 = -4 - $1_1 | 0;
        $1_1 = 4194303 - (HEAP32[$10_1 + 3780 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
        HEAP32[$10_1 + 3776 >> 2] = $4_1;
        HEAP32[$10_1 + 3780 >> 2] = $1_1;
        $1_1 = HEAP32[$10_1 + 3784 >> 2];
        $4_1 = -4 - $1_1 | 0;
        $1_1 = 4194303 - (HEAP32[$10_1 + 3788 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
        HEAP32[$10_1 + 3784 >> 2] = $4_1;
        HEAP32[$10_1 + 3788 >> 2] = $1_1;
        $1_1 = HEAP32[$10_1 + 3792 >> 2];
        $4_1 = -4 - $1_1 | 0;
        $1_1 = 262143 - (HEAP32[$10_1 + 3796 >> 2] + ($1_1 >>> 0 > 4294967292) | 0) | 0;
        HEAP32[$10_1 + 3792 >> 2] = $4_1;
        HEAP32[$10_1 + 3796 >> 2] = $1_1;
        break label$25;
       }
       $4_1 = $1_1 - 1 >>> 1 | 0;
       $15_1 = ($10_1 + 1536 | 0) + Math_imul($4_1, 88) | 0;
       $1_1 = HEAP32[$15_1 + 44 >> 2];
       HEAP32[$16_1 >> 2] = HEAP32[$15_1 + 40 >> 2];
       HEAP32[$16_1 + 4 >> 2] = $1_1;
       $9_1 = ($10_1 + 2240 | 0) + Math_imul($4_1, 40) | 0;
       $5_1 = $9_1 + 8 | 0;
       $4_1 = HEAP32[$5_1 + 4 >> 2];
       $6_1 = $10_1 + 3720 | 0;
       $1_1 = $6_1 + 8 | 0;
       HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
       HEAP32[$1_1 + 4 >> 2] = $4_1;
       $5_1 = $9_1 + 16 | 0;
       $4_1 = HEAP32[$5_1 + 4 >> 2];
       $1_1 = $6_1 + 16 | 0;
       HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
       HEAP32[$1_1 + 4 >> 2] = $4_1;
       $5_1 = $9_1 + 24 | 0;
       $4_1 = HEAP32[$5_1 + 4 >> 2];
       $1_1 = $6_1 + 24 | 0;
       HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
       HEAP32[$1_1 + 4 >> 2] = $4_1;
       $5_1 = $9_1 + 32 | 0;
       $4_1 = HEAP32[$5_1 + 4 >> 2];
       $1_1 = $6_1 + 32 | 0;
       HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
       HEAP32[$1_1 + 4 >> 2] = $4_1;
       $5_1 = $15_1 + 48 | 0;
       $4_1 = HEAP32[$5_1 + 4 >> 2];
       $1_1 = $16_1 + 8 | 0;
       HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
       HEAP32[$1_1 + 4 >> 2] = $4_1;
       $5_1 = $15_1 + 56 | 0;
       $4_1 = HEAP32[$5_1 + 4 >> 2];
       $1_1 = $16_1 + 16 | 0;
       HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
       HEAP32[$1_1 + 4 >> 2] = $4_1;
       $5_1 = $15_1 - -64 | 0;
       $4_1 = HEAP32[$5_1 + 4 >> 2];
       $1_1 = $16_1 + 24 | 0;
       HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
       HEAP32[$1_1 + 4 >> 2] = $4_1;
       $5_1 = $15_1 + 72 | 0;
       $4_1 = HEAP32[$5_1 + 4 >> 2];
       $1_1 = $16_1 + 32 | 0;
       HEAP32[$1_1 >> 2] = HEAP32[$5_1 >> 2];
       HEAP32[$1_1 + 4 >> 2] = $4_1;
       HEAP32[$10_1 + 3800 >> 2] = 0;
       $1_1 = HEAP32[$9_1 + 4 >> 2];
       HEAP32[$10_1 + 3720 >> 2] = HEAP32[$9_1 >> 2];
       HEAP32[$10_1 + 3724 >> 2] = $1_1;
      }
      $65($14_1, $14_1, $10_1 + 3720 | 0, 0);
     }
     label$27 : {
      if (($2_1 | 0) > ($12_1 | 0)) {
       break label$27
      }
      $4_1 = HEAP32[$0_1 >> 2];
      if (!$4_1) {
       break label$27
      }
      $1_1 = $10_1 + 3720 | 0;
      $63($1_1, 655920, $4_1);
      $64($14_1, $14_1, $1_1, $10_1 + 3680 | 0);
     }
     $1_1 = $2_1 - 1 | 0;
     label$28 : {
      if (($2_1 | 0) > ($13_1 | 0)) {
       break label$28
      }
      $4_1 = HEAP32[$11_1 >> 2];
      if (!$4_1) {
       break label$28
      }
      $2_1 = $10_1 + 3720 | 0;
      $63($2_1, 656176, $4_1);
      $64($14_1, $14_1, $2_1, $10_1 + 3680 | 0);
     }
     if (($1_1 | 0) <= 0) {
      break label$11
     }
     $0_1 = $0_1 - 4 | 0;
     $11_1 = $11_1 - 4 | 0;
     $3_1 = $3_1 - 4 | 0;
     $4_1 = HEAP32[$14_1 + 120 >> 2];
     $2_1 = $1_1;
     continue;
    };
   }
   if (HEAP32[$14_1 + 120 >> 2]) {
    break label$10
   }
   $0_1 = $14_1 + 80 | 0;
   $34($0_1, $0_1, $10_1 + 3680 | 0);
  }
  global$0 = $10_1 + 3808 | 0;
 }
 
 function $43($0_1, $1_1) {
  var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0;
  $8_1 = global$0 - 48 | 0;
  global$0 = $8_1;
  $3_1 = $8_1 + 8 | 0;
  $54($3_1, $1_1 + 80 | 0);
  $34($3_1, $3_1, $0_1);
  $5_1 = HEAP32[$1_1 + 24 >> 2];
  $4_1 = HEAP32[$1_1 + 28 >> 2];
  $9_1 = HEAP32[$1_1 + 16 >> 2];
  $6_1 = HEAP32[$1_1 + 20 >> 2];
  $3_1 = HEAP32[$1_1 + 8 >> 2];
  $11_1 = HEAP32[$1_1 + 12 >> 2];
  $2_1 = HEAP32[$1_1 >> 2];
  $7_1 = HEAP32[$1_1 + 4 >> 2];
  $12_1 = HEAP32[$1_1 + 32 >> 2];
  $1_1 = HEAP32[$1_1 + 36 >> 2];
  $13_1 = $1_1;
  $0_1 = $2_1;
  $2_1 = __wasm_i64_mul($1_1 >>> 16 | 0, 0, 977, 1);
  $1_1 = $0_1 + $2_1 | 0;
  $0_1 = $7_1 + i64toi32_i32$HIGH_BITS | 0;
  $0_1 = $1_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $2_1 = $1_1;
  $7_1 = $0_1;
  $0_1 = $11_1;
  $1_1 = $7_1 >>> 20 | 0;
  $10_1 = $1_1;
  $1_1 = $1_1 + $3_1 | 0;
  $11_1 = $10_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = $6_1;
  $3_1 = $11_1 >>> 20 | 0;
  $9_1 = $3_1 + $9_1 | 0;
  $6_1 = $3_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = $4_1;
  $3_1 = $6_1 >>> 20 | 0;
  $5_1 = $3_1 + $5_1 | 0;
  $3_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = HEAP32[$8_1 + 8 >> 2];
  $4_1 = $2_1 - $0_1 | 0;
  $14_1 = ($7_1 & 1048575) - (HEAP32[$8_1 + 12 >> 2] + ($0_1 >>> 0 > $2_1 >>> 0) | 0) | 0;
  $0_1 = HEAP32[$8_1 + 40 >> 2];
  $7_1 = $12_1 - $0_1 | 0;
  $0_1 = ($13_1 & 65535) - (HEAP32[$8_1 + 44 >> 2] + ($0_1 >>> 0 > $12_1 >>> 0) | 0) | 0;
  $2_1 = $3_1 >>> 20 | 0;
  $10_1 = $2_1;
  $2_1 = $2_1 + $7_1 | 0;
  $0_1 = ($10_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 262143 | 0;
  $10_1 = $4_1;
  $2_1 = $2_1 - 4 | 0;
  $12_1 = $2_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
  $4_1 = __wasm_i64_mul($12_1 >>> 16 | 0, 0, 977, 1);
  $7_1 = $10_1 + $4_1 | 0;
  $0_1 = $14_1 + i64toi32_i32$HIGH_BITS | 0;
  $0_1 = ($7_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194299 | 0;
  $7_1 = $7_1 - 3908 | 0;
  $0_1 = $7_1 >>> 0 < 4294963388 ? $0_1 + 1 | 0 : $0_1;
  $4_1 = $0_1 & 1048575;
  $15_1 = $4_1;
  $13_1 = $7_1 ^ 976;
  $14_1 = $4_1 ^ 1;
  global$0 = $8_1 + 48 | 0;
  label$1 : {
   if ($7_1 | $4_1) {
    $4_1 = 0;
    if (($13_1 | 0) != -1 | ($14_1 | 0) != 1048575) {
     break label$1
    }
   }
   $4_1 = $2_1;
   $12_1 = $12_1 & 65535;
   $2_1 = HEAP32[$8_1 + 32 >> 2];
   $16_1 = $5_1 - $2_1 | 0;
   $10_1 = ($3_1 & 1048575) - (HEAP32[$8_1 + 36 >> 2] + ($2_1 >>> 0 > $5_1 >>> 0) | 0) | 0;
   $3_1 = HEAP32[$8_1 + 24 >> 2];
   $5_1 = $9_1 - $3_1 | 0;
   $9_1 = ($6_1 & 1048575) - (HEAP32[$8_1 + 28 >> 2] + ($3_1 >>> 0 > $9_1 >>> 0) | 0) | 0;
   $3_1 = $0_1;
   $0_1 = $11_1 & 1048575;
   $3_1 = $3_1 >>> 20 | 0;
   $2_1 = $3_1;
   $3_1 = $1_1 + $3_1 | 0;
   $0_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $2_1 = HEAP32[$8_1 + 16 >> 2];
   $1_1 = ($3_1 - $2_1 | 0) - 4 | 0;
   $0_1 = ($0_1 - (HEAP32[$8_1 + 20 >> 2] + ($3_1 >>> 0 < $2_1 >>> 0) | 0) | 0) + 4194303 | 0;
   $3_1 = $1_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
   $0_1 = $9_1;
   $2_1 = $3_1 >>> 20 | 0;
   $6_1 = $2_1;
   $2_1 = $2_1 + $5_1 | 0;
   $0_1 = ($6_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194303 | 0;
   $2_1 = $2_1 - 4 | 0;
   $9_1 = $2_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
   $0_1 = $10_1;
   $5_1 = $9_1 >>> 20 | 0;
   $6_1 = $5_1;
   $5_1 = $5_1 + $16_1 | 0;
   $0_1 = ($6_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + 4194303 | 0;
   $5_1 = $5_1 - 4 | 0;
   $11_1 = $5_1 >>> 0 < 4294967292 ? $0_1 + 1 | 0 : $0_1;
   $0_1 = $12_1;
   $6_1 = $11_1 >>> 20 | 0;
   $10_1 = $6_1;
   $6_1 = $4_1 + $6_1 | 0;
   $0_1 = $10_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   if (($1_1 & $13_1 & $2_1 & $5_1 & $6_1) == -1) {
    $4_1 = ($3_1 & $14_1 & $9_1 & $11_1 & ($0_1 ^ 983040)) == 1048575
   } else {
    $4_1 = 0
   }
   if ($4_1) {
    $1_1 = 0;
    $0_1 = 0;
   } else {
    $1_1 = $5_1 | ($2_1 | ($1_1 | $7_1)) | $6_1;
    $0_1 = $11_1 & 1048575 | ($9_1 & 1048575 | ($3_1 & 1048575 | $15_1)) | $0_1;
   }
   $4_1 = !($0_1 | $1_1);
  }
  return $4_1;
 }
 
 function $44($0_1, $1_1, $2_1, $3_1, $4_1, $5_1) {
  $0_1 = $0_1 | 0;
  $1_1 = $1_1 | 0;
  $2_1 = $2_1 | 0;
  $3_1 = $3_1 | 0;
  $4_1 = $4_1 | 0;
  $5_1 = $5_1 | 0;
  var $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0;
  $6_1 = global$0 - 224 | 0;
  global$0 = $6_1;
  $38($6_1 + 8 | 0, $1_1, 0);
  $1_1 = $2_1 + 16 | 0;
  $7_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
  $8_1 = $6_1 + 112 | 0;
  $9_1 = $8_1 + 16 | 0;
  HEAP32[$9_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
  HEAP32[$9_1 + 4 >> 2] = $7_1;
  $1_1 = $2_1 + 24 | 0;
  $7_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
  $8_1 = $8_1 + 24 | 0;
  HEAP32[$8_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
  HEAP32[$8_1 + 4 >> 2] = $7_1;
  $1_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
  HEAP32[$6_1 + 112 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
  HEAP32[$6_1 + 116 >> 2] = $1_1;
  $1_1 = $2_1 + 8 | 0;
  $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
  HEAP32[$6_1 + 120 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
  HEAP32[$6_1 + 124 >> 2] = $2_1;
  $1_1 = HEAP32[$6_1 + 12 >> 2];
  $9_1 = HEAP32[$6_1 + 8 >> 2];
  HEAP8[$6_1 + 175 | 0] = $9_1;
  $2_1 = HEAP32[$6_1 + 20 >> 2];
  $10_1 = HEAP32[$6_1 + 16 >> 2];
  HEAP8[$6_1 + 167 | 0] = $10_1;
  $7_1 = HEAP32[$6_1 + 28 >> 2];
  $11_1 = HEAP32[$6_1 + 24 >> 2];
  HEAP8[$6_1 + 159 | 0] = $11_1;
  $8_1 = HEAP32[$6_1 + 36 >> 2];
  $12_1 = HEAP32[$6_1 + 32 >> 2];
  HEAP8[$6_1 + 151 | 0] = $12_1;
  HEAP8[$6_1 + 174 | 0] = ($1_1 & 255) << 24 | $9_1 >>> 8;
  HEAP8[$6_1 + 173 | 0] = ($1_1 & 65535) << 16 | $9_1 >>> 16;
  HEAP8[$6_1 + 172 | 0] = ($1_1 & 16777215) << 8 | $9_1 >>> 24;
  HEAP8[$6_1 + 171 | 0] = $1_1;
  HEAP8[$6_1 + 170 | 0] = $1_1 >>> 8;
  HEAP8[$6_1 + 169 | 0] = $1_1 >>> 16;
  HEAP8[$6_1 + 168 | 0] = $1_1 >>> 24;
  HEAP8[$6_1 + 166 | 0] = ($2_1 & 255) << 24 | $10_1 >>> 8;
  HEAP8[$6_1 + 165 | 0] = ($2_1 & 65535) << 16 | $10_1 >>> 16;
  HEAP8[$6_1 + 164 | 0] = ($2_1 & 16777215) << 8 | $10_1 >>> 24;
  HEAP8[$6_1 + 163 | 0] = $2_1;
  HEAP8[$6_1 + 162 | 0] = $2_1 >>> 8;
  HEAP8[$6_1 + 161 | 0] = $2_1 >>> 16;
  HEAP8[$6_1 + 160 | 0] = $2_1 >>> 24;
  HEAP8[$6_1 + 158 | 0] = ($7_1 & 255) << 24 | $11_1 >>> 8;
  HEAP8[$6_1 + 157 | 0] = ($7_1 & 65535) << 16 | $11_1 >>> 16;
  HEAP8[$6_1 + 156 | 0] = ($7_1 & 16777215) << 8 | $11_1 >>> 24;
  HEAP8[$6_1 + 155 | 0] = $7_1;
  HEAP8[$6_1 + 154 | 0] = $7_1 >>> 8;
  HEAP8[$6_1 + 153 | 0] = $7_1 >>> 16;
  HEAP8[$6_1 + 152 | 0] = $7_1 >>> 24;
  HEAP8[$6_1 + 150 | 0] = ($8_1 & 255) << 24 | $12_1 >>> 8;
  HEAP8[$6_1 + 149 | 0] = ($8_1 & 65535) << 16 | $12_1 >>> 16;
  HEAP8[$6_1 + 148 | 0] = ($8_1 & 16777215) << 8 | $12_1 >>> 24;
  HEAP8[$6_1 + 147 | 0] = $8_1;
  HEAP8[$6_1 + 146 | 0] = $8_1 >>> 8;
  HEAP8[$6_1 + 145 | 0] = $8_1 >>> 16;
  HEAP8[$6_1 + 144 | 0] = $8_1 >>> 24;
  if ($4_1) {
   $1_1 = $4_1 + 24 | 0;
   $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
   $7_1 = $6_1 + 200 | 0;
   HEAP32[$7_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
   HEAP32[$7_1 + 4 >> 2] = $2_1;
   $1_1 = $4_1 + 16 | 0;
   $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
   $7_1 = $6_1 + 192 | 0;
   HEAP32[$7_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
   HEAP32[$7_1 + 4 >> 2] = $2_1;
   $1_1 = $4_1 + 8 | 0;
   $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
   $7_1 = $6_1 + 184 | 0;
   HEAP32[$7_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
   HEAP32[$7_1 + 4 >> 2] = $2_1;
   $1_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
   HEAP32[$6_1 + 176 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
   HEAP32[$6_1 + 180 >> 2] = $1_1;
   $2_1 = 96;
  } else {
   $2_1 = 64
  }
  if ($3_1) {
   $4_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
   $1_1 = ($6_1 + 112 | 0) + $2_1 | 0;
   $7_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
   HEAP8[$1_1 | 0] = $7_1;
   HEAP8[$1_1 + 1 | 0] = $7_1 >>> 8;
   HEAP8[$1_1 + 2 | 0] = $7_1 >>> 16;
   HEAP8[$1_1 + 3 | 0] = $7_1 >>> 24;
   HEAP8[$1_1 + 4 | 0] = $4_1;
   HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
   HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
   HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
   $3_1 = $3_1 + 8 | 0;
   $4_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
   $1_1 = $1_1 + 8 | 0;
   $3_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
   HEAP8[$1_1 | 0] = $3_1;
   HEAP8[$1_1 + 1 | 0] = $3_1 >>> 8;
   HEAP8[$1_1 + 2 | 0] = $3_1 >>> 16;
   HEAP8[$1_1 + 3 | 0] = $3_1 >>> 24;
   HEAP8[$1_1 + 4 | 0] = $4_1;
   HEAP8[$1_1 + 5 | 0] = $4_1 >>> 8;
   HEAP8[$1_1 + 6 | 0] = $4_1 >>> 16;
   HEAP8[$1_1 + 7 | 0] = $4_1 >>> 24;
   $2_1 = $2_1 | 16;
  }
  $1_1 = $6_1 + 112 | 0;
  $45($6_1 + 40 | 0, $1_1, $2_1);
  $2_1 = 0;
  $68($1_1, 112);
  while (1) {
   $46($6_1 + 40 | 0, $0_1);
   $2_1 = $2_1 + 1 | 0;
   if ($5_1 >>> 0 >= $2_1 >>> 0) {
    continue
   }
   break;
  };
  global$0 = $6_1 + 224 | 0;
  return 1;
 }
 
 function $45($0_1, $1_1, $2_1) {
  var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0;
  $3_1 = global$0 - 272 | 0;
  global$0 = $3_1;
  HEAP32[$0_1 >> 2] = 16843009;
  HEAP32[$0_1 + 4 >> 2] = 16843009;
  HEAP32[$0_1 + 32 >> 2] = 0;
  HEAP32[$0_1 + 36 >> 2] = 0;
  $6_1 = $0_1 + 24 | 0;
  HEAP32[$6_1 >> 2] = 16843009;
  HEAP32[$6_1 + 4 >> 2] = 16843009;
  $6_1 = $0_1 + 16 | 0;
  HEAP32[$6_1 >> 2] = 16843009;
  HEAP32[$6_1 + 4 >> 2] = 16843009;
  $6_1 = $0_1 + 8 | 0;
  HEAP32[$6_1 >> 2] = 16843009;
  HEAP32[$6_1 + 4 >> 2] = 16843009;
  $6_1 = $0_1 + 40 | 0;
  HEAP32[$6_1 >> 2] = 0;
  HEAP32[$6_1 + 4 >> 2] = 0;
  $6_1 = $0_1 + 48 | 0;
  HEAP32[$6_1 >> 2] = 0;
  HEAP32[$6_1 + 4 >> 2] = 0;
  $6_1 = $0_1 + 56 | 0;
  HEAP32[$6_1 >> 2] = 0;
  HEAP32[$6_1 + 4 >> 2] = 0;
  $6_1 = $3_1 + 128 | 0;
  HEAP32[$6_1 >> 2] = 528734635;
  HEAP32[$6_1 + 4 >> 2] = 1541459225;
  $6_1 = $3_1 + 120 | 0;
  HEAP32[$6_1 >> 2] = 1359893119;
  HEAP32[$6_1 + 4 >> 2] = -1694144372;
  $6_1 = $3_1 + 112 | 0;
  HEAP32[$6_1 >> 2] = 1013904242;
  HEAP32[$6_1 + 4 >> 2] = -1521486534;
  $6_1 = $3_1 + 200 | 0;
  HEAP32[$6_1 >> 2] = 0;
  HEAP32[$6_1 + 4 >> 2] = 0;
  $6_1 = $3_1 + 208 | 0;
  $4_1 = $6_1 + 56 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $4_1 = $6_1 + 48 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $4_1 = $6_1 + 40 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $4_1 = $6_1 + 32 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $4_1 = $6_1 + 24 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $6_1 = $6_1 + 16 | 0;
  HEAP32[$6_1 >> 2] = 0;
  HEAP32[$6_1 + 4 >> 2] = 0;
  HEAP32[$3_1 + 104 >> 2] = 1779033703;
  HEAP32[$3_1 + 108 >> 2] = -1150833019;
  HEAP32[$3_1 + 216 >> 2] = 0;
  HEAP32[$3_1 + 220 >> 2] = 0;
  HEAP32[$3_1 + 208 >> 2] = 0;
  HEAP32[$3_1 + 212 >> 2] = 0;
  $6_1 = $0_1 + 32 | 0;
  $8_1 = $3_1 + 104 | 0;
  $4_1 = 0;
  while (1) {
   $5_1 = ($3_1 + 208 | 0) + $4_1 | 0;
   HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
   $7_1 = $5_1 + 1 | 0;
   HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
   $7_1 = $5_1 + 2 | 0;
   HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
   $5_1 = $5_1 + 3 | 0;
   HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
   $4_1 = $4_1 + 4 | 0;
   if (($4_1 | 0) != 64) {
    continue
   }
   break;
  };
  $29($8_1, $3_1 + 208 | 0, 64);
  HEAP32[$3_1 + 96 >> 2] = 0;
  HEAP32[$3_1 + 100 >> 2] = 0;
  HEAP32[$3_1 + 24 >> 2] = 528734635;
  HEAP32[$3_1 + 28 >> 2] = 1541459225;
  HEAP32[$3_1 + 16 >> 2] = 1359893119;
  HEAP32[$3_1 + 20 >> 2] = -1694144372;
  HEAP32[$3_1 + 8 >> 2] = 1013904242;
  HEAP32[$3_1 + 12 >> 2] = -1521486534;
  HEAP32[$3_1 >> 2] = 1779033703;
  HEAP32[$3_1 + 4 >> 2] = -1150833019;
  $4_1 = 0;
  while (1) {
   $5_1 = ($3_1 + 208 | 0) + $4_1 | 0;
   HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
   $7_1 = $5_1 + 1 | 0;
   HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
   $7_1 = $5_1 + 2 | 0;
   HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
   $5_1 = $5_1 + 3 | 0;
   HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
   $4_1 = $4_1 + 4 | 0;
   if (($4_1 | 0) != 64) {
    continue
   }
   break;
  };
  $5_1 = $3_1 + 208 | 0;
  $29($3_1, $5_1, 64);
  $29($3_1, $0_1, 32);
  $29($3_1, 690368, 1);
  $29($3_1, $1_1, $2_1);
  $30($3_1, $5_1);
  $29($8_1, $5_1, 32);
  $30($8_1, $6_1);
  $4_1 = $3_1 + 248 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $4_1 = $3_1 + 256 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $4_1 = $3_1 + 264 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $4_1 = $6_1 + 24 | 0;
  $7_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
  $9_1 = $5_1 + 24 | 0;
  HEAP32[$9_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
  HEAP32[$9_1 + 4 >> 2] = $7_1;
  $4_1 = $6_1 + 16 | 0;
  $7_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
  $5_1 = $5_1 + 16 | 0;
  HEAP32[$5_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
  HEAP32[$5_1 + 4 >> 2] = $7_1;
  HEAP32[$3_1 + 200 >> 2] = 0;
  HEAP32[$3_1 + 204 >> 2] = 0;
  HEAP32[$3_1 + 128 >> 2] = 528734635;
  HEAP32[$3_1 + 132 >> 2] = 1541459225;
  HEAP32[$3_1 + 120 >> 2] = 1359893119;
  HEAP32[$3_1 + 124 >> 2] = -1694144372;
  HEAP32[$3_1 + 112 >> 2] = 1013904242;
  HEAP32[$3_1 + 116 >> 2] = -1521486534;
  HEAP32[$3_1 + 104 >> 2] = 1779033703;
  HEAP32[$3_1 + 108 >> 2] = -1150833019;
  HEAP32[$3_1 + 240 >> 2] = 0;
  HEAP32[$3_1 + 244 >> 2] = 0;
  $4_1 = $6_1 + 8 | 0;
  $5_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
  HEAP32[$3_1 + 216 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
  HEAP32[$3_1 + 220 >> 2] = $5_1;
  $4_1 = HEAPU8[$6_1 + 4 | 0] | HEAPU8[$6_1 + 5 | 0] << 8 | (HEAPU8[$6_1 + 6 | 0] << 16 | HEAPU8[$6_1 + 7 | 0] << 24);
  HEAP32[$3_1 + 208 >> 2] = HEAPU8[$6_1 | 0] | HEAPU8[$6_1 + 1 | 0] << 8 | (HEAPU8[$6_1 + 2 | 0] << 16 | HEAPU8[$6_1 + 3 | 0] << 24);
  HEAP32[$3_1 + 212 >> 2] = $4_1;
  $4_1 = 0;
  while (1) {
   $5_1 = ($3_1 + 208 | 0) + $4_1 | 0;
   HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
   $7_1 = $5_1 + 1 | 0;
   HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
   $7_1 = $5_1 + 2 | 0;
   HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
   $5_1 = $5_1 + 3 | 0;
   HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
   $4_1 = $4_1 + 4 | 0;
   if (($4_1 | 0) != 64) {
    continue
   }
   break;
  };
  $29($8_1, $3_1 + 208 | 0, 64);
  HEAP32[$3_1 + 96 >> 2] = 0;
  HEAP32[$3_1 + 100 >> 2] = 0;
  HEAP32[$3_1 + 24 >> 2] = 528734635;
  HEAP32[$3_1 + 28 >> 2] = 1541459225;
  HEAP32[$3_1 + 16 >> 2] = 1359893119;
  HEAP32[$3_1 + 20 >> 2] = -1694144372;
  HEAP32[$3_1 + 8 >> 2] = 1013904242;
  HEAP32[$3_1 + 12 >> 2] = -1521486534;
  HEAP32[$3_1 >> 2] = 1779033703;
  HEAP32[$3_1 + 4 >> 2] = -1150833019;
  $4_1 = 0;
  while (1) {
   $5_1 = ($3_1 + 208 | 0) + $4_1 | 0;
   HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
   $7_1 = $5_1 + 1 | 0;
   HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
   $7_1 = $5_1 + 2 | 0;
   HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
   $5_1 = $5_1 + 3 | 0;
   HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
   $4_1 = $4_1 + 4 | 0;
   if (($4_1 | 0) != 64) {
    continue
   }
   break;
  };
  $5_1 = $3_1 + 208 | 0;
  $29($3_1, $5_1, 64);
  $29($3_1, $0_1, 32);
  $30($3_1, $5_1);
  $29($8_1, $5_1, 32);
  $30($8_1, $0_1);
  $4_1 = $3_1 + 248 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $4_1 = $3_1 + 256 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $4_1 = $3_1 + 264 | 0;
  HEAP32[$4_1 >> 2] = 0;
  HEAP32[$4_1 + 4 >> 2] = 0;
  $4_1 = $6_1 + 24 | 0;
  $7_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
  $9_1 = $5_1 + 24 | 0;
  HEAP32[$9_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
  HEAP32[$9_1 + 4 >> 2] = $7_1;
  $4_1 = $6_1 + 16 | 0;
  $7_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
  $5_1 = $5_1 + 16 | 0;
  HEAP32[$5_1 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
  HEAP32[$5_1 + 4 >> 2] = $7_1;
  HEAP32[$3_1 + 200 >> 2] = 0;
  HEAP32[$3_1 + 204 >> 2] = 0;
  HEAP32[$3_1 + 128 >> 2] = 528734635;
  HEAP32[$3_1 + 132 >> 2] = 1541459225;
  HEAP32[$3_1 + 120 >> 2] = 1359893119;
  HEAP32[$3_1 + 124 >> 2] = -1694144372;
  HEAP32[$3_1 + 112 >> 2] = 1013904242;
  HEAP32[$3_1 + 116 >> 2] = -1521486534;
  HEAP32[$3_1 + 104 >> 2] = 1779033703;
  HEAP32[$3_1 + 108 >> 2] = -1150833019;
  HEAP32[$3_1 + 240 >> 2] = 0;
  HEAP32[$3_1 + 244 >> 2] = 0;
  $4_1 = $6_1 + 8 | 0;
  $5_1 = HEAPU8[$4_1 + 4 | 0] | HEAPU8[$4_1 + 5 | 0] << 8 | (HEAPU8[$4_1 + 6 | 0] << 16 | HEAPU8[$4_1 + 7 | 0] << 24);
  HEAP32[$3_1 + 216 >> 2] = HEAPU8[$4_1 | 0] | HEAPU8[$4_1 + 1 | 0] << 8 | (HEAPU8[$4_1 + 2 | 0] << 16 | HEAPU8[$4_1 + 3 | 0] << 24);
  HEAP32[$3_1 + 220 >> 2] = $5_1;
  $4_1 = HEAPU8[$6_1 + 4 | 0] | HEAPU8[$6_1 + 5 | 0] << 8 | (HEAPU8[$6_1 + 6 | 0] << 16 | HEAPU8[$6_1 + 7 | 0] << 24);
  HEAP32[$3_1 + 208 >> 2] = HEAPU8[$6_1 | 0] | HEAPU8[$6_1 + 1 | 0] << 8 | (HEAPU8[$6_1 + 2 | 0] << 16 | HEAPU8[$6_1 + 3 | 0] << 24);
  HEAP32[$3_1 + 212 >> 2] = $4_1;
  $4_1 = 0;
  while (1) {
   $5_1 = ($3_1 + 208 | 0) + $4_1 | 0;
   HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
   $7_1 = $5_1 + 1 | 0;
   HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
   $7_1 = $5_1 + 2 | 0;
   HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
   $5_1 = $5_1 + 3 | 0;
   HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
   $4_1 = $4_1 + 4 | 0;
   if (($4_1 | 0) != 64) {
    continue
   }
   break;
  };
  $29($8_1, $3_1 + 208 | 0, 64);
  HEAP32[$3_1 + 96 >> 2] = 0;
  HEAP32[$3_1 + 100 >> 2] = 0;
  HEAP32[$3_1 + 24 >> 2] = 528734635;
  HEAP32[$3_1 + 28 >> 2] = 1541459225;
  HEAP32[$3_1 + 16 >> 2] = 1359893119;
  HEAP32[$3_1 + 20 >> 2] = -1694144372;
  HEAP32[$3_1 + 8 >> 2] = 1013904242;
  HEAP32[$3_1 + 12 >> 2] = -1521486534;
  HEAP32[$3_1 >> 2] = 1779033703;
  HEAP32[$3_1 + 4 >> 2] = -1150833019;
  $4_1 = 0;
  while (1) {
   $5_1 = ($3_1 + 208 | 0) + $4_1 | 0;
   HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
   $7_1 = $5_1 + 1 | 0;
   HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
   $7_1 = $5_1 + 2 | 0;
   HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
   $5_1 = $5_1 + 3 | 0;
   HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
   $4_1 = $4_1 + 4 | 0;
   if (($4_1 | 0) != 64) {
    continue
   }
   break;
  };
  $4_1 = $3_1 + 208 | 0;
  $29($3_1, $4_1, 64);
  $29($3_1, $0_1, 32);
  $29($3_1, 690369, 1);
  $29($3_1, $1_1, $2_1);
  $30($3_1, $4_1);
  $29($8_1, $4_1, 32);
  $30($8_1, $6_1);
  $1_1 = $3_1 + 248 | 0;
  HEAP32[$1_1 >> 2] = 0;
  HEAP32[$1_1 + 4 >> 2] = 0;
  $1_1 = $3_1 + 256 | 0;
  HEAP32[$1_1 >> 2] = 0;
  HEAP32[$1_1 + 4 >> 2] = 0;
  $1_1 = $3_1 + 264 | 0;
  HEAP32[$1_1 >> 2] = 0;
  HEAP32[$1_1 + 4 >> 2] = 0;
  $1_1 = $6_1 + 24 | 0;
  $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
  $5_1 = $4_1 + 24 | 0;
  HEAP32[$5_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
  HEAP32[$5_1 + 4 >> 2] = $2_1;
  $1_1 = $6_1 + 16 | 0;
  $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
  $4_1 = $4_1 + 16 | 0;
  HEAP32[$4_1 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
  HEAP32[$4_1 + 4 >> 2] = $2_1;
  HEAP32[$3_1 + 200 >> 2] = 0;
  HEAP32[$3_1 + 204 >> 2] = 0;
  HEAP32[$3_1 + 128 >> 2] = 528734635;
  HEAP32[$3_1 + 132 >> 2] = 1541459225;
  HEAP32[$3_1 + 120 >> 2] = 1359893119;
  HEAP32[$3_1 + 124 >> 2] = -1694144372;
  HEAP32[$3_1 + 112 >> 2] = 1013904242;
  HEAP32[$3_1 + 116 >> 2] = -1521486534;
  HEAP32[$3_1 + 104 >> 2] = 1779033703;
  HEAP32[$3_1 + 108 >> 2] = -1150833019;
  HEAP32[$3_1 + 240 >> 2] = 0;
  HEAP32[$3_1 + 244 >> 2] = 0;
  $1_1 = $6_1 + 8 | 0;
  $2_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
  HEAP32[$3_1 + 216 >> 2] = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
  HEAP32[$3_1 + 220 >> 2] = $2_1;
  $1_1 = HEAPU8[$6_1 + 4 | 0] | HEAPU8[$6_1 + 5 | 0] << 8 | (HEAPU8[$6_1 + 6 | 0] << 16 | HEAPU8[$6_1 + 7 | 0] << 24);
  HEAP32[$3_1 + 208 >> 2] = HEAPU8[$6_1 | 0] | HEAPU8[$6_1 + 1 | 0] << 8 | (HEAPU8[$6_1 + 2 | 0] << 16 | HEAPU8[$6_1 + 3 | 0] << 24);
  HEAP32[$3_1 + 212 >> 2] = $1_1;
  $4_1 = 0;
  while (1) {
   $1_1 = ($3_1 + 208 | 0) + $4_1 | 0;
   HEAP8[$1_1 | 0] = HEAPU8[$1_1 | 0] ^ 92;
   $2_1 = $1_1 + 1 | 0;
   HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 92;
   $2_1 = $1_1 + 2 | 0;
   HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 92;
   $1_1 = $1_1 + 3 | 0;
   HEAP8[$1_1 | 0] = HEAPU8[$1_1 | 0] ^ 92;
   $4_1 = $4_1 + 4 | 0;
   if (($4_1 | 0) != 64) {
    continue
   }
   break;
  };
  $29($8_1, $3_1 + 208 | 0, 64);
  HEAP32[$3_1 + 96 >> 2] = 0;
  HEAP32[$3_1 + 100 >> 2] = 0;
  HEAP32[$3_1 + 24 >> 2] = 528734635;
  HEAP32[$3_1 + 28 >> 2] = 1541459225;
  HEAP32[$3_1 + 16 >> 2] = 1359893119;
  HEAP32[$3_1 + 20 >> 2] = -1694144372;
  HEAP32[$3_1 + 8 >> 2] = 1013904242;
  HEAP32[$3_1 + 12 >> 2] = -1521486534;
  HEAP32[$3_1 >> 2] = 1779033703;
  HEAP32[$3_1 + 4 >> 2] = -1150833019;
  $4_1 = 0;
  while (1) {
   $1_1 = ($3_1 + 208 | 0) + $4_1 | 0;
   HEAP8[$1_1 | 0] = HEAPU8[$1_1 | 0] ^ 106;
   $2_1 = $1_1 + 1 | 0;
   HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 106;
   $2_1 = $1_1 + 2 | 0;
   HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 106;
   $1_1 = $1_1 + 3 | 0;
   HEAP8[$1_1 | 0] = HEAPU8[$1_1 | 0] ^ 106;
   $4_1 = $4_1 + 4 | 0;
   if (($4_1 | 0) != 64) {
    continue
   }
   break;
  };
  $1_1 = $3_1 + 208 | 0;
  $29($3_1, $1_1, 64);
  $29($3_1, $0_1, 32);
  $30($3_1, $1_1);
  $29($8_1, $1_1, 32);
  $30($8_1, $0_1);
  HEAP32[$0_1 + 64 >> 2] = 0;
  global$0 = $3_1 + 272 | 0;
 }
 
 function $46($0_1, $1_1) {
  var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0;
  $4_1 = global$0 - 272 | 0;
  global$0 = $4_1;
  if (HEAP32[$0_1 + 64 >> 2]) {
   $2_1 = $4_1 + 208 | 0;
   $3_1 = $2_1 + 40 | 0;
   HEAP32[$3_1 >> 2] = 0;
   HEAP32[$3_1 + 4 >> 2] = 0;
   $3_1 = $2_1 + 48 | 0;
   HEAP32[$3_1 >> 2] = 0;
   HEAP32[$3_1 + 4 >> 2] = 0;
   $2_1 = $2_1 + 56 | 0;
   HEAP32[$2_1 >> 2] = 0;
   HEAP32[$2_1 + 4 >> 2] = 0;
   $2_1 = $4_1 + 200 | 0;
   HEAP32[$2_1 >> 2] = 0;
   HEAP32[$2_1 + 4 >> 2] = 0;
   $2_1 = $4_1 + 128 | 0;
   HEAP32[$2_1 >> 2] = 528734635;
   HEAP32[$2_1 + 4 >> 2] = 1541459225;
   $2_1 = $4_1 + 120 | 0;
   HEAP32[$2_1 >> 2] = 1359893119;
   HEAP32[$2_1 + 4 >> 2] = -1694144372;
   $2_1 = $4_1 + 112 | 0;
   HEAP32[$2_1 >> 2] = 1013904242;
   HEAP32[$2_1 + 4 >> 2] = -1521486534;
   $2_1 = $0_1 + 56 | 0;
   $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
   $6_1 = $4_1 + 232 | 0;
   HEAP32[$6_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
   HEAP32[$6_1 + 4 >> 2] = $3_1;
   $2_1 = $0_1 + 48 | 0;
   $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
   $6_1 = $4_1 + 224 | 0;
   HEAP32[$6_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
   HEAP32[$6_1 + 4 >> 2] = $3_1;
   HEAP32[$4_1 + 104 >> 2] = 1779033703;
   HEAP32[$4_1 + 108 >> 2] = -1150833019;
   HEAP32[$4_1 + 240 >> 2] = 0;
   HEAP32[$4_1 + 244 >> 2] = 0;
   $2_1 = $0_1 + 40 | 0;
   $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
   HEAP32[$4_1 + 216 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
   HEAP32[$4_1 + 220 >> 2] = $3_1;
   $2_1 = HEAPU8[$0_1 + 36 | 0] | HEAPU8[$0_1 + 37 | 0] << 8 | (HEAPU8[$0_1 + 38 | 0] << 16 | HEAPU8[$0_1 + 39 | 0] << 24);
   HEAP32[$4_1 + 208 >> 2] = HEAPU8[$0_1 + 32 | 0] | HEAPU8[$0_1 + 33 | 0] << 8 | (HEAPU8[$0_1 + 34 | 0] << 16 | HEAPU8[$0_1 + 35 | 0] << 24);
   HEAP32[$4_1 + 212 >> 2] = $2_1;
   $2_1 = $0_1 + 32 | 0;
   $6_1 = $4_1 + 104 | 0;
   $3_1 = 0;
   while (1) {
    $5_1 = ($4_1 + 208 | 0) + $3_1 | 0;
    HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
    $7_1 = $5_1 + 1 | 0;
    HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
    $7_1 = $5_1 + 2 | 0;
    HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 92;
    $5_1 = $5_1 + 3 | 0;
    HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
    $3_1 = $3_1 + 4 | 0;
    if (($3_1 | 0) != 64) {
     continue
    }
    break;
   };
   $29($6_1, $4_1 + 208 | 0, 64);
   HEAP32[$4_1 + 96 >> 2] = 0;
   HEAP32[$4_1 + 100 >> 2] = 0;
   HEAP32[$4_1 + 24 >> 2] = 528734635;
   HEAP32[$4_1 + 28 >> 2] = 1541459225;
   HEAP32[$4_1 + 16 >> 2] = 1359893119;
   HEAP32[$4_1 + 20 >> 2] = -1694144372;
   HEAP32[$4_1 + 8 >> 2] = 1013904242;
   HEAP32[$4_1 + 12 >> 2] = -1521486534;
   HEAP32[$4_1 >> 2] = 1779033703;
   HEAP32[$4_1 + 4 >> 2] = -1150833019;
   $3_1 = 0;
   while (1) {
    $5_1 = ($4_1 + 208 | 0) + $3_1 | 0;
    HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
    $7_1 = $5_1 + 1 | 0;
    HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
    $7_1 = $5_1 + 2 | 0;
    HEAP8[$7_1 | 0] = HEAPU8[$7_1 | 0] ^ 106;
    $5_1 = $5_1 + 3 | 0;
    HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
    $3_1 = $3_1 + 4 | 0;
    if (($3_1 | 0) != 64) {
     continue
    }
    break;
   };
   $5_1 = $4_1 + 208 | 0;
   $29($4_1, $5_1, 64);
   $29($4_1, $0_1, 32);
   $29($4_1, 690370, 1);
   $30($4_1, $5_1);
   $29($6_1, $5_1, 32);
   $30($6_1, $2_1);
   $3_1 = $4_1 + 248 | 0;
   HEAP32[$3_1 >> 2] = 0;
   HEAP32[$3_1 + 4 >> 2] = 0;
   $3_1 = $4_1 + 256 | 0;
   HEAP32[$3_1 >> 2] = 0;
   HEAP32[$3_1 + 4 >> 2] = 0;
   $3_1 = $4_1 + 264 | 0;
   HEAP32[$3_1 >> 2] = 0;
   HEAP32[$3_1 + 4 >> 2] = 0;
   $3_1 = $2_1 + 24 | 0;
   $7_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
   $8_1 = $5_1 + 24 | 0;
   HEAP32[$8_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
   HEAP32[$8_1 + 4 >> 2] = $7_1;
   $3_1 = $2_1 + 16 | 0;
   $7_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
   $5_1 = $5_1 + 16 | 0;
   HEAP32[$5_1 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
   HEAP32[$5_1 + 4 >> 2] = $7_1;
   HEAP32[$4_1 + 200 >> 2] = 0;
   HEAP32[$4_1 + 204 >> 2] = 0;
   HEAP32[$4_1 + 128 >> 2] = 528734635;
   HEAP32[$4_1 + 132 >> 2] = 1541459225;
   HEAP32[$4_1 + 120 >> 2] = 1359893119;
   HEAP32[$4_1 + 124 >> 2] = -1694144372;
   HEAP32[$4_1 + 112 >> 2] = 1013904242;
   HEAP32[$4_1 + 116 >> 2] = -1521486534;
   HEAP32[$4_1 + 104 >> 2] = 1779033703;
   HEAP32[$4_1 + 108 >> 2] = -1150833019;
   HEAP32[$4_1 + 240 >> 2] = 0;
   HEAP32[$4_1 + 244 >> 2] = 0;
   $3_1 = $2_1 + 8 | 0;
   $5_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
   HEAP32[$4_1 + 216 >> 2] = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
   HEAP32[$4_1 + 220 >> 2] = $5_1;
   $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
   HEAP32[$4_1 + 208 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
   HEAP32[$4_1 + 212 >> 2] = $3_1;
   $3_1 = 0;
   while (1) {
    $2_1 = ($4_1 + 208 | 0) + $3_1 | 0;
    HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 92;
    $5_1 = $2_1 + 1 | 0;
    HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
    $5_1 = $2_1 + 2 | 0;
    HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
    $2_1 = $2_1 + 3 | 0;
    HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 92;
    $3_1 = $3_1 + 4 | 0;
    if (($3_1 | 0) != 64) {
     continue
    }
    break;
   };
   $29($6_1, $4_1 + 208 | 0, 64);
   HEAP32[$4_1 + 96 >> 2] = 0;
   HEAP32[$4_1 + 100 >> 2] = 0;
   HEAP32[$4_1 + 24 >> 2] = 528734635;
   HEAP32[$4_1 + 28 >> 2] = 1541459225;
   HEAP32[$4_1 + 16 >> 2] = 1359893119;
   HEAP32[$4_1 + 20 >> 2] = -1694144372;
   HEAP32[$4_1 + 8 >> 2] = 1013904242;
   HEAP32[$4_1 + 12 >> 2] = -1521486534;
   HEAP32[$4_1 >> 2] = 1779033703;
   HEAP32[$4_1 + 4 >> 2] = -1150833019;
   $3_1 = 0;
   while (1) {
    $2_1 = ($4_1 + 208 | 0) + $3_1 | 0;
    HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 106;
    $5_1 = $2_1 + 1 | 0;
    HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
    $5_1 = $2_1 + 2 | 0;
    HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
    $2_1 = $2_1 + 3 | 0;
    HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 106;
    $3_1 = $3_1 + 4 | 0;
    if (($3_1 | 0) != 64) {
     continue
    }
    break;
   };
   $2_1 = $4_1 + 208 | 0;
   $29($4_1, $2_1, 64);
   $29($4_1, $0_1, 32);
   $30($4_1, $2_1);
   $29($6_1, $2_1, 32);
   $30($6_1, $0_1);
  }
  $2_1 = $4_1 + 208 | 0;
  $3_1 = $2_1 + 40 | 0;
  HEAP32[$3_1 >> 2] = 0;
  HEAP32[$3_1 + 4 >> 2] = 0;
  $3_1 = $2_1 + 48 | 0;
  HEAP32[$3_1 >> 2] = 0;
  HEAP32[$3_1 + 4 >> 2] = 0;
  $2_1 = $2_1 + 56 | 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  $2_1 = $4_1 + 200 | 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  $2_1 = $4_1 + 128 | 0;
  HEAP32[$2_1 >> 2] = 528734635;
  HEAP32[$2_1 + 4 >> 2] = 1541459225;
  $2_1 = $4_1 + 120 | 0;
  HEAP32[$2_1 >> 2] = 1359893119;
  HEAP32[$2_1 + 4 >> 2] = -1694144372;
  $2_1 = $4_1 + 112 | 0;
  HEAP32[$2_1 >> 2] = 1013904242;
  HEAP32[$2_1 + 4 >> 2] = -1521486534;
  $2_1 = $0_1 + 56 | 0;
  $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
  $6_1 = $4_1 + 232 | 0;
  HEAP32[$6_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
  HEAP32[$6_1 + 4 >> 2] = $3_1;
  $2_1 = $0_1 + 48 | 0;
  $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
  $6_1 = $4_1 + 224 | 0;
  HEAP32[$6_1 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
  HEAP32[$6_1 + 4 >> 2] = $3_1;
  HEAP32[$4_1 + 104 >> 2] = 1779033703;
  HEAP32[$4_1 + 108 >> 2] = -1150833019;
  HEAP32[$4_1 + 240 >> 2] = 0;
  HEAP32[$4_1 + 244 >> 2] = 0;
  $2_1 = $0_1 + 40 | 0;
  $3_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
  HEAP32[$4_1 + 216 >> 2] = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
  HEAP32[$4_1 + 220 >> 2] = $3_1;
  $2_1 = HEAPU8[$0_1 + 36 | 0] | HEAPU8[$0_1 + 37 | 0] << 8 | (HEAPU8[$0_1 + 38 | 0] << 16 | HEAPU8[$0_1 + 39 | 0] << 24);
  HEAP32[$4_1 + 208 >> 2] = HEAPU8[$0_1 + 32 | 0] | HEAPU8[$0_1 + 33 | 0] << 8 | (HEAPU8[$0_1 + 34 | 0] << 16 | HEAPU8[$0_1 + 35 | 0] << 24);
  HEAP32[$4_1 + 212 >> 2] = $2_1;
  $6_1 = $4_1 + 104 | 0;
  $3_1 = 0;
  while (1) {
   $2_1 = ($4_1 + 208 | 0) + $3_1 | 0;
   HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 92;
   $5_1 = $2_1 + 1 | 0;
   HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
   $5_1 = $2_1 + 2 | 0;
   HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 92;
   $2_1 = $2_1 + 3 | 0;
   HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 92;
   $3_1 = $3_1 + 4 | 0;
   if (($3_1 | 0) != 64) {
    continue
   }
   break;
  };
  $29($6_1, $4_1 + 208 | 0, 64);
  HEAP32[$4_1 + 96 >> 2] = 0;
  HEAP32[$4_1 + 100 >> 2] = 0;
  HEAP32[$4_1 + 24 >> 2] = 528734635;
  HEAP32[$4_1 + 28 >> 2] = 1541459225;
  HEAP32[$4_1 + 16 >> 2] = 1359893119;
  HEAP32[$4_1 + 20 >> 2] = -1694144372;
  HEAP32[$4_1 + 8 >> 2] = 1013904242;
  HEAP32[$4_1 + 12 >> 2] = -1521486534;
  HEAP32[$4_1 >> 2] = 1779033703;
  HEAP32[$4_1 + 4 >> 2] = -1150833019;
  $3_1 = 0;
  while (1) {
   $2_1 = ($4_1 + 208 | 0) + $3_1 | 0;
   HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 106;
   $5_1 = $2_1 + 1 | 0;
   HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
   $5_1 = $2_1 + 2 | 0;
   HEAP8[$5_1 | 0] = HEAPU8[$5_1 | 0] ^ 106;
   $2_1 = $2_1 + 3 | 0;
   HEAP8[$2_1 | 0] = HEAPU8[$2_1 | 0] ^ 106;
   $3_1 = $3_1 + 4 | 0;
   if (($3_1 | 0) != 64) {
    continue
   }
   break;
  };
  $2_1 = $4_1 + 208 | 0;
  $29($4_1, $2_1, 64);
  $29($4_1, $0_1, 32);
  $30($4_1, $2_1);
  $29($6_1, $2_1, 32);
  $30($6_1, $0_1);
  $2_1 = $0_1 + 24 | 0;
  $6_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
  $3_1 = $1_1 + 24 | 0;
  $2_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
  HEAP8[$3_1 | 0] = $2_1;
  HEAP8[$3_1 + 1 | 0] = $2_1 >>> 8;
  HEAP8[$3_1 + 2 | 0] = $2_1 >>> 16;
  HEAP8[$3_1 + 3 | 0] = $2_1 >>> 24;
  HEAP8[$3_1 + 4 | 0] = $6_1;
  HEAP8[$3_1 + 5 | 0] = $6_1 >>> 8;
  HEAP8[$3_1 + 6 | 0] = $6_1 >>> 16;
  HEAP8[$3_1 + 7 | 0] = $6_1 >>> 24;
  $2_1 = $0_1 + 16 | 0;
  $6_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
  $3_1 = $1_1 + 16 | 0;
  $2_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
  HEAP8[$3_1 | 0] = $2_1;
  HEAP8[$3_1 + 1 | 0] = $2_1 >>> 8;
  HEAP8[$3_1 + 2 | 0] = $2_1 >>> 16;
  HEAP8[$3_1 + 3 | 0] = $2_1 >>> 24;
  HEAP8[$3_1 + 4 | 0] = $6_1;
  HEAP8[$3_1 + 5 | 0] = $6_1 >>> 8;
  HEAP8[$3_1 + 6 | 0] = $6_1 >>> 16;
  HEAP8[$3_1 + 7 | 0] = $6_1 >>> 24;
  $2_1 = $0_1 + 8 | 0;
  $6_1 = HEAPU8[$2_1 + 4 | 0] | HEAPU8[$2_1 + 5 | 0] << 8 | (HEAPU8[$2_1 + 6 | 0] << 16 | HEAPU8[$2_1 + 7 | 0] << 24);
  $3_1 = $1_1 + 8 | 0;
  $2_1 = HEAPU8[$2_1 | 0] | HEAPU8[$2_1 + 1 | 0] << 8 | (HEAPU8[$2_1 + 2 | 0] << 16 | HEAPU8[$2_1 + 3 | 0] << 24);
  HEAP8[$3_1 | 0] = $2_1;
  HEAP8[$3_1 + 1 | 0] = $2_1 >>> 8;
  HEAP8[$3_1 + 2 | 0] = $2_1 >>> 16;
  HEAP8[$3_1 + 3 | 0] = $2_1 >>> 24;
  HEAP8[$3_1 + 4 | 0] = $6_1;
  HEAP8[$3_1 + 5 | 0] = $6_1 >>> 8;
  HEAP8[$3_1 + 6 | 0] = $6_1 >>> 16;
  HEAP8[$3_1 + 7 | 0] = $6_1 >>> 24;
  $2_1 = HEAPU8[$0_1 + 4 | 0] | HEAPU8[$0_1 + 5 | 0] << 8 | (HEAPU8[$0_1 + 6 | 0] << 16 | HEAPU8[$0_1 + 7 | 0] << 24);
  $3_1 = HEAPU8[$0_1 | 0] | HEAPU8[$0_1 + 1 | 0] << 8 | (HEAPU8[$0_1 + 2 | 0] << 16 | HEAPU8[$0_1 + 3 | 0] << 24);
  HEAP8[$1_1 | 0] = $3_1;
  HEAP8[$1_1 + 1 | 0] = $3_1 >>> 8;
  HEAP8[$1_1 + 2 | 0] = $3_1 >>> 16;
  HEAP8[$1_1 + 3 | 0] = $3_1 >>> 24;
  HEAP8[$1_1 + 4 | 0] = $2_1;
  HEAP8[$1_1 + 5 | 0] = $2_1 >>> 8;
  HEAP8[$1_1 + 6 | 0] = $2_1 >>> 16;
  HEAP8[$1_1 + 7 | 0] = $2_1 >>> 24;
  HEAP32[$0_1 + 64 >> 2] = 1;
  global$0 = $4_1 + 272 | 0;
 }
 
 function $47($0_1, $1_1, $2_1, $3_1, $4_1, $5_1) {
  var $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0;
  $11_1 = global$0 - 464 | 0;
  global$0 = $11_1;
  $6_1 = $1_1 + 24 | 0;
  HEAP32[$6_1 >> 2] = 0;
  HEAP32[$6_1 + 4 >> 2] = 0;
  $6_1 = $1_1 + 16 | 0;
  HEAP32[$6_1 >> 2] = 0;
  HEAP32[$6_1 + 4 >> 2] = 0;
  $6_1 = $1_1 + 8 | 0;
  HEAP32[$6_1 >> 2] = 0;
  HEAP32[$6_1 + 4 >> 2] = 0;
  HEAP32[$1_1 >> 2] = 0;
  HEAP32[$1_1 + 4 >> 2] = 0;
  $6_1 = $2_1 + 24 | 0;
  HEAP32[$6_1 >> 2] = 0;
  HEAP32[$6_1 + 4 >> 2] = 0;
  $6_1 = $2_1 + 16 | 0;
  HEAP32[$6_1 >> 2] = 0;
  HEAP32[$6_1 + 4 >> 2] = 0;
  $6_1 = $2_1 + 8 | 0;
  HEAP32[$6_1 >> 2] = 0;
  HEAP32[$6_1 + 4 >> 2] = 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  if ($3_1) {
   HEAP32[$3_1 >> 2] = 0
  }
  $38($11_1 + 96 | 0, 690788, $11_1 + 256 | 0);
  $14_1 = HEAP32[$11_1 + 120 >> 2];
  $13_1 = HEAP32[$11_1 + 112 >> 2];
  $10_1 = HEAP32[$11_1 + 104 >> 2];
  $12_1 = HEAP32[$11_1 + 96 >> 2];
  $18_1 = HEAP32[$11_1 + 124 >> 2];
  $16_1 = HEAP32[$11_1 + 116 >> 2];
  $8_1 = HEAP32[$11_1 + 108 >> 2];
  $15_1 = HEAP32[$11_1 + 100 >> 2];
  $7_1 = HEAP32[$11_1 + 256 >> 2] | !($14_1 | ($13_1 | ($10_1 | $12_1)) | ($18_1 | ($16_1 | ($8_1 | $15_1))));
  $6_1 = $7_1 ? 0 : -1;
  HEAP32[$11_1 + 120 >> 2] = $6_1 & $14_1;
  HEAP32[$11_1 + 124 >> 2] = $6_1 & $18_1;
  HEAP32[$11_1 + 112 >> 2] = $6_1 & $13_1;
  HEAP32[$11_1 + 116 >> 2] = $6_1 & $16_1;
  HEAP32[$11_1 + 104 >> 2] = $6_1 & $10_1;
  HEAP32[$11_1 + 108 >> 2] = $6_1 & $8_1;
  HEAP32[$11_1 + 96 >> 2] = $6_1 & $12_1 | ($7_1 | 0) != 0;
  HEAP32[$11_1 + 100 >> 2] = $6_1 & $15_1;
  $38($11_1 + 32 | 0, 655649, 0);
  $31_1 = !$7_1;
  $28_1 = $4_1 ? $4_1 : 4;
  label$2 : {
   if (!(FUNCTION_TABLE[$28_1 | 0]($11_1, 655649, 690788, 0, $5_1, 0) | 0)) {
    break label$2
   }
   $4_1 = 1;
   while (1) {
    $29_1 = $4_1;
    $38($11_1 - -64 | 0, $11_1, $11_1 + 256 | 0);
    label$4 : {
     if (HEAP32[$11_1 + 256 >> 2] | !(HEAP32[$11_1 + 88 >> 2] | (HEAP32[$11_1 + 80 >> 2] | (HEAP32[$11_1 + 72 >> 2] | HEAP32[$11_1 + 64 >> 2])) | (HEAP32[$11_1 + 92 >> 2] | (HEAP32[$11_1 + 84 >> 2] | (HEAP32[$11_1 + 76 >> 2] | HEAP32[$11_1 + 68 >> 2]))))) {
      break label$4
     }
     HEAP32[$11_1 + 132 >> 2] = 0;
     $4_1 = $11_1 + 256 | 0;
     $48($0_1, $4_1, $11_1 - -64 | 0);
     $49($11_1 + 168 | 0, $4_1);
     $6_1 = $11_1;
     $16_1 = HEAP32[$6_1 + 232 >> 2];
     $18_1 = HEAP32[$6_1 + 236 >> 2];
     $14_1 = HEAP32[$6_1 + 224 >> 2];
     $15_1 = HEAP32[$6_1 + 228 >> 2];
     $10_1 = HEAP32[$6_1 + 216 >> 2];
     $8_1 = HEAP32[$6_1 + 220 >> 2];
     $9_1 = HEAP32[$6_1 + 212 >> 2];
     $12_1 = HEAP32[$6_1 + 240 >> 2];
     $13_1 = HEAP32[$6_1 + 244 >> 2];
     $20_1 = $13_1;
     $4_1 = HEAP32[$6_1 + 208 >> 2];
     $13_1 = __wasm_i64_mul($13_1 >>> 16 | 0, 0, 977, 1);
     $7_1 = $4_1 + $13_1 | 0;
     $4_1 = $9_1 + i64toi32_i32$HIGH_BITS | 0;
     $13_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $4_1 = $8_1;
     $9_1 = $13_1 >>> 20 | 0;
     $17_1 = $9_1;
     $9_1 = $10_1 + $9_1 | 0;
     $8_1 = $17_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $4_1 = $15_1;
     $10_1 = $8_1 >>> 20 | 0;
     $15_1 = $10_1;
     $10_1 = $10_1 + $14_1 | 0;
     $14_1 = $15_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $4_1 = $18_1;
     $15_1 = $14_1 >>> 20 | 0;
     $17_1 = $15_1;
     $15_1 = $16_1 + $15_1 | 0;
     $4_1 = $17_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $21_1 = $10_1;
     $16_1 = $4_1;
     $30_1 = $14_1 & 1048575;
     $14_1 = ($15_1 & ($10_1 & $9_1)) == -1 & ($4_1 & ($30_1 & $8_1)) == 1048575;
     $4_1 = $20_1 & 65535;
     $10_1 = $16_1 >>> 20 | 0;
     $17_1 = $10_1;
     $10_1 = $10_1 + $12_1 | 0;
     $18_1 = $17_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $4_1 = $13_1 & 1048575;
     $22_1 = $10_1;
     $10_1 = __wasm_i64_mul($14_1 & (($10_1 | 0) == -1 & ($18_1 | 0) == 65535) & (($4_1 | 0) == 1048574 & $7_1 >>> 0 > 4294966318 | $4_1 >>> 0 > 1048574) | $18_1 >>> 16, 0, 977, 1) + $7_1 | 0;
     $4_1 = i64toi32_i32$HIGH_BITS + $4_1 | 0;
     $27_1 = $10_1;
     HEAP32[$6_1 + 208 >> 2] = $10_1;
     $14_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     HEAP32[$6_1 + 212 >> 2] = $14_1 & 1048575;
     $20_1 = HEAP32[$6_1 + 192 >> 2];
     $17_1 = HEAP32[$6_1 + 196 >> 2];
     $13_1 = HEAP32[$6_1 + 184 >> 2];
     $23_1 = HEAP32[$6_1 + 188 >> 2];
     $12_1 = HEAP32[$6_1 + 176 >> 2];
     $19_1 = HEAP32[$6_1 + 180 >> 2];
     $25_1 = HEAP32[$6_1 + 172 >> 2];
     $26_1 = HEAP32[$6_1 + 200 >> 2];
     $10_1 = HEAP32[$6_1 + 204 >> 2];
     $32_1 = $10_1;
     $4_1 = HEAP32[$6_1 + 168 >> 2];
     $7_1 = __wasm_i64_mul($10_1 >>> 16 | 0, 0, 977, 1);
     $10_1 = $4_1 + $7_1 | 0;
     $4_1 = $25_1 + i64toi32_i32$HIGH_BITS | 0;
     $25_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $4_1 = $19_1;
     $7_1 = $25_1 >>> 20 | 0;
     $19_1 = $7_1;
     $7_1 = $7_1 + $12_1 | 0;
     $19_1 = $19_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $4_1 = $23_1;
     $12_1 = $19_1 >>> 20 | 0;
     $23_1 = $12_1;
     $12_1 = $12_1 + $13_1 | 0;
     $24_1 = $23_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $4_1 = $17_1;
     $13_1 = $24_1 >>> 20 | 0;
     $20_1 = $13_1 + $20_1 | 0;
     $4_1 = $13_1 >>> 0 > $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $13_1 = $19_1 & 1048575;
     $23_1 = $12_1;
     $17_1 = $4_1;
     $24_1 = $24_1 & 1048575;
     $12_1 = ($7_1 & $12_1 & $20_1) == -1 & ($4_1 & ($19_1 & $24_1)) == 1048575;
     $4_1 = $32_1 & 65535;
     $6_1 = $17_1 >>> 20 | 0;
     $19_1 = $6_1;
     $6_1 = $6_1 + $26_1 | 0;
     $19_1 = $19_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $4_1 = $25_1 & 1048575;
     $26_1 = $6_1;
     $6_1 = __wasm_i64_mul($12_1 & (($6_1 | 0) == -1 & ($19_1 | 0) == 65535) & (($4_1 | 0) == 1048574 & $10_1 >>> 0 > 4294966318 | $4_1 >>> 0 > 1048574) | $19_1 >>> 16, 0, 977, 1) + $10_1 | 0;
     $4_1 = i64toi32_i32$HIGH_BITS + $4_1 | 0;
     $4_1 = $6_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $10_1 = $6_1;
     $6_1 = $4_1;
     $4_1 = $13_1;
     $12_1 = $6_1 >>> 20 | 0;
     $13_1 = $12_1;
     $12_1 = $7_1 + $12_1 | 0;
     $4_1 = $13_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     HEAP32[$11_1 + 176 >> 2] = $12_1;
     $7_1 = $4_1;
     HEAP32[$11_1 + 180 >> 2] = $4_1 & 1048575;
     $4_1 = $8_1 & 1048575;
     $14_1 = $14_1 >>> 20 | 0;
     $9_1 = $9_1 + $14_1 | 0;
     $4_1 = $14_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     HEAP32[$11_1 + 216 >> 2] = $9_1;
     HEAP32[$11_1 + 220 >> 2] = $4_1 & 1048575;
     $9_1 = $4_1;
     $4_1 = $30_1;
     $9_1 = ($9_1 >>> 20 | 0) + $21_1 | 0;
     $4_1 = $9_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     HEAP32[$11_1 + 224 >> 2] = $9_1;
     $21_1 = $4_1;
     HEAP32[$11_1 + 228 >> 2] = $4_1 & 1048575;
     $8_1 = $11_1;
     $9_1 = $20_1;
     $17_1 = $17_1 & 1048575;
     $4_1 = $24_1;
     $20_1 = $7_1;
     $13_1 = ($7_1 >>> 20 | 0) + $23_1 | 0;
     $7_1 = $13_1 >>> 0 < $23_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $4_1 = $17_1;
     $14_1 = $7_1 >>> 20 | 0;
     $17_1 = $14_1;
     $14_1 = $9_1 + $14_1 | 0;
     $4_1 = $17_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     HEAP32[$8_1 + 192 >> 2] = $14_1;
     $9_1 = $4_1;
     HEAP32[$8_1 + 196 >> 2] = $4_1 & 1048575;
     $4_1 = $16_1 & 1048575;
     $16_1 = $21_1 >>> 20 | 0;
     $15_1 = $16_1 + $15_1 | 0;
     $4_1 = $16_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     HEAP32[$8_1 + 232 >> 2] = $15_1;
     $15_1 = $4_1;
     HEAP32[$8_1 + 236 >> 2] = $4_1 & 1048575;
     $4_1 = $19_1;
     $16_1 = $9_1;
     $17_1 = ($9_1 >>> 20 | 0) + $26_1 | 0;
     $4_1 = $17_1 >>> 0 < $26_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     HEAP32[$8_1 + 200 >> 2] = $17_1;
     $9_1 = $4_1;
     HEAP32[$8_1 + 204 >> 2] = $4_1 & 65535;
     $4_1 = $18_1;
     $15_1 = ($15_1 >>> 20 | 0) + $22_1 | 0;
     $4_1 = $15_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     HEAP32[$8_1 + 240 >> 2] = $15_1;
     HEAP32[$8_1 + 244 >> 2] = $4_1 & 65535;
     $15_1 = $13_1;
     HEAP32[$8_1 + 184 >> 2] = $13_1;
     $4_1 = $7_1 & 1048575;
     HEAP32[$8_1 + 188 >> 2] = $4_1;
     HEAP32[$8_1 + 168 >> 2] = $10_1;
     $13_1 = $6_1 & 1048575;
     HEAP32[$8_1 + 172 >> 2] = $13_1;
     HEAP8[$8_1 + 415 | 0] = $10_1;
     HEAP8[$8_1 + 414 | 0] = ($6_1 & 255) << 24 | $10_1 >>> 8;
     HEAP8[$8_1 + 413 | 0] = ($6_1 & 65535) << 16 | $10_1 >>> 16;
     HEAP8[$8_1 + 412 | 0] = ($6_1 & 16777215) << 8 | $10_1 >>> 24;
     HEAP8[$8_1 + 411 | 0] = $6_1;
     HEAP8[$8_1 + 410 | 0] = $6_1 >>> 8;
     $6_1 = $12_1 >>> 28 | 0;
     HEAP8[$8_1 + 409 | 0] = $12_1 << 4 | $13_1 >>> 16;
     HEAP8[$8_1 + 408 | 0] = ($20_1 & 15) << 28 | $12_1 >>> 4;
     HEAP8[$8_1 + 407 | 0] = ($20_1 & 4095) << 20 | $12_1 >>> 12;
     HEAP8[$8_1 + 406 | 0] = ($20_1 & 1048575) << 12 | $12_1 >>> 20;
     HEAP8[$8_1 + 405 | 0] = $6_1 | ($20_1 & 268435455) << 4;
     HEAP8[$8_1 + 404 | 0] = $20_1 >>> 4;
     HEAP8[$8_1 + 403 | 0] = $20_1 >>> 12;
     HEAP8[$8_1 + 402 | 0] = $15_1;
     HEAP8[$8_1 + 401 | 0] = ($7_1 & 255) << 24 | $15_1 >>> 8;
     HEAP8[$8_1 + 400 | 0] = ($7_1 & 65535) << 16 | $15_1 >>> 16;
     HEAP8[$8_1 + 399 | 0] = ($7_1 & 16777215) << 8 | $15_1 >>> 24;
     HEAP8[$8_1 + 398 | 0] = $7_1;
     HEAP8[$8_1 + 397 | 0] = $7_1 >>> 8;
     $6_1 = $14_1 >>> 28 | 0;
     HEAP8[$8_1 + 396 | 0] = $14_1 << 4 | $4_1 >>> 16;
     HEAP8[$8_1 + 395 | 0] = ($16_1 & 15) << 28 | $14_1 >>> 4;
     HEAP8[$8_1 + 394 | 0] = ($16_1 & 4095) << 20 | $14_1 >>> 12;
     HEAP8[$8_1 + 393 | 0] = ($16_1 & 1048575) << 12 | $14_1 >>> 20;
     HEAP8[$8_1 + 392 | 0] = $6_1 | ($16_1 & 268435455) << 4;
     HEAP8[$8_1 + 391 | 0] = $16_1 >>> 4;
     HEAP8[$8_1 + 390 | 0] = $16_1 >>> 12;
     HEAP8[$8_1 + 389 | 0] = $17_1;
     HEAP8[$8_1 + 388 | 0] = ($9_1 & 255) << 24 | $17_1 >>> 8;
     HEAP8[$8_1 + 387 | 0] = ($9_1 & 65535) << 16 | $17_1 >>> 16;
     HEAP8[$8_1 + 386 | 0] = ($9_1 & 16777215) << 8 | $17_1 >>> 24;
     HEAP8[$8_1 + 385 | 0] = $9_1;
     HEAP8[$8_1 + 384 | 0] = $9_1 >>> 8;
     $38($1_1, $8_1 + 384 | 0, $8_1 + 132 | 0);
     if ($3_1) {
      HEAP32[$3_1 >> 2] = $27_1 & 1 | HEAP32[$8_1 + 132 >> 2] << 1
     }
     $21_1 = $8_1 + 136 | 0;
     $41($21_1, $1_1, $8_1 + 96 | 0);
     $7_1 = HEAP32[$8_1 + 32 >> 2];
     $9_1 = HEAP32[$8_1 + 136 >> 2];
     $15_1 = $7_1 + $9_1 | 0;
     $6_1 = HEAP32[$8_1 + 36 >> 2];
     $4_1 = $6_1 + HEAP32[$8_1 + 140 >> 2] | 0;
     $10_1 = $9_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $18_1 = ($6_1 | 0) == ($10_1 | 0) & $7_1 >>> 0 > $15_1 >>> 0 | $6_1 >>> 0 > $10_1 >>> 0;
     $7_1 = HEAP32[$8_1 + 144 >> 2];
     $6_1 = $18_1 + $7_1 | 0;
     $4_1 = HEAP32[$8_1 + 148 >> 2];
     $4_1 = $6_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $9_1 = $6_1;
     $6_1 = HEAP32[$8_1 + 40 >> 2];
     $13_1 = $9_1 + $6_1 | 0;
     $7_1 = $4_1;
     $4_1 = $4_1 + HEAP32[$8_1 + 44 >> 2] | 0;
     $12_1 = $6_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $19_1 = HEAP32[$8_1 + 48 >> 2];
     $6_1 = HEAP32[$8_1 + 152 >> 2];
     $14_1 = $19_1 + $6_1 | 0;
     $20_1 = HEAP32[$8_1 + 52 >> 2];
     $4_1 = $20_1 + HEAP32[$8_1 + 156 >> 2] | 0;
     $6_1 = $6_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $16_1 = $14_1;
     $4_1 = !$7_1 & $9_1 >>> 0 < $18_1 >>> 0;
     $9_1 = ($7_1 | 0) == ($12_1 | 0) & $9_1 >>> 0 > $13_1 >>> 0 | $7_1 >>> 0 > $12_1 >>> 0;
     $7_1 = $4_1 + $9_1 | 0;
     $4_1 = ($7_1 >>> 0 < $9_1 >>> 0) + $6_1 | 0;
     $14_1 = $7_1 + $14_1 | 0;
     $9_1 = $14_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $22_1 = HEAP32[$8_1 + 56 >> 2];
     $7_1 = HEAP32[$8_1 + 160 >> 2];
     $18_1 = $22_1 + $7_1 | 0;
     $17_1 = HEAP32[$8_1 + 60 >> 2];
     $4_1 = $17_1 + HEAP32[$8_1 + 164 >> 2] | 0;
     $7_1 = $7_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $4_1 = ($6_1 | 0) == ($20_1 | 0) & $16_1 >>> 0 < $19_1 >>> 0 | $6_1 >>> 0 < $20_1 >>> 0;
     $16_1 = ($6_1 | 0) == ($9_1 | 0) & $14_1 >>> 0 < $16_1 >>> 0 | $6_1 >>> 0 > $9_1 >>> 0;
     $6_1 = $4_1 + $16_1 | 0;
     $4_1 = ($6_1 >>> 0 < $16_1 >>> 0) + $7_1 | 0;
     $16_1 = $6_1;
     $6_1 = $6_1 + $18_1 | 0;
     $4_1 = $16_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $16_1 = $6_1;
     $6_1 = $8_1;
     $20_1 = $4_1;
     $17_1 = (($7_1 | 0) == ($17_1 | 0) & $18_1 >>> 0 < $22_1 >>> 0 | $7_1 >>> 0 < $17_1 >>> 0) + (($7_1 | 0) == ($4_1 | 0) & $16_1 >>> 0 < $18_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0) | 0;
     $7_1 = ($9_1 | 0) == -1;
     $8_1 = $7_1 & $14_1 >>> 0 < 4294967294 | ($9_1 | 0) != -1 | ($16_1 & $4_1) != -1;
     $4_1 = ($12_1 | 0) == -1162945306;
     $18_1 = ($8_1 | ($4_1 & $13_1 >>> 0 < 2940772411 | $12_1 >>> 0 < 3132021990)) ^ -1;
     $19_1 = $17_1 + ($18_1 & (($10_1 | 0) == -1076732276 & $15_1 >>> 0 > 3493216576 | $10_1 >>> 0 > 3218235020) | ($18_1 & ($4_1 & $13_1 >>> 0 > 2940772411 | $12_1 >>> 0 > 3132021990) | ($14_1 | 0) == -1 & $7_1 & ($8_1 ^ -1))) | 0;
     $8_1 = __wasm_i64_mul($19_1, 0, 801750719, 1076732275);
     $7_1 = $8_1 + $15_1 | 0;
     $4_1 = $10_1 + i64toi32_i32$HIGH_BITS | 0;
     $17_1 = $7_1;
     HEAP32[$6_1 + 136 >> 2] = $7_1;
     $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     HEAP32[$6_1 + 140 >> 2] = $8_1;
     $7_1 = $6_1;
     $6_1 = __wasm_i64_mul($19_1, 0, 1354194884, 1162945305);
     $18_1 = $6_1 + $13_1 | 0;
     $4_1 = $12_1 + i64toi32_i32$HIGH_BITS | 0;
     $8_1 = ($8_1 | 0) == ($10_1 | 0) & $15_1 >>> 0 > $17_1 >>> 0 | $8_1 >>> 0 < $10_1 >>> 0;
     $10_1 = $18_1 + $8_1 | 0;
     $4_1 = $6_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $6_1 = $4_1;
     $17_1 = $10_1;
     HEAP32[$7_1 + 144 >> 2] = $10_1;
     $8_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     HEAP32[$7_1 + 148 >> 2] = $8_1;
     $10_1 = $7_1;
     $4_1 = $9_1;
     $15_1 = $14_1 + $19_1 | 0;
     $7_1 = $15_1 >>> 0 < $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $4_1 = ($6_1 | 0) == ($12_1 | 0) & $13_1 >>> 0 > $18_1 >>> 0 | $6_1 >>> 0 < $12_1 >>> 0;
     $12_1 = ($6_1 | 0) == ($8_1 | 0) & $18_1 >>> 0 > $17_1 >>> 0 | $6_1 >>> 0 > $8_1 >>> 0;
     $6_1 = $4_1 + $12_1 | 0;
     $4_1 = ($6_1 >>> 0 < $12_1 >>> 0) + $7_1 | 0;
     $17_1 = $6_1;
     $6_1 = $6_1 + $15_1 | 0;
     $4_1 = $17_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     HEAP32[$10_1 + 152 >> 2] = $6_1;
     HEAP32[$10_1 + 156 >> 2] = $4_1;
     $9_1 = ($7_1 | 0) == ($9_1 | 0) & $14_1 >>> 0 > $15_1 >>> 0 | $7_1 >>> 0 < $9_1 >>> 0;
     $7_1 = ($4_1 | 0) == ($7_1 | 0) & $6_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0;
     $6_1 = $9_1 + $7_1 | 0;
     $4_1 = $20_1 + ($6_1 >>> 0 < $7_1 >>> 0) | 0;
     $6_1 = $6_1 + $16_1 | 0;
     $4_1 = $6_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     HEAP32[$10_1 + 160 >> 2] = $6_1;
     HEAP32[$10_1 + 164 >> 2] = $4_1;
     $6_1 = HEAP32[$10_1 + 88 >> 2];
     $7_1 = HEAP32[$10_1 + 92 >> 2];
     HEAP32[$10_1 + 456 >> 2] = $7_1 >>> 24;
     HEAP32[$10_1 + 460 >> 2] = 0;
     $7_1 = $7_1 << 6 | $6_1 >>> 26;
     $9_1 = HEAP32[$10_1 + 80 >> 2];
     $12_1 = HEAP32[$10_1 + 84 >> 2];
     HEAP32[$10_1 + 448 >> 2] = $6_1 << 6 | $12_1 >>> 26;
     HEAP32[$10_1 + 452 >> 2] = $7_1 & 1073741823;
     $6_1 = $9_1;
     $7_1 = $12_1 << 4 | $6_1 >>> 28;
     $9_1 = HEAP32[$10_1 + 72 >> 2];
     $12_1 = HEAP32[$10_1 + 76 >> 2];
     HEAP32[$10_1 + 440 >> 2] = $6_1 << 4 | $12_1 >>> 28;
     HEAP32[$10_1 + 444 >> 2] = $7_1 & 1073741823;
     $6_1 = $9_1;
     $7_1 = $12_1 << 2 | $6_1 >>> 30;
     $9_1 = HEAP32[$11_1 + 64 >> 2];
     $10_1 = HEAP32[$11_1 + 68 >> 2];
     HEAP32[$11_1 + 432 >> 2] = $6_1 << 2 | $10_1 >>> 30;
     HEAP32[$11_1 + 436 >> 2] = $7_1 & 1073741823;
     HEAP32[$11_1 + 424 >> 2] = $9_1;
     HEAP32[$11_1 + 428 >> 2] = $10_1 & 1073741823;
     $50($11_1 + 424 | 0, 690320);
     $7_1 = HEAP32[$11_1 + 456 >> 2] << 24;
     $10_1 = HEAP32[$11_1 + 452 >> 2];
     $4_1 = $10_1 >>> 6 | 0;
     $9_1 = HEAP32[$11_1 + 448 >> 2];
     HEAP32[$2_1 + 24 >> 2] = ($10_1 & 63) << 26 | $9_1 >>> 6;
     HEAP32[$2_1 + 28 >> 2] = $4_1 | $7_1;
     $7_1 = $9_1 << 26;
     $10_1 = HEAP32[$11_1 + 444 >> 2];
     $4_1 = $10_1 >>> 4 | 0;
     $9_1 = HEAP32[$11_1 + 440 >> 2];
     HEAP32[$2_1 + 16 >> 2] = ($10_1 & 15) << 28 | $9_1 >>> 4;
     HEAP32[$2_1 + 20 >> 2] = $4_1 | $7_1;
     $7_1 = $9_1 << 28;
     $10_1 = HEAP32[$11_1 + 436 >> 2];
     $4_1 = $10_1 >>> 2 | 0;
     $9_1 = HEAP32[$11_1 + 432 >> 2];
     HEAP32[$2_1 + 8 >> 2] = ($10_1 & 3) << 30 | $9_1 >>> 2;
     HEAP32[$2_1 + 12 >> 2] = $4_1 | $7_1;
     $7_1 = HEAP32[$11_1 + 428 >> 2];
     $4_1 = $9_1 << 30;
     HEAP32[$2_1 >> 2] = HEAP32[$11_1 + 424 >> 2];
     HEAP32[$2_1 + 4 >> 2] = $4_1 | $7_1;
     $41($2_1, $2_1, $21_1);
     $4_1 = HEAP32[$2_1 + 28 >> 2];
     $18_1 = $4_1;
     $4_1 = $4_1 >>> 31 | 0;
     $6_1 = $4_1 ^ -1;
     $8_1 = HEAP32[$2_1 + 12 >> 2];
     $9_1 = ($8_1 | 0) == 1566010995;
     $13_1 = HEAP32[$2_1 + 8 >> 2];
     $17_1 = HEAP32[$2_1 + 16 >> 2];
     $19_1 = HEAP32[$2_1 + 20 >> 2];
     $20_1 = HEAP32[$2_1 + 24 >> 2];
     $6_1 = ($6_1 & ($9_1 & $13_1 >>> 0 < 1470386205 | $8_1 >>> 0 < 1566010995) | (($17_1 & $19_1) != -1 & $6_1 | (($18_1 | 0) == 2147483647 & ($20_1 | 0) != -1 | $18_1 >>> 0 < 2147483647))) ^ -1;
     $7_1 = HEAP32[$2_1 + 4 >> 2];
     $12_1 = HEAP32[$2_1 >> 2];
     $16_1 = $6_1 & (($7_1 | 0) == -538366138 & $12_1 >>> 0 > 1746608288 | $7_1 >>> 0 > 3756601158) | ($6_1 & ($9_1 & $13_1 >>> 0 > 1470386205 | $8_1 >>> 0 > 1566010995) | $4_1);
     $15_1 = $16_1 ? -801750718 : 0;
     $10_1 = $16_1 ? -1 : 0;
     $9_1 = $10_1 ^ $12_1;
     $6_1 = $15_1 + $9_1 | 0;
     $21_1 = $16_1 ? -1076732276 : 0;
     $4_1 = $21_1 + ($7_1 ^ $10_1) | 0;
     $12_1 = $17_1 | $20_1 | $13_1 | $12_1 | ($18_1 | $19_1 | $8_1 | $7_1) ? -1 : 0;
     $23_1 = $6_1 & $12_1;
     HEAP32[$2_1 >> 2] = $23_1;
     $9_1 = $6_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $26_1 = $12_1 & $9_1;
     HEAP32[$2_1 + 4 >> 2] = $26_1;
     $7_1 = $2_1;
     $22_1 = $16_1 ? -1162945306 : 0;
     $4_1 = $22_1 + ($8_1 ^ $10_1) | 0;
     $14_1 = ($9_1 | 0) == ($21_1 | 0) & $6_1 >>> 0 < $15_1 >>> 0 | $9_1 >>> 0 < $21_1 >>> 0;
     $27_1 = $16_1 ? -1354194885 : 0;
     $6_1 = $10_1 ^ $13_1;
     $13_1 = $27_1 + $6_1 | 0;
     $9_1 = $14_1 + $13_1 | 0;
     $4_1 = $6_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $6_1 = $4_1;
     $15_1 = $9_1;
     $21_1 = $9_1 & $12_1;
     HEAP32[$7_1 + 8 >> 2] = $21_1;
     $14_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $25_1 = $12_1 & $14_1;
     HEAP32[$7_1 + 12 >> 2] = $25_1;
     $9_1 = $7_1;
     $24_1 = $16_1 ? -2 : 0;
     $7_1 = $10_1 ^ $17_1;
     $8_1 = $24_1 + $7_1 | 0;
     $17_1 = $16_1 ? -1 : 0;
     $4_1 = $17_1 + ($10_1 ^ $19_1) | 0;
     $7_1 = $7_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $4_1 = ($6_1 | 0) == ($22_1 | 0) & $13_1 >>> 0 < $27_1 >>> 0 | $6_1 >>> 0 < $22_1 >>> 0;
     $13_1 = ($6_1 | 0) == ($14_1 | 0) & $13_1 >>> 0 > $15_1 >>> 0 | $6_1 >>> 0 > $14_1 >>> 0;
     $6_1 = $4_1 + $13_1 | 0;
     $4_1 = ($6_1 >>> 0 < $13_1 >>> 0) + $7_1 | 0;
     $15_1 = $6_1;
     $6_1 = $6_1 + $8_1 | 0;
     $4_1 = $15_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $13_1 = $6_1 & $12_1;
     HEAP32[$9_1 + 16 >> 2] = $13_1;
     $14_1 = $4_1 & $12_1;
     HEAP32[$9_1 + 20 >> 2] = $14_1;
     $9_1 = ($7_1 | 0) == ($17_1 | 0) & $8_1 >>> 0 < $24_1 >>> 0 | $7_1 >>> 0 < $17_1 >>> 0;
     $7_1 = ($4_1 | 0) == ($7_1 | 0) & $6_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0;
     $6_1 = $9_1 + $7_1 | 0;
     $4_1 = $6_1 >>> 0 < $7_1 >>> 0;
     $7_1 = $10_1 ^ $20_1;
     $9_1 = $7_1 - $16_1 | 0;
     $6_1 = $9_1 + $6_1 | 0;
     $4_1 = $4_1 + (($10_1 ^ $18_1) - ($7_1 >>> 0 < $16_1 >>> 0) | 0) | 0;
     $4_1 = $6_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $6_1 = $6_1 & $12_1;
     HEAP32[$2_1 + 24 >> 2] = $6_1;
     $4_1 = $4_1 & $12_1;
     HEAP32[$2_1 + 28 >> 2] = $4_1;
     if ($3_1) {
      HEAP32[$3_1 >> 2] = HEAP32[$3_1 >> 2] ^ $16_1
     }
     if (!($21_1 | $23_1 | $13_1 | $6_1 | ($25_1 | $26_1 | $14_1 | $4_1))) {
      break label$4
     }
     if (!(HEAP32[$1_1 + 24 >> 2] | (HEAP32[$1_1 + 16 >> 2] | (HEAP32[$1_1 + 8 >> 2] | HEAP32[$1_1 >> 2])) | (HEAP32[$1_1 + 28 >> 2] | (HEAP32[$1_1 + 20 >> 2] | (HEAP32[$1_1 + 12 >> 2] | HEAP32[$1_1 + 4 >> 2]))))) {
      break label$4
     }
     $9_1 = 1;
     break label$2;
    }
    $4_1 = $29_1 + 1 | 0;
    $9_1 = 0;
    if (FUNCTION_TABLE[$28_1 | 0]($11_1, 655649, 690788, 0, $5_1, $29_1) | 0) {
     continue
    }
    break;
   };
  }
  $6_1 = $9_1 & $31_1;
  $5_1 = !$6_1;
  $0_1 = $5_1 - 1 | 0;
  $4_1 = 0 - !$5_1 | 0;
  $7_1 = $4_1 & HEAP32[$1_1 + 4 >> 2];
  HEAP32[$1_1 >> 2] = $0_1 & HEAP32[$1_1 >> 2];
  HEAP32[$1_1 + 4 >> 2] = $7_1;
  $7_1 = HEAP32[$1_1 + 12 >> 2] & $4_1;
  HEAP32[$1_1 + 8 >> 2] = HEAP32[$1_1 + 8 >> 2] & $0_1;
  HEAP32[$1_1 + 12 >> 2] = $7_1;
  $7_1 = HEAP32[$1_1 + 20 >> 2] & $4_1;
  HEAP32[$1_1 + 16 >> 2] = HEAP32[$1_1 + 16 >> 2] & $0_1;
  HEAP32[$1_1 + 20 >> 2] = $7_1;
  $7_1 = HEAP32[$1_1 + 28 >> 2] & $4_1;
  HEAP32[$1_1 + 24 >> 2] = HEAP32[$1_1 + 24 >> 2] & $0_1;
  HEAP32[$1_1 + 28 >> 2] = $7_1;
  $1_1 = HEAP32[$2_1 + 4 >> 2] & $4_1;
  HEAP32[$2_1 >> 2] = HEAP32[$2_1 >> 2] & $0_1;
  HEAP32[$2_1 + 4 >> 2] = $1_1;
  $1_1 = HEAP32[$2_1 + 12 >> 2] & $4_1;
  HEAP32[$2_1 + 8 >> 2] = HEAP32[$2_1 + 8 >> 2] & $0_1;
  HEAP32[$2_1 + 12 >> 2] = $1_1;
  $1_1 = HEAP32[$2_1 + 20 >> 2] & $4_1;
  HEAP32[$2_1 + 16 >> 2] = HEAP32[$2_1 + 16 >> 2] & $0_1;
  HEAP32[$2_1 + 20 >> 2] = $1_1;
  $1_1 = HEAP32[$2_1 + 28 >> 2] & $4_1;
  HEAP32[$2_1 + 24 >> 2] = HEAP32[$2_1 + 24 >> 2] & $0_1;
  HEAP32[$2_1 + 28 >> 2] = $1_1;
  if ($3_1) {
   HEAP32[$11_1 + 256 >> 2] = $5_1;
   HEAP32[$3_1 >> 2] = HEAP32[$3_1 >> 2] & HEAP32[$11_1 + 256 >> 2] - 1;
  }
  global$0 = $11_1 + 464 | 0;
  return $6_1;
 }
 
 function $48($0_1, $1_1, $2_1) {
  var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0;
  $5_1 = global$0 - 128 | 0;
  global$0 = $5_1;
  $26_1 = $70($1_1, $0_1 + 40 | 0, 128);
  $6_1 = HEAP32[$0_1 + 8 >> 2];
  $9_1 = HEAP32[$2_1 >> 2];
  $20_1 = $6_1 + $9_1 | 0;
  $1_1 = HEAP32[$0_1 + 12 >> 2];
  $3_1 = $1_1 + HEAP32[$2_1 + 4 >> 2] | 0;
  $7_1 = $9_1 >>> 0 > $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = ($1_1 | 0) == ($7_1 | 0) & $6_1 >>> 0 > $20_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
  $6_1 = HEAP32[$2_1 + 8 >> 2];
  $3_1 = $8_1 + $6_1 | 0;
  $1_1 = HEAP32[$2_1 + 12 >> 2];
  $1_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $6_1 = $3_1;
  $3_1 = $0_1 + 16 | 0;
  $9_1 = HEAP32[$3_1 >> 2];
  $19_1 = $6_1 + $9_1 | 0;
  $3_1 = $1_1 + HEAP32[$3_1 + 4 >> 2] | 0;
  $8_1 = !$1_1 & $6_1 >>> 0 < $8_1 >>> 0;
  $9_1 = $9_1 >>> 0 > $19_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = ($1_1 | 0) == ($9_1 | 0) & $6_1 >>> 0 > $19_1 >>> 0 | $1_1 >>> 0 > $9_1 >>> 0;
  $3_1 = $8_1 + $6_1 | 0;
  $1_1 = $3_1 >>> 0 < $6_1 >>> 0;
  $13_1 = $3_1;
  $3_1 = HEAP32[$2_1 + 16 >> 2];
  $8_1 = $13_1 + $3_1 | 0;
  $6_1 = $1_1;
  $1_1 = $1_1 + HEAP32[$2_1 + 20 >> 2] | 0;
  $3_1 = $3_1 >>> 0 > $8_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $0_1 + 24 | 0;
  $17_1 = HEAP32[$1_1 >> 2];
  $11_1 = $17_1 + $8_1 | 0;
  $1_1 = $3_1 + HEAP32[$1_1 + 4 >> 2] | 0;
  $13_1 = ($3_1 | 0) == ($6_1 | 0) & $8_1 >>> 0 < $13_1 >>> 0 | $3_1 >>> 0 < $6_1 >>> 0;
  $6_1 = $11_1 >>> 0 < $17_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $8_1;
  $8_1 = $11_1;
  $11_1 = ($3_1 | 0) == ($6_1 | 0) & $1_1 >>> 0 > $8_1 >>> 0 | $3_1 >>> 0 > $6_1 >>> 0;
  $3_1 = $13_1 + $11_1 | 0;
  $1_1 = $3_1 >>> 0 < $11_1 >>> 0;
  $17_1 = $3_1;
  $13_1 = HEAP32[$2_1 + 24 >> 2];
  $11_1 = $3_1 + $13_1 | 0;
  $3_1 = $1_1;
  $1_1 = $1_1 + HEAP32[$2_1 + 28 >> 2] | 0;
  $1_1 = $11_1 >>> 0 < $13_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $0_1 = $0_1 + 32 | 0;
  $13_1 = HEAP32[$0_1 >> 2];
  $2_1 = $13_1 + $11_1 | 0;
  $0_1 = $1_1 + HEAP32[$0_1 + 4 >> 2] | 0;
  $21_1 = $2_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $13_1 = $2_1;
  $17_1 = (($1_1 | 0) == ($3_1 | 0) & $11_1 >>> 0 < $17_1 >>> 0 | $1_1 >>> 0 < $3_1 >>> 0) + (($1_1 | 0) == ($21_1 | 0) & $2_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $21_1 >>> 0) | 0;
  $1_1 = ($6_1 | 0) == -1;
  $2_1 = $1_1 & $8_1 >>> 0 < 4294967294 | ($6_1 | 0) != -1 | ($2_1 & $21_1) != -1;
  $0_1 = ($9_1 | 0) == -1162945306;
  $3_1 = ($2_1 | ($0_1 & $19_1 >>> 0 < 2940772411 | $9_1 >>> 0 < 3132021990)) ^ -1;
  $11_1 = $17_1 + ($3_1 & (($7_1 | 0) == -1076732276 & $20_1 >>> 0 > 3493216576 | $7_1 >>> 0 > 3218235020) | ($3_1 & ($0_1 & $19_1 >>> 0 > 2940772411 | $9_1 >>> 0 > 3132021990) | ($8_1 | 0) == -1 & $1_1 & ($2_1 ^ -1))) | 0;
  $0_1 = __wasm_i64_mul($11_1, 0, 801750719, 1076732275);
  $2_1 = $0_1 + $20_1 | 0;
  $1_1 = $7_1 + i64toi32_i32$HIGH_BITS | 0;
  HEAP32[$5_1 + 8 >> 2] = $2_1;
  $1_1 = $0_1 >>> 0 > $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  HEAP32[$5_1 + 12 >> 2] = $1_1;
  $0_1 = $5_1;
  $7_1 = ($1_1 | 0) == ($7_1 | 0) & $2_1 >>> 0 < $20_1 >>> 0 | $1_1 >>> 0 < $7_1 >>> 0;
  $3_1 = __wasm_i64_mul($11_1, 0, 1354194884, 1162945305);
  $2_1 = $3_1 + $19_1 | 0;
  $1_1 = $9_1 + i64toi32_i32$HIGH_BITS | 0;
  $1_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $7_1 = $2_1 + $7_1 | 0;
  $3_1 = $7_1 >>> 0 < $2_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  HEAP32[$0_1 + 16 >> 2] = $7_1;
  HEAP32[$0_1 + 20 >> 2] = $3_1;
  $3_1 = ($1_1 | 0) == ($3_1 | 0) & $2_1 >>> 0 > $7_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
  $2_1 = $3_1 + (($1_1 | 0) == ($9_1 | 0) & $2_1 >>> 0 < $19_1 >>> 0 | $1_1 >>> 0 < $9_1 >>> 0) | 0;
  $1_1 = $2_1 >>> 0 < $3_1 >>> 0;
  $3_1 = $2_1;
  $9_1 = $1_1;
  $1_1 = $6_1;
  $7_1 = $8_1 + $11_1 | 0;
  $2_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $1_1 = $2_1 + $9_1 | 0;
  $17_1 = $3_1;
  $3_1 = $7_1;
  $7_1 = $17_1 + $3_1 | 0;
  HEAP32[$0_1 + 24 >> 2] = $7_1;
  $1_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  HEAP32[$0_1 + 28 >> 2] = $1_1;
  $0_1 = ($2_1 | 0) == ($6_1 | 0) & $3_1 >>> 0 < $8_1 >>> 0 | $2_1 >>> 0 < $6_1 >>> 0;
  $2_1 = ($1_1 | 0) == ($2_1 | 0) & $3_1 >>> 0 > $7_1 >>> 0 | $1_1 >>> 0 < $2_1 >>> 0;
  $1_1 = $0_1 + $2_1 | 0;
  $3_1 = $21_1 + ($1_1 >>> 0 < $2_1 >>> 0) | 0;
  $0_1 = $1_1 + $13_1 | 0;
  $3_1 = $0_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$5_1 + 32 >> 2] = $0_1;
  HEAP32[$5_1 + 36 >> 2] = $3_1;
  $2_1 = 0;
  $19_1 = 0;
  $6_1 = 0;
  $20_1 = 0;
  $11_1 = 0;
  $13_1 = 0;
  $9_1 = 0;
  $7_1 = 0;
  $17_1 = 0;
  $8_1 = 0;
  $21_1 = 0;
  while (1) {
   HEAP32[$5_1 + 120 >> 2] = 0;
   $1_1 = ($5_1 + 8 | 0) + ($27_1 >>> 2 & 1073741816) | 0;
   $0_1 = HEAP32[$1_1 >> 2];
   $3_1 = HEAP32[$1_1 + 4 >> 2];
   $4_1 = $28_1 & 62;
   $1_1 = $4_1 & 31;
   if ($4_1 >>> 0 >= 32) {
    $0_1 = $3_1 >>> $1_1 | 0
   } else {
    $0_1 = ((1 << $1_1) - 1 & $3_1) << 32 - $1_1 | $0_1 >>> $1_1
   }
   $12_1 = $0_1 & 3;
   $14_1 = ($12_1 | 0) == 1;
   $4_1 = $22_1 + 656432 | 0;
   $0_1 = $4_1 + 248 | 0;
   $1_1 = $4_1 + 184 | 0;
   $3_1 = $4_1 + 120 | 0;
   $10_1 = $4_1 + 56 | 0;
   $15_1 = ($12_1 | 0) == 2;
   $16_1 = ($12_1 | 0) == 3;
   $2_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$1_1 >> 2] : $14_1 ? HEAP32[$3_1 >> 2] : $12_1 ? $2_1 : HEAP32[$10_1 >> 2];
   $1_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$1_1 + 4 >> 2] : $14_1 ? HEAP32[$3_1 + 4 >> 2] : $12_1 ? $19_1 : HEAP32[$10_1 + 4 >> 2];
   $19_1 = $1_1;
   $0_1 = $1_1 >>> 16 | 0;
   HEAP32[$5_1 + 112 >> 2] = ($1_1 & 65535) << 16 | $2_1 >>> 16;
   HEAP32[$5_1 + 116 >> 2] = $0_1;
   $0_1 = $4_1 + 224 | 0;
   $1_1 = $4_1 + 160 | 0;
   $3_1 = $4_1 + 96 | 0;
   $10_1 = $4_1 + 32 | 0;
   $29_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$1_1 >> 2] : $14_1 ? HEAP32[$3_1 >> 2] : $12_1 ? $29_1 : HEAP32[$10_1 >> 2];
   $9_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$1_1 + 4 >> 2] : $14_1 ? HEAP32[$3_1 + 4 >> 2] : $12_1 ? $9_1 : HEAP32[$10_1 + 4 >> 2];
   HEAP32[$5_1 + 80 >> 2] = $29_1;
   HEAP32[$5_1 + 84 >> 2] = $9_1 & 1048575;
   $0_1 = $4_1 + 216 | 0;
   $1_1 = $4_1 + 152 | 0;
   $3_1 = $4_1 + 88 | 0;
   $10_1 = $4_1 + 24 | 0;
   $7_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$1_1 >> 2] : $14_1 ? HEAP32[$3_1 >> 2] : $12_1 ? $7_1 : HEAP32[$10_1 >> 2];
   $0_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$1_1 + 4 >> 2] : $14_1 ? HEAP32[$3_1 + 4 >> 2] : $12_1 ? $17_1 : HEAP32[$10_1 + 4 >> 2];
   $17_1 = $0_1;
   $3_1 = $0_1 >>> 16 | 0;
   HEAP32[$5_1 + 72 >> 2] = ($0_1 & 65535) << 16 | $7_1 >>> 16;
   HEAP32[$5_1 + 76 >> 2] = $3_1;
   $0_1 = $4_1 + 192 | 0;
   $1_1 = $4_1 + 128 | 0;
   $3_1 = $4_1 - -64 | 0;
   $30_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$1_1 >> 2] : $14_1 ? HEAP32[$3_1 >> 2] : $12_1 ? $30_1 : HEAP32[$4_1 >> 2];
   $23_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$1_1 + 4 >> 2] : $14_1 ? HEAP32[$3_1 + 4 >> 2] : $12_1 ? $23_1 : HEAP32[$4_1 + 4 >> 2];
   HEAP32[$5_1 + 40 >> 2] = $30_1;
   HEAP32[$5_1 + 44 >> 2] = $23_1 & 1048575;
   $3_1 = $2_1 << 4 & 1048560;
   $0_1 = $4_1 + 240 | 0;
   $1_1 = $4_1 + 176 | 0;
   $10_1 = $4_1 + 112 | 0;
   $18_1 = $4_1 + 48 | 0;
   $6_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$1_1 >> 2] : $14_1 ? HEAP32[$10_1 >> 2] : $12_1 ? $6_1 : HEAP32[$18_1 >> 2];
   $1_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$1_1 + 4 >> 2] : $14_1 ? HEAP32[$10_1 + 4 >> 2] : $12_1 ? $20_1 : HEAP32[$18_1 + 4 >> 2];
   $20_1 = $1_1;
   $0_1 = $1_1 >>> 28 | 0;
   HEAP32[$5_1 + 104 >> 2] = ($1_1 & 268435455) << 4 | $6_1 >>> 28;
   HEAP32[$5_1 + 108 >> 2] = $0_1 | $3_1;
   $3_1 = $4_1 + 232 | 0;
   $10_1 = $4_1 + 168 | 0;
   $18_1 = $4_1 + 104 | 0;
   $0_1 = $4_1 + 40 | 0;
   $11_1 = $16_1 ? HEAP32[$3_1 >> 2] : $15_1 ? HEAP32[$10_1 >> 2] : $14_1 ? HEAP32[$18_1 >> 2] : $12_1 ? $11_1 : HEAP32[$0_1 >> 2];
   $13_1 = $16_1 ? HEAP32[$3_1 + 4 >> 2] : $15_1 ? HEAP32[$10_1 + 4 >> 2] : $14_1 ? HEAP32[$18_1 + 4 >> 2] : $12_1 ? $13_1 : HEAP32[$0_1 + 4 >> 2];
   HEAP32[$5_1 + 96 >> 2] = $6_1 << 24 & -16777216 | $13_1 >>> 8;
   HEAP32[$5_1 + 100 >> 2] = ($1_1 << 24 | $6_1 >>> 8) & 1048575;
   HEAP32[$5_1 + 88 >> 2] = $11_1 << 12 & -4096 | $9_1 >>> 20;
   HEAP32[$5_1 + 92 >> 2] = ($13_1 << 12 | $11_1 >>> 20) & 1048575;
   $0_1 = $4_1 + 208 | 0;
   $1_1 = $4_1 + 144 | 0;
   $10_1 = $4_1 + 80 | 0;
   $18_1 = $4_1 + 16 | 0;
   $8_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$1_1 >> 2] : $14_1 ? HEAP32[$10_1 >> 2] : $12_1 ? $8_1 : HEAP32[$18_1 >> 2];
   $0_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$1_1 + 4 >> 2] : $14_1 ? HEAP32[$10_1 + 4 >> 2] : $12_1 ? $21_1 : HEAP32[$18_1 + 4 >> 2];
   $21_1 = $0_1;
   $1_1 = $0_1 >>> 28 | 0;
   HEAP32[$5_1 + 64 >> 2] = ($0_1 & 268435455) << 4 | $8_1 >>> 28;
   HEAP32[$5_1 + 68 >> 2] = $1_1 | $7_1 << 4 & 1048560;
   $1_1 = $8_1 << 24 & -16777216;
   $0_1 = $4_1 + 200 | 0;
   $10_1 = $4_1 + 136 | 0;
   $18_1 = $4_1 + 72 | 0;
   $4_1 = $4_1 + 8 | 0;
   $24_1 = $16_1 ? HEAP32[$0_1 >> 2] : $15_1 ? HEAP32[$10_1 >> 2] : $14_1 ? HEAP32[$18_1 >> 2] : $12_1 ? $24_1 : HEAP32[$4_1 >> 2];
   $25_1 = $16_1 ? HEAP32[$0_1 + 4 >> 2] : $15_1 ? HEAP32[$10_1 + 4 >> 2] : $14_1 ? HEAP32[$18_1 + 4 >> 2] : $12_1 ? $25_1 : HEAP32[$4_1 + 4 >> 2];
   HEAP32[$5_1 + 56 >> 2] = $25_1 >>> 8 | $1_1;
   HEAP32[$5_1 + 60 >> 2] = ($21_1 << 24 | $8_1 >>> 8) & 1048575;
   HEAP32[$5_1 + 48 >> 2] = $24_1 << 12 & -4096 | $23_1 >>> 20;
   HEAP32[$5_1 + 52 >> 2] = ($25_1 << 12 | $24_1 >>> 20) & 1048575;
   $53($26_1, $26_1, $5_1 + 40 | 0);
   $28_1 = $28_1 + 2 | 0;
   $27_1 = $27_1 + 1 | 0;
   $22_1 = $22_1 + 256 | 0;
   if (($22_1 | 0) != 32768) {
    continue
   }
   break;
  };
  global$0 = $5_1 + 128 | 0;
 }
 
 function $49($0_1, $1_1) {
  var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0;
  $6_1 = global$0 - 80 | 0;
  global$0 = $6_1;
  HEAP32[$0_1 + 80 >> 2] = HEAP32[$1_1 + 120 >> 2];
  $13_1 = $1_1 + 104 | 0;
  $11_1 = HEAP32[$13_1 >> 2];
  $12_1 = HEAP32[$13_1 + 4 >> 2];
  $14_1 = $1_1 + 96 | 0;
  $7_1 = HEAP32[$14_1 >> 2];
  $10_1 = HEAP32[$14_1 + 4 >> 2];
  $15_1 = $1_1 + 88 | 0;
  $5_1 = HEAP32[$15_1 >> 2];
  $8_1 = HEAP32[$15_1 + 4 >> 2];
  $9_1 = HEAP32[$1_1 + 84 >> 2];
  $16_1 = $1_1 + 112 | 0;
  $17_1 = HEAP32[$16_1 >> 2];
  $4_1 = HEAP32[$16_1 + 4 >> 2];
  $21_1 = $4_1;
  $2_1 = HEAP32[$1_1 + 80 >> 2];
  $3_1 = __wasm_i64_mul($4_1 >>> 16 | 0, 0, 977, 1);
  $4_1 = $2_1 + $3_1 | 0;
  $2_1 = $9_1 + i64toi32_i32$HIGH_BITS | 0;
  $9_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $8_1;
  $3_1 = $9_1 >>> 20 | 0;
  $8_1 = $3_1;
  $3_1 = $3_1 + $5_1 | 0;
  $8_1 = $8_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $10_1;
  $5_1 = $8_1 >>> 20 | 0;
  $10_1 = $5_1;
  $5_1 = $5_1 + $7_1 | 0;
  $10_1 = $10_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $12_1;
  $7_1 = $10_1 >>> 20 | 0;
  $12_1 = $7_1;
  $7_1 = $7_1 + $11_1 | 0;
  $11_1 = $12_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $22_1 = $8_1 & 1048575;
  $2_1 = $9_1 & 1048575;
  $19_1 = $4_1;
  $18_1 = $2_1;
  $12_1 = $3_1;
  $9_1 = $5_1;
  $20_1 = $10_1 & 1048575;
  $5_1 = ($3_1 & $5_1 & $7_1) == -1 & ($20_1 & $8_1 & $11_1) == 1048575;
  $2_1 = $21_1 & 65535;
  $3_1 = $11_1 >>> 20 | 0;
  $4_1 = $3_1;
  $3_1 = $3_1 + $17_1 | 0;
  $2_1 = $4_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $8_1 = $3_1;
  $4_1 = $2_1;
  $5_1 = __wasm_i64_mul($5_1 & (($3_1 | 0) == -1 & ($2_1 | 0) == 65535) & (($18_1 | 0) == 1048574 & $19_1 >>> 0 > 4294966318 | $18_1 >>> 0 > 1048574) | $2_1 >>> 16, 0, 977, 1);
  $3_1 = $5_1 + $19_1 | 0;
  $2_1 = $18_1 + i64toi32_i32$HIGH_BITS | 0;
  $2_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $5_1 = $3_1;
  $17_1 = $2_1;
  $2_1 = $22_1;
  $3_1 = $17_1 >>> 20 | 0;
  $10_1 = $3_1 + $12_1 | 0;
  $3_1 = $3_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$6_1 + 40 >> 2] = $5_1;
  HEAP32[$6_1 + 44 >> 2] = $10_1 << 20 & 1072693248 | $17_1 & 1048575;
  $2_1 = $20_1;
  $12_1 = $9_1;
  $5_1 = $3_1;
  $9_1 = ($3_1 >>> 20 | 0) + $9_1 | 0;
  $3_1 = $12_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $17_1 = $9_1 << 10 & 1073740800;
  $2_1 = $5_1 >>> 10 | 0;
  HEAP32[$6_1 + 48 >> 2] = ($5_1 & 1023) << 22 | $10_1 >>> 10;
  HEAP32[$6_1 + 52 >> 2] = $17_1 | $2_1 & 1023;
  $2_1 = $11_1 & 1048575;
  $5_1 = $3_1;
  $3_1 = $3_1 >>> 20 | 0;
  $7_1 = $3_1 + $7_1 | 0;
  $3_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$6_1 + 56 >> 2] = ($5_1 & 1048575) << 12 | $9_1 >>> 20;
  HEAP32[$6_1 + 60 >> 2] = $7_1 & 1073741823;
  $2_1 = $4_1;
  $4_1 = ($3_1 >>> 20 | 0) + $8_1 | 0;
  $2_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$6_1 + 72 >> 2] = $2_1 >>> 8 & 255;
  HEAP32[$6_1 + 76 >> 2] = 0;
  $2_1 = $2_1 << 22 | $4_1 >>> 10;
  HEAP32[$6_1 + 64 >> 2] = (($3_1 & 1073741823) << 2 | $7_1 >>> 30) & 4194303 | $4_1 << 22 & -4194304;
  HEAP32[$6_1 + 68 >> 2] = $2_1 & 1073741823;
  $8_1 = $6_1 + 40 | 0;
  $50($8_1, 690464);
  $3_1 = HEAP32[$6_1 + 44 >> 2];
  $4_1 = $3_1;
  HEAP32[$1_1 + 80 >> 2] = HEAP32[$6_1 + 40 >> 2];
  HEAP32[$1_1 + 84 >> 2] = $3_1 & 1048575;
  $5_1 = HEAP32[$6_1 + 72 >> 2] << 8;
  $11_1 = HEAP32[$6_1 + 68 >> 2];
  $2_1 = $11_1 >>> 22 | 0;
  $7_1 = HEAP32[$6_1 + 64 >> 2];
  HEAP32[$16_1 >> 2] = ($11_1 & 4194303) << 10 | $7_1 >>> 22;
  HEAP32[$16_1 + 4 >> 2] = $2_1 | $5_1;
  $3_1 = $7_1;
  $2_1 = $11_1 << 30 | $3_1 >>> 2;
  $7_1 = $3_1 << 30 & -1073741824;
  $3_1 = HEAP32[$6_1 + 56 >> 2];
  $5_1 = HEAP32[$6_1 + 60 >> 2];
  HEAP32[$13_1 >> 2] = $5_1 | $7_1;
  HEAP32[$13_1 + 4 >> 2] = $2_1 & 1048575;
  $2_1 = $5_1 << 20 | $3_1 >>> 12;
  $7_1 = $3_1 << 20 & -1048576;
  $3_1 = HEAP32[$6_1 + 48 >> 2];
  $5_1 = HEAP32[$6_1 + 52 >> 2];
  HEAP32[$14_1 >> 2] = $5_1 >>> 10 | $7_1;
  HEAP32[$14_1 + 4 >> 2] = $2_1 & 1048575;
  $5_1 = ($5_1 << 10 | $3_1 >>> 22) & 1048575;
  HEAP32[$15_1 >> 2] = $3_1 << 10 & -1024 | $4_1 >>> 20;
  HEAP32[$15_1 + 4 >> 2] = $5_1;
  $2_1 = $1_1 + 80 | 0;
  $54($8_1, $2_1);
  $34($6_1, $2_1, $8_1);
  $34($1_1, $1_1, $8_1);
  $2_1 = $1_1 + 40 | 0;
  $34($2_1, $2_1, $6_1);
  HEAP32[$16_1 >> 2] = 0;
  HEAP32[$16_1 + 4 >> 2] = 0;
  HEAP32[$13_1 >> 2] = 0;
  HEAP32[$13_1 + 4 >> 2] = 0;
  HEAP32[$14_1 >> 2] = 0;
  HEAP32[$14_1 + 4 >> 2] = 0;
  HEAP32[$15_1 >> 2] = 0;
  HEAP32[$15_1 + 4 >> 2] = 0;
  HEAP32[$1_1 + 80 >> 2] = 1;
  HEAP32[$1_1 + 84 >> 2] = 0;
  $2_1 = HEAP32[$1_1 + 4 >> 2];
  HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
  HEAP32[$0_1 + 4 >> 2] = $2_1;
  $2_1 = $1_1 + 8 | 0;
  $3_1 = HEAP32[$2_1 + 4 >> 2];
  $4_1 = $0_1 + 8 | 0;
  HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
  HEAP32[$4_1 + 4 >> 2] = $3_1;
  $2_1 = $1_1 + 16 | 0;
  $3_1 = HEAP32[$2_1 + 4 >> 2];
  $4_1 = $0_1 + 16 | 0;
  HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
  HEAP32[$4_1 + 4 >> 2] = $3_1;
  $2_1 = $1_1 + 24 | 0;
  $3_1 = HEAP32[$2_1 + 4 >> 2];
  $4_1 = $0_1 + 24 | 0;
  HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
  HEAP32[$4_1 + 4 >> 2] = $3_1;
  $2_1 = $1_1 + 32 | 0;
  $3_1 = HEAP32[$2_1 + 4 >> 2];
  $4_1 = $0_1 + 32 | 0;
  HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
  HEAP32[$4_1 + 4 >> 2] = $3_1;
  $2_1 = HEAP32[$1_1 + 44 >> 2];
  HEAP32[$0_1 + 40 >> 2] = HEAP32[$1_1 + 40 >> 2];
  HEAP32[$0_1 + 44 >> 2] = $2_1;
  $2_1 = $1_1 + 48 | 0;
  $3_1 = HEAP32[$2_1 + 4 >> 2];
  $4_1 = $0_1 + 48 | 0;
  HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
  HEAP32[$4_1 + 4 >> 2] = $3_1;
  $2_1 = $1_1 + 56 | 0;
  $3_1 = HEAP32[$2_1 + 4 >> 2];
  $4_1 = $0_1 + 56 | 0;
  HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
  HEAP32[$4_1 + 4 >> 2] = $3_1;
  $2_1 = $1_1 - -64 | 0;
  $3_1 = HEAP32[$2_1 + 4 >> 2];
  $4_1 = $0_1 - -64 | 0;
  HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
  HEAP32[$4_1 + 4 >> 2] = $3_1;
  $1_1 = $1_1 + 72 | 0;
  $2_1 = HEAP32[$1_1 + 4 >> 2];
  $0_1 = $0_1 + 72 | 0;
  HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
  HEAP32[$0_1 + 4 >> 2] = $2_1;
  global$0 = $6_1 + 80 | 0;
 }
 
 function $50($0_1, $1_1) {
  var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0;
  $7_1 = global$0 - 432 | 0;
  global$0 = $7_1;
  $3_1 = $7_1 + 392 | 0;
  $2_1 = $3_1 + 32 | 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  $2_1 = $3_1 + 24 | 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  $2_1 = $3_1 + 16 | 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  $3_1 = $3_1 + 8 | 0;
  HEAP32[$3_1 >> 2] = 0;
  HEAP32[$3_1 + 4 >> 2] = 0;
  HEAP32[$7_1 + 392 >> 2] = 0;
  HEAP32[$7_1 + 396 >> 2] = 0;
  $3_1 = $7_1 + 352 | 0;
  $2_1 = $3_1 + 32 | 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  $2_1 = $3_1 + 24 | 0;
  HEAP32[$2_1 >> 2] = 0;
  HEAP32[$2_1 + 4 >> 2] = 0;
  $3_1 = $3_1 + 16 | 0;
  HEAP32[$3_1 >> 2] = 0;
  HEAP32[$3_1 + 4 >> 2] = 0;
  HEAP32[$7_1 + 360 >> 2] = 0;
  HEAP32[$7_1 + 364 >> 2] = 0;
  HEAP32[$7_1 + 352 >> 2] = 1;
  HEAP32[$7_1 + 356 >> 2] = 0;
  $34_1 = $0_1;
  $41_1 = HEAP32[$0_1 + 32 >> 2];
  $43_1 = HEAP32[$0_1 + 36 >> 2];
  $20_1 = HEAP32[$0_1 + 24 >> 2];
  $39_1 = HEAP32[$0_1 + 28 >> 2];
  $26_1 = HEAP32[$0_1 + 16 >> 2];
  $29_1 = HEAP32[$0_1 + 20 >> 2];
  $22_1 = HEAP32[$0_1 + 8 >> 2];
  $35_1 = HEAP32[$0_1 + 12 >> 2];
  $3_1 = HEAP32[$0_1 >> 2];
  $9_1 = HEAP32[$0_1 + 4 >> 2];
  $42_1 = HEAP32[$1_1 + 32 >> 2];
  $23_1 = HEAP32[$1_1 + 36 >> 2];
  $30_1 = HEAP32[$1_1 + 24 >> 2];
  $31_1 = HEAP32[$1_1 + 28 >> 2];
  $27_1 = HEAP32[$1_1 + 16 >> 2];
  $32_1 = HEAP32[$1_1 + 20 >> 2];
  $24_1 = HEAP32[$1_1 + 8 >> 2];
  $33_1 = HEAP32[$1_1 + 12 >> 2];
  $2_1 = HEAP32[$1_1 >> 2];
  $11_1 = HEAP32[$1_1 + 4 >> 2];
  $44_1 = -1;
  $21_1 = -1;
  while (1) {
   $5_1 = 8;
   $4_1 = 0;
   $36_1 = 59;
   $6_1 = 0;
   $14_1 = 0;
   $8_1 = $3_1;
   $0_1 = $9_1;
   $12_1 = $2_1;
   $19_1 = $11_1;
   $10_1 = 0;
   $15_1 = 0;
   $16_1 = 8;
   $13_1 = 0;
   while (1) {
    $18_1 = $0_1;
    $0_1 = $8_1 & 1;
    $28_1 = 0 - $0_1 | 0;
    $37_1 = 0 - $0_1 | 0;
    $25_1 = $37_1;
    $38_1 = $21_1;
    $0_1 = $21_1 >> 31;
    $17_1 = $0_1;
    $0_1 = $0_1 ^ $12_1;
    $21_1 = $0_1 - $17_1 & $28_1;
    $8_1 = $21_1 + $8_1 | 0;
    $0_1 = $18_1 + ($25_1 & ($17_1 ^ $19_1) - (($0_1 >>> 0 < $17_1 >>> 0) + $17_1 | 0)) | 0;
    $40_1 = $8_1;
    $8_1 = $8_1 >>> 0 < $21_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $18_1 = $17_1 & $25_1;
    $0_1 = ($8_1 & $18_1) + $19_1 | 0;
    $19_1 = $12_1;
    $21_1 = $17_1 & $28_1;
    $12_1 = ($21_1 & $40_1) + $12_1 | 0;
    $19_1 = $19_1 >>> 0 > $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = $6_1 ^ $17_1;
    $25_1 = $0_1 - $17_1 & $28_1;
    $16_1 = $25_1 + $16_1 | 0;
    $0_1 = $13_1 + (($14_1 ^ $17_1) - (($0_1 >>> 0 < $17_1 >>> 0) + $17_1 | 0) & $37_1) | 0;
    $13_1 = $16_1 >>> 0 < $25_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = ($13_1 & $18_1) + $14_1 | 0;
    $14_1 = $6_1;
    $6_1 = ($16_1 & $21_1) + $6_1 | 0;
    $0_1 = ($14_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) << 1 | $6_1 >>> 31;
    $6_1 = $6_1 << 1;
    $14_1 = $0_1;
    $25_1 = $21_1;
    $0_1 = $5_1 ^ $17_1;
    $21_1 = ($0_1 - $17_1 & $28_1) + $10_1 | 0;
    $0_1 = (($4_1 ^ $17_1) - (($0_1 >>> 0 < $17_1 >>> 0) + $17_1 | 0) & $37_1) + $15_1 | 0;
    $15_1 = $10_1 >>> 0 > $21_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
    $0_1 = ($15_1 & $18_1) + $4_1 | 0;
    $4_1 = $5_1;
    $10_1 = $21_1;
    $5_1 = ($25_1 & $10_1) + $5_1 | 0;
    $0_1 = ($4_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) << 1 | $5_1 >>> 31;
    $5_1 = $5_1 << 1;
    $4_1 = $0_1;
    $0_1 = $25_1 ^ $44_1;
    $44_1 = $0_1 - 1 | 0;
    $21_1 = ($18_1 ^ $38_1) - !$0_1 | 0;
    $0_1 = $8_1 >>> 1 | 0;
    $8_1 = ($8_1 & 1) << 31 | $40_1 >>> 1;
    $36_1 = $36_1 - 1 | 0;
    if ($36_1) {
     continue
    }
    break;
   };
   HEAP32[$7_1 + 344 >> 2] = $16_1;
   HEAP32[$7_1 + 348 >> 2] = $13_1;
   HEAP32[$7_1 + 336 >> 2] = $10_1;
   HEAP32[$7_1 + 340 >> 2] = $15_1;
   HEAP32[$7_1 + 328 >> 2] = $6_1;
   HEAP32[$7_1 + 332 >> 2] = $14_1;
   HEAP32[$7_1 + 320 >> 2] = $5_1;
   HEAP32[$7_1 + 324 >> 2] = $4_1;
   $67($7_1 + 392 | 0, $7_1 + 352 | 0, $7_1 + 320 | 0, $1_1);
   $0_1 = $11_1 >> 31;
   $40_1 = $7_1 + 304 | 0;
   $8_1 = $4_1 >> 31;
   $12_1 = $2_1;
   $19_1 = $0_1;
   $69($40_1, $5_1, $4_1, $8_1, $8_1, $2_1, $11_1, $0_1, $0_1);
   $0_1 = $9_1 >> 31;
   $25_1 = $7_1 + 272 | 0;
   $2_1 = $14_1 >> 31;
   $18_1 = $3_1;
   $17_1 = $0_1;
   $69($25_1, $6_1, $14_1, $2_1, $2_1, $3_1, $9_1, $0_1, $0_1);
   $0_1 = $15_1 >> 31;
   $28_1 = $7_1 + 288 | 0;
   $38_1 = $10_1;
   $3_1 = $0_1;
   $69($28_1, $10_1, $15_1, $0_1, $0_1, $12_1, $11_1, $19_1, $19_1);
   $0_1 = $13_1 >> 31;
   $11_1 = $7_1 + 256 | 0;
   $10_1 = $0_1;
   $69($11_1, $16_1, $13_1, $0_1, $0_1, $18_1, $9_1, $17_1, $17_1);
   $0_1 = $33_1 >> 31;
   $12_1 = $7_1 + 240 | 0;
   $9_1 = $0_1;
   $69($12_1, $5_1, $4_1, $8_1, $8_1, $24_1, $33_1, $0_1, $0_1);
   $19_1 = $7_1 + 208 | 0;
   $18_1 = $35_1;
   $0_1 = $18_1 >> 31;
   $69($19_1, $6_1, $14_1, $2_1, $2_1, $22_1, $18_1, $0_1, $0_1);
   $18_1 = $7_1 + 224 | 0;
   $69($18_1, $38_1, $15_1, $3_1, $3_1, $24_1, $33_1, $9_1, $9_1);
   $17_1 = $7_1 + 192 | 0;
   $69($17_1, $16_1, $13_1, $10_1, $10_1, $22_1, $35_1, $0_1, $0_1);
   $0_1 = $32_1 >> 31;
   $22_1 = $7_1 + 176 | 0;
   $9_1 = $0_1;
   $69($22_1, $5_1, $4_1, $8_1, $8_1, $27_1, $32_1, $0_1, $0_1);
   $35_1 = $7_1 + 144 | 0;
   $0_1 = $29_1 >> 31;
   $69($35_1, $6_1, $14_1, $2_1, $2_1, $26_1, $29_1, $0_1, $0_1);
   $33_1 = $7_1 + 160 | 0;
   $69($33_1, $38_1, $15_1, $3_1, $3_1, $27_1, $32_1, $9_1, $9_1);
   $32_1 = $7_1 + 128 | 0;
   $69($32_1, $16_1, $13_1, $10_1, $10_1, $26_1, $29_1, $0_1, $0_1);
   $0_1 = $31_1 >> 31;
   $26_1 = $7_1 + 112 | 0;
   $9_1 = $0_1;
   $69($26_1, $5_1, $4_1, $8_1, $8_1, $30_1, $31_1, $0_1, $0_1);
   $29_1 = $7_1 + 80 | 0;
   $24_1 = $39_1;
   $0_1 = $24_1 >> 31;
   $69($29_1, $6_1, $14_1, $2_1, $2_1, $20_1, $24_1, $0_1, $0_1);
   $37_1 = $7_1 + 96 | 0;
   $69($37_1, $38_1, $15_1, $3_1, $3_1, $30_1, $31_1, $9_1, $9_1);
   $31_1 = $7_1 - -64 | 0;
   $69($31_1, $16_1, $13_1, $10_1, $10_1, $20_1, $24_1, $0_1, $0_1);
   $0_1 = $23_1 >> 31;
   $20_1 = $7_1 + 48 | 0;
   $9_1 = $8_1;
   $8_1 = $0_1;
   $69($20_1, $5_1, $4_1, $9_1, $9_1, $42_1, $23_1, $0_1, $0_1);
   $39_1 = $7_1 + 16 | 0;
   $4_1 = $43_1;
   $0_1 = $4_1 >> 31;
   $69($39_1, $6_1, $14_1, $2_1, $2_1, $41_1, $4_1, $0_1, $0_1);
   $36_1 = $7_1 + 32 | 0;
   $69($36_1, $38_1, $15_1, $3_1, $3_1, $42_1, $23_1, $8_1, $8_1);
   $69($7_1, $16_1, $13_1, $10_1, $10_1, $41_1, $4_1, $0_1, $0_1);
   $5_1 = HEAP32[$7_1 + 272 >> 2];
   $2_1 = HEAP32[$7_1 + 304 >> 2];
   $3_1 = $5_1 + $2_1 | 0;
   $8_1 = HEAP32[$7_1 + 276 >> 2];
   $0_1 = $8_1 + HEAP32[$7_1 + 308 >> 2] | 0;
   $0_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $2_1 = $3_1;
   $3_1 = $0_1;
   $8_1 = ($8_1 | 0) == ($0_1 | 0) & $2_1 >>> 0 < $5_1 >>> 0 | $0_1 >>> 0 < $8_1 >>> 0;
   $0_1 = $40_1 + 8 | 0;
   $5_1 = HEAP32[$0_1 >> 2];
   $4_1 = $25_1 + 8 | 0;
   $2_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
   $0_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
   $0_1 = $2_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $8_1 = $2_1 + $8_1 | 0;
   $2_1 = $8_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $5_1 = $2_1 << 2 | $8_1 >>> 30;
   $4_1 = $8_1 << 2 | $3_1 >>> 30;
   $10_1 = HEAP32[$7_1 + 208 >> 2];
   $8_1 = HEAP32[$7_1 + 240 >> 2];
   $3_1 = $10_1 + $8_1 | 0;
   $6_1 = HEAP32[$7_1 + 212 >> 2];
   $0_1 = $6_1 + HEAP32[$7_1 + 244 >> 2] | 0;
   $8_1 = $3_1 >>> 0 < $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $0_1 = $8_1 + $5_1 | 0;
   $5_1 = $3_1;
   $4_1 = $3_1 + $4_1 | 0;
   $3_1 = $3_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $0_1 = $8_1;
   $8_1 = $4_1;
   $14_1 = ($3_1 | 0) == ($0_1 | 0) & $4_1 >>> 0 < $5_1 >>> 0 | $0_1 >>> 0 > $3_1 >>> 0;
   $4_1 = ($0_1 | 0) == ($6_1 | 0) & $5_1 >>> 0 < $10_1 >>> 0 | $0_1 >>> 0 < $6_1 >>> 0;
   $0_1 = $12_1 + 8 | 0;
   $6_1 = HEAP32[$0_1 >> 2];
   $10_1 = $19_1 + 8 | 0;
   $5_1 = $6_1 + HEAP32[$10_1 >> 2] | 0;
   $0_1 = HEAP32[$10_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
   $0_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $6_1 = $5_1;
   $5_1 = $4_1 + $5_1 | 0;
   $0_1 = ($2_1 >> 31) + ($6_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
   $2_1 = $2_1 >> 30;
   $4_1 = $2_1;
   $2_1 = $2_1 + $5_1 | 0;
   $0_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $5_1 = $2_1 + $14_1 | 0;
   $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $4_1 = $2_1 << 2 | $5_1 >>> 30;
   $14_1 = $3_1;
   $10_1 = $5_1 << 2 | $3_1 >>> 30;
   $13_1 = HEAP32[$7_1 + 144 >> 2];
   $5_1 = HEAP32[$7_1 + 176 >> 2];
   $3_1 = $13_1 + $5_1 | 0;
   $6_1 = HEAP32[$7_1 + 148 >> 2];
   $0_1 = $6_1 + HEAP32[$7_1 + 180 >> 2] | 0;
   $5_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $0_1 = $5_1 + $4_1 | 0;
   $4_1 = $3_1;
   $24_1 = $3_1 + $10_1 | 0;
   $3_1 = $3_1 >>> 0 > $24_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $10_1 = ($5_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 > $24_1 >>> 0 | $3_1 >>> 0 < $5_1 >>> 0;
   $4_1 = ($5_1 | 0) == ($6_1 | 0) & $4_1 >>> 0 < $13_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
   $0_1 = $22_1 + 8 | 0;
   $6_1 = HEAP32[$0_1 >> 2];
   $15_1 = $35_1 + 8 | 0;
   $5_1 = $6_1 + HEAP32[$15_1 >> 2] | 0;
   $0_1 = HEAP32[$15_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
   $0_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $6_1 = $5_1;
   $5_1 = $4_1 + $5_1 | 0;
   $0_1 = ($2_1 >> 31) + ($6_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
   $2_1 = $2_1 >> 30;
   $4_1 = $2_1;
   $2_1 = $2_1 + $5_1 | 0;
   $0_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $5_1 = $2_1 + $10_1 | 0;
   $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $4_1 = $2_1 << 2 | $5_1 >>> 30;
   $10_1 = $3_1;
   $15_1 = $5_1 << 2 | $3_1 >>> 30;
   $16_1 = HEAP32[$7_1 + 80 >> 2];
   $5_1 = HEAP32[$7_1 + 112 >> 2];
   $3_1 = $16_1 + $5_1 | 0;
   $6_1 = HEAP32[$7_1 + 84 >> 2];
   $0_1 = $6_1 + HEAP32[$7_1 + 116 >> 2] | 0;
   $5_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $0_1 = $5_1 + $4_1 | 0;
   $4_1 = $3_1;
   $27_1 = $3_1 + $15_1 | 0;
   $3_1 = $3_1 >>> 0 > $27_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $15_1 = ($5_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 > $27_1 >>> 0 | $3_1 >>> 0 < $5_1 >>> 0;
   $4_1 = ($5_1 | 0) == ($6_1 | 0) & $4_1 >>> 0 < $16_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
   $0_1 = $26_1 + 8 | 0;
   $6_1 = HEAP32[$0_1 >> 2];
   $13_1 = $29_1 + 8 | 0;
   $5_1 = $6_1 + HEAP32[$13_1 >> 2] | 0;
   $0_1 = HEAP32[$13_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
   $0_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $6_1 = $5_1;
   $5_1 = $4_1 + $5_1 | 0;
   $0_1 = ($2_1 >> 31) + ($6_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
   $2_1 = $2_1 >> 30;
   $4_1 = $2_1;
   $2_1 = $2_1 + $5_1 | 0;
   $0_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $5_1 = $2_1 + $15_1 | 0;
   $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $4_1 = $2_1 << 2 | $5_1 >>> 30;
   $15_1 = $3_1;
   $13_1 = $5_1 << 2 | $3_1 >>> 30;
   $9_1 = HEAP32[$7_1 + 16 >> 2];
   $5_1 = HEAP32[$7_1 + 48 >> 2];
   $3_1 = $9_1 + $5_1 | 0;
   $6_1 = HEAP32[$7_1 + 20 >> 2];
   $0_1 = $6_1 + HEAP32[$7_1 + 52 >> 2] | 0;
   $5_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $0_1 = $5_1 + $4_1 | 0;
   $4_1 = $3_1;
   $30_1 = $3_1 + $13_1 | 0;
   $3_1 = $3_1 >>> 0 > $30_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $13_1 = ($5_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 > $30_1 >>> 0 | $3_1 >>> 0 < $5_1 >>> 0;
   $4_1 = ($5_1 | 0) == ($6_1 | 0) & $4_1 >>> 0 < $9_1 >>> 0 | $5_1 >>> 0 < $6_1 >>> 0;
   $0_1 = $20_1 + 8 | 0;
   $6_1 = HEAP32[$0_1 >> 2];
   $16_1 = $39_1 + 8 | 0;
   $5_1 = $6_1 + HEAP32[$16_1 >> 2] | 0;
   $0_1 = HEAP32[$16_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
   $0_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $6_1 = $5_1;
   $5_1 = $4_1 + $5_1 | 0;
   $0_1 = ($2_1 >> 31) + ($6_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
   $2_1 = $2_1 >> 30;
   $4_1 = $2_1;
   $2_1 = $2_1 + $5_1 | 0;
   $0_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $4_1 = $2_1;
   $2_1 = $2_1 + $13_1 | 0;
   $5_1 = ($4_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) << 2 | $2_1 >>> 30;
   $13_1 = $3_1;
   $42_1 = $2_1 << 2 | $3_1 >>> 30;
   $23_1 = $5_1;
   $4_1 = HEAP32[$7_1 + 256 >> 2];
   $2_1 = HEAP32[$7_1 + 288 >> 2];
   $3_1 = $4_1 + $2_1 | 0;
   $5_1 = HEAP32[$7_1 + 260 >> 2];
   $0_1 = $5_1 + HEAP32[$7_1 + 292 >> 2] | 0;
   $0_1 = $2_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $2_1 = $3_1;
   $3_1 = $0_1;
   $5_1 = ($5_1 | 0) == ($0_1 | 0) & $2_1 >>> 0 < $4_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
   $0_1 = $28_1 + 8 | 0;
   $4_1 = HEAP32[$0_1 >> 2];
   $6_1 = $11_1 + 8 | 0;
   $2_1 = $4_1 + HEAP32[$6_1 >> 2] | 0;
   $0_1 = HEAP32[$6_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
   $0_1 = $2_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $5_1 = $2_1 + $5_1 | 0;
   $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $4_1 = $2_1 << 2 | $5_1 >>> 30;
   $6_1 = $5_1 << 2 | $3_1 >>> 30;
   $11_1 = HEAP32[$7_1 + 192 >> 2];
   $5_1 = HEAP32[$7_1 + 224 >> 2];
   $3_1 = $11_1 + $5_1 | 0;
   $16_1 = HEAP32[$7_1 + 196 >> 2];
   $0_1 = $16_1 + HEAP32[$7_1 + 228 >> 2] | 0;
   $5_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $0_1 = $5_1 + $4_1 | 0;
   $4_1 = $3_1;
   $6_1 = $3_1 + $6_1 | 0;
   $3_1 = $3_1 >>> 0 > $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $0_1 = $5_1;
   $5_1 = $6_1;
   $9_1 = ($3_1 | 0) == ($0_1 | 0) & $4_1 >>> 0 > $5_1 >>> 0 | $0_1 >>> 0 > $3_1 >>> 0;
   $6_1 = ($0_1 | 0) == ($16_1 | 0) & $4_1 >>> 0 < $11_1 >>> 0 | $0_1 >>> 0 < $16_1 >>> 0;
   $0_1 = $18_1 + 8 | 0;
   $16_1 = HEAP32[$0_1 >> 2];
   $11_1 = $17_1 + 8 | 0;
   $4_1 = $16_1 + HEAP32[$11_1 >> 2] | 0;
   $0_1 = HEAP32[$11_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
   $0_1 = $4_1 >>> 0 < $16_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $19_1 = $4_1;
   $4_1 = $4_1 + $6_1 | 0;
   $0_1 = ($2_1 >> 31) + ($19_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
   $2_1 = $2_1 >> 30;
   $6_1 = $2_1;
   $2_1 = $2_1 + $4_1 | 0;
   $0_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $4_1 = $2_1 + $9_1 | 0;
   $2_1 = $4_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $6_1 = $2_1 << 2 | $4_1 >>> 30;
   $16_1 = $3_1;
   $11_1 = $4_1 << 2 | $3_1 >>> 30;
   $20_1 = HEAP32[$7_1 + 128 >> 2];
   $4_1 = HEAP32[$7_1 + 160 >> 2];
   $3_1 = $20_1 + $4_1 | 0;
   $9_1 = HEAP32[$7_1 + 132 >> 2];
   $0_1 = $9_1 + HEAP32[$7_1 + 164 >> 2] | 0;
   $4_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $0_1 = $4_1 + $6_1 | 0;
   $6_1 = $3_1;
   $22_1 = $3_1 + $11_1 | 0;
   $3_1 = $3_1 >>> 0 > $22_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $11_1 = ($4_1 | 0) == ($3_1 | 0) & $6_1 >>> 0 > $22_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
   $6_1 = ($4_1 | 0) == ($9_1 | 0) & $6_1 >>> 0 < $20_1 >>> 0 | $4_1 >>> 0 < $9_1 >>> 0;
   $0_1 = $33_1 + 8 | 0;
   $9_1 = HEAP32[$0_1 >> 2];
   $12_1 = $32_1 + 8 | 0;
   $4_1 = $9_1 + HEAP32[$12_1 >> 2] | 0;
   $0_1 = HEAP32[$12_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
   $0_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $9_1 = $4_1;
   $4_1 = $4_1 + $6_1 | 0;
   $0_1 = ($2_1 >> 31) + ($9_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
   $2_1 = $2_1 >> 30;
   $6_1 = $2_1;
   $2_1 = $2_1 + $4_1 | 0;
   $0_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $4_1 = $2_1 + $11_1 | 0;
   $2_1 = $4_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $6_1 = $2_1 << 2 | $4_1 >>> 30;
   $9_1 = $3_1;
   $12_1 = $4_1 << 2 | $3_1 >>> 30;
   $19_1 = HEAP32[$7_1 + 64 >> 2];
   $4_1 = HEAP32[$7_1 + 96 >> 2];
   $3_1 = $19_1 + $4_1 | 0;
   $11_1 = HEAP32[$7_1 + 68 >> 2];
   $0_1 = $11_1 + HEAP32[$7_1 + 100 >> 2] | 0;
   $4_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $0_1 = $4_1 + $6_1 | 0;
   $6_1 = $3_1;
   $26_1 = $3_1 + $12_1 | 0;
   $3_1 = $3_1 >>> 0 > $26_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $12_1 = ($4_1 | 0) == ($3_1 | 0) & $6_1 >>> 0 > $26_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
   $6_1 = ($4_1 | 0) == ($11_1 | 0) & $6_1 >>> 0 < $19_1 >>> 0 | $4_1 >>> 0 < $11_1 >>> 0;
   $0_1 = $37_1 + 8 | 0;
   $11_1 = HEAP32[$0_1 >> 2];
   $20_1 = $31_1 + 8 | 0;
   $4_1 = $11_1 + HEAP32[$20_1 >> 2] | 0;
   $0_1 = HEAP32[$20_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
   $0_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $19_1 = $4_1;
   $4_1 = $4_1 + $6_1 | 0;
   $0_1 = ($2_1 >> 31) + ($19_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
   $2_1 = $2_1 >> 30;
   $6_1 = $2_1;
   $2_1 = $2_1 + $4_1 | 0;
   $0_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $4_1 = $2_1 + $12_1 | 0;
   $2_1 = $4_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $6_1 = $2_1 << 2 | $4_1 >>> 30;
   $11_1 = $3_1;
   $20_1 = $4_1 << 2 | $3_1 >>> 30;
   $18_1 = HEAP32[$7_1 >> 2];
   $4_1 = HEAP32[$7_1 + 32 >> 2];
   $3_1 = $18_1 + $4_1 | 0;
   $12_1 = HEAP32[$7_1 + 4 >> 2];
   $0_1 = $12_1 + HEAP32[$7_1 + 36 >> 2] | 0;
   $4_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $0_1 = $4_1 + $6_1 | 0;
   $6_1 = $3_1;
   $20_1 = $3_1 + $20_1 | 0;
   $3_1 = $3_1 >>> 0 > $20_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $19_1 = ($4_1 | 0) == ($3_1 | 0) & $6_1 >>> 0 > $20_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
   $6_1 = ($4_1 | 0) == ($12_1 | 0) & $6_1 >>> 0 < $18_1 >>> 0 | $4_1 >>> 0 < $12_1 >>> 0;
   $0_1 = $36_1 + 8 | 0;
   $12_1 = HEAP32[$0_1 >> 2];
   $18_1 = $7_1 + 8 | 0;
   $4_1 = $12_1 + HEAP32[$18_1 >> 2] | 0;
   $0_1 = HEAP32[$18_1 + 4 >> 2] + HEAP32[$0_1 + 4 >> 2] | 0;
   $0_1 = $4_1 >>> 0 < $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $12_1 = $4_1;
   $4_1 = $4_1 + $6_1 | 0;
   $0_1 = ($2_1 >> 31) + ($12_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
   $2_1 = $2_1 >> 30;
   $6_1 = $2_1;
   $2_1 = $2_1 + $4_1 | 0;
   $0_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
   $4_1 = $2_1;
   $2_1 = $2_1 + $19_1 | 0;
   $4_1 = ($4_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) << 2 | $2_1 >>> 30;
   $41_1 = $2_1 << 2 | $3_1 >>> 30;
   $43_1 = $4_1;
   $39_1 = $3_1 & 1073741823;
   $31_1 = $13_1 & 1073741823;
   $29_1 = $11_1 & 1073741823;
   $32_1 = $15_1 & 1073741823;
   $35_1 = $9_1 & 1073741823;
   $33_1 = $10_1 & 1073741823;
   $3_1 = $5_1;
   $9_1 = $16_1 & 1073741823;
   $2_1 = $8_1;
   $11_1 = $14_1 & 1073741823;
   $45_1 = $45_1 + 1 | 0;
   if (($45_1 | 0) != 10) {
    continue
   }
   break;
  };
  $0_1 = $23_1 >> 31;
  $3_1 = $0_1;
  $14_1 = $7_1 + 392 | 0;
  $8_1 = $14_1 + 32 | 0;
  $15_1 = HEAP32[$8_1 >> 2];
  $0_1 = HEAP32[$8_1 + 4 >> 2];
  $9_1 = $0_1;
  $0_1 = $0_1 >> 31;
  $2_1 = $0_1;
  $4_1 = HEAP32[$1_1 >> 2];
  $13_1 = $0_1 & $4_1;
  $5_1 = $13_1 + HEAP32[$7_1 + 392 >> 2] | 0;
  $6_1 = HEAP32[$1_1 + 4 >> 2];
  $0_1 = HEAP32[$7_1 + 396 >> 2] + ($6_1 & $0_1) | 0;
  $0_1 = $5_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $5_1 = $3_1 ^ $5_1;
  $20_1 = $5_1 - $3_1 | 0;
  $5_1 = ($0_1 ^ $3_1) - (($3_1 >>> 0 > $5_1 >>> 0) + $3_1 | 0) | 0;
  $13_1 = $4_1;
  $16_1 = $6_1;
  $0_1 = HEAP32[$1_1 + 32 >> 2];
  $26_1 = $0_1;
  $6_1 = $0_1 & $2_1;
  $4_1 = $6_1 + $15_1 | 0;
  $22_1 = HEAP32[$1_1 + 36 >> 2];
  $0_1 = $9_1 + ($22_1 & $2_1) | 0;
  $0_1 = $4_1 >>> 0 < $6_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $4_1 = $3_1 ^ $4_1;
  $15_1 = $4_1 - $3_1 | 0;
  $12_1 = ($0_1 ^ $3_1) - (($3_1 >>> 0 > $4_1 >>> 0) + $3_1 | 0) | 0;
  $0_1 = HEAP32[$1_1 + 24 >> 2];
  $30_1 = $0_1;
  $10_1 = $0_1 & $2_1;
  $4_1 = $14_1 + 24 | 0;
  $6_1 = $10_1 + HEAP32[$4_1 >> 2] | 0;
  $27_1 = HEAP32[$1_1 + 28 >> 2];
  $0_1 = HEAP32[$4_1 + 4 >> 2] + ($27_1 & $2_1) | 0;
  $0_1 = $6_1 >>> 0 < $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $6_1 = $3_1 ^ $6_1;
  $11_1 = $6_1 - $3_1 | 0;
  $24_1 = ($0_1 ^ $3_1) - (($3_1 >>> 0 > $6_1 >>> 0) + $3_1 | 0) | 0;
  $0_1 = HEAP32[$1_1 + 16 >> 2];
  $19_1 = $0_1;
  $9_1 = $0_1 & $2_1;
  $6_1 = $14_1 + 16 | 0;
  $10_1 = $9_1 + HEAP32[$6_1 >> 2] | 0;
  $21_1 = HEAP32[$1_1 + 20 >> 2];
  $0_1 = HEAP32[$6_1 + 4 >> 2] + ($21_1 & $2_1) | 0;
  $0_1 = $9_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $10_1 = $3_1 ^ $10_1;
  $23_1 = $10_1 - $3_1 | 0;
  $10_1 = ($0_1 ^ $3_1) - (($3_1 >>> 0 > $10_1 >>> 0) + $3_1 | 0) | 0;
  $18_1 = HEAP32[$1_1 + 8 >> 2];
  $9_1 = $18_1 & $2_1;
  $0_1 = $14_1 + 8 | 0;
  $14_1 = $9_1 + HEAP32[$0_1 >> 2] | 0;
  $17_1 = HEAP32[$1_1 + 12 >> 2];
  $0_1 = HEAP32[$0_1 + 4 >> 2] + ($17_1 & $2_1) | 0;
  $1_1 = $3_1 ^ $14_1;
  $2_1 = $1_1 - $3_1 | 0;
  $0_1 = (($3_1 ^ ($9_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1)) - (($1_1 >>> 0 < $3_1 >>> 0) + $3_1 | 0) | 0) + ($5_1 >> 31) | 0;
  $1_1 = $5_1 >> 30;
  $2_1 = $1_1 + $2_1 | 0;
  $9_1 = $1_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = ($9_1 >> 31) + $10_1 | 0;
  $1_1 = $9_1 >> 30;
  $14_1 = $1_1 + $23_1 | 0;
  $23_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = ($23_1 >> 31) + $24_1 | 0;
  $1_1 = $23_1 >> 30;
  $10_1 = $1_1 + $11_1 | 0;
  $11_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = ($11_1 >> 31) + $12_1 | 0;
  $1_1 = $11_1 >> 30;
  $15_1 = $1_1 + $15_1 | 0;
  $12_1 = $1_1 >>> 0 > $15_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $1_1 = $12_1 >> 31;
  $0_1 = ($1_1 & $16_1) + ($5_1 & 1073741823) | 0;
  $3_1 = $1_1;
  $1_1 = ($3_1 & $13_1) + $20_1 | 0;
  $0_1 = $1_1 >>> 0 < $20_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  HEAP32[$34_1 >> 2] = $1_1;
  $1_1 = $0_1;
  HEAP32[$34_1 + 4 >> 2] = $0_1 & 1073741823;
  $13_1 = $34_1 + 8 | 0;
  $0_1 = ($3_1 & $17_1) + ($9_1 & 1073741823) | 0;
  $5_1 = $2_1;
  $2_1 = ($3_1 & $18_1) + $2_1 | 0;
  $0_1 = ($1_1 >> 31) + ($5_1 >>> 0 > $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
  $1_1 = $1_1 >> 30;
  $5_1 = $1_1;
  $1_1 = $1_1 + $2_1 | 0;
  $0_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  HEAP32[$13_1 >> 2] = $1_1;
  $1_1 = $0_1;
  HEAP32[$13_1 + 4 >> 2] = $0_1 & 1073741823;
  $0_1 = ($3_1 & $21_1) + ($23_1 & 1073741823) | 0;
  $2_1 = ($3_1 & $19_1) + $14_1 | 0;
  $0_1 = ($1_1 >> 31) + ($2_1 >>> 0 < $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
  $1_1 = $1_1 >> 30;
  $5_1 = $1_1;
  $1_1 = $1_1 + $2_1 | 0;
  $0_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $2_1 = $1_1;
  HEAP32[$6_1 >> 2] = $2_1;
  $1_1 = $0_1;
  $0_1 = $0_1 & 1073741823;
  HEAP32[$6_1 + 4 >> 2] = $0_1;
  $5_1 = $34_1 + 16 | 0;
  HEAP32[$5_1 >> 2] = $2_1;
  HEAP32[$5_1 + 4 >> 2] = $0_1;
  $0_1 = ($3_1 & $27_1) + ($11_1 & 1073741823) | 0;
  $2_1 = ($3_1 & $30_1) + $10_1 | 0;
  $0_1 = ($1_1 >> 31) + ($2_1 >>> 0 < $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
  $1_1 = $1_1 >> 30;
  $5_1 = $1_1;
  $1_1 = $1_1 + $2_1 | 0;
  $0_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $2_1 = $1_1;
  HEAP32[$4_1 >> 2] = $2_1;
  $1_1 = $0_1;
  $0_1 = $0_1 & 1073741823;
  HEAP32[$4_1 + 4 >> 2] = $0_1;
  $5_1 = $34_1 + 24 | 0;
  HEAP32[$5_1 >> 2] = $2_1;
  HEAP32[$5_1 + 4 >> 2] = $0_1;
  $0_1 = ($3_1 & $22_1) + $12_1 | 0;
  $3_1 = ($3_1 & $26_1) + $15_1 | 0;
  $0_1 = ($1_1 >> 31) + ($3_1 >>> 0 < $15_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) | 0;
  $1_1 = $1_1 >> 30;
  $2_1 = $1_1;
  $1_1 = $1_1 + $3_1 | 0;
  $0_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  HEAP32[$8_1 >> 2] = $1_1;
  HEAP32[$8_1 + 4 >> 2] = $0_1;
  $3_1 = $34_1 + 32 | 0;
  HEAP32[$3_1 >> 2] = $1_1;
  HEAP32[$3_1 + 4 >> 2] = $0_1;
  global$0 = $7_1 + 432 | 0;
 }
 
 function $51($0_1, $1_1) {
  var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0;
  $4_1 = global$0 - 48 | 0;
  global$0 = $4_1;
  label$1 : {
   if (!$1_1) {
    FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689571, HEAP32[$0_1 + 172 >> 2]);
    $0_1 = 0;
    break label$1;
   }
   $14_1 = $4_1 + 8 | 0;
   $38($14_1, $1_1, $4_1 + 44 | 0);
   $8_1 = HEAP32[$4_1 + 32 >> 2];
   $2_1 = HEAP32[$4_1 + 24 >> 2];
   $7_1 = HEAP32[$4_1 + 16 >> 2];
   $3_1 = HEAP32[$4_1 + 8 >> 2];
   $11_1 = HEAP32[$4_1 + 36 >> 2];
   $9_1 = HEAP32[$4_1 + 28 >> 2];
   $5_1 = HEAP32[$4_1 + 20 >> 2];
   $6_1 = HEAP32[$4_1 + 12 >> 2];
   $15_1 = HEAP32[$4_1 + 44 >> 2] | !($8_1 | ($2_1 | ($7_1 | $3_1)) | ($11_1 | ($9_1 | ($5_1 | $6_1))));
   $0_1 = $15_1 ? 0 : -1;
   $8_1 = $0_1 & $8_1;
   $12_1 = $0_1 & $2_1;
   $10_1 = $0_1 & $7_1;
   $3_1 = $0_1 & $3_1;
   $11_1 = $0_1 & $11_1;
   $16_1 = $0_1 & $9_1;
   $13_1 = $0_1 & $5_1;
   $2_1 = $0_1 & $6_1;
   $7_1 = $8_1 | ($12_1 | ($10_1 | $3_1)) | ($11_1 | ($16_1 | ($13_1 | $2_1))) ? -1 : 0;
   $3_1 = $3_1 ^ -1;
   $6_1 = $3_1 - 801750718 | 0;
   HEAP32[$4_1 + 8 >> 2] = $7_1 & $6_1;
   $2_1 = $2_1 ^ -1;
   $5_1 = $2_1 - (($3_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
   HEAP32[$4_1 + 12 >> 2] = $5_1 & $7_1;
   $0_1 = ($2_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 > $6_1 >>> 0 | $2_1 >>> 0 > $5_1 >>> 0;
   $5_1 = $10_1 ^ -1;
   $3_1 = $0_1 + $5_1 | 0;
   $6_1 = $13_1 ^ -1;
   $2_1 = $6_1;
   $13_1 = $3_1 - 1354194885 | 0;
   HEAP32[$4_1 + 16 >> 2] = $13_1 & $7_1;
   $2_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
   $9_1 = $2_1 - (($3_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
   HEAP32[$4_1 + 20 >> 2] = $9_1 & $7_1;
   $12_1 = $12_1 ^ -1;
   $0_1 = ($2_1 | 0) == ($6_1 | 0) & $3_1 >>> 0 < $5_1 >>> 0 | $2_1 >>> 0 < $6_1 >>> 0;
   $5_1 = ($2_1 | 0) == ($9_1 | 0) & $3_1 >>> 0 > $13_1 >>> 0 | $2_1 >>> 0 > $9_1 >>> 0;
   $2_1 = $0_1 + $5_1 | 0;
   $10_1 = $16_1 ^ -1;
   $3_1 = $10_1 + ($2_1 >>> 0 < $5_1 >>> 0) | 0;
   $0_1 = $2_1;
   $2_1 = $2_1 + $12_1 | 0;
   $3_1 = $0_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $6_1 = $2_1 - 2 | 0;
   HEAP32[$4_1 + 24 >> 2] = $6_1 & $7_1;
   $5_1 = $3_1 - ($2_1 >>> 0 < 2) | 0;
   HEAP32[$4_1 + 28 >> 2] = $5_1 & $7_1;
   $0_1 = ($3_1 | 0) == ($10_1 | 0) & $2_1 >>> 0 < $12_1 >>> 0 | $3_1 >>> 0 < $10_1 >>> 0;
   $2_1 = ($3_1 | 0) == ($5_1 | 0) & $2_1 >>> 0 > $6_1 >>> 0 | $3_1 >>> 0 > $5_1 >>> 0;
   $0_1 = $0_1 + $2_1 | 0;
   $3_1 = $0_1 >>> 0 < $2_1 >>> 0;
   $2_1 = $0_1 - $8_1 | 0;
   HEAP32[$4_1 + 32 >> 2] = $2_1 - 2 & $7_1;
   HEAP32[$4_1 + 36 >> 2] = ($3_1 - (($0_1 >>> 0 < $8_1 >>> 0) + $11_1 | 0) | 0) - ($2_1 >>> 0 < 2) & $7_1;
   $39($1_1, $14_1);
   $0_1 = !$15_1;
  }
  global$0 = $4_1 + 48 | 0;
  return $0_1;
 }
 
 function $52() {
  var $0_1 = 0, $1_1 = 0, $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0;
  $4_1 = global$0 - 80 | 0;
  global$0 = $4_1;
  $24_1 = $4_1 + 8 | 0;
  $0_1 = $4_1 + 48 | 0;
  $38($24_1, 690788, $0_1);
  $29_1 = HEAP32[$4_1 + 48 >> 2];
  $20_1 = HEAP32[$4_1 + 32 >> 2];
  $25_1 = HEAP32[$4_1 + 36 >> 2];
  $21_1 = HEAP32[$4_1 + 24 >> 2];
  $26_1 = HEAP32[$4_1 + 28 >> 2];
  $22_1 = HEAP32[$4_1 + 8 >> 2];
  $27_1 = HEAP32[$4_1 + 12 >> 2];
  $23_1 = HEAP32[$4_1 + 16 >> 2];
  $28_1 = HEAP32[$4_1 + 20 >> 2];
  HEAP32[$4_1 + 44 >> 2] = 0;
  $38($0_1, 690949, $4_1 + 44 | 0);
  $3_1 = HEAP32[$4_1 + 52 >> 2];
  $0_1 = $3_1 + $27_1 | 0;
  $2_1 = HEAP32[$4_1 + 48 >> 2];
  $18_1 = $2_1 + $22_1 | 0;
  $15_1 = $18_1 >>> 0 < $22_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $5_1 = HEAP32[$4_1 + 60 >> 2];
  $0_1 = $5_1 + $28_1 | 0;
  $9_1 = $0_1 + 1 | 0;
  $10_1 = $0_1;
  $0_1 = HEAP32[$4_1 + 56 >> 2];
  $1_1 = $0_1 + $23_1 | 0;
  $6_1 = $1_1 >>> 0 < $23_1 >>> 0 ? $9_1 : $10_1;
  $5_1 = ($6_1 | 0) == ($5_1 | 0) & $0_1 >>> 0 > $1_1 >>> 0 | $6_1 >>> 0 < $5_1 >>> 0;
  $0_1 = ($3_1 | 0) == ($15_1 | 0) & $2_1 >>> 0 > $18_1 >>> 0 | $3_1 >>> 0 > $15_1 >>> 0;
  $17_1 = $0_1 + $1_1 | 0;
  $13_1 = $17_1 >>> 0 < $0_1 >>> 0 ? $6_1 + 1 | 0 : $6_1;
  $2_1 = ($13_1 | 0) == ($6_1 | 0) & $1_1 >>> 0 > $17_1 >>> 0 | $6_1 >>> 0 > $13_1 >>> 0;
  $5_1 = $5_1 + $2_1 | 0;
  $1_1 = HEAP32[$4_1 + 68 >> 2];
  $0_1 = $1_1 + $26_1 | 0;
  $9_1 = $0_1 + 1 | 0;
  $10_1 = $0_1;
  $0_1 = HEAP32[$4_1 + 64 >> 2];
  $6_1 = $0_1 + $21_1 | 0;
  $7_1 = $6_1 >>> 0 < $21_1 >>> 0 ? $9_1 : $10_1;
  $2_1 = $7_1 + ($2_1 >>> 0 > $5_1 >>> 0) | 0;
  $16_1 = $6_1 + $5_1 | 0;
  $5_1 = $16_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $3_1 = ($5_1 | 0) == ($7_1 | 0) & $6_1 >>> 0 > $16_1 >>> 0 | $5_1 >>> 0 < $7_1 >>> 0;
  $8_1 = $3_1 + (($1_1 | 0) == ($7_1 | 0) & $0_1 >>> 0 > $6_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0) | 0;
  $0_1 = $5_1;
  $6_1 = ($0_1 | 0) == -1;
  $14_1 = HEAP32[$4_1 + 76 >> 2];
  $2_1 = $14_1 + $25_1 | 0;
  $1_1 = HEAP32[$4_1 + 72 >> 2];
  $12_1 = $1_1 + $20_1 | 0;
  $11_1 = $12_1 >>> 0 < $20_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $11_1 + ($3_1 >>> 0 > $8_1 >>> 0) | 0;
  $9_1 = $2_1 + 1 | 0;
  $10_1 = $2_1;
  $2_1 = $8_1 + $12_1 | 0;
  $19_1 = $2_1 >>> 0 < $8_1 >>> 0 ? $9_1 : $10_1;
  $3_1 = $6_1 & $16_1 >>> 0 < 4294967294 | ($0_1 | 0) != -1 | ($19_1 & $2_1) != -1;
  $7_1 = ($13_1 | 0) == -1162945306;
  $8_1 = ($3_1 | ($7_1 & $17_1 >>> 0 < 2940772411 | $13_1 >>> 0 < 3132021990)) ^ -1;
  $3_1 = ((($11_1 | 0) == ($14_1 | 0) & $1_1 >>> 0 > $12_1 >>> 0 | $11_1 >>> 0 < $14_1 >>> 0) + (($11_1 | 0) == ($19_1 | 0) & $2_1 >>> 0 < $12_1 >>> 0 | $11_1 >>> 0 > $19_1 >>> 0) | 0) + ($8_1 & (($15_1 | 0) == -1076732276 & $18_1 >>> 0 > 3493216576 | $15_1 >>> 0 > 3218235020) | ($8_1 & ($7_1 & $17_1 >>> 0 > 2940772411 | $13_1 >>> 0 > 3132021990) | ($16_1 | 0) == -1 & $6_1 & ($3_1 ^ -1))) | 0;
  $12_1 = $3_1 + $16_1 | 0;
  if ($12_1 >>> 0 < $16_1 >>> 0) {
   $0_1 = $0_1 + 1 | 0
  }
  $7_1 = __wasm_i64_mul($3_1, 0, 1354194884, 1162945305);
  $6_1 = $13_1 + i64toi32_i32$HIGH_BITS | 0;
  $1_1 = __wasm_i64_mul($3_1, 0, 801750719, 1076732275);
  $9_1 = $1_1 + $18_1 | 0;
  $14_1 = $7_1 + $17_1 | 0;
  $3_1 = $15_1 + i64toi32_i32$HIGH_BITS | 0;
  $8_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = ($8_1 | 0) == ($15_1 | 0) & $18_1 >>> 0 > $9_1 >>> 0 | $8_1 >>> 0 < $15_1 >>> 0;
  $11_1 = $14_1 + $3_1 | 0;
  $1_1 = $7_1 >>> 0 > $14_1 >>> 0 ? $6_1 + 1 | 0 : $6_1;
  $7_1 = $3_1 >>> 0 > $11_1 >>> 0 ? $1_1 + 1 | 0 : $1_1;
  $3_1 = ($1_1 | 0) == ($7_1 | 0) & $11_1 >>> 0 < $14_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
  $1_1 = $3_1 + (($1_1 | 0) == ($13_1 | 0) & $14_1 >>> 0 < $17_1 >>> 0 | $1_1 >>> 0 < $13_1 >>> 0) | 0;
  $10_1 = ($0_1 | 0) == ($5_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $0_1 >>> 0 < $5_1 >>> 0;
  $3_1 = ($1_1 >>> 0 < $3_1 >>> 0) + $0_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $12_1 | 0;
  $6_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $0_1 = ($6_1 | 0) == ($0_1 | 0) & $1_1 >>> 0 < $12_1 >>> 0 | $0_1 >>> 0 > $6_1 >>> 0;
  $5_1 = $10_1 + $0_1 | 0;
  $0_1 = $19_1 + ($0_1 >>> 0 > $5_1 >>> 0) | 0;
  $5_1 = $2_1 + $5_1 | 0;
  $3_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = $4_1;
  if ($5_1 | ($11_1 | $9_1 | $1_1) | ($3_1 | ($7_1 | $8_1 | $6_1))) {
   $10_1 = HEAP32[$0_1 + 44 >> 2] | ($29_1 | !($20_1 | ($21_1 | ($22_1 | $23_1)) | ($25_1 | ($26_1 | ($27_1 | $28_1)))))
  } else {
   $10_1 = 1
  }
  $4_1 = !$10_1;
  $2_1 = 0 - $4_1 | 0;
  HEAP32[$0_1 + 32 >> 2] = $5_1 & $2_1;
  HEAP32[$0_1 + 36 >> 2] = $2_1 & $3_1;
  HEAP32[$0_1 + 24 >> 2] = $1_1 & $2_1;
  HEAP32[$0_1 + 28 >> 2] = $2_1 & $6_1;
  HEAP32[$0_1 + 16 >> 2] = $2_1 & $11_1;
  HEAP32[$0_1 + 20 >> 2] = $2_1 & $7_1;
  HEAP32[$0_1 + 8 >> 2] = $2_1 & $9_1;
  HEAP32[$0_1 + 12 >> 2] = $2_1 & $8_1;
  $39(690788, $24_1);
  global$0 = $0_1 + 80 | 0;
  return $4_1;
 }
 
 function $53($0_1, $1_1, $2_1) {
  var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0, $51_1 = 0, $52_1 = 0, $53_1 = 0, $54_1 = 0, $55_1 = 0, $56_1 = 0, $57_1 = 0, $58_1 = 0, $59_1 = 0, $60_1 = 0, $61_1 = 0, $62_1 = 0, $63_1 = 0, $64_1 = 0, $65_1 = 0, $66_1 = 0, $67_1 = 0, $68_1 = 0, $69_1 = 0, $70_1 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0;
  $5_1 = global$0 - 1744 | 0;
  global$0 = $5_1;
  $15_1 = $5_1 + 1704 | 0;
  $69_1 = $1_1 + 80 | 0;
  $54($15_1, $69_1);
  $35_1 = $5_1 + 1664 | 0;
  $20_1 = $35_1 + 8 | 0;
  $6_1 = $20_1;
  $3_1 = $1_1 + 8 | 0;
  $27_1 = HEAP32[$3_1 >> 2];
  $19_1 = HEAP32[$3_1 + 4 >> 2];
  $7_1 = HEAP32[$1_1 + 4 >> 2];
  $3_1 = $1_1 + 32 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $9_1 = HEAP32[$3_1 + 4 >> 2];
  $8_1 = $9_1;
  $4_1 = HEAP32[$1_1 >> 2];
  $9_1 = __wasm_i64_mul($8_1 >>> 16 | 0, 0, 977, 1);
  $4_1 = $4_1 + $9_1 | 0;
  $3_1 = $7_1 + i64toi32_i32$HIGH_BITS | 0;
  $7_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $19_1;
  $9_1 = $7_1 >>> 20 | 0;
  $24_1 = $9_1 + $27_1 | 0;
  $3_1 = $9_1 >>> 0 > $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$6_1 >> 2] = $24_1;
  $71 = $3_1 & 1048575;
  HEAP32[$6_1 + 4 >> 2] = $71;
  $27_1 = $35_1 + 16 | 0;
  $9_1 = $27_1;
  $6_1 = $1_1 + 16 | 0;
  $19_1 = HEAP32[$6_1 >> 2];
  $13_1 = HEAP32[$6_1 + 4 >> 2];
  $6_1 = $3_1;
  $3_1 = $13_1;
  $6_1 = $6_1 >>> 20 | 0;
  $25_1 = $6_1 + $19_1 | 0;
  $3_1 = $6_1 >>> 0 > $25_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$9_1 >> 2] = $25_1;
  $72 = $3_1 & 1048575;
  HEAP32[$9_1 + 4 >> 2] = $72;
  $19_1 = $35_1 + 24 | 0;
  $9_1 = $19_1;
  $6_1 = $1_1 + 24 | 0;
  $13_1 = HEAP32[$6_1 >> 2];
  $47_1 = HEAP32[$6_1 + 4 >> 2];
  $6_1 = $3_1;
  $3_1 = $47_1;
  $6_1 = $6_1 >>> 20 | 0;
  $28_1 = $6_1 + $13_1 | 0;
  $3_1 = $6_1 >>> 0 > $28_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$9_1 >> 2] = $28_1;
  $73 = $3_1 & 1048575;
  HEAP32[$9_1 + 4 >> 2] = $73;
  $13_1 = $35_1 + 32 | 0;
  $9_1 = $13_1;
  $6_1 = $3_1;
  $3_1 = $8_1 & 65535;
  $6_1 = $6_1 >>> 20 | 0;
  $45_1 = $6_1 + $11_1 | 0;
  $3_1 = $6_1 >>> 0 > $45_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$9_1 >> 2] = $45_1;
  $57_1 = $3_1;
  HEAP32[$9_1 + 4 >> 2] = $3_1;
  $54_1 = $4_1;
  HEAP32[$5_1 + 1664 >> 2] = $4_1;
  $74 = $7_1 & 1048575;
  HEAP32[$5_1 + 1668 >> 2] = $74;
  $34($5_1 + 1624 | 0, $2_1, $15_1);
  $3_1 = $1_1 - -64 | 0;
  $22_1 = HEAP32[$3_1 >> 2];
  $16_1 = HEAP32[$3_1 + 4 >> 2];
  $3_1 = $1_1 + 56 | 0;
  $21_1 = HEAP32[$3_1 >> 2];
  $33_1 = HEAP32[$3_1 + 4 >> 2];
  $3_1 = $1_1 + 48 | 0;
  $38_1 = HEAP32[$3_1 >> 2];
  $42_1 = HEAP32[$3_1 + 4 >> 2];
  $3_1 = $1_1 + 72 | 0;
  $44_1 = HEAP32[$3_1 >> 2];
  $47_1 = HEAP32[$3_1 + 4 >> 2];
  $36_1 = HEAP32[$1_1 + 40 >> 2];
  $26_1 = HEAP32[$1_1 + 44 >> 2];
  $3_1 = $5_1 + 1584 | 0;
  $34($3_1, $2_1 + 40 | 0, $15_1);
  $34($3_1, $3_1, $69_1);
  $34_1 = HEAP32[$5_1 + 1636 >> 2];
  $3_1 = $34_1 + HEAP32[$20_1 + 4 >> 2] | 0;
  $63_1 = $5_1 + 1544 | 0;
  $65_1 = $63_1 + 8 | 0;
  $4_1 = $65_1;
  $58_1 = HEAP32[$5_1 + 1632 >> 2];
  $11_1 = HEAP32[$20_1 >> 2];
  $9_1 = $58_1 + $11_1 | 0;
  HEAP32[$4_1 >> 2] = $9_1;
  $15_1 = $9_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$4_1 + 4 >> 2] = $15_1;
  $31_1 = HEAP32[$5_1 + 1644 >> 2];
  $3_1 = $31_1 + HEAP32[$27_1 + 4 >> 2] | 0;
  $66_1 = $63_1 + 16 | 0;
  $7_1 = $66_1;
  $59_1 = HEAP32[$5_1 + 1640 >> 2];
  $4_1 = HEAP32[$27_1 >> 2];
  $11_1 = $59_1 + $4_1 | 0;
  HEAP32[$7_1 >> 2] = $11_1;
  $4_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$7_1 + 4 >> 2] = $4_1;
  $32_1 = HEAP32[$5_1 + 1652 >> 2];
  $3_1 = $32_1 + HEAP32[$19_1 + 4 >> 2] | 0;
  $67_1 = $63_1 + 24 | 0;
  $20_1 = $67_1;
  $39_1 = HEAP32[$5_1 + 1648 >> 2];
  $7_1 = HEAP32[$19_1 >> 2];
  $6_1 = $39_1 + $7_1 | 0;
  HEAP32[$20_1 >> 2] = $6_1;
  $7_1 = $6_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$20_1 + 4 >> 2] = $7_1;
  $48_1 = HEAP32[$5_1 + 1660 >> 2];
  $3_1 = $48_1 + HEAP32[$13_1 + 4 >> 2] | 0;
  $61_1 = $63_1 + 32 | 0;
  $27_1 = $61_1;
  $37_1 = HEAP32[$5_1 + 1656 >> 2];
  $19_1 = HEAP32[$13_1 >> 2];
  $20_1 = $37_1 + $19_1 | 0;
  HEAP32[$27_1 >> 2] = $20_1;
  $13_1 = $19_1 >>> 0 > $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$27_1 + 4 >> 2] = $13_1;
  $51_1 = HEAP32[$5_1 + 1628 >> 2];
  $3_1 = $51_1 + HEAP32[$5_1 + 1668 >> 2] | 0;
  $30_1 = HEAP32[$5_1 + 1624 >> 2];
  $19_1 = HEAP32[$5_1 + 1664 >> 2];
  $27_1 = $30_1 + $19_1 | 0;
  HEAP32[$5_1 + 1544 >> 2] = $27_1;
  $19_1 = $19_1 >>> 0 > $27_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$5_1 + 1548 >> 2] = $19_1;
  $56_1 = $5_1 + 1232 | 0;
  $12_1 = $27_1 << 1;
  $10_1 = $19_1 << 1 | $27_1 >>> 31;
  $69($56_1, $6_1, $7_1, 0, 0, $12_1, $10_1, 0, 0);
  $40_1 = $5_1 + 1312 | 0;
  $23_1 = $9_1 << 1;
  $17_1 = $15_1;
  $14_1 = $9_1;
  $15_1 = $15_1 << 1 | $9_1 >>> 31;
  $69($40_1, $11_1, $4_1, 0, 0, $23_1, $15_1, 0, 0);
  $18_1 = $5_1 + 1168 | 0;
  $3_1 = $13_1;
  $69($18_1, $20_1, $3_1, 0, 0, $20_1, $3_1, 0, 0);
  $52_1 = $5_1 + 1152 | 0;
  $69($52_1, HEAP32[$5_1 + 1168 >> 2], HEAP32[$5_1 + 1172 >> 2], 0, 0, 15632, 16, 0, 0);
  $43_1 = $5_1 + 1120 | 0;
  $9_1 = $20_1 << 1;
  $13_1 = $3_1 << 1 | $20_1 >>> 31;
  $69($43_1, $9_1, $13_1, 0, 0, $27_1, $19_1, 0, 0);
  $46_1 = $5_1 + 1216 | 0;
  $69($46_1, $6_1, $7_1, 0, 0, $23_1, $15_1, 0, 0);
  $53_1 = $5_1 + 1328 | 0;
  $69($53_1, $11_1, $4_1, 0, 0, $11_1, $4_1, 0, 0);
  $49_1 = $5_1 + 1136 | 0;
  $3_1 = $18_1 + 8 | 0;
  $69($49_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $60_1 = $5_1 + 1248 | 0;
  $69($60_1, $27_1, $19_1, 0, 0, $27_1, $19_1, 0, 0);
  $50_1 = $5_1 + 1104 | 0;
  $69($50_1, $9_1, $13_1, 0, 0, $14_1, $17_1, 0, 0);
  $41_1 = $4_1;
  $27_1 = $11_1;
  $3_1 = $4_1 << 1 | $11_1 >>> 31;
  $55_1 = $5_1 + 1200 | 0;
  $23_1 = $6_1;
  $18_1 = $7_1;
  $69($55_1, $6_1, $7_1, 0, 0, $11_1 << 1, $3_1, 0, 0);
  $15_1 = HEAP32[$5_1 + 1232 >> 2];
  $4_1 = HEAP32[$5_1 + 1312 >> 2];
  $11_1 = $15_1 + $4_1 | 0;
  $6_1 = HEAP32[$5_1 + 1236 >> 2];
  $3_1 = $6_1 + HEAP32[$5_1 + 1316 >> 2] | 0;
  $4_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1 + HEAP32[$5_1 + 1156 >> 2] | 0;
  $7_1 = $11_1;
  $20_1 = HEAP32[$5_1 + 1152 >> 2];
  $11_1 = $7_1 + $20_1 | 0;
  $29_1 = $11_1;
  $11_1 = $11_1 >>> 0 < $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $20_1 = ($4_1 | 0) == ($11_1 | 0) & $7_1 >>> 0 > $29_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
  $3_1 = $52_1 + 8 | 0;
  $19_1 = HEAP32[$3_1 >> 2];
  $8_1 = HEAP32[$3_1 + 4 >> 2];
  $6_1 = ($4_1 | 0) == ($6_1 | 0) & $7_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $6_1 >>> 0;
  $3_1 = $40_1 + 8 | 0;
  $15_1 = HEAP32[$3_1 >> 2];
  $4_1 = $56_1 + 8 | 0;
  $7_1 = $15_1 + HEAP32[$4_1 >> 2] | 0;
  $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $7_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $4_1 = $6_1 + $7_1 | 0;
  $3_1 = ($4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $8_1 | 0;
  $6_1 = $4_1;
  $4_1 = $4_1 + $19_1 | 0;
  $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $4_1;
  $4_1 = $4_1 + $20_1 | 0;
  $7_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $7_1 << 12 | $4_1 >>> 20;
  $40_1 = $11_1;
  $11_1 = $4_1 << 12 | $11_1 >>> 20;
  $56_1 = $6_1;
  $62_1 = HEAP32[$5_1 + 1216 >> 2];
  $6_1 = HEAP32[$5_1 + 1328 >> 2];
  $4_1 = $62_1 + $6_1 | 0;
  $52_1 = HEAP32[$5_1 + 1220 >> 2];
  $3_1 = $52_1 + HEAP32[$5_1 + 1332 >> 2] | 0;
  $6_1 = $4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $20_1 = $4_1;
  $15_1 = HEAP32[$5_1 + 1120 >> 2];
  $3_1 = $4_1 + $15_1 | 0;
  $4_1 = $6_1 + HEAP32[$5_1 + 1124 >> 2] | 0;
  $15_1 = $3_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $19_1 = $3_1;
  $8_1 = HEAP32[$5_1 + 1136 >> 2];
  $4_1 = $3_1 + $8_1 | 0;
  $3_1 = $15_1 + HEAP32[$5_1 + 1140 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $4_1;
  $4_1 = $3_1;
  $3_1 = $3_1 + $56_1 | 0;
  $68_1 = $5_1 + 1088 | 0;
  $56_1 = $8_1 + $11_1 | 0;
  $11_1 = $56_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $64_1 = ($4_1 | 0) == ($11_1 | 0) & $8_1 >>> 0 > $56_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
  $8_1 = ($4_1 | 0) == ($15_1 | 0) & $8_1 >>> 0 < $19_1 >>> 0 | $4_1 >>> 0 < $15_1 >>> 0;
  $3_1 = $49_1 + 8 | 0;
  $49_1 = HEAP32[$3_1 >> 2];
  $70_1 = HEAP32[$3_1 + 4 >> 2];
  $15_1 = ($6_1 | 0) == ($15_1 | 0) & $19_1 >>> 0 < $20_1 >>> 0 | $6_1 >>> 0 > $15_1 >>> 0;
  $3_1 = $43_1 + 8 | 0;
  $19_1 = HEAP32[$3_1 >> 2];
  $43_1 = HEAP32[$3_1 + 4 >> 2];
  $20_1 = ($6_1 | 0) == ($52_1 | 0) & $20_1 >>> 0 < $62_1 >>> 0 | $6_1 >>> 0 < $52_1 >>> 0;
  $3_1 = $53_1 + 8 | 0;
  $52_1 = HEAP32[$3_1 >> 2];
  $4_1 = $46_1 + 8 | 0;
  $6_1 = $52_1 + HEAP32[$4_1 >> 2] | 0;
  $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $6_1 >>> 0 < $52_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $4_1 = $6_1 + $20_1 | 0;
  $3_1 = ($4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $43_1 | 0;
  $6_1 = $4_1;
  $4_1 = $4_1 + $19_1 | 0;
  $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $4_1;
  $4_1 = $4_1 + $15_1 | 0;
  $3_1 = ($6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $70_1 | 0;
  $6_1 = $4_1 + $49_1 | 0;
  $4_1 = $6_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $6_1 + $8_1 | 0;
  $4_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $6_1 = $3_1;
  $3_1 = $4_1;
  $7_1 = $7_1 >>> 20 | 0;
  $4_1 = $6_1 + $7_1 | 0;
  $3_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $4_1;
  $4_1 = $4_1 + $64_1 | 0;
  $7_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $15_1 = $7_1 << 12 | $4_1 >>> 20;
  $6_1 = $11_1;
  $4_1 = $4_1 << 12 | $6_1 >>> 20;
  $11_1 = $15_1;
  $8_1 = HEAP32[$5_1 + 1104 >> 2];
  $15_1 = HEAP32[$5_1 + 1200 >> 2];
  $20_1 = $8_1 + $15_1 | 0;
  $19_1 = HEAP32[$5_1 + 1108 >> 2];
  $3_1 = $19_1 + HEAP32[$5_1 + 1204 >> 2] | 0;
  $15_1 = $15_1 >>> 0 > $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1 + $20_1 | 0;
  $4_1 = $11_1 + $15_1 | 0;
  $11_1 = $3_1 >>> 0 < $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $4_1 = $3_1;
  $3_1 = $11_1 << 4 | $3_1 >>> 28;
  $43_1 = $4_1 << 4 & -16;
  $52_1 = $6_1;
  $69($68_1, $43_1 | $6_1 >>> 16 & 15, $3_1 & 16777215, 0, 0, 977, 1, 0, 0);
  $43_1 = $5_1 + 1280 | 0;
  $69($43_1, $14_1, $17_1, 0, 0, $12_1, $10_1, 0, 0);
  $46_1 = $5_1 + 1072 | 0;
  $69($46_1, $9_1, $13_1, 0, 0, $27_1, $41_1, 0, 0);
  $53_1 = $5_1 + 1184 | 0;
  $69($53_1, $23_1, $18_1, 0, 0, $23_1, $18_1, 0, 0);
  $64_1 = $5_1 + 1056 | 0;
  $49_1 = $64_1;
  $62_1 = ($11_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $20_1 >>> 0 | $11_1 >>> 0 < $15_1 >>> 0;
  $6_1 = ($15_1 | 0) == ($19_1 | 0) & $8_1 >>> 0 > $20_1 >>> 0 | $15_1 >>> 0 < $19_1 >>> 0;
  $3_1 = $55_1 + 8 | 0;
  $15_1 = HEAP32[$3_1 >> 2];
  $20_1 = $50_1 + 8 | 0;
  $4_1 = $15_1 + HEAP32[$20_1 >> 2] | 0;
  $3_1 = HEAP32[$20_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $4_1;
  $4_1 = $4_1 + $6_1 | 0;
  $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $7_1 >>> 20 | 0;
  $6_1 = $7_1;
  $7_1 = $4_1 + $7_1 | 0;
  $4_1 = $6_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $7_1 + $62_1 | 0;
  $4_1 = $3_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $6_1 = $4_1 << 12 | $3_1 >>> 20;
  $7_1 = $3_1 << 12 | $11_1 >>> 20;
  $15_1 = $6_1;
  $19_1 = HEAP32[$5_1 + 1072 >> 2];
  $6_1 = HEAP32[$5_1 + 1184 >> 2];
  $11_1 = $19_1 + $6_1 | 0;
  $20_1 = HEAP32[$5_1 + 1076 >> 2];
  $3_1 = $20_1 + HEAP32[$5_1 + 1188 >> 2] | 0;
  $3_1 = $6_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $11_1;
  $11_1 = $3_1;
  $3_1 = $3_1 + $15_1 | 0;
  $7_1 = $6_1 + $7_1 | 0;
  $3_1 = $7_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $15_1 = $7_1;
  $7_1 = $3_1;
  $69($49_1, $15_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $8_1 = $5_1 + 1264 | 0;
  $69($8_1, $27_1, $41_1, 0, 0, $12_1, $10_1, 0, 0);
  $10_1 = $5_1 + 1296 | 0;
  $69($10_1, $14_1, $17_1, 0, 0, $14_1, $17_1, 0, 0);
  $27_1 = $5_1 + 1040 | 0;
  $69($27_1, $9_1, $13_1, 0, 0, $23_1, $18_1, 0, 0);
  $12_1 = $5_1 + 1024 | 0;
  $9_1 = $12_1;
  $15_1 = ($3_1 | 0) == ($11_1 | 0) & $6_1 >>> 0 > $15_1 >>> 0 | $3_1 >>> 0 < $11_1 >>> 0;
  $6_1 = ($11_1 | 0) == ($20_1 | 0) & $6_1 >>> 0 < $19_1 >>> 0 | $11_1 >>> 0 < $20_1 >>> 0;
  $3_1 = $53_1 + 8 | 0;
  $20_1 = HEAP32[$3_1 >> 2];
  $19_1 = $46_1 + 8 | 0;
  $11_1 = $20_1 + HEAP32[$19_1 >> 2] | 0;
  $3_1 = HEAP32[$19_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $11_1 >>> 0 < $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $11_1;
  $11_1 = $6_1 + $11_1 | 0;
  $3_1 = $13_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $6_1 = $4_1;
  $4_1 = $4_1 + $11_1 | 0;
  $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $11_1 = $4_1 + $15_1 | 0;
  $4_1 = $11_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $4_1 << 12 | $11_1 >>> 20;
  $15_1 = $11_1 << 12 | $7_1 >>> 20;
  $20_1 = HEAP32[$5_1 + 1040 >> 2];
  $11_1 = $15_1 + $20_1 | 0;
  $7_1 = $6_1;
  $3_1 = $6_1 + HEAP32[$5_1 + 1044 >> 2] | 0;
  $3_1 = $11_1 >>> 0 < $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($9_1, $11_1, $3_1, 0, 0, 15632, 16, 0, 0);
  $14_1 = $5_1 + 1008 | 0;
  $6_1 = $14_1;
  $11_1 = ($3_1 | 0) == ($7_1 | 0) & $11_1 >>> 0 < $15_1 >>> 0 | $3_1 >>> 0 < $7_1 >>> 0;
  $3_1 = $27_1 + 8 | 0;
  $7_1 = HEAP32[$3_1 >> 2];
  $3_1 = HEAP32[$3_1 + 4 >> 2];
  $4_1 = $4_1 >>> 20 | 0;
  $9_1 = $4_1;
  $4_1 = $4_1 + $7_1 | 0;
  $3_1 = $9_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $4_1;
  $4_1 = $4_1 + $11_1 | 0;
  $3_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($6_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
  $49_1 = HEAP32[$5_1 + 1608 >> 2];
  $53_1 = HEAP32[$5_1 + 1612 >> 2];
  $50_1 = HEAP32[$5_1 + 1600 >> 2];
  $70_1 = HEAP32[$5_1 + 1604 >> 2];
  $62_1 = HEAP32[$5_1 + 1584 >> 2];
  $75 = HEAP32[$5_1 + 1588 >> 2];
  $27_1 = HEAP32[$5_1 + 1616 >> 2];
  $19_1 = HEAP32[$5_1 + 1620 >> 2];
  $55_1 = HEAP32[$5_1 + 1592 >> 2];
  $76 = HEAP32[$5_1 + 1596 >> 2];
  HEAP32[$5_1 + 1416 >> 2] = -4 - $37_1;
  HEAP32[$5_1 + 1420 >> 2] = 262143 - (($37_1 >>> 0 > 4294967292) + $48_1 | 0);
  HEAP32[$5_1 + 1408 >> 2] = -4 - $39_1;
  HEAP32[$5_1 + 1412 >> 2] = 4194303 - (($39_1 >>> 0 > 4294967292) + $32_1 | 0);
  HEAP32[$5_1 + 1400 >> 2] = -4 - $59_1;
  HEAP32[$5_1 + 1404 >> 2] = 4194303 - (($59_1 >>> 0 > 4294967292) + $31_1 | 0);
  HEAP32[$5_1 + 1392 >> 2] = -4 - $58_1;
  HEAP32[$5_1 + 1396 >> 2] = 4194303 - (($58_1 >>> 0 > 4294967292) + $34_1 | 0);
  HEAP32[$5_1 + 1384 >> 2] = -3908 - $30_1;
  HEAP32[$5_1 + 1388 >> 2] = 4194299 - (($30_1 >>> 0 > 4294963388) + $51_1 | 0);
  $3_1 = $60_1 + 8 | 0;
  $17_1 = HEAP32[$3_1 >> 2];
  $23_1 = HEAP32[$3_1 + 4 >> 2];
  $3_1 = $68_1 + 8 | 0;
  $7_1 = HEAP32[$3_1 >> 2];
  $39_1 = HEAP32[$3_1 + 4 >> 2];
  $11_1 = HEAP32[$5_1 + 1248 >> 2];
  $3_1 = HEAP32[$5_1 + 1252 >> 2];
  $6_1 = HEAP32[$5_1 + 1088 >> 2];
  $4_1 = HEAP32[$5_1 + 1092 >> 2];
  $15_1 = $43_1 + 8 | 0;
  $37_1 = HEAP32[$15_1 >> 2];
  $30_1 = HEAP32[$15_1 + 4 >> 2];
  $15_1 = $64_1 + 8 | 0;
  $9_1 = HEAP32[$15_1 >> 2];
  $34_1 = HEAP32[$15_1 + 4 >> 2];
  $20_1 = HEAP32[$5_1 + 1280 >> 2];
  $31_1 = HEAP32[$5_1 + 1284 >> 2];
  $13_1 = HEAP32[$5_1 + 1056 >> 2];
  $15_1 = HEAP32[$5_1 + 1060 >> 2];
  $10_1 = $10_1 + 8 | 0;
  $60_1 = HEAP32[$10_1 >> 2];
  $68_1 = HEAP32[$10_1 + 4 >> 2];
  $8_1 = $8_1 + 8 | 0;
  $51_1 = HEAP32[$8_1 >> 2];
  $64_1 = HEAP32[$8_1 + 4 >> 2];
  $8_1 = HEAP32[$5_1 + 1296 >> 2];
  $77 = HEAP32[$5_1 + 1300 >> 2];
  $43_1 = HEAP32[$5_1 + 1264 >> 2];
  $32_1 = HEAP32[$5_1 + 1268 >> 2];
  $10_1 = $12_1 + 8 | 0;
  $41_1 = HEAP32[$10_1 >> 2];
  $58_1 = HEAP32[$10_1 + 4 >> 2];
  $10_1 = HEAP32[$5_1 + 1024 >> 2];
  $12_1 = HEAP32[$5_1 + 1028 >> 2];
  $46_1 = HEAP32[$5_1 + 1008 >> 2];
  $48_1 = HEAP32[$5_1 + 1012 >> 2];
  $14_1 = $14_1 + 8 | 0;
  $78 = HEAP32[$14_1 >> 2];
  $59_1 = HEAP32[$14_1 + 4 >> 2];
  $79 = $5_1 + 1384 | 0;
  $34($5_1 + 1504 | 0, $35_1, $79);
  $3_1 = $3_1 + $4_1 | 0;
  $18_1 = $6_1 + $11_1 | 0;
  $11_1 = $18_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = ($4_1 | 0) == ($11_1 | 0) & $6_1 >>> 0 > $18_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
  $4_1 = $23_1 + $39_1 | 0;
  $3_1 = $7_1;
  $7_1 = $7_1 + $17_1 | 0;
  $3_1 = $3_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $4_1 = $6_1 + $7_1 | 0;
  $7_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $7_1 << 12 | $4_1 >>> 20;
  $35_1 = $11_1;
  $11_1 = $4_1 << 12 | $11_1 >>> 20;
  $14_1 = $3_1;
  $3_1 = $15_1 + $31_1 | 0;
  $6_1 = $13_1 + $20_1 | 0;
  $4_1 = $6_1 >>> 0 < $20_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1 + $14_1 | 0;
  $23_1 = $6_1 + $11_1 | 0;
  $11_1 = $23_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $20_1 = ($4_1 | 0) == ($11_1 | 0) & $6_1 >>> 0 > $23_1 >>> 0 | $4_1 >>> 0 > $11_1 >>> 0;
  $15_1 = ($4_1 | 0) == ($15_1 | 0) & $6_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 < $15_1 >>> 0;
  $3_1 = $30_1 + $34_1 | 0;
  $6_1 = $9_1 + $37_1 | 0;
  $4_1 = $6_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $6_1 + $15_1 | 0;
  $4_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $6_1 = $3_1;
  $3_1 = $4_1;
  $7_1 = $7_1 >>> 20 | 0;
  $4_1 = $6_1 + $7_1 | 0;
  $3_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $4_1;
  $4_1 = $4_1 + $20_1 | 0;
  $15_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $15_1 << 12 | $4_1 >>> 20;
  $39_1 = $11_1;
  $11_1 = $4_1 << 12 | $11_1 >>> 20;
  $3_1 = $32_1 + $77 | 0;
  $14_1 = $8_1 + $43_1 | 0;
  $9_1 = $14_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $9_1 + $12_1 | 0;
  $12_1 = $10_1 + $14_1 | 0;
  $20_1 = $12_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $3_1 = $20_1 + $7_1 | 0;
  $17_1 = $11_1 + $12_1 | 0;
  $11_1 = $17_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $27_1;
  $6_1 = $19_1;
  $10_1 = $44_1;
  $44_1 = $47_1 & 65535;
  $4_1 = __wasm_i64_mul($47_1 >>> 16 | 0, 0, 977, 1);
  $19_1 = $4_1 + $36_1 | 0;
  $3_1 = $26_1 + i64toi32_i32$HIGH_BITS | 0;
  $37_1 = $4_1 >>> 0 > $19_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $42_1;
  $4_1 = $37_1 >>> 20 | 0;
  $27_1 = $4_1 + $38_1 | 0;
  $30_1 = $4_1 >>> 0 > $27_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $33_1;
  $4_1 = $30_1 >>> 20 | 0;
  $13_1 = $4_1 + $21_1 | 0;
  $34_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $16_1;
  $3_1 = $44_1;
  $8_1 = $34_1 >>> 20 | 0;
  $16_1 = $8_1;
  $8_1 = $8_1 + $22_1 | 0;
  $31_1 = $16_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $4_1 = $31_1 >>> 20 | 0;
  $47_1 = $4_1 + $10_1 | 0;
  $10_1 = $4_1 >>> 0 > $47_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $10_1 + $6_1 | 0;
  $6_1 = $7_1 + $47_1 | 0;
  $7_1 = $6_1 >>> 0 < $47_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $16_1 = HEAP32[$5_1 + 1528 >> 2];
  $21_1 = HEAP32[$5_1 + 1532 >> 2];
  $22_1 = ($11_1 | 0) == ($20_1 | 0) & $12_1 >>> 0 > $17_1 >>> 0 | $11_1 >>> 0 < $20_1 >>> 0;
  $20_1 = ($9_1 | 0) == ($20_1 | 0) & $12_1 >>> 0 < $14_1 >>> 0 | $9_1 >>> 0 > $20_1 >>> 0;
  $12_1 = ($9_1 | 0) == ($32_1 | 0) & $14_1 >>> 0 < $43_1 >>> 0 | $9_1 >>> 0 < $32_1 >>> 0;
  $3_1 = $64_1 + $68_1 | 0;
  $9_1 = $51_1 + $60_1 | 0;
  $4_1 = $9_1 >>> 0 < $51_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $9_1;
  $9_1 = $9_1 + $12_1 | 0;
  $3_1 = ($3_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $58_1 | 0;
  $4_1 = $9_1 + $41_1 | 0;
  $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = $4_1;
  $4_1 = $4_1 + $20_1 | 0;
  $3_1 = $9_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $15_1 = $15_1 >>> 20 | 0;
  $4_1 = $4_1 + $15_1 | 0;
  $3_1 = $15_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = $4_1;
  $4_1 = $4_1 + $22_1 | 0;
  $15_1 = $9_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1;
  $4_1 = $15_1 << 12 | $3_1 >>> 20;
  $22_1 = $11_1;
  $11_1 = $3_1 << 12 | $11_1 >>> 20;
  $12_1 = $4_1;
  $9_1 = $29_1 & -2;
  $4_1 = $9_1 + $46_1 | 0;
  $3_1 = $48_1 + ($40_1 & 1048575) | 0;
  $9_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $9_1 + $12_1 | 0;
  $20_1 = $4_1;
  $33_1 = $4_1 + $11_1 | 0;
  $11_1 = $4_1 >>> 0 > $33_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $21_1 + ($11_1 & 1048575) | 0;
  $12_1 = $16_1 + $33_1 | 0;
  $14_1 = $12_1 >>> 0 < $33_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = HEAP32[$5_1 + 1524 >> 2] + ($22_1 & 1048575) | 0;
  $4_1 = $17_1;
  $17_1 = HEAP32[$5_1 + 1520 >> 2] + $17_1 | 0;
  $22_1 = $4_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = HEAP32[$5_1 + 1516 >> 2] + ($39_1 & 1048575) | 0;
  $4_1 = $23_1;
  $23_1 = HEAP32[$5_1 + 1512 >> 2] + $23_1 | 0;
  $16_1 = $4_1 >>> 0 > $23_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = HEAP32[$5_1 + 1508 >> 2] + ($35_1 & 1048575) | 0;
  $3_1 = $18_1;
  $18_1 = HEAP32[$5_1 + 1504 >> 2] + $18_1 | 0;
  $21_1 = $3_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $3_1 = HEAP32[$5_1 + 1540 >> 2] + ($52_1 & 65535) | 0;
  $4_1 = HEAP32[$5_1 + 1536 >> 2] + $56_1 | 0;
  $3_1 = $4_1 >>> 0 < $56_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $56_1 = $4_1;
  $38_1 = $3_1;
  $33_1 = ($9_1 | 0) == ($11_1 | 0) & $20_1 >>> 0 > $33_1 >>> 0 | $9_1 >>> 0 > $11_1 >>> 0;
  $9_1 = ($9_1 | 0) == ($48_1 | 0) & $20_1 >>> 0 < $46_1 >>> 0 | $9_1 >>> 0 < $48_1 >>> 0;
  $4_1 = $9_1 + $78 | 0;
  $3_1 = $59_1;
  $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $15_1 = $15_1 >>> 20 | 0;
  $9_1 = $15_1;
  $15_1 = $4_1 + $15_1 | 0;
  $4_1 = $9_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $15_1;
  $15_1 = $15_1 + $33_1 | 0;
  $3_1 = ($3_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) << 12 | $15_1 >>> 20;
  $4_1 = $15_1 << 12 | $11_1 >>> 20;
  $11_1 = $4_1 + $56_1 | 0;
  $3_1 = $3_1 + $38_1 | 0;
  $15_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = __wasm_i64_mul($15_1 >>> 16 | 0, 0, 977, 1);
  $4_1 = $9_1 + $18_1 | 0;
  $3_1 = $21_1 + i64toi32_i32$HIGH_BITS | 0;
  $33_1 = $4_1;
  $38_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $16_1;
  $4_1 = $38_1 >>> 20 | 0;
  $42_1 = $4_1 + $23_1 | 0;
  $44_1 = $4_1 >>> 0 > $42_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $22_1;
  $3_1 = $14_1;
  $9_1 = $44_1 >>> 20 | 0;
  $36_1 = $9_1 + $17_1 | 0;
  $26_1 = $9_1 >>> 0 > $36_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $4_1 = $26_1 >>> 20 | 0;
  $41_1 = $4_1 + $12_1 | 0;
  $9_1 = $4_1 >>> 0 > $41_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $15_1 & 65535;
  $4_1 = $9_1 >>> 20 | 0;
  $29_1 = $4_1 + $11_1 | 0;
  $40_1 = $4_1 >>> 0 > $29_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $48_1 = $47_1 << 1;
  $51_1 = $10_1 << 1 | $47_1 >>> 31;
  $43_1 = $11_1;
  $46_1 = $15_1;
  $47_1 = $6_1;
  $60_1 = $7_1 & 65535;
  $4_1 = $53_1;
  $53_1 = $31_1 & 1048575;
  $3_1 = $4_1 + $53_1 | 0;
  $52_1 = $8_1 + $49_1 | 0;
  $15_1 = $52_1 >>> 0 < $49_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $49_1 = $34_1 & 1048575;
  $3_1 = $49_1 + $70_1 | 0;
  $58_1 = $13_1 + $50_1 | 0;
  $20_1 = $58_1 >>> 0 < $50_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $50_1 = $30_1 & 1048575;
  $4_1 = $50_1 + $76 | 0;
  $6_1 = $27_1;
  $59_1 = $6_1 + $55_1 | 0;
  $27_1 = $59_1 >>> 0 < $55_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $55_1 = $37_1 & 1048575;
  $3_1 = $55_1 + $75 | 0;
  $10_1 = $19_1;
  $19_1 = $10_1 + $62_1 | 0;
  $11_1 = $19_1 >>> 0 < $62_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $56_1 = $7_1;
  $7_1 = __wasm_i64_mul($7_1 >>> 16 | 0, 0, 977, 1);
  $4_1 = $7_1 + $19_1 | 0;
  $3_1 = $11_1 + i64toi32_i32$HIGH_BITS | 0;
  $3_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $4_1;
  $35_1 = $3_1;
  $3_1 = $27_1;
  $4_1 = $35_1 >>> 20 | 0;
  $39_1 = $4_1 + $59_1 | 0;
  $37_1 = $4_1 >>> 0 > $39_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $20_1;
  $4_1 = $37_1 >>> 20 | 0;
  $30_1 = $4_1 + $58_1 | 0;
  $34_1 = $4_1 >>> 0 > $30_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $15_1;
  $3_1 = $60_1;
  $31_1 = $34_1 >>> 20 | 0;
  $32_1 = $31_1;
  $31_1 = $31_1 + $52_1 | 0;
  $4_1 = $32_1 >>> 0 > $31_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $32_1 = $4_1 >>> 20 | 0;
  $60_1 = $32_1;
  $32_1 = $32_1 + $47_1 | 0;
  $3_1 = $60_1 >>> 0 > $32_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  if ($32_1 | ($31_1 | ($7_1 | $39_1 | $30_1)) | ($3_1 | ($35_1 | $37_1 | $34_1 | $4_1) & 1048575)) {
   if (($39_1 & ($7_1 ^ 976) & $30_1 & $31_1 & $32_1) == -1) {
    $4_1 = ($37_1 & ($35_1 ^ 1) & $34_1 & $4_1 & ($3_1 ^ 983040)) == 1048575
   } else {
    $4_1 = 0
   }
  } else {
   $4_1 = 1
  }
  $3_1 = $4_1;
  if ($41_1 | ($33_1 | $42_1 | $36_1) | $29_1 | (($44_1 | $38_1 | $26_1 | $9_1) & 1048575 | $40_1)) {
   if (($42_1 & ($33_1 ^ 976) & $36_1 & $41_1 & $29_1) == -1) {
    $4_1 = ($44_1 & ($38_1 ^ 1) & $26_1 & $9_1 & ($40_1 ^ 983040)) == 1048575
   } else {
    $4_1 = 0
   }
  } else {
   $4_1 = 1
  }
  $29_1 = $3_1 & $4_1;
  HEAP32[$5_1 + 1376 >> 2] = $29_1 ? $48_1 : $43_1;
  HEAP32[$5_1 + 1380 >> 2] = $29_1 ? $51_1 : $46_1;
  HEAP32[$5_1 + 1368 >> 2] = $29_1 ? $8_1 << 1 : $12_1;
  HEAP32[$5_1 + 1372 >> 2] = $29_1 ? $53_1 << 1 | $8_1 >>> 31 : $14_1;
  HEAP32[$5_1 + 1360 >> 2] = $29_1 ? $13_1 << 1 : $17_1;
  HEAP32[$5_1 + 1364 >> 2] = $29_1 ? $49_1 << 1 | $13_1 >>> 31 : $22_1;
  HEAP32[$5_1 + 1352 >> 2] = $29_1 ? $6_1 << 1 : $23_1;
  HEAP32[$5_1 + 1356 >> 2] = $29_1 ? $50_1 << 1 | $6_1 >>> 31 : $16_1;
  HEAP32[$5_1 + 1344 >> 2] = $29_1 ? $10_1 << 1 : $18_1;
  HEAP32[$5_1 + 1348 >> 2] = $29_1 ? $55_1 << 1 | $10_1 >>> 31 : $21_1;
  $3_1 = HEAP32[$5_1 + 1420 >> 2] + $57_1 | 0;
  $4_1 = HEAP32[$5_1 + 1416 >> 2] + $45_1 | 0;
  $3_1 = $4_1 >>> 0 < $45_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $29_1 ? $4_1 : $47_1;
  HEAP32[$5_1 + 1416 >> 2] = $8_1;
  $10_1 = $29_1 ? $3_1 : $56_1;
  HEAP32[$5_1 + 1420 >> 2] = $10_1;
  $3_1 = HEAP32[$5_1 + 1412 >> 2] + $73 | 0;
  $4_1 = HEAP32[$5_1 + 1408 >> 2] + $28_1 | 0;
  $3_1 = $4_1 >>> 0 < $28_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $41_1 = $29_1 ? $4_1 : $52_1;
  HEAP32[$5_1 + 1408 >> 2] = $41_1;
  $40_1 = $29_1 ? $3_1 : $15_1;
  HEAP32[$5_1 + 1412 >> 2] = $40_1;
  $3_1 = HEAP32[$5_1 + 1404 >> 2] + $72 | 0;
  $4_1 = HEAP32[$5_1 + 1400 >> 2] + $25_1 | 0;
  $3_1 = $4_1 >>> 0 < $25_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $7_1 = $29_1 ? $4_1 : $58_1;
  HEAP32[$5_1 + 1400 >> 2] = $7_1;
  $6_1 = $29_1 ? $3_1 : $20_1;
  HEAP32[$5_1 + 1404 >> 2] = $6_1;
  $3_1 = HEAP32[$5_1 + 1396 >> 2] + $71 | 0;
  $4_1 = HEAP32[$5_1 + 1392 >> 2] + $24_1 | 0;
  $3_1 = $4_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $29_1 ? $4_1 : $59_1;
  HEAP32[$5_1 + 1392 >> 2] = $4_1;
  $9_1 = $29_1 ? $3_1 : $27_1;
  HEAP32[$5_1 + 1396 >> 2] = $9_1;
  $3_1 = HEAP32[$5_1 + 1388 >> 2] + $74 | 0;
  $13_1 = HEAP32[$5_1 + 1384 >> 2] + $54_1 | 0;
  $3_1 = $13_1 >>> 0 < $54_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $29_1 ? $13_1 : $19_1;
  HEAP32[$5_1 + 1384 >> 2] = $13_1;
  $3_1 = $29_1 ? $3_1 : $11_1;
  $12_1 = $3_1;
  HEAP32[$5_1 + 1388 >> 2] = $3_1;
  $14_1 = $5_1 + 896 | 0;
  $25_1 = $13_1 << 1;
  $24_1 = $3_1 << 1 | $13_1 >>> 31;
  $69($14_1, $25_1, $24_1, 0, 0, $41_1, $40_1, 0, 0);
  $33_1 = $9_1;
  $28_1 = $4_1;
  $4_1 = $9_1 << 1 | $4_1 >>> 31;
  $17_1 = $5_1 + 944 | 0;
  $9_1 = $28_1 << 1;
  $69($17_1, $9_1, $4_1, 0, 0, $7_1, $6_1, 0, 0);
  $22_1 = $5_1 + 832 | 0;
  $69($22_1, $8_1, $10_1, 0, 0, $8_1, $10_1, 0, 0);
  $23_1 = $5_1 + 816 | 0;
  $69($23_1, HEAP32[$5_1 + 832 >> 2], HEAP32[$5_1 + 836 >> 2], 0, 0, 15632, 16, 0, 0);
  $18_1 = $5_1 + 784 | 0;
  $16_1 = $8_1 << 1;
  $45_1 = $10_1 << 1 | $8_1 >>> 31;
  $69($18_1, $16_1, $45_1, 0, 0, $13_1, $3_1, 0, 0);
  $21_1 = $5_1 + 880 | 0;
  $69($21_1, $9_1, $4_1, 0, 0, $41_1, $40_1, 0, 0);
  $36_1 = $5_1 + 928 | 0;
  $69($36_1, $7_1, $6_1, 0, 0, $7_1, $6_1, 0, 0);
  $26_1 = $5_1 + 800 | 0;
  $3_1 = $22_1 + 8 | 0;
  $69($26_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $39_1 = $5_1 + 992 | 0;
  $69($39_1, $13_1, $12_1, 0, 0, $13_1, $12_1, 0, 0);
  $35_1 = $5_1 + 768 | 0;
  $69($35_1, $16_1, $45_1, 0, 0, $28_1, $33_1, 0, 0);
  $38_1 = $6_1;
  $54_1 = $7_1;
  $4_1 = $6_1 << 1 | $7_1 >>> 31;
  $37_1 = $5_1 + 864 | 0;
  $69($37_1, $7_1 << 1, $4_1, 0, 0, $41_1, $40_1, 0, 0);
  $13_1 = HEAP32[$5_1 + 896 >> 2];
  $7_1 = HEAP32[$5_1 + 944 >> 2];
  $4_1 = $13_1 + $7_1 | 0;
  $9_1 = HEAP32[$5_1 + 900 >> 2];
  $3_1 = $9_1 + HEAP32[$5_1 + 948 >> 2] | 0;
  $7_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $7_1 + HEAP32[$5_1 + 820 >> 2] | 0;
  $6_1 = $4_1;
  $8_1 = HEAP32[$5_1 + 816 >> 2];
  $4_1 = $4_1 + $8_1 | 0;
  $42_1 = $4_1;
  $4_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = ($7_1 | 0) == ($4_1 | 0) & $6_1 >>> 0 > $42_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0;
  $3_1 = $23_1 + 8 | 0;
  $10_1 = HEAP32[$3_1 >> 2];
  $12_1 = HEAP32[$3_1 + 4 >> 2];
  $6_1 = ($7_1 | 0) == ($9_1 | 0) & $6_1 >>> 0 < $13_1 >>> 0 | $7_1 >>> 0 < $9_1 >>> 0;
  $3_1 = $17_1 + 8 | 0;
  $9_1 = HEAP32[$3_1 >> 2];
  $13_1 = $14_1 + 8 | 0;
  $7_1 = $9_1 + HEAP32[$13_1 >> 2] | 0;
  $3_1 = HEAP32[$13_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = $7_1;
  $7_1 = $6_1 + $7_1 | 0;
  $3_1 = ($9_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $12_1 | 0;
  $6_1 = $7_1;
  $7_1 = $7_1 + $10_1 | 0;
  $3_1 = $6_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $7_1;
  $7_1 = $7_1 + $8_1 | 0;
  $6_1 = $6_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = $6_1 << 12 | $7_1 >>> 20;
  $44_1 = $4_1;
  $7_1 = $7_1 << 12 | $4_1 >>> 20;
  $13_1 = $9_1;
  $22_1 = HEAP32[$5_1 + 880 >> 2];
  $9_1 = HEAP32[$5_1 + 928 >> 2];
  $3_1 = $22_1 + $9_1 | 0;
  $17_1 = HEAP32[$5_1 + 884 >> 2];
  $4_1 = $17_1 + HEAP32[$5_1 + 932 >> 2] | 0;
  $8_1 = $3_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $10_1 = $3_1;
  $9_1 = HEAP32[$5_1 + 784 >> 2];
  $4_1 = $3_1 + $9_1 | 0;
  $3_1 = $8_1 + HEAP32[$5_1 + 788 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $4_1;
  $14_1 = HEAP32[$5_1 + 800 >> 2];
  $4_1 = $4_1 + $14_1 | 0;
  $9_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$5_1 + 804 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = $4_1;
  $4_1 = $3_1 + $13_1 | 0;
  $30_1 = $5_1 + 752 | 0;
  $23_1 = $30_1;
  $13_1 = $7_1 + $14_1 | 0;
  $7_1 = $13_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $34_1 = ($3_1 | 0) == ($7_1 | 0) & $13_1 >>> 0 < $14_1 >>> 0 | $3_1 >>> 0 > $7_1 >>> 0;
  $14_1 = ($3_1 | 0) == ($9_1 | 0) & $12_1 >>> 0 > $14_1 >>> 0 | $3_1 >>> 0 < $9_1 >>> 0;
  $3_1 = $26_1 + 8 | 0;
  $26_1 = HEAP32[$3_1 >> 2];
  $31_1 = HEAP32[$3_1 + 4 >> 2];
  $9_1 = ($8_1 | 0) == ($9_1 | 0) & $10_1 >>> 0 > $12_1 >>> 0 | $8_1 >>> 0 > $9_1 >>> 0;
  $3_1 = $18_1 + 8 | 0;
  $12_1 = HEAP32[$3_1 >> 2];
  $18_1 = HEAP32[$3_1 + 4 >> 2];
  $8_1 = ($8_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $22_1 >>> 0 | $8_1 >>> 0 < $17_1 >>> 0;
  $3_1 = $36_1 + 8 | 0;
  $10_1 = HEAP32[$3_1 >> 2];
  $17_1 = $21_1 + 8 | 0;
  $4_1 = $10_1 + HEAP32[$17_1 >> 2] | 0;
  $3_1 = HEAP32[$17_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $4_1;
  $4_1 = $4_1 + $8_1 | 0;
  $3_1 = ($10_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
  $8_1 = $4_1;
  $4_1 = $4_1 + $12_1 | 0;
  $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = $4_1 + $9_1 | 0;
  $4_1 = ($9_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $31_1 | 0;
  $3_1 = $9_1;
  $9_1 = $9_1 + $26_1 | 0;
  $3_1 = $3_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $4_1 = $9_1 + $14_1 | 0;
  $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $6_1 >>> 20 | 0;
  $4_1 = $4_1 + $6_1 | 0;
  $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $4_1;
  $4_1 = $4_1 + $34_1 | 0;
  $6_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = $6_1 << 12 | $4_1 >>> 20;
  $10_1 = $4_1 << 12 | $7_1 >>> 20;
  $3_1 = $9_1;
  $18_1 = HEAP32[$5_1 + 768 >> 2];
  $9_1 = HEAP32[$5_1 + 864 >> 2];
  $8_1 = $18_1 + $9_1 | 0;
  $14_1 = HEAP32[$5_1 + 772 >> 2];
  $4_1 = $14_1 + HEAP32[$5_1 + 868 >> 2] | 0;
  $9_1 = $8_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $3_1 = $9_1 + $3_1 | 0;
  $10_1 = $8_1 + $10_1 | 0;
  $4_1 = $10_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $10_1;
  $3_1 = $4_1 << 4 | $10_1 >>> 28;
  $36_1 = $7_1;
  $69($23_1, $7_1 >>> 16 & 15 | $10_1 << 4 & -16, $3_1 & 16777215, 0, 0, 977, 1, 0, 0);
  $17_1 = HEAP32[$5_1 + 756 >> 2];
  $3_1 = $17_1 + HEAP32[$5_1 + 996 >> 2] | 0;
  $21_1 = HEAP32[$5_1 + 752 >> 2];
  $7_1 = HEAP32[$5_1 + 992 >> 2];
  $10_1 = $21_1 + $7_1 | 0;
  $22_1 = $10_1;
  HEAP32[$5_1 + 1464 >> 2] = $10_1;
  $7_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $23_1 = $7_1 & 1048575;
  HEAP32[$5_1 + 1468 >> 2] = $23_1;
  $34_1 = $5_1 + 976 | 0;
  $69($34_1, $25_1, $24_1, 0, 0, $28_1, $33_1, 0, 0);
  $31_1 = $5_1 + 720 | 0;
  $69($31_1, $16_1, $45_1, 0, 0, $54_1, $38_1, 0, 0);
  $32_1 = $5_1 + 848 | 0;
  $69($32_1, $41_1, $40_1, 0, 0, $41_1, $40_1, 0, 0);
  $57_1 = $5_1 + 704 | 0;
  $12_1 = ($4_1 | 0) == ($9_1 | 0) & $8_1 >>> 0 > $12_1 >>> 0 | $4_1 >>> 0 < $9_1 >>> 0;
  $8_1 = ($9_1 | 0) == ($14_1 | 0) & $8_1 >>> 0 < $18_1 >>> 0 | $9_1 >>> 0 < $14_1 >>> 0;
  $3_1 = $37_1 + 8 | 0;
  $14_1 = HEAP32[$3_1 >> 2];
  $18_1 = $35_1 + 8 | 0;
  $9_1 = $14_1 + HEAP32[$18_1 >> 2] | 0;
  $3_1 = HEAP32[$18_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $9_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = $9_1;
  $9_1 = $8_1 + $9_1 | 0;
  $3_1 = $14_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $6_1 >>> 20 | 0;
  $8_1 = $6_1;
  $6_1 = $6_1 + $9_1 | 0;
  $3_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = $6_1;
  $6_1 = $6_1 + $12_1 | 0;
  $9_1 = $9_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $9_1 << 12 | $6_1 >>> 20;
  $4_1 = $6_1 << 12 | $4_1 >>> 20;
  $6_1 = $8_1;
  $37_1 = HEAP32[$5_1 + 720 >> 2];
  $8_1 = HEAP32[$5_1 + 848 >> 2];
  $18_1 = $37_1 + $8_1 | 0;
  $35_1 = HEAP32[$5_1 + 724 >> 2];
  $3_1 = $35_1 + HEAP32[$5_1 + 852 >> 2] | 0;
  $8_1 = $8_1 >>> 0 > $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $8_1 + $6_1 | 0;
  $4_1 = $4_1 + $18_1 | 0;
  $3_1 = $4_1 >>> 0 < $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $26_1 = $4_1;
  $6_1 = $3_1;
  $69($57_1, $4_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $10_1 = ($7_1 | 0) == ($17_1 | 0) & $10_1 >>> 0 < $21_1 >>> 0 | $7_1 >>> 0 < $17_1 >>> 0;
  $3_1 = $39_1 + 8 | 0;
  $12_1 = HEAP32[$3_1 >> 2];
  $14_1 = $30_1 + 8 | 0;
  $4_1 = $12_1 + HEAP32[$14_1 >> 2] | 0;
  $3_1 = HEAP32[$14_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $4_1;
  $4_1 = $4_1 + $10_1 | 0;
  $10_1 = $12_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $10_1 << 12 | $4_1 >>> 20;
  $7_1 = $4_1 << 12 | $7_1 >>> 20;
  $3_1 = $12_1;
  $30_1 = HEAP32[$5_1 + 704 >> 2];
  $12_1 = HEAP32[$5_1 + 976 >> 2];
  $21_1 = $30_1 + $12_1 | 0;
  $39_1 = HEAP32[$5_1 + 708 >> 2];
  $4_1 = $39_1 + HEAP32[$5_1 + 980 >> 2] | 0;
  $12_1 = $12_1 >>> 0 > $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $3_1 = $12_1 + $3_1 | 0;
  $4_1 = $7_1 + $21_1 | 0;
  $3_1 = $4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = $4_1;
  HEAP32[$5_1 + 1472 >> 2] = $4_1;
  $7_1 = $3_1;
  $17_1 = $3_1 & 1048575;
  HEAP32[$5_1 + 1476 >> 2] = $17_1;
  $48_1 = $5_1 + 912 | 0;
  $69($48_1, $25_1, $24_1, 0, 0, $54_1, $38_1, 0, 0);
  $54_1 = $5_1 + 960 | 0;
  $69($54_1, $28_1, $33_1, 0, 0, $28_1, $33_1, 0, 0);
  $33_1 = $5_1 + 656 | 0;
  $69($33_1, $16_1, $45_1, 0, 0, $41_1, $40_1, 0, 0);
  $45_1 = $5_1 + 640 | 0;
  $16_1 = $45_1;
  $24_1 = ($6_1 | 0) == ($8_1 | 0) & $18_1 >>> 0 > $26_1 >>> 0 | $6_1 >>> 0 < $8_1 >>> 0;
  $8_1 = ($8_1 | 0) == ($35_1 | 0) & $18_1 >>> 0 < $37_1 >>> 0 | $8_1 >>> 0 < $35_1 >>> 0;
  $3_1 = $32_1 + 8 | 0;
  $18_1 = HEAP32[$3_1 >> 2];
  $25_1 = $31_1 + 8 | 0;
  $4_1 = $18_1 + HEAP32[$25_1 >> 2] | 0;
  $3_1 = HEAP32[$25_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $18_1 = $4_1;
  $4_1 = $4_1 + $8_1 | 0;
  $3_1 = $18_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $4_1;
  $9_1 = $9_1 >>> 20 | 0;
  $4_1 = $9_1;
  $9_1 = $8_1 + $9_1 | 0;
  $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $9_1 + $24_1 | 0;
  $9_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $9_1 << 12 | $4_1 >>> 20;
  $38_1 = $4_1 << 12 | $6_1 >>> 20;
  $8_1 = HEAP32[$5_1 + 656 >> 2];
  $6_1 = $38_1 + $8_1 | 0;
  $25_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$5_1 + 660 >> 2] | 0;
  $24_1 = $6_1;
  $18_1 = $6_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($16_1, $6_1, $18_1, 0, 0, 15632, 16, 0, 0);
  $16_1 = ($7_1 | 0) == ($12_1 | 0) & $14_1 >>> 0 < $21_1 >>> 0 | $7_1 >>> 0 < $12_1 >>> 0;
  $6_1 = ($12_1 | 0) == ($39_1 | 0) & $21_1 >>> 0 < $30_1 >>> 0 | $12_1 >>> 0 < $39_1 >>> 0;
  $3_1 = $34_1 + 8 | 0;
  $8_1 = HEAP32[$3_1 >> 2];
  $12_1 = $57_1 + 8 | 0;
  $4_1 = $8_1 + HEAP32[$12_1 >> 2] | 0;
  $3_1 = HEAP32[$12_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $4_1;
  $4_1 = $4_1 + $6_1 | 0;
  $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $4_1;
  $8_1 = $10_1 >>> 20 | 0;
  $6_1 = $6_1 + $8_1 | 0;
  $3_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $6_1 + $16_1 | 0;
  $6_1 = $4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $6_1 << 12 | $4_1 >>> 20;
  $7_1 = $4_1 << 12 | $7_1 >>> 20;
  $10_1 = $3_1;
  $26_1 = HEAP32[$5_1 + 912 >> 2];
  $8_1 = HEAP32[$5_1 + 960 >> 2];
  $4_1 = $26_1 + $8_1 | 0;
  $28_1 = HEAP32[$5_1 + 916 >> 2];
  $3_1 = $28_1 + HEAP32[$5_1 + 964 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $21_1 = $4_1;
  $4_1 = HEAP32[$5_1 + 640 >> 2];
  $16_1 = $21_1 + $4_1 | 0;
  $12_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$5_1 + 644 >> 2] | 0;
  $4_1 = $4_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1 + $10_1 | 0;
  $8_1 = $7_1 + $16_1 | 0;
  $3_1 = $8_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$5_1 + 1480 >> 2] = $8_1;
  $7_1 = $3_1;
  $10_1 = $3_1 & 1048575;
  HEAP32[$5_1 + 1484 >> 2] = $10_1;
  $41_1 = $5_1 + 576 | 0;
  $18_1 = ($18_1 | 0) == ($25_1 | 0) & $24_1 >>> 0 < $38_1 >>> 0 | $18_1 >>> 0 < $25_1 >>> 0;
  $3_1 = $33_1 + 8 | 0;
  $24_1 = HEAP32[$3_1 >> 2];
  $3_1 = HEAP32[$3_1 + 4 >> 2];
  $9_1 = $9_1 >>> 20 | 0;
  $25_1 = $9_1;
  $9_1 = $9_1 + $24_1 | 0;
  $3_1 = $25_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $24_1 = $9_1;
  $9_1 = $9_1 + $18_1 | 0;
  $3_1 = $24_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($41_1, $9_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
  $18_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 < $16_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
  $16_1 = ($4_1 | 0) == ($12_1 | 0) & $16_1 >>> 0 < $21_1 >>> 0 | $4_1 >>> 0 < $12_1 >>> 0;
  $3_1 = $45_1 + 8 | 0;
  $24_1 = HEAP32[$3_1 >> 2];
  $25_1 = HEAP32[$3_1 + 4 >> 2];
  $12_1 = ($12_1 | 0) == ($28_1 | 0) & $21_1 >>> 0 < $26_1 >>> 0 | $12_1 >>> 0 < $28_1 >>> 0;
  $3_1 = $54_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $21_1 = $48_1 + 8 | 0;
  $9_1 = $4_1 + HEAP32[$21_1 >> 2] | 0;
  $3_1 = HEAP32[$21_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $4_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $9_1;
  $9_1 = $9_1 + $12_1 | 0;
  $3_1 = ($3_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $25_1 | 0;
  $4_1 = $9_1 + $24_1 | 0;
  $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $9_1 = $4_1;
  $4_1 = $4_1 + $16_1 | 0;
  $3_1 = $9_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $6_1 >>> 20 | 0;
  $4_1 = $6_1 + $4_1 | 0;
  $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $4_1;
  $4_1 = $4_1 + $18_1 | 0;
  $6_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1;
  $4_1 = $6_1 << 12 | $3_1 >>> 20;
  $7_1 = $3_1 << 12 | $7_1 >>> 20;
  $9_1 = $4_1;
  $18_1 = HEAP32[$5_1 + 576 >> 2];
  $16_1 = $18_1 + ($42_1 & -2) | 0;
  $21_1 = HEAP32[$5_1 + 580 >> 2];
  $3_1 = $21_1 + ($44_1 & 1048575) | 0;
  $4_1 = $16_1 >>> 0 < $18_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1 + $9_1 | 0;
  $7_1 = $7_1 + $16_1 | 0;
  $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$5_1 + 1488 >> 2] = $7_1;
  $9_1 = $3_1;
  $12_1 = $3_1 & 1048575;
  HEAP32[$5_1 + 1492 >> 2] = $12_1;
  $24_1 = $36_1 & 65535;
  $25_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $16_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
  $16_1 = ($4_1 | 0) == ($21_1 | 0) & $16_1 >>> 0 < $18_1 >>> 0 | $4_1 >>> 0 < $21_1 >>> 0;
  $4_1 = $41_1 + 8 | 0;
  $3_1 = $16_1 + HEAP32[$4_1 >> 2] | 0;
  $4_1 = HEAP32[$4_1 + 4 >> 2];
  $4_1 = $3_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $16_1 = $3_1;
  $3_1 = $4_1;
  $6_1 = $6_1 >>> 20 | 0;
  $4_1 = $6_1 + $16_1 | 0;
  $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $4_1;
  $4_1 = $4_1 + $25_1 | 0;
  $3_1 = $24_1 + (($6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) << 12 | $4_1 >>> 20) | 0;
  $4_1 = $4_1 << 12 | $9_1 >>> 20;
  $6_1 = $4_1 + $13_1 | 0;
  HEAP32[$5_1 + 1496 >> 2] = $6_1;
  $4_1 = $4_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$5_1 + 1500 >> 2] = $4_1;
  $3_1 = HEAP32[$5_1 + 1544 >> 2];
  $9_1 = -5862 - $3_1 | 0;
  $3_1 = 6291449 - (HEAP32[$5_1 + 1548 >> 2] + ($3_1 >>> 0 > 4294961434) | 0) | 0;
  HEAP32[$5_1 + 1424 >> 2] = $9_1;
  HEAP32[$5_1 + 1428 >> 2] = $3_1;
  $3_1 = HEAP32[$65_1 >> 2];
  $9_1 = -6 - $3_1 | 0;
  $3_1 = 6291455 - (HEAP32[$65_1 + 4 >> 2] + ($3_1 >>> 0 > 4294967290) | 0) | 0;
  HEAP32[$5_1 + 1432 >> 2] = $9_1;
  HEAP32[$5_1 + 1436 >> 2] = $3_1;
  $3_1 = HEAP32[$66_1 >> 2];
  $9_1 = -6 - $3_1 | 0;
  $3_1 = 6291455 - (HEAP32[$66_1 + 4 >> 2] + ($3_1 >>> 0 > 4294967290) | 0) | 0;
  HEAP32[$5_1 + 1440 >> 2] = $9_1;
  HEAP32[$5_1 + 1444 >> 2] = $3_1;
  $3_1 = HEAP32[$67_1 >> 2];
  $9_1 = -6 - $3_1 | 0;
  $3_1 = 6291455 - (HEAP32[$67_1 + 4 >> 2] + ($3_1 >>> 0 > 4294967290) | 0) | 0;
  HEAP32[$5_1 + 1448 >> 2] = $9_1;
  HEAP32[$5_1 + 1452 >> 2] = $3_1;
  $3_1 = HEAP32[$61_1 >> 2];
  $9_1 = -6 - $3_1 | 0;
  $3_1 = 393215 - (HEAP32[$61_1 + 4 >> 2] + ($3_1 >>> 0 > 4294967290) | 0) | 0;
  HEAP32[$5_1 + 1456 >> 2] = $9_1;
  HEAP32[$5_1 + 1460 >> 2] = $3_1;
  $16_1 = $23_1;
  $3_1 = $16_1 << 1 | $22_1 >>> 31;
  $54_1 = $5_1 + 528 | 0;
  $9_1 = $12_1;
  $23_1 = $22_1 << 1;
  $12_1 = $3_1;
  $69($54_1, $7_1, $9_1, 0, 0, $23_1, $3_1, 0, 0);
  $33_1 = $5_1 + 592 | 0;
  $13_1 = $8_1;
  $8_1 = $10_1;
  $24_1 = $14_1 << 1;
  $21_1 = $17_1;
  $18_1 = $17_1 << 1 | $14_1 >>> 31;
  $69($33_1, $13_1, $8_1, 0, 0, $24_1, $18_1, 0, 0);
  $25_1 = $5_1 + 496 | 0;
  $69($25_1, $6_1, $4_1, 0, 0, $6_1, $4_1, 0, 0);
  $38_1 = $5_1 + 480 | 0;
  $69($38_1, HEAP32[$5_1 + 496 >> 2], HEAP32[$5_1 + 500 >> 2], 0, 0, 15632, 16, 0, 0);
  $42_1 = $5_1 + 448 | 0;
  $10_1 = $6_1 << 1;
  $17_1 = $4_1 << 1 | $6_1 >>> 31;
  $69($42_1, $10_1, $17_1, 0, 0, $22_1, $16_1, 0, 0);
  $44_1 = $5_1 + 544 | 0;
  $69($44_1, $7_1, $9_1, 0, 0, $24_1, $18_1, 0, 0);
  $36_1 = $5_1 + 608 | 0;
  $69($36_1, $13_1, $8_1, 0, 0, $13_1, $8_1, 0, 0);
  $26_1 = $5_1 + 464 | 0;
  $3_1 = $25_1 + 8 | 0;
  $69($26_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $41_1 = $5_1 + 736 | 0;
  $69($41_1, $22_1, $16_1, 0, 0, $22_1, $16_1, 0, 0);
  $40_1 = $5_1 + 432 | 0;
  $69($40_1, $10_1, $17_1, 0, 0, $14_1, $21_1, 0, 0);
  $35_1 = $5_1 + 512 | 0;
  $24_1 = $7_1;
  $25_1 = $9_1;
  $28_1 = $8_1;
  $22_1 = $13_1;
  $69($35_1, $7_1, $9_1, 0, 0, $13_1 << 1, $8_1 << 1 | $13_1 >>> 31, 0, 0);
  $13_1 = HEAP32[$5_1 + 528 >> 2];
  $7_1 = HEAP32[$5_1 + 592 >> 2];
  $4_1 = $13_1 + $7_1 | 0;
  $9_1 = HEAP32[$5_1 + 532 >> 2];
  $3_1 = $9_1 + HEAP32[$5_1 + 596 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $4_1;
  $8_1 = HEAP32[$5_1 + 480 >> 2];
  $7_1 = $4_1 + $8_1 | 0;
  $4_1 = $3_1 + HEAP32[$5_1 + 484 >> 2] | 0;
  $45_1 = $7_1;
  $7_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $8_1 = ($3_1 | 0) == ($7_1 | 0) & $6_1 >>> 0 > $45_1 >>> 0 | $3_1 >>> 0 > $7_1 >>> 0;
  $4_1 = $38_1 + 8 | 0;
  $16_1 = HEAP32[$4_1 >> 2];
  $18_1 = HEAP32[$4_1 + 4 >> 2];
  $6_1 = ($3_1 | 0) == ($9_1 | 0) & $6_1 >>> 0 < $13_1 >>> 0 | $3_1 >>> 0 < $9_1 >>> 0;
  $3_1 = $33_1 + 8 | 0;
  $9_1 = HEAP32[$3_1 >> 2];
  $13_1 = $54_1 + 8 | 0;
  $4_1 = $9_1 + HEAP32[$13_1 >> 2] | 0;
  $3_1 = HEAP32[$13_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $4_1 + $6_1 | 0;
  $4_1 = ($6_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
  $3_1 = $6_1;
  $6_1 = $6_1 + $16_1 | 0;
  $3_1 = $3_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $4_1 = $6_1 + $8_1 | 0;
  $6_1 = $4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $6_1 << 12 | $4_1 >>> 20;
  $54_1 = $7_1;
  $33_1 = $4_1 << 12 | $7_1 >>> 20;
  $39_1 = $3_1;
  $37_1 = HEAP32[$5_1 + 544 >> 2];
  $7_1 = HEAP32[$5_1 + 608 >> 2];
  $4_1 = $37_1 + $7_1 | 0;
  $38_1 = HEAP32[$5_1 + 548 >> 2];
  $3_1 = $38_1 + HEAP32[$5_1 + 612 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $4_1;
  $4_1 = HEAP32[$5_1 + 448 >> 2];
  $7_1 = $8_1 + $4_1 | 0;
  $13_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$5_1 + 452 >> 2] | 0;
  $3_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $16_1 = $7_1;
  $9_1 = HEAP32[$5_1 + 464 >> 2];
  $7_1 = $7_1 + $9_1 | 0;
  $4_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$5_1 + 468 >> 2] | 0;
  $9_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $9_1 + $39_1 | 0;
  $39_1 = $5_1 + 416 | 0;
  $18_1 = $7_1;
  $33_1 = $7_1 + $33_1 | 0;
  $7_1 = $7_1 >>> 0 > $33_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $9_1;
  $9_1 = $33_1;
  $33_1 = ($7_1 | 0) == ($3_1 | 0) & $18_1 >>> 0 > $9_1 >>> 0 | $3_1 >>> 0 > $7_1 >>> 0;
  $18_1 = ($3_1 | 0) == ($4_1 | 0) & $16_1 >>> 0 > $18_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
  $3_1 = $26_1 + 8 | 0;
  $26_1 = HEAP32[$3_1 >> 2];
  $30_1 = HEAP32[$3_1 + 4 >> 2];
  $16_1 = ($4_1 | 0) == ($13_1 | 0) & $8_1 >>> 0 > $16_1 >>> 0 | $4_1 >>> 0 < $13_1 >>> 0;
  $3_1 = $42_1 + 8 | 0;
  $42_1 = HEAP32[$3_1 >> 2];
  $34_1 = HEAP32[$3_1 + 4 >> 2];
  $8_1 = ($13_1 | 0) == ($38_1 | 0) & $8_1 >>> 0 < $37_1 >>> 0 | $13_1 >>> 0 < $38_1 >>> 0;
  $3_1 = $36_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $38_1 = $44_1 + 8 | 0;
  $13_1 = $4_1 + HEAP32[$38_1 >> 2] | 0;
  $3_1 = HEAP32[$38_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $4_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $13_1;
  $13_1 = $8_1 + $13_1 | 0;
  $3_1 = ($3_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $34_1 | 0;
  $4_1 = $13_1 + $42_1 | 0;
  $3_1 = $4_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $4_1;
  $4_1 = $4_1 + $16_1 | 0;
  $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $30_1 | 0;
  $8_1 = $4_1;
  $4_1 = $4_1 + $26_1 | 0;
  $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $4_1;
  $4_1 = $4_1 + $18_1 | 0;
  $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $4_1;
  $6_1 = $6_1 >>> 20 | 0;
  $4_1 = $6_1;
  $6_1 = $6_1 + $13_1 | 0;
  $3_1 = $4_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $6_1 + $33_1 | 0;
  $6_1 = $4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $6_1 << 12 | $4_1 >>> 20;
  $13_1 = $7_1;
  $7_1 = $4_1 << 12 | $7_1 >>> 20;
  $33_1 = $3_1;
  $38_1 = HEAP32[$5_1 + 432 >> 2];
  $4_1 = HEAP32[$5_1 + 512 >> 2];
  $8_1 = $38_1 + $4_1 | 0;
  $18_1 = HEAP32[$5_1 + 436 >> 2];
  $3_1 = $18_1 + HEAP32[$5_1 + 516 >> 2] | 0;
  $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1 + $33_1 | 0;
  $16_1 = $7_1 + $8_1 | 0;
  $3_1 = $16_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $42_1 = $16_1 << 4 & -16;
  $33_1 = $13_1;
  $7_1 = $3_1;
  $69($39_1, $42_1 | $13_1 >>> 16 & 15, ($3_1 << 4 | $16_1 >>> 28) & 16777215, 0, 0, 977, 1, 0, 0);
  $37_1 = $5_1 + 672 | 0;
  $69($37_1, $14_1, $21_1, 0, 0, $23_1, $12_1, 0, 0);
  $42_1 = $5_1 + 400 | 0;
  $69($42_1, $10_1, $17_1, 0, 0, $22_1, $28_1, 0, 0);
  $44_1 = $5_1 + 560 | 0;
  $69($44_1, $24_1, $25_1, 0, 0, $24_1, $25_1, 0, 0);
  $57_1 = $5_1 + 384 | 0;
  $36_1 = $57_1;
  $16_1 = ($4_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $16_1 >>> 0 | $4_1 >>> 0 > $3_1 >>> 0;
  $8_1 = ($4_1 | 0) == ($18_1 | 0) & $8_1 >>> 0 < $38_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
  $3_1 = $35_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $18_1 = $40_1 + 8 | 0;
  $13_1 = $4_1 + HEAP32[$18_1 >> 2] | 0;
  $3_1 = HEAP32[$18_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $4_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $8_1 + $13_1 | 0;
  $4_1 = $3_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $13_1 = $3_1;
  $3_1 = $4_1;
  $6_1 = $6_1 >>> 20 | 0;
  $4_1 = $6_1 + $13_1 | 0;
  $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $4_1;
  $4_1 = $4_1 + $16_1 | 0;
  $6_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $6_1 << 12 | $4_1 >>> 20;
  $7_1 = $4_1 << 12 | $7_1 >>> 20;
  $8_1 = $13_1;
  $18_1 = HEAP32[$5_1 + 400 >> 2];
  $13_1 = HEAP32[$5_1 + 560 >> 2];
  $4_1 = $18_1 + $13_1 | 0;
  $16_1 = HEAP32[$5_1 + 404 >> 2];
  $3_1 = $16_1 + HEAP32[$5_1 + 564 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $4_1;
  $4_1 = $3_1 + $8_1 | 0;
  $7_1 = $7_1 + $13_1 | 0;
  $4_1 = $7_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $8_1 = $7_1;
  $7_1 = $4_1;
  $69($36_1, $8_1, $4_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $40_1 = $5_1 + 624 | 0;
  $69($40_1, $22_1, $28_1, 0, 0, $23_1, $12_1, 0, 0);
  $35_1 = $5_1 + 688 | 0;
  $69($35_1, $14_1, $21_1, 0, 0, $14_1, $21_1, 0, 0);
  $12_1 = $5_1 + 368 | 0;
  $69($12_1, $10_1, $17_1, 0, 0, $24_1, $25_1, 0, 0);
  $48_1 = $5_1 + 352 | 0;
  $10_1 = $48_1;
  $8_1 = ($3_1 | 0) == ($4_1 | 0) & $8_1 >>> 0 < $13_1 >>> 0 | $3_1 >>> 0 > $4_1 >>> 0;
  $13_1 = ($3_1 | 0) == ($16_1 | 0) & $13_1 >>> 0 < $18_1 >>> 0 | $3_1 >>> 0 < $16_1 >>> 0;
  $3_1 = $44_1 + 8 | 0;
  $14_1 = HEAP32[$3_1 >> 2];
  $17_1 = $42_1 + 8 | 0;
  $4_1 = $14_1 + HEAP32[$17_1 >> 2] | 0;
  $3_1 = HEAP32[$17_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = $4_1;
  $4_1 = $4_1 + $13_1 | 0;
  $3_1 = $14_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $4_1;
  $6_1 = $6_1 >>> 20 | 0;
  $4_1 = $6_1;
  $6_1 = $6_1 + $13_1 | 0;
  $3_1 = $4_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $6_1 + $8_1 | 0;
  $6_1 = $4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $6_1 << 12 | $4_1 >>> 20;
  $13_1 = $4_1 << 12 | $7_1 >>> 20;
  $8_1 = HEAP32[$5_1 + 368 >> 2];
  $7_1 = $13_1 + $8_1 | 0;
  $4_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$5_1 + 372 >> 2] | 0;
  $3_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($10_1, $7_1, $3_1, 0, 0, 15632, 16, 0, 0);
  $50_1 = $5_1 + 336 | 0;
  $8_1 = $50_1;
  $13_1 = ($3_1 | 0) == ($4_1 | 0) & $7_1 >>> 0 < $13_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
  $3_1 = $12_1 + 8 | 0;
  $10_1 = HEAP32[$3_1 >> 2];
  $3_1 = HEAP32[$3_1 + 4 >> 2];
  $7_1 = $6_1 >>> 20 | 0;
  $4_1 = $7_1 + $10_1 | 0;
  $3_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $4_1;
  $4_1 = $4_1 + $13_1 | 0;
  $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($8_1, $4_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
  $3_1 = $5_1 + 1424 | 0;
  $34($3_1, $3_1, $5_1 + 1464 | 0);
  $3_1 = HEAP32[$5_1 + 1348 >> 2];
  $16_1 = $3_1;
  $18_1 = HEAP32[$5_1 + 1344 >> 2];
  $6_1 = $18_1;
  $3_1 = $3_1 << 1 | $6_1 >>> 31;
  $21_1 = $5_1 - -64 | 0;
  $4_1 = HEAP32[$5_1 + 1368 >> 2];
  $7_1 = HEAP32[$5_1 + 1372 >> 2];
  $17_1 = $6_1 << 1;
  $14_1 = $3_1;
  $69($21_1, $4_1, $7_1, 0, 0, $17_1, $3_1, 0, 0);
  $3_1 = HEAP32[$5_1 + 1356 >> 2];
  $44_1 = $3_1;
  $36_1 = HEAP32[$5_1 + 1352 >> 2];
  $8_1 = $36_1;
  $3_1 = $3_1 << 1 | $8_1 >>> 31;
  $42_1 = $5_1 + 272 | 0;
  $6_1 = HEAP32[$5_1 + 1360 >> 2];
  $13_1 = HEAP32[$5_1 + 1364 >> 2];
  $23_1 = $8_1 << 1;
  $10_1 = $3_1;
  $69($42_1, $6_1, $13_1, 0, 0, $23_1, $3_1, 0, 0);
  $24_1 = $5_1 + 224 | 0;
  $3_1 = HEAP32[$5_1 + 1376 >> 2];
  $8_1 = HEAP32[$5_1 + 1380 >> 2];
  $69($24_1, $3_1, $8_1, 0, 0, $3_1, $8_1, 0, 0);
  $26_1 = $5_1 + 208 | 0;
  $69($26_1, HEAP32[$5_1 + 224 >> 2], HEAP32[$5_1 + 228 >> 2], 0, 0, 15632, 16, 0, 0);
  $12_1 = $8_1 << 1;
  $8_1 = $3_1;
  $3_1 = $12_1 | $3_1 >>> 31;
  $30_1 = $5_1 + 176 | 0;
  $12_1 = $8_1 << 1;
  $22_1 = $3_1;
  $69($30_1, $12_1, $3_1, 0, 0, $18_1, $16_1, 0, 0);
  $34_1 = $5_1 + 80 | 0;
  $69($34_1, $4_1, $7_1, 0, 0, $23_1, $10_1, 0, 0);
  $31_1 = $5_1 + 256 | 0;
  $69($31_1, $6_1, $13_1, 0, 0, $6_1, $13_1, 0, 0);
  $32_1 = $5_1 + 192 | 0;
  $3_1 = $24_1 + 8 | 0;
  $69($32_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $51_1 = $5_1 + 320 | 0;
  $69($51_1, $18_1, $16_1, 0, 0, $18_1, $16_1, 0, 0);
  $43_1 = $5_1 + 160 | 0;
  $69($43_1, $12_1, $22_1, 0, 0, $36_1, $44_1, 0, 0);
  $46_1 = $5_1 + 96 | 0;
  $24_1 = $4_1;
  $25_1 = $7_1;
  $28_1 = $13_1;
  $23_1 = $6_1;
  $69($46_1, $4_1, $7_1, 0, 0, $6_1 << 1, $13_1 << 1 | $6_1 >>> 31, 0, 0);
  $10_1 = HEAP32[$5_1 + 64 >> 2];
  $7_1 = HEAP32[$5_1 + 272 >> 2];
  $4_1 = $10_1 + $7_1 | 0;
  $8_1 = HEAP32[$5_1 + 68 >> 2];
  $3_1 = $8_1 + HEAP32[$5_1 + 276 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $4_1;
  $4_1 = HEAP32[$5_1 + 208 >> 2];
  $13_1 = $6_1 + $4_1 | 0;
  $7_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$5_1 + 212 >> 2] | 0;
  $4_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $38_1 = $13_1;
  $13_1 = ($7_1 | 0) == ($4_1 | 0) & $13_1 >>> 0 < $6_1 >>> 0 | $4_1 >>> 0 < $7_1 >>> 0;
  $3_1 = $26_1 + 8 | 0;
  $16_1 = HEAP32[$3_1 >> 2];
  $18_1 = HEAP32[$3_1 + 4 >> 2];
  $6_1 = ($7_1 | 0) == ($8_1 | 0) & $6_1 >>> 0 < $10_1 >>> 0 | $7_1 >>> 0 < $8_1 >>> 0;
  $3_1 = $42_1 + 8 | 0;
  $8_1 = HEAP32[$3_1 >> 2];
  $10_1 = $21_1 + 8 | 0;
  $7_1 = $8_1 + HEAP32[$10_1 >> 2] | 0;
  $3_1 = HEAP32[$10_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $7_1;
  $7_1 = $6_1 + $7_1 | 0;
  $3_1 = ($8_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $18_1 | 0;
  $6_1 = $7_1;
  $7_1 = $7_1 + $16_1 | 0;
  $3_1 = $6_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $7_1;
  $7_1 = $7_1 + $13_1 | 0;
  $6_1 = $6_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $13_1 = $6_1 << 12 | $7_1 >>> 20;
  $42_1 = $4_1;
  $7_1 = $7_1 << 12 | $4_1 >>> 20;
  $53_1 = HEAP32[$5_1 + 80 >> 2];
  $8_1 = HEAP32[$5_1 + 256 >> 2];
  $4_1 = $53_1 + $8_1 | 0;
  $26_1 = HEAP32[$5_1 + 84 >> 2];
  $3_1 = $26_1 + HEAP32[$5_1 + 260 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $16_1 = $4_1;
  $10_1 = HEAP32[$5_1 + 176 >> 2];
  $4_1 = $4_1 + $10_1 | 0;
  $8_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$5_1 + 180 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $18_1 = $4_1;
  $21_1 = HEAP32[$5_1 + 192 >> 2];
  $4_1 = $4_1 + $21_1 | 0;
  $10_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$5_1 + 196 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $21_1 = $4_1;
  $4_1 = $3_1;
  $3_1 = $3_1 + $13_1 | 0;
  $13_1 = $7_1 + $21_1 | 0;
  $7_1 = $13_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $49_1 = ($4_1 | 0) == ($7_1 | 0) & $13_1 >>> 0 < $21_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
  $21_1 = ($4_1 | 0) == ($10_1 | 0) & $18_1 >>> 0 > $21_1 >>> 0 | $4_1 >>> 0 < $10_1 >>> 0;
  $3_1 = $32_1 + 8 | 0;
  $32_1 = HEAP32[$3_1 >> 2];
  $55_1 = HEAP32[$3_1 + 4 >> 2];
  $10_1 = ($8_1 | 0) == ($10_1 | 0) & $16_1 >>> 0 > $18_1 >>> 0 | $8_1 >>> 0 > $10_1 >>> 0;
  $3_1 = $30_1 + 8 | 0;
  $18_1 = HEAP32[$3_1 >> 2];
  $30_1 = HEAP32[$3_1 + 4 >> 2];
  $8_1 = ($8_1 | 0) == ($26_1 | 0) & $16_1 >>> 0 < $53_1 >>> 0 | $8_1 >>> 0 < $26_1 >>> 0;
  $3_1 = $31_1 + 8 | 0;
  $16_1 = HEAP32[$3_1 >> 2];
  $26_1 = $34_1 + 8 | 0;
  $4_1 = $16_1 + HEAP32[$26_1 >> 2] | 0;
  $3_1 = HEAP32[$26_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $16_1 = $4_1;
  $4_1 = $4_1 + $8_1 | 0;
  $3_1 = ($16_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $30_1 | 0;
  $8_1 = $4_1 + $18_1 | 0;
  $4_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $8_1;
  $8_1 = $8_1 + $10_1 | 0;
  $3_1 = ($3_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $55_1 | 0;
  $4_1 = $8_1 + $32_1 | 0;
  $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $4_1;
  $4_1 = $4_1 + $21_1 | 0;
  $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $6_1 >>> 20 | 0;
  $4_1 = $6_1 + $4_1 | 0;
  $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $4_1;
  $4_1 = $4_1 + $49_1 | 0;
  $6_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1;
  $10_1 = $6_1 << 12 | $3_1 >>> 20;
  $4_1 = $7_1;
  $16_1 = $3_1 << 12 | $4_1 >>> 20;
  $26_1 = HEAP32[$5_1 + 160 >> 2];
  $8_1 = HEAP32[$5_1 + 96 >> 2];
  $7_1 = $26_1 + $8_1 | 0;
  $21_1 = HEAP32[$5_1 + 164 >> 2];
  $3_1 = $21_1 + HEAP32[$5_1 + 100 >> 2] | 0;
  $8_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $8_1 + $10_1 | 0;
  $10_1 = $7_1;
  $16_1 = $7_1 + $16_1 | 0;
  $3_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $30_1 = $16_1 << 4 & -16;
  $18_1 = $4_1;
  $7_1 = $3_1;
  $69($5_1, $30_1 | $4_1 >>> 16 & 15, ($3_1 << 4 | $16_1 >>> 28) & 16777215, 0, 0, 977, 1, 0, 0);
  $31_1 = $5_1 + 304 | 0;
  $69($31_1, $36_1, $44_1, 0, 0, $17_1, $14_1, 0, 0);
  $30_1 = $5_1 + 144 | 0;
  $69($30_1, $12_1, $22_1, 0, 0, $23_1, $28_1, 0, 0);
  $34_1 = $5_1 + 112 | 0;
  $69($34_1, $24_1, $25_1, 0, 0, $24_1, $25_1, 0, 0);
  $32_1 = $5_1 + 48 | 0;
  $16_1 = ($3_1 | 0) == ($8_1 | 0) & $10_1 >>> 0 > $16_1 >>> 0 | $3_1 >>> 0 < $8_1 >>> 0;
  $10_1 = ($8_1 | 0) == ($21_1 | 0) & $10_1 >>> 0 < $26_1 >>> 0 | $8_1 >>> 0 < $21_1 >>> 0;
  $3_1 = $46_1 + 8 | 0;
  $21_1 = HEAP32[$3_1 >> 2];
  $4_1 = $43_1 + 8 | 0;
  $8_1 = $21_1 + HEAP32[$4_1 >> 2] | 0;
  $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $8_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $4_1 = $8_1 + $10_1 | 0;
  $3_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $6_1 >>> 20 | 0;
  $4_1 = $4_1 + $6_1 | 0;
  $3_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $4_1;
  $4_1 = $4_1 + $16_1 | 0;
  $6_1 = $6_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $8_1 = $6_1 << 12 | $4_1 >>> 20;
  $7_1 = $4_1 << 12 | $7_1 >>> 20;
  $3_1 = $8_1;
  $21_1 = HEAP32[$5_1 + 144 >> 2];
  $10_1 = HEAP32[$5_1 + 112 >> 2];
  $8_1 = $21_1 + $10_1 | 0;
  $16_1 = HEAP32[$5_1 + 148 >> 2];
  $4_1 = $16_1 + HEAP32[$5_1 + 116 >> 2] | 0;
  $4_1 = $8_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $3_1 = $4_1 + $3_1 | 0;
  $7_1 = $7_1 + $8_1 | 0;
  $3_1 = $7_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $7_1;
  $7_1 = $3_1;
  $69($32_1, $10_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $26_1 = $5_1 + 240 | 0;
  $69($26_1, $23_1, $28_1, 0, 0, $17_1, $14_1, 0, 0);
  $43_1 = $5_1 + 288 | 0;
  $69($43_1, $36_1, $44_1, 0, 0, $36_1, $44_1, 0, 0);
  $14_1 = $5_1 + 128 | 0;
  $69($14_1, $12_1, $22_1, 0, 0, $24_1, $25_1, 0, 0);
  $36_1 = $5_1 + 32 | 0;
  $12_1 = $36_1;
  $10_1 = ($3_1 | 0) == ($4_1 | 0) & $8_1 >>> 0 > $10_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
  $8_1 = ($4_1 | 0) == ($16_1 | 0) & $8_1 >>> 0 < $21_1 >>> 0 | $4_1 >>> 0 < $16_1 >>> 0;
  $3_1 = $34_1 + 8 | 0;
  $17_1 = HEAP32[$3_1 >> 2];
  $22_1 = $30_1 + 8 | 0;
  $4_1 = $17_1 + HEAP32[$22_1 >> 2] | 0;
  $3_1 = HEAP32[$22_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $16_1 = $4_1;
  $4_1 = $4_1 + $8_1 | 0;
  $3_1 = $16_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $6_1 >>> 20 | 0;
  $8_1 = $6_1;
  $6_1 = $4_1 + $6_1 | 0;
  $4_1 = $8_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $6_1 + $10_1 | 0;
  $4_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $8_1 = $4_1 << 12 | $3_1 >>> 20;
  $10_1 = $3_1 << 12 | $7_1 >>> 20;
  $17_1 = HEAP32[$5_1 + 128 >> 2];
  $7_1 = $10_1 + $17_1 | 0;
  $6_1 = $8_1;
  $3_1 = $6_1 + HEAP32[$5_1 + 132 >> 2] | 0;
  $3_1 = $7_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($12_1, $7_1, $3_1, 0, 0, 15632, 16, 0, 0);
  $46_1 = $5_1 + 16 | 0;
  $8_1 = $46_1;
  $6_1 = ($3_1 | 0) == ($6_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $3_1 >>> 0 < $6_1 >>> 0;
  $3_1 = $14_1 + 8 | 0;
  $7_1 = HEAP32[$3_1 >> 2];
  $3_1 = HEAP32[$3_1 + 4 >> 2];
  $4_1 = $4_1 >>> 20 | 0;
  $7_1 = $4_1 + $7_1 | 0;
  $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $6_1 + $7_1 | 0;
  $4_1 = $3_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $69($8_1, $3_1, $4_1, 0, 0, 64028672, 65536, 0, 0);
  $34($0_1 + 80 | 0, $69_1, $79);
  $69_1 = HEAP32[$1_1 + 120 >> 2];
  $7_1 = $0_1;
  $0_1 = HEAP32[$5_1 + 1424 >> 2];
  $16_1 = $0_1;
  $3_1 = HEAP32[$5_1 + 1428 >> 2];
  $21_1 = $3_1;
  $6_1 = $0_1;
  $8_1 = $3_1;
  $14_1 = HEAP32[$5_1 >> 2];
  $0_1 = HEAP32[$5_1 + 320 >> 2];
  $4_1 = $14_1 + $0_1 | 0;
  $12_1 = HEAP32[$5_1 + 4 >> 2];
  $3_1 = $12_1 + HEAP32[$5_1 + 324 >> 2] | 0;
  $0_1 = $0_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $8_1 + ($0_1 & 1048575) | 0;
  $6_1 = $4_1 + $6_1 | 0;
  $3_1 = $6_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$7_1 >> 2] = $6_1;
  $8_1 = $3_1;
  HEAP32[$7_1 + 4 >> 2] = $3_1;
  $30_1 = $7_1 + 8 | 0;
  $24_1 = $30_1;
  $3_1 = HEAP32[$5_1 + 1432 >> 2];
  $22_1 = $3_1;
  $10_1 = HEAP32[$5_1 + 1436 >> 2];
  $23_1 = $10_1;
  $10_1 = ($0_1 | 0) == ($12_1 | 0) & $4_1 >>> 0 < $14_1 >>> 0 | $0_1 >>> 0 < $12_1 >>> 0;
  $3_1 = $51_1 + 8 | 0;
  $12_1 = HEAP32[$3_1 >> 2];
  $14_1 = $5_1 + 8 | 0;
  $4_1 = $12_1 + HEAP32[$14_1 >> 2] | 0;
  $3_1 = HEAP32[$14_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $4_1;
  $4_1 = $4_1 + $10_1 | 0;
  $10_1 = $12_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $10_1 << 12 | $4_1 >>> 20;
  $0_1 = $4_1 << 12 | $0_1 >>> 20;
  $4_1 = $12_1;
  $51_1 = HEAP32[$5_1 + 48 >> 2];
  $12_1 = HEAP32[$5_1 + 304 >> 2];
  $14_1 = $51_1 + $12_1 | 0;
  $28_1 = HEAP32[$5_1 + 52 >> 2];
  $3_1 = $28_1 + HEAP32[$5_1 + 308 >> 2] | 0;
  $12_1 = $12_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $12_1 + $4_1 | 0;
  $3_1 = $0_1 + $14_1 | 0;
  $0_1 = $3_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $17_1 = $3_1;
  $4_1 = $22_1 + $3_1 | 0;
  $3_1 = $23_1 + ($0_1 & 1048575) | 0;
  HEAP32[$24_1 >> 2] = $4_1;
  $3_1 = $4_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$24_1 + 4 >> 2] = $3_1;
  $24_1 = $3_1 << 1;
  $3_1 = $4_1;
  $4_1 = $24_1 | $3_1 >>> 31;
  $24_1 = $3_1 << 1;
  $3_1 = $4_1 + $23_1 | 0;
  $4_1 = $22_1 + $24_1 | 0;
  $3_1 = $4_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$65_1 >> 2] = $4_1;
  HEAP32[$65_1 + 4 >> 2] = $3_1;
  $34_1 = $7_1 + 16 | 0;
  $3_1 = HEAP32[$5_1 + 1440 >> 2];
  $24_1 = $3_1;
  $4_1 = HEAP32[$5_1 + 1444 >> 2];
  $25_1 = $4_1;
  $17_1 = ($0_1 | 0) == ($12_1 | 0) & $14_1 >>> 0 > $17_1 >>> 0 | $0_1 >>> 0 < $12_1 >>> 0;
  $12_1 = ($12_1 | 0) == ($28_1 | 0) & $14_1 >>> 0 < $51_1 >>> 0 | $12_1 >>> 0 < $28_1 >>> 0;
  $3_1 = $31_1 + 8 | 0;
  $14_1 = HEAP32[$3_1 >> 2];
  $22_1 = $32_1 + 8 | 0;
  $4_1 = $14_1 + HEAP32[$22_1 >> 2] | 0;
  $3_1 = HEAP32[$22_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $3_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $14_1 = $4_1;
  $4_1 = $4_1 + $12_1 | 0;
  $3_1 = $14_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $4_1;
  $10_1 = $10_1 >>> 20 | 0;
  $4_1 = $10_1;
  $10_1 = $10_1 + $12_1 | 0;
  $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $10_1 + $17_1 | 0;
  $10_1 = $4_1 >>> 0 < $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $10_1 << 12 | $4_1 >>> 20;
  $14_1 = $4_1 << 12 | $0_1 >>> 20;
  $31_1 = $3_1;
  $32_1 = HEAP32[$5_1 + 240 >> 2];
  $4_1 = HEAP32[$5_1 + 288 >> 2];
  $0_1 = $32_1 + $4_1 | 0;
  $28_1 = HEAP32[$5_1 + 244 >> 2];
  $3_1 = $28_1 + HEAP32[$5_1 + 292 >> 2] | 0;
  $3_1 = $0_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $17_1 = $0_1;
  $4_1 = HEAP32[$5_1 + 32 >> 2];
  $0_1 = $0_1 + $4_1 | 0;
  $12_1 = $3_1;
  $3_1 = $3_1 + HEAP32[$5_1 + 36 >> 2] | 0;
  $4_1 = $0_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1 + $31_1 | 0;
  $22_1 = $0_1;
  $14_1 = $0_1 + $14_1 | 0;
  $0_1 = $0_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $25_1 + ($0_1 & 1048575) | 0;
  $23_1 = $14_1;
  $14_1 = $24_1 + $14_1 | 0;
  HEAP32[$34_1 >> 2] = $14_1;
  $3_1 = $14_1 >>> 0 < $23_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$34_1 + 4 >> 2] = $3_1;
  $3_1 = ($3_1 << 1 | $14_1 >>> 31) + $25_1 | 0;
  $14_1 = $14_1 << 1;
  $25_1 = $14_1;
  $14_1 = $14_1 + $24_1 | 0;
  $3_1 = $25_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$66_1 >> 2] = $14_1;
  HEAP32[$66_1 + 4 >> 2] = $3_1;
  $31_1 = $7_1 + 24 | 0;
  $3_1 = HEAP32[$5_1 + 1448 >> 2];
  $14_1 = HEAP32[$5_1 + 1452 >> 2];
  $24_1 = $3_1;
  $25_1 = $14_1;
  $14_1 = ($0_1 | 0) == ($4_1 | 0) & $22_1 >>> 0 > $23_1 >>> 0 | $0_1 >>> 0 < $4_1 >>> 0;
  $22_1 = ($4_1 | 0) == ($12_1 | 0) & $17_1 >>> 0 > $22_1 >>> 0 | $4_1 >>> 0 < $12_1 >>> 0;
  $3_1 = $36_1 + 8 | 0;
  $23_1 = HEAP32[$3_1 >> 2];
  $36_1 = HEAP32[$3_1 + 4 >> 2];
  $17_1 = ($12_1 | 0) == ($28_1 | 0) & $17_1 >>> 0 < $32_1 >>> 0 | $12_1 >>> 0 < $28_1 >>> 0;
  $3_1 = $43_1 + 8 | 0;
  $4_1 = HEAP32[$3_1 >> 2];
  $28_1 = $26_1 + 8 | 0;
  $12_1 = $4_1 + HEAP32[$28_1 >> 2] | 0;
  $3_1 = HEAP32[$28_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $4_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $12_1;
  $12_1 = $12_1 + $17_1 | 0;
  $3_1 = ($3_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $36_1 | 0;
  $4_1 = $12_1 + $23_1 | 0;
  $3_1 = $4_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $4_1;
  $4_1 = $4_1 + $22_1 | 0;
  $3_1 = $12_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $10_1 >>> 20 | 0;
  $4_1 = $10_1 + $4_1 | 0;
  $3_1 = $10_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $4_1;
  $4_1 = $4_1 + $14_1 | 0;
  $10_1 = $10_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1;
  $4_1 = $10_1 << 12 | $3_1 >>> 20;
  $17_1 = $3_1 << 12 | $0_1 >>> 20;
  $36_1 = HEAP32[$5_1 + 16 >> 2];
  $12_1 = $38_1 & -2;
  $0_1 = $36_1 + $12_1 | 0;
  $28_1 = HEAP32[$5_1 + 20 >> 2];
  $3_1 = $28_1 + ($42_1 & 1048575) | 0;
  $12_1 = $0_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $12_1 + $4_1 | 0;
  $14_1 = $0_1;
  $17_1 = $0_1 + $17_1 | 0;
  $0_1 = $0_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $25_1 + ($0_1 & 1048575) | 0;
  $4_1 = $17_1 + $24_1 | 0;
  $3_1 = $4_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$31_1 >> 2] = $4_1;
  HEAP32[$31_1 + 4 >> 2] = $3_1;
  $22_1 = $4_1 << 1;
  $4_1 = ($3_1 << 1 | $4_1 >>> 31) + $25_1 | 0;
  $3_1 = $22_1 + $24_1 | 0;
  $4_1 = $3_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  HEAP32[$67_1 >> 2] = $3_1;
  HEAP32[$67_1 + 4 >> 2] = $4_1;
  $32_1 = $7_1 + 32 | 0;
  $25_1 = $32_1;
  $3_1 = HEAP32[$5_1 + 1456 >> 2];
  $4_1 = HEAP32[$5_1 + 1460 >> 2];
  $22_1 = $3_1;
  $23_1 = $4_1;
  $24_1 = $13_1;
  $18_1 = $18_1 & 65535;
  $17_1 = ($0_1 | 0) == ($12_1 | 0) & $14_1 >>> 0 > $17_1 >>> 0 | $0_1 >>> 0 < $12_1 >>> 0;
  $13_1 = ($12_1 | 0) == ($28_1 | 0) & $14_1 >>> 0 < $36_1 >>> 0 | $12_1 >>> 0 < $28_1 >>> 0;
  $3_1 = $46_1 + 8 | 0;
  $4_1 = $13_1 + HEAP32[$3_1 >> 2] | 0;
  $3_1 = HEAP32[$3_1 + 4 >> 2];
  $3_1 = $4_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $10_1 = $10_1 >>> 20 | 0;
  $13_1 = $4_1 + $10_1 | 0;
  $4_1 = $10_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $13_1;
  $13_1 = $13_1 + $17_1 | 0;
  $3_1 = ($3_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) << 12 | $13_1 >>> 20;
  $4_1 = $13_1 << 12 | $0_1 >>> 20;
  $0_1 = $4_1 + $24_1 | 0;
  $3_1 = $3_1 + $18_1 | 0;
  $3_1 = ($0_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $23_1 | 0;
  $4_1 = $0_1;
  $0_1 = $0_1 + $22_1 | 0;
  $3_1 = $4_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$25_1 >> 2] = $0_1;
  HEAP32[$25_1 + 4 >> 2] = $3_1;
  $3_1 = ($3_1 << 1 | $0_1 >>> 31) + $23_1 | 0;
  $0_1 = $0_1 << 1;
  $4_1 = $0_1;
  $0_1 = $0_1 + $22_1 | 0;
  $3_1 = $4_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$61_1 >> 2] = $0_1;
  HEAP32[$61_1 + 4 >> 2] = $3_1;
  $13_1 = $5_1;
  $3_1 = ($8_1 << 1 | $6_1 >>> 31) + $21_1 | 0;
  $0_1 = $6_1 << 1;
  $4_1 = $0_1;
  $0_1 = $0_1 + $16_1 | 0;
  $3_1 = $4_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$5_1 + 1544 >> 2] = $0_1;
  HEAP32[$5_1 + 1548 >> 2] = $3_1;
  $0_1 = $41_1 + 8 | 0;
  $12_1 = HEAP32[$0_1 >> 2];
  $62_1 = HEAP32[$0_1 + 4 >> 2];
  $0_1 = $39_1 + 8 | 0;
  $71 = HEAP32[$0_1 >> 2];
  $72 = HEAP32[$0_1 + 4 >> 2];
  $0_1 = HEAP32[$5_1 + 736 >> 2];
  $3_1 = HEAP32[$5_1 + 740 >> 2];
  $14_1 = HEAP32[$5_1 + 416 >> 2];
  $6_1 = HEAP32[$5_1 + 420 >> 2];
  $4_1 = $37_1 + 8 | 0;
  $73 = HEAP32[$4_1 >> 2];
  $74 = HEAP32[$4_1 + 4 >> 2];
  $4_1 = $57_1 + 8 | 0;
  $17_1 = HEAP32[$4_1 >> 2];
  $60_1 = HEAP32[$4_1 + 4 >> 2];
  $26_1 = HEAP32[$5_1 + 672 >> 2];
  $68_1 = HEAP32[$5_1 + 676 >> 2];
  $41_1 = HEAP32[$5_1 + 384 >> 2];
  $5_1 = HEAP32[$5_1 + 388 >> 2];
  $4_1 = $35_1 + 8 | 0;
  $64_1 = HEAP32[$4_1 >> 2];
  $70_1 = HEAP32[$4_1 + 4 >> 2];
  $4_1 = $40_1 + 8 | 0;
  $51_1 = HEAP32[$4_1 >> 2];
  $75 = HEAP32[$4_1 + 4 >> 2];
  $43_1 = HEAP32[$13_1 + 688 >> 2];
  $76 = HEAP32[$13_1 + 692 >> 2];
  $46_1 = HEAP32[$13_1 + 624 >> 2];
  $57_1 = HEAP32[$13_1 + 628 >> 2];
  $4_1 = $48_1 + 8 | 0;
  $22_1 = HEAP32[$4_1 >> 2];
  $23_1 = HEAP32[$4_1 + 4 >> 2];
  $53_1 = HEAP32[$13_1 + 352 >> 2];
  $77 = HEAP32[$13_1 + 356 >> 2];
  $49_1 = HEAP32[$13_1 + 336 >> 2];
  $48_1 = HEAP32[$13_1 + 340 >> 2];
  $4_1 = $50_1 + 8 | 0;
  $78 = HEAP32[$4_1 >> 2];
  $16_1 = HEAP32[$4_1 + 4 >> 2];
  $40_1 = $7_1 + 104 | 0;
  $18_1 = HEAP32[$40_1 >> 2];
  $21_1 = HEAP32[$40_1 + 4 >> 2];
  $35_1 = $7_1 + 96 | 0;
  $24_1 = HEAP32[$35_1 >> 2];
  $25_1 = HEAP32[$35_1 + 4 >> 2];
  $39_1 = $7_1 + 88 | 0;
  $28_1 = HEAP32[$39_1 >> 2];
  $38_1 = HEAP32[$39_1 + 4 >> 2];
  $37_1 = $7_1 + 112 | 0;
  $42_1 = HEAP32[$37_1 >> 2];
  $8_1 = HEAP32[$37_1 + 4 >> 2];
  $44_1 = HEAP32[$7_1 + 80 >> 2];
  $36_1 = HEAP32[$7_1 + 84 >> 2];
  $34($63_1, $63_1, $13_1 + 1344 | 0);
  $10_1 = HEAP32[$13_1 + 1544 >> 2];
  $50_1 = HEAP32[$13_1 + 1548 >> 2];
  $3_1 = $3_1 + $6_1 | 0;
  $4_1 = $0_1 + $14_1 | 0;
  $0_1 = $4_1 >>> 0 < $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $55_1 = $10_1;
  $3_1 = $4_1;
  $10_1 = $29_1 ? $19_1 : $3_1;
  $19_1 = $55_1 + $10_1 | 0;
  $4_1 = $50_1 + ($29_1 ? $11_1 : $0_1 & 1048575) | 0;
  $63_1 = 8388599 - (($19_1 >>> 0 > 4294959480) + ($10_1 >>> 0 > $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0) | 0;
  $50_1 = -7816 - $19_1 | 0;
  $4_1 = $50_1 & 1;
  $55_1 = 0 - $4_1 | 0;
  $10_1 = 0 - $4_1 | 0;
  $6_1 = ($0_1 | 0) == ($6_1 | 0) & $3_1 >>> 0 < $14_1 >>> 0 | $0_1 >>> 0 < $6_1 >>> 0;
  $3_1 = $62_1 + $72 | 0;
  $11_1 = $12_1 + $71 | 0;
  $4_1 = $11_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $6_1 + $11_1 | 0;
  $4_1 = $3_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $6_1 = $4_1 << 12 | $3_1 >>> 20;
  $0_1 = $3_1 << 12 | $0_1 >>> 20;
  $19_1 = $6_1;
  $3_1 = $5_1 + $68_1 | 0;
  $6_1 = $26_1 + $41_1 | 0;
  $11_1 = $6_1 >>> 0 < $26_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $11_1 + $19_1 | 0;
  $19_1 = $0_1 + $6_1 | 0;
  $0_1 = $19_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $26_1 = $19_1;
  $19_1 = ($11_1 | 0) == ($0_1 | 0) & $19_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 < $11_1 >>> 0;
  $6_1 = ($5_1 | 0) == ($11_1 | 0) & $6_1 >>> 0 < $41_1 >>> 0 | $5_1 >>> 0 > $11_1 >>> 0;
  $3_1 = $60_1 + $74 | 0;
  $11_1 = $17_1 + $73 | 0;
  $3_1 = $11_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $11_1;
  $11_1 = $6_1 + $11_1 | 0;
  $3_1 = $12_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $11_1 = $4_1 + $11_1 | 0;
  $4_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $11_1 + $19_1 | 0;
  $6_1 = $3_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $11_1 = $6_1 << 12 | $3_1 >>> 20;
  $41_1 = $0_1;
  $0_1 = $3_1 << 12 | $0_1 >>> 20;
  $3_1 = $57_1 + $76 | 0;
  $12_1 = $43_1 + $46_1 | 0;
  $4_1 = $12_1 >>> 0 < $43_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $77 + $4_1 | 0;
  $5_1 = $12_1 + $53_1 | 0;
  $19_1 = $5_1 >>> 0 < $53_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $19_1 + $11_1 | 0;
  $14_1 = $0_1 + $5_1 | 0;
  $11_1 = $14_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $0_1 = $45_1 & -2;
  $17_1 = $0_1 + $49_1 | 0;
  $3_1 = $48_1 + ($54_1 & 1048575) | 0;
  $0_1 = $0_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $45_1 = ($11_1 | 0) == ($19_1 | 0) & $5_1 >>> 0 > $14_1 >>> 0 | $11_1 >>> 0 < $19_1 >>> 0;
  $5_1 = ($4_1 | 0) == ($19_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $4_1 >>> 0 > $19_1 >>> 0;
  $12_1 = ($4_1 | 0) == ($57_1 | 0) & $12_1 >>> 0 < $46_1 >>> 0 | $4_1 >>> 0 < $57_1 >>> 0;
  $4_1 = $70_1 + $75 | 0;
  $19_1 = $51_1 + $64_1 | 0;
  $3_1 = $19_1 >>> 0 < $51_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $4_1 = $12_1 + $19_1 | 0;
  $3_1 = ($4_1 >>> 0 < $19_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $23_1 | 0;
  $12_1 = $4_1;
  $4_1 = $4_1 + $22_1 | 0;
  $3_1 = $12_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $12_1 = $4_1;
  $4_1 = $4_1 + $5_1 | 0;
  $3_1 = $12_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $6_1 >>> 20 | 0;
  $12_1 = $6_1;
  $6_1 = $4_1 + $6_1 | 0;
  $4_1 = $12_1 >>> 0 > $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $6_1 + $45_1 | 0;
  $4_1 = $3_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $6_1 = $3_1;
  $3_1 = $0_1 + ($4_1 << 12 | $3_1 >>> 20) | 0;
  $12_1 = $11_1;
  $6_1 = $6_1 << 12 | $11_1 >>> 20;
  $11_1 = $6_1 + $17_1 | 0;
  $19_1 = $11_1;
  $11_1 = $6_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $22_1 = $7_1 + 72 | 0;
  $6_1 = $10_1;
  $3_1 = $6_1 >>> 16 | 0;
  $5_1 = ($6_1 & 65535) << 16 | $55_1 >>> 16;
  $10_1 = $3_1;
  $23_1 = HEAP32[$61_1 >> 2];
  $61_1 = HEAP32[$61_1 + 4 >> 2];
  $45_1 = $33_1 & 65535;
  $54_1 = ($0_1 | 0) == ($11_1 | 0) & $17_1 >>> 0 > $19_1 >>> 0 | $0_1 >>> 0 > $11_1 >>> 0;
  $17_1 = ($0_1 | 0) == ($48_1 | 0) & $17_1 >>> 0 < $49_1 >>> 0 | $0_1 >>> 0 < $48_1 >>> 0;
  $0_1 = $78 + $17_1 | 0;
  $3_1 = $16_1;
  $3_1 = $0_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $4_1 >>> 20 | 0;
  $0_1 = $0_1 + $4_1 | 0;
  $4_1 = $4_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $0_1;
  $0_1 = $0_1 + $54_1 | 0;
  $4_1 = ($3_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) << 12 | $0_1 >>> 20;
  $17_1 = $11_1;
  $11_1 = $0_1 << 12 | $11_1 >>> 20;
  $0_1 = $11_1 + $9_1 | 0;
  $3_1 = $4_1 + $45_1 | 0;
  $3_1 = $0_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $29_1 ? $47_1 : $0_1;
  $0_1 = $4_1 + $23_1 | 0;
  $3_1 = $61_1 + ($29_1 ? $56_1 : $3_1) | 0;
  $3_1 = ($10_1 - (($0_1 >>> 0 > $5_1 >>> 0) + ($0_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) | 0) | 0) + 524287 | 0;
  $0_1 = ($5_1 - $0_1 | 0) - 8 | 0;
  $4_1 = $0_1 >>> 0 < 4294967288 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $4_1 >>> 1 | 0;
  $5_1 = ($4_1 & 1) << 31 | $0_1 >>> 1;
  HEAP32[$22_1 >> 2] = $5_1;
  $9_1 = $3_1;
  HEAP32[$22_1 + 4 >> 2] = $3_1;
  $23_1 = $7_1 - -64 | 0;
  $10_1 = $23_1;
  $47_1 = $0_1 << 19 & 524288;
  $11_1 = ($6_1 & 4095) << 20 | $55_1 >>> 12;
  $0_1 = $6_1 >>> 12 | 0;
  $6_1 = $29_1 ? $52_1 : $19_1;
  $4_1 = $6_1 + HEAP32[$67_1 >> 2] | 0;
  $3_1 = HEAP32[$67_1 + 4 >> 2] + ($29_1 ? $15_1 : $17_1 & 1048575) | 0;
  $3_1 = ($0_1 - (($4_1 >>> 0 > $11_1 >>> 0) + ($4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) | 0) | 0) + 8388607 | 0;
  $6_1 = ($11_1 - $4_1 | 0) - 8 | 0;
  $15_1 = $6_1 >>> 0 < 4294967288 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = ($15_1 >>> 1 | 0) + $47_1 | 0;
  $19_1 = ($15_1 & 1) << 31 | $6_1 >>> 1;
  $3_1 = $19_1;
  $4_1 = $3_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  HEAP32[$10_1 >> 2] = $3_1;
  $47_1 = $4_1;
  HEAP32[$10_1 + 4 >> 2] = $4_1;
  $17_1 = $7_1 + 56 | 0;
  $10_1 = $17_1;
  $16_1 = $6_1 << 19 & 524288;
  $6_1 = $29_1 ? $58_1 : $14_1;
  $4_1 = $6_1 + HEAP32[$66_1 >> 2] | 0;
  $3_1 = HEAP32[$66_1 + 4 >> 2] + ($29_1 ? $20_1 : $12_1 & 1048575) | 0;
  $3_1 = ($0_1 - (($4_1 >>> 0 > $11_1 >>> 0) + ($4_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) | 0) | 0) + 8388607 | 0;
  $4_1 = ($11_1 - $4_1 | 0) - 8 | 0;
  $6_1 = $4_1 >>> 0 < 4294967288 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = ($6_1 >>> 1 | 0) + $16_1 | 0;
  $15_1 = ($6_1 & 1) << 31 | $4_1 >>> 1;
  $3_1 = $15_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$10_1 >> 2] = $15_1;
  $20_1 = $3_1;
  HEAP32[$10_1 + 4 >> 2] = $3_1;
  $14_1 = $7_1 + 48 | 0;
  $12_1 = $4_1 << 19 & 524288;
  $6_1 = $11_1;
  $10_1 = $0_1;
  $3_1 = $29_1 ? $59_1 : $26_1;
  $0_1 = $3_1 + HEAP32[$65_1 >> 2] | 0;
  $4_1 = HEAP32[$65_1 + 4 >> 2] + ($29_1 ? $27_1 : $41_1 & 1048575) | 0;
  $3_1 = ($10_1 - (($0_1 >>> 0 > $6_1 >>> 0) + ($0_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0) | 0) + 8388607 | 0;
  $0_1 = ($6_1 - $0_1 | 0) - 8 | 0;
  $11_1 = $0_1 >>> 0 < 4294967288 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = ($11_1 >>> 1 | 0) + $12_1 | 0;
  $27_1 = ($11_1 & 1) << 31 | $0_1 >>> 1;
  $4_1 = $27_1;
  $3_1 = $4_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$14_1 >> 2] = $4_1;
  $12_1 = $3_1;
  HEAP32[$14_1 + 4 >> 2] = $3_1;
  $11_1 = $0_1 << 19 & 524288;
  $3_1 = ($10_1 & 1048574) + $63_1 | 0;
  $0_1 = ($6_1 & -977) + $50_1 | 0;
  $3_1 = $0_1 >>> 0 < $50_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $0_1 = ($3_1 & 1) << 31 | $0_1 >>> 1;
  $3_1 = ($3_1 >>> 1 | 0) + $11_1 | 0;
  $11_1 = $0_1;
  $3_1 = $0_1 >>> 0 < $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$7_1 + 40 >> 2] = $0_1;
  HEAP32[$7_1 + 44 >> 2] = $3_1;
  $1_1 = HEAP32[$1_1 + 120 >> 2];
  $6_1 = $1_1 >> 31;
  $0_1 = $1_1 - 1 | 0;
  $16_1 = $0_1;
  $4_1 = 0 - ((($1_1 | 0) != 0) + $6_1 | 0) | 0;
  $10_1 = $6_1 - !$1_1 | 0;
  $6_1 = $4_1 & HEAP32[$2_1 + 4 >> 2] | $10_1 & HEAP32[$7_1 + 4 >> 2];
  $1_1 = 0 - $1_1 | 0;
  HEAP32[$7_1 >> 2] = $1_1 & HEAP32[$2_1 >> 2] | $0_1 & HEAP32[$7_1 >> 2];
  HEAP32[$7_1 + 4 >> 2] = $6_1;
  $6_1 = HEAP32[$2_1 + 12 >> 2] & $4_1 | HEAP32[$30_1 + 4 >> 2] & $10_1;
  HEAP32[$30_1 >> 2] = HEAP32[$2_1 + 8 >> 2] & $1_1 | HEAP32[$30_1 >> 2] & $0_1;
  HEAP32[$30_1 + 4 >> 2] = $6_1;
  $6_1 = HEAP32[$2_1 + 20 >> 2] & $4_1 | HEAP32[$34_1 + 4 >> 2] & $10_1;
  HEAP32[$34_1 >> 2] = HEAP32[$2_1 + 16 >> 2] & $1_1 | HEAP32[$34_1 >> 2] & $0_1;
  HEAP32[$34_1 + 4 >> 2] = $6_1;
  $6_1 = HEAP32[$2_1 + 28 >> 2] & $4_1 | HEAP32[$31_1 + 4 >> 2] & $10_1;
  HEAP32[$31_1 >> 2] = HEAP32[$2_1 + 24 >> 2] & $1_1 | HEAP32[$31_1 >> 2] & $0_1;
  HEAP32[$31_1 + 4 >> 2] = $6_1;
  $6_1 = HEAP32[$2_1 + 36 >> 2] & $4_1 | HEAP32[$32_1 + 4 >> 2] & $10_1;
  HEAP32[$32_1 >> 2] = HEAP32[$2_1 + 32 >> 2] & $1_1 | HEAP32[$32_1 >> 2] & $0_1;
  HEAP32[$32_1 + 4 >> 2] = $6_1;
  $3_1 = HEAP32[$2_1 + 44 >> 2] & $4_1 | $3_1 & $10_1;
  HEAP32[$7_1 + 40 >> 2] = HEAP32[$2_1 + 40 >> 2] & $1_1 | $0_1 & $11_1;
  HEAP32[$7_1 + 44 >> 2] = $3_1;
  $3_1 = $2_1 + 48 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $3_1 = HEAP32[$3_1 + 4 >> 2] & $4_1 | $10_1 & $12_1;
  HEAP32[$14_1 >> 2] = $1_1 & $11_1 | $0_1 & $27_1;
  HEAP32[$14_1 + 4 >> 2] = $3_1;
  $3_1 = $2_1 + 56 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $3_1 = HEAP32[$3_1 + 4 >> 2] & $4_1 | $10_1 & $20_1;
  HEAP32[$17_1 >> 2] = $1_1 & $11_1 | $0_1 & $15_1;
  HEAP32[$17_1 + 4 >> 2] = $3_1;
  $3_1 = $2_1 - -64 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $3_1 = HEAP32[$3_1 + 4 >> 2] & $4_1 | $10_1 & $47_1;
  HEAP32[$23_1 >> 2] = $1_1 & $11_1 | $0_1 & $19_1;
  HEAP32[$23_1 + 4 >> 2] = $3_1;
  $2_1 = $2_1 + 72 | 0;
  $3_1 = HEAP32[$2_1 >> 2];
  $2_1 = HEAP32[$2_1 + 4 >> 2] & $4_1 | $9_1 & $10_1;
  HEAP32[$22_1 >> 2] = $1_1 & $3_1 | $0_1 & $5_1;
  HEAP32[$22_1 + 4 >> 2] = $2_1;
  $2_1 = $10_1 & HEAP32[$7_1 + 84 >> 2];
  HEAP32[$7_1 + 80 >> 2] = HEAP32[$7_1 + 80 >> 2] & $0_1 | $1_1 & 1;
  HEAP32[$7_1 + 84 >> 2] = $2_1;
  $1_1 = HEAP32[$39_1 + 4 >> 2] & $10_1;
  HEAP32[$39_1 >> 2] = HEAP32[$39_1 >> 2] & $0_1;
  HEAP32[$39_1 + 4 >> 2] = $1_1;
  $1_1 = HEAP32[$35_1 + 4 >> 2] & $10_1;
  HEAP32[$35_1 >> 2] = HEAP32[$35_1 >> 2] & $0_1;
  HEAP32[$35_1 + 4 >> 2] = $1_1;
  $1_1 = HEAP32[$40_1 + 4 >> 2] & $10_1;
  HEAP32[$40_1 >> 2] = HEAP32[$40_1 >> 2] & $0_1;
  HEAP32[$40_1 + 4 >> 2] = $1_1;
  $19_1 = HEAP32[$37_1 >> 2];
  $5_1 = HEAP32[$37_1 + 4 >> 2];
  $20_1 = $7_1;
  $12_1 = $8_1 & 65535;
  $1_1 = __wasm_i64_mul($8_1 >>> 16 | 0, 0, 977, 1);
  $0_1 = $1_1 + $44_1 | 0;
  $3_1 = $36_1 + i64toi32_i32$HIGH_BITS | 0;
  $1_1 = $0_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $2_1 = $1_1 >>> 20 | 0;
  $3_1 = $38_1;
  $4_1 = $2_1;
  $2_1 = $2_1 + $28_1 | 0;
  $11_1 = $4_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $25_1;
  $4_1 = $11_1 >>> 20 | 0;
  $7_1 = $4_1 + $24_1 | 0;
  $6_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $21_1;
  $4_1 = $6_1 >>> 20 | 0;
  $15_1 = $4_1 + $18_1 | 0;
  $9_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $4_1 = $12_1;
  $27_1 = $9_1 >>> 20 | 0;
  $3_1 = $27_1 + $42_1 | 0;
  $4_1 = $27_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  if ($3_1 | ($15_1 | ($0_1 | $2_1 | $7_1)) | ($4_1 | ($1_1 | $11_1 | $6_1 | $9_1) & 1048575)) {
   if (($2_1 & ($0_1 ^ 976) & $7_1 & $15_1 & $3_1) == -1) {
    $0_1 = ($11_1 & ($1_1 ^ 1) & $6_1 & $9_1 & ($4_1 ^ 983040)) == 1048575
   } else {
    $0_1 = 0
   }
  } else {
   $0_1 = 1
  }
  HEAP32[$20_1 + 120 >> 2] = $0_1 & ($69_1 ^ -1);
  HEAP32[$37_1 >> 2] = $16_1 & $19_1;
  HEAP32[$37_1 + 4 >> 2] = $5_1 & $10_1;
  global$0 = $13_1 + 1744 | 0;
 }
 
 function $54($0_1, $1_1) {
  var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0;
  $4_1 = global$0 - 336 | 0;
  global$0 = $4_1;
  $2_1 = HEAP32[$1_1 + 4 >> 2];
  $19_1 = $2_1;
  $15_1 = HEAP32[$1_1 >> 2];
  $3_1 = $15_1;
  $2_1 = $2_1 << 1 | $3_1 >>> 31;
  $10_1 = $4_1 - -64 | 0;
  $14_1 = HEAP32[$1_1 + 24 >> 2];
  $13_1 = HEAP32[$1_1 + 28 >> 2];
  $25_1 = $3_1 << 1;
  $29_1 = $2_1;
  $69($10_1, $14_1, $13_1, 0, 0, $25_1, $2_1, 0, 0);
  $2_1 = HEAP32[$1_1 + 12 >> 2];
  $35_1 = $2_1;
  $30_1 = HEAP32[$1_1 + 8 >> 2];
  $3_1 = $30_1;
  $2_1 = $2_1 << 1 | $3_1 >>> 31;
  $8_1 = $4_1 + 272 | 0;
  $18_1 = HEAP32[$1_1 + 16 >> 2];
  $12_1 = HEAP32[$1_1 + 20 >> 2];
  $3_1 = $3_1 << 1;
  $5_1 = $2_1;
  $69($8_1, $18_1, $12_1, 0, 0, $3_1, $2_1, 0, 0);
  $7_1 = $4_1 + 224 | 0;
  $6_1 = HEAP32[$1_1 + 32 >> 2];
  $1_1 = HEAP32[$1_1 + 36 >> 2];
  $69($7_1, $6_1, $1_1, 0, 0, $6_1, $1_1, 0, 0);
  $9_1 = $4_1 + 208 | 0;
  $69($9_1, HEAP32[$4_1 + 224 >> 2], HEAP32[$4_1 + 228 >> 2], 0, 0, 15632, 16, 0, 0);
  $2_1 = $1_1 << 1 | $6_1 >>> 31;
  $31_1 = $4_1 + 176 | 0;
  $21_1 = $6_1 << 1;
  $32_1 = $2_1;
  $69($31_1, $21_1, $2_1, 0, 0, $15_1, $19_1, 0, 0);
  $33_1 = $4_1 + 80 | 0;
  $69($33_1, $14_1, $13_1, 0, 0, $3_1, $5_1, 0, 0);
  $34_1 = $4_1 + 256 | 0;
  $69($34_1, $18_1, $12_1, 0, 0, $18_1, $12_1, 0, 0);
  $11_1 = $4_1 + 192 | 0;
  $1_1 = $7_1 + 8 | 0;
  $69($11_1, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $37_1 = $4_1 + 320 | 0;
  $69($37_1, $15_1, $19_1, 0, 0, $15_1, $19_1, 0, 0);
  $26_1 = $4_1 + 160 | 0;
  $69($26_1, $21_1, $2_1, 0, 0, $30_1, $35_1, 0, 0);
  $27_1 = $4_1 + 96 | 0;
  $69($27_1, $14_1, $13_1, 0, 0, $18_1 << 1, $12_1 << 1 | $18_1 >>> 31, 0, 0);
  $15_1 = HEAP32[$4_1 + 68 >> 2];
  $2_1 = $15_1 + HEAP32[$4_1 + 276 >> 2] | 0;
  $6_1 = HEAP32[$4_1 + 64 >> 2];
  $1_1 = HEAP32[$4_1 + 272 >> 2];
  $3_1 = $6_1 + $1_1 | 0;
  $5_1 = HEAP32[$4_1 + 208 >> 2];
  $36_1 = $3_1 + $5_1 | 0;
  $1_1 = $1_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $1_1 + HEAP32[$4_1 + 212 >> 2] | 0;
  $5_1 = $5_1 >>> 0 > $36_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $7_1 = ($1_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 > $36_1 >>> 0 | $1_1 >>> 0 > $5_1 >>> 0;
  $2_1 = $9_1 + 8 | 0;
  $9_1 = HEAP32[$2_1 >> 2];
  $23_1 = HEAP32[$2_1 + 4 >> 2];
  $6_1 = ($1_1 | 0) == ($15_1 | 0) & $3_1 >>> 0 < $6_1 >>> 0 | $1_1 >>> 0 < $15_1 >>> 0;
  $2_1 = $8_1 + 8 | 0;
  $3_1 = HEAP32[$2_1 >> 2];
  $1_1 = $10_1 + 8 | 0;
  $8_1 = $3_1 + HEAP32[$1_1 >> 2] | 0;
  $2_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
  $2_1 = $3_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = $6_1 + $8_1 | 0;
  $2_1 = ($1_1 >>> 0 < $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $23_1 | 0;
  $3_1 = $1_1;
  $1_1 = $1_1 + $9_1 | 0;
  $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $3_1 = $1_1;
  $1_1 = $1_1 + $7_1 | 0;
  $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $19_1 = $5_1;
  $23_1 = $1_1 << 12 | $5_1 >>> 20;
  $3_1 = $2_1;
  $6_1 = $2_1 << 12 | $1_1 >>> 20;
  $20_1 = HEAP32[$4_1 + 80 >> 2];
  $1_1 = HEAP32[$4_1 + 256 >> 2];
  $7_1 = $20_1 + $1_1 | 0;
  $28_1 = HEAP32[$4_1 + 84 >> 2];
  $2_1 = $28_1 + HEAP32[$4_1 + 260 >> 2] | 0;
  $2_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = HEAP32[$4_1 + 176 >> 2];
  $9_1 = $1_1 + $7_1 | 0;
  $10_1 = $2_1;
  $2_1 = $2_1 + HEAP32[$4_1 + 180 >> 2] | 0;
  $2_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = HEAP32[$4_1 + 192 >> 2];
  $5_1 = $1_1 + $9_1 | 0;
  $8_1 = $2_1;
  $2_1 = $2_1 + HEAP32[$4_1 + 196 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $1_1 + $6_1 | 0;
  $23_1 = $5_1 + $23_1 | 0;
  $6_1 = $23_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $22_1 = ($1_1 | 0) == ($6_1 | 0) & $5_1 >>> 0 > $23_1 >>> 0 | $1_1 >>> 0 > $6_1 >>> 0;
  $24_1 = ($1_1 | 0) == ($8_1 | 0) & $5_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 < $8_1 >>> 0;
  $1_1 = $11_1 + 8 | 0;
  $17_1 = HEAP32[$1_1 >> 2];
  $16_1 = HEAP32[$1_1 + 4 >> 2];
  $15_1 = ($8_1 | 0) == ($10_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $8_1 >>> 0 < $10_1 >>> 0;
  $1_1 = $31_1 + 8 | 0;
  $11_1 = HEAP32[$1_1 >> 2];
  $8_1 = HEAP32[$1_1 + 4 >> 2];
  $9_1 = ($10_1 | 0) == ($28_1 | 0) & $7_1 >>> 0 < $20_1 >>> 0 | $10_1 >>> 0 < $28_1 >>> 0;
  $2_1 = $34_1 + 8 | 0;
  $5_1 = HEAP32[$2_1 >> 2];
  $1_1 = $33_1 + 8 | 0;
  $7_1 = $5_1 + HEAP32[$1_1 >> 2] | 0;
  $2_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
  $2_1 = $5_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = $7_1 + $9_1 | 0;
  $2_1 = ($1_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $8_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $11_1 | 0;
  $2_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $15_1 | 0;
  $2_1 = ($5_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $16_1 | 0;
  $5_1 = $1_1;
  $1_1 = $1_1 + $17_1 | 0;
  $2_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $5_1 = $1_1 + $24_1 | 0;
  $2_1 = $5_1 >>> 0 < $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $3_1 = $3_1 >>> 20 | 0;
  $1_1 = $3_1 + $5_1 | 0;
  $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $3_1 = $1_1;
  $1_1 = $1_1 + $22_1 | 0;
  $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $3_1 = $6_1;
  $7_1 = $1_1 << 12 | $3_1 >>> 20;
  $5_1 = $2_1;
  $9_1 = $2_1 << 12 | $1_1 >>> 20;
  $17_1 = HEAP32[$4_1 + 160 >> 2];
  $1_1 = HEAP32[$4_1 + 96 >> 2];
  $6_1 = $17_1 + $1_1 | 0;
  $20_1 = HEAP32[$4_1 + 164 >> 2];
  $2_1 = $20_1 + HEAP32[$4_1 + 100 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $6_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $1_1 + $9_1 | 0;
  $11_1 = $6_1;
  $6_1 = $6_1 + $7_1 | 0;
  $7_1 = $6_1 << 4 & -16;
  $8_1 = $6_1 >>> 0 < $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $9_1 = ($8_1 << 4 | $6_1 >>> 28) & 16777215;
  $15_1 = $3_1;
  $69($4_1, $7_1 | $3_1 >>> 16 & 15, $9_1, 0, 0, 977, 1, 0, 0);
  $22_1 = HEAP32[$4_1 + 4 >> 2];
  $2_1 = $22_1 + HEAP32[$4_1 + 324 >> 2] | 0;
  $9_1 = $0_1;
  $24_1 = HEAP32[$4_1 >> 2];
  $0_1 = HEAP32[$4_1 + 320 >> 2];
  $10_1 = $24_1 + $0_1 | 0;
  HEAP32[$9_1 >> 2] = $10_1;
  $7_1 = $0_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$9_1 + 4 >> 2] = $7_1 & 1048575;
  $28_1 = $4_1 + 304 | 0;
  $69($28_1, $30_1, $35_1, 0, 0, $25_1, $29_1, 0, 0);
  $31_1 = $4_1 + 144 | 0;
  $69($31_1, $21_1, $32_1, 0, 0, $18_1, $12_1, 0, 0);
  $33_1 = $4_1 + 112 | 0;
  $69($33_1, $14_1, $13_1, 0, 0, $14_1, $13_1, 0, 0);
  $34_1 = $4_1 + 48 | 0;
  $16_1 = $34_1;
  $6_1 = ($1_1 | 0) == ($8_1 | 0) & $6_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
  $3_1 = ($1_1 | 0) == ($20_1 | 0) & $11_1 >>> 0 < $17_1 >>> 0 | $1_1 >>> 0 < $20_1 >>> 0;
  $2_1 = $27_1 + 8 | 0;
  $1_1 = HEAP32[$2_1 >> 2];
  $0_1 = $26_1 + 8 | 0;
  $11_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
  $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
  $2_1 = $1_1 >>> 0 > $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = $3_1 + $11_1 | 0;
  $2_1 = $1_1 >>> 0 < $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $3_1 = $5_1 >>> 20 | 0;
  $0_1 = $1_1 + $3_1 | 0;
  $2_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = $0_1;
  $0_1 = $0_1 + $6_1 | 0;
  $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $8_1 = $0_1 << 12 | $8_1 >>> 20;
  $6_1 = $2_1;
  $5_1 = $2_1 << 12 | $0_1 >>> 20;
  $26_1 = HEAP32[$4_1 + 148 >> 2];
  $2_1 = $26_1 + HEAP32[$4_1 + 116 >> 2] | 0;
  $20_1 = HEAP32[$4_1 + 144 >> 2];
  $1_1 = HEAP32[$4_1 + 112 >> 2];
  $0_1 = $20_1 + $1_1 | 0;
  $17_1 = $0_1;
  $11_1 = $0_1 + $8_1 | 0;
  $3_1 = $0_1 >>> 0 < $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $3_1 + $5_1 | 0;
  $8_1 = $11_1 >>> 0 < $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $69($16_1, $11_1, $8_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $5_1 = ($7_1 | 0) == ($22_1 | 0) & $10_1 >>> 0 < $24_1 >>> 0 | $7_1 >>> 0 < $22_1 >>> 0;
  $2_1 = $37_1 + 8 | 0;
  $1_1 = HEAP32[$2_1 >> 2];
  $0_1 = $4_1 + 8 | 0;
  $10_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
  $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
  $2_1 = $1_1 >>> 0 > $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = $5_1 + $10_1 | 0;
  $2_1 = $0_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $10_1 = $0_1 << 12 | $7_1 >>> 20;
  $5_1 = $2_1;
  $7_1 = $2_1 << 12 | $0_1 >>> 20;
  $22_1 = HEAP32[$4_1 + 48 >> 2];
  $0_1 = HEAP32[$4_1 + 304 >> 2];
  $16_1 = $22_1 + $0_1 | 0;
  $27_1 = HEAP32[$4_1 + 52 >> 2];
  $2_1 = $27_1 + HEAP32[$4_1 + 308 >> 2] | 0;
  $1_1 = $0_1 >>> 0 > $16_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $1_1 + $7_1 | 0;
  $10_1 = $10_1 + $16_1 | 0;
  $2_1 = $10_1 >>> 0 < $16_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$9_1 + 8 >> 2] = $10_1;
  $7_1 = $2_1;
  HEAP32[$9_1 + 12 >> 2] = $2_1 & 1048575;
  $24_1 = $4_1 + 240 | 0;
  $69($24_1, $18_1, $12_1, 0, 0, $25_1, $29_1, 0, 0);
  $29_1 = $4_1 + 288 | 0;
  $69($29_1, $30_1, $35_1, 0, 0, $30_1, $35_1, 0, 0);
  $25_1 = $4_1 + 128 | 0;
  $69($25_1, $21_1, $32_1, 0, 0, $14_1, $13_1, 0, 0);
  $32_1 = $4_1 + 32 | 0;
  $13_1 = $32_1;
  $12_1 = ($3_1 | 0) == ($8_1 | 0) & $11_1 >>> 0 < $17_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
  $11_1 = ($3_1 | 0) == ($26_1 | 0) & $17_1 >>> 0 < $20_1 >>> 0 | $3_1 >>> 0 < $26_1 >>> 0;
  $2_1 = $33_1 + 8 | 0;
  $3_1 = HEAP32[$2_1 >> 2];
  $0_1 = $31_1 + 8 | 0;
  $14_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
  $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
  $2_1 = $3_1 >>> 0 > $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $3_1 = $11_1 + $14_1 | 0;
  $2_1 = $3_1 >>> 0 < $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $6_1 = $6_1 >>> 20 | 0;
  $0_1 = $3_1 + $6_1 | 0;
  $2_1 = $6_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $3_1 = $0_1;
  $0_1 = $0_1 + $12_1 | 0;
  $2_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $18_1 = $0_1 << 12 | $8_1 >>> 20;
  $6_1 = HEAP32[$4_1 + 128 >> 2];
  $8_1 = $18_1 + $6_1 | 0;
  $3_1 = $2_1;
  $21_1 = $2_1 << 12 | $0_1 >>> 20;
  $2_1 = $21_1 + HEAP32[$4_1 + 132 >> 2] | 0;
  $11_1 = $6_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $69($13_1, $8_1, $11_1, 0, 0, 15632, 16, 0, 0);
  $6_1 = $9_1;
  $10_1 = ($1_1 | 0) == ($7_1 | 0) & $10_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 > $7_1 >>> 0;
  $9_1 = ($1_1 | 0) == ($27_1 | 0) & $16_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $27_1 >>> 0;
  $2_1 = $28_1 + 8 | 0;
  $1_1 = HEAP32[$2_1 >> 2];
  $0_1 = $34_1 + 8 | 0;
  $12_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
  $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
  $2_1 = $1_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = $9_1 + $12_1 | 0;
  $2_1 = $1_1 >>> 0 < $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $5_1 = $5_1 >>> 20 | 0;
  $0_1 = $1_1 + $5_1 | 0;
  $2_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = $0_1;
  $0_1 = $0_1 + $10_1 | 0;
  $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $9_1 = $0_1 << 12 | $7_1 >>> 20;
  $1_1 = $2_1;
  $13_1 = $2_1 << 12 | $0_1 >>> 20;
  $16_1 = HEAP32[$4_1 + 240 >> 2];
  $0_1 = HEAP32[$4_1 + 288 >> 2];
  $7_1 = $16_1 + $0_1 | 0;
  $17_1 = HEAP32[$4_1 + 244 >> 2];
  $2_1 = $17_1 + HEAP32[$4_1 + 292 >> 2] | 0;
  $12_1 = $0_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $12_1 + HEAP32[$4_1 + 36 >> 2] | 0;
  $0_1 = HEAP32[$4_1 + 32 >> 2];
  $5_1 = $0_1 + $7_1 | 0;
  $10_1 = $5_1;
  $9_1 = $5_1 + $9_1 | 0;
  $0_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $0_1 + $13_1 | 0;
  HEAP32[$6_1 + 16 >> 2] = $9_1;
  $5_1 = $9_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$6_1 + 20 >> 2] = $5_1 & 1048575;
  $14_1 = $4_1 + 16 | 0;
  $13_1 = ($11_1 | 0) == ($21_1 | 0) & $8_1 >>> 0 < $18_1 >>> 0 | $11_1 >>> 0 < $21_1 >>> 0;
  $2_1 = $25_1 + 8 | 0;
  $11_1 = HEAP32[$2_1 >> 2];
  $2_1 = HEAP32[$2_1 + 4 >> 2];
  $3_1 = $3_1 >>> 20 | 0;
  $8_1 = $3_1;
  $3_1 = $3_1 + $11_1 | 0;
  $2_1 = $8_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $8_1 = $3_1;
  $3_1 = $3_1 + $13_1 | 0;
  $2_1 = $8_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $69($14_1, $3_1, $2_1, 0, 0, 64028672, 65536, 0, 0);
  $3_1 = $6_1;
  $13_1 = ($0_1 | 0) == ($5_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $0_1 >>> 0 > $5_1 >>> 0;
  $11_1 = ($0_1 | 0) == ($12_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $0_1 >>> 0 < $12_1 >>> 0;
  $0_1 = $32_1 + 8 | 0;
  $10_1 = HEAP32[$0_1 >> 2];
  $8_1 = HEAP32[$0_1 + 4 >> 2];
  $9_1 = ($12_1 | 0) == ($17_1 | 0) & $7_1 >>> 0 < $16_1 >>> 0 | $12_1 >>> 0 < $17_1 >>> 0;
  $2_1 = $29_1 + 8 | 0;
  $6_1 = HEAP32[$2_1 >> 2];
  $0_1 = $24_1 + 8 | 0;
  $7_1 = $6_1 + HEAP32[$0_1 >> 2] | 0;
  $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
  $2_1 = $7_1 >>> 0 < $6_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = $7_1 + $9_1 | 0;
  $2_1 = ($0_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $8_1 | 0;
  $6_1 = $0_1;
  $0_1 = $0_1 + $10_1 | 0;
  $2_1 = $6_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $6_1 = $0_1 + $11_1 | 0;
  $2_1 = $6_1 >>> 0 < $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = $1_1 >>> 20 | 0;
  $0_1 = $1_1 + $6_1 | 0;
  $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = $0_1;
  $0_1 = $0_1 + $13_1 | 0;
  $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $6_1 = $0_1 << 12 | $5_1 >>> 20;
  $1_1 = $2_1;
  $5_1 = $2_1 << 12 | $0_1 >>> 20;
  $11_1 = HEAP32[$4_1 + 16 >> 2];
  $0_1 = $36_1 & -2;
  $9_1 = $11_1 + $0_1 | 0;
  $2_1 = $19_1 & 1048575;
  $19_1 = HEAP32[$4_1 + 20 >> 2];
  $2_1 = $2_1 + $19_1 | 0;
  $7_1 = $0_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $7_1 + $5_1 | 0;
  $5_1 = $6_1 + $9_1 | 0;
  $2_1 = $5_1 >>> 0 < $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$3_1 + 24 >> 2] = $5_1;
  $0_1 = $2_1;
  HEAP32[$3_1 + 28 >> 2] = $2_1 & 1048575;
  $6_1 = $3_1;
  $10_1 = $15_1 & 65535;
  $8_1 = ($2_1 | 0) == ($7_1 | 0) & $5_1 >>> 0 < $9_1 >>> 0 | $2_1 >>> 0 < $7_1 >>> 0;
  $3_1 = ($7_1 | 0) == ($19_1 | 0) & $9_1 >>> 0 < $11_1 >>> 0 | $7_1 >>> 0 < $19_1 >>> 0;
  $2_1 = $14_1 + 8 | 0;
  $5_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
  $2_1 = HEAP32[$2_1 + 4 >> 2];
  $2_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = $1_1 >>> 20 | 0;
  $3_1 = $1_1;
  $1_1 = $1_1 + $5_1 | 0;
  $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $3_1 = $1_1;
  $1_1 = $1_1 + $8_1 | 0;
  $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = $1_1 << 12 | $0_1 >>> 20;
  $3_1 = $0_1 + $23_1 | 0;
  $2_1 = $10_1 + ($2_1 << 12 | $1_1 >>> 20) | 0;
  HEAP32[$6_1 + 32 >> 2] = $3_1;
  HEAP32[$6_1 + 36 >> 2] = $0_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  global$0 = $4_1 + 336 | 0;
 }
 
 function $55($0_1, $1_1) {
  var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0, $51_1 = 0, $52_1 = 0, $53_1 = 0, $54_1 = 0, $55_1 = 0, $56_1 = 0, $57_1 = 0, $58_1 = 0, $59_1 = 0, $60_1 = 0;
  $4_1 = global$0 - 464 | 0;
  global$0 = $4_1;
  HEAP32[$0_1 + 120 >> 2] = HEAP32[$1_1 + 120 >> 2];
  $2_1 = $1_1 + 40 | 0;
  $34($0_1 + 80 | 0, $1_1 + 80 | 0, $2_1);
  $54($4_1 + 384 | 0, $2_1);
  $33_1 = $4_1 + 424 | 0;
  $54($33_1, $1_1);
  $15_1 = HEAP32[$4_1 + 388 >> 2];
  $16_1 = HEAP32[$4_1 + 384 >> 2];
  HEAP32[$4_1 + 344 >> 2] = -3908 - $16_1;
  HEAP32[$4_1 + 348 >> 2] = 4194299 - (($16_1 >>> 0 > 4294963388) + $15_1 | 0);
  $13_1 = HEAP32[$4_1 + 396 >> 2];
  $19_1 = HEAP32[$4_1 + 392 >> 2];
  HEAP32[$4_1 + 352 >> 2] = -4 - $19_1;
  HEAP32[$4_1 + 356 >> 2] = 4194303 - (($19_1 >>> 0 > 4294967292) + $13_1 | 0);
  $21_1 = HEAP32[$4_1 + 404 >> 2];
  $18_1 = HEAP32[$4_1 + 400 >> 2];
  HEAP32[$4_1 + 360 >> 2] = -4 - $18_1;
  HEAP32[$4_1 + 364 >> 2] = 4194303 - (($18_1 >>> 0 > 4294967292) + $21_1 | 0);
  $10_1 = HEAP32[$4_1 + 412 >> 2];
  $7_1 = HEAP32[$4_1 + 408 >> 2];
  HEAP32[$4_1 + 368 >> 2] = -4 - $7_1;
  HEAP32[$4_1 + 372 >> 2] = 4194303 - (($7_1 >>> 0 > 4294967292) + $10_1 | 0);
  $6_1 = __wasm_i64_mul(HEAP32[$4_1 + 456 >> 2], HEAP32[$4_1 + 460 >> 2], 3, 0);
  $5_1 = i64toi32_i32$HIGH_BITS;
  $20_1 = __wasm_i64_mul(HEAP32[$4_1 + 424 >> 2], HEAP32[$4_1 + 428 >> 2], 3, 0);
  $9_1 = i64toi32_i32$HIGH_BITS;
  $2_1 = $20_1 & 1;
  $3_1 = 0 - $2_1 | 0;
  $12_1 = $3_1;
  $11_1 = 0 - $2_1 | 0;
  $2_1 = ($11_1 >>> 16 | 0) + $5_1 | 0;
  $3_1 = ($11_1 & 65535) << 16 | $3_1 >>> 16;
  $5_1 = $3_1 + $6_1 | 0;
  $2_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$4_1 + 456 >> 2] = ($2_1 & 1) << 31 | $5_1 >>> 1;
  HEAP32[$4_1 + 460 >> 2] = $2_1 >>> 1;
  $8_1 = $5_1 << 19 & 524288;
  $6_1 = $11_1 >>> 12 | 0;
  $12_1 = ($11_1 & 4095) << 20 | $12_1 >>> 12;
  $3_1 = __wasm_i64_mul(HEAP32[$4_1 + 448 >> 2], HEAP32[$4_1 + 452 >> 2], 3, 0);
  $5_1 = $12_1 + $3_1 | 0;
  $2_1 = $6_1 + i64toi32_i32$HIGH_BITS | 0;
  $3_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = ($3_1 >>> 1 | 0) + $8_1 | 0;
  $11_1 = ($3_1 & 1) << 31 | $5_1 >>> 1;
  $2_1 = $11_1 >>> 0 > $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$4_1 + 448 >> 2] = $11_1;
  HEAP32[$4_1 + 452 >> 2] = $2_1;
  $11_1 = $5_1 << 19 & 524288;
  $5_1 = __wasm_i64_mul(HEAP32[$4_1 + 440 >> 2], HEAP32[$4_1 + 444 >> 2], 3, 0) + $12_1 | 0;
  $3_1 = i64toi32_i32$HIGH_BITS + $6_1 | 0;
  $3_1 = $5_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $2_1 = ($3_1 >>> 1 | 0) + $11_1 | 0;
  $8_1 = ($3_1 & 1) << 31 | $5_1 >>> 1;
  $2_1 = $8_1 >>> 0 > $8_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$4_1 + 440 >> 2] = $8_1;
  HEAP32[$4_1 + 444 >> 2] = $2_1;
  $8_1 = $5_1 << 19 & 524288;
  $3_1 = __wasm_i64_mul(HEAP32[$4_1 + 432 >> 2], HEAP32[$4_1 + 436 >> 2], 3, 0);
  $11_1 = $3_1 + $12_1 | 0;
  $2_1 = $6_1 + i64toi32_i32$HIGH_BITS | 0;
  $5_1 = $3_1 >>> 0 > $11_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = ($5_1 >>> 1 | 0) + $8_1 | 0;
  $22_1 = ($5_1 & 1) << 31 | $11_1 >>> 1;
  $3_1 = $22_1;
  $2_1 = $3_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$4_1 + 432 >> 2] = $3_1;
  HEAP32[$4_1 + 436 >> 2] = $2_1;
  $11_1 = $11_1 << 19 & 524288;
  $2_1 = ($6_1 & 1048574) + $9_1 | 0;
  $5_1 = ($12_1 & -977) + $20_1 | 0;
  $2_1 = $5_1 >>> 0 < $20_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $5_1 = ($2_1 & 1) << 31 | $5_1 >>> 1;
  $2_1 = ($2_1 >>> 1 | 0) + $11_1 | 0;
  $3_1 = $5_1;
  $2_1 = $3_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$4_1 + 424 >> 2] = $3_1;
  HEAP32[$4_1 + 428 >> 2] = $2_1;
  $9_1 = HEAP32[$4_1 + 420 >> 2];
  $8_1 = HEAP32[$4_1 + 416 >> 2];
  HEAP32[$4_1 + 376 >> 2] = -4 - $8_1;
  HEAP32[$4_1 + 380 >> 2] = 262143 - (($8_1 >>> 0 > 4294967292) + $9_1 | 0);
  $34_1 = $4_1 + 344 | 0;
  $34($34_1, $34_1, $1_1);
  $54($0_1, $33_1);
  $1_1 = HEAP32[$4_1 + 376 >> 2];
  $51_1 = $1_1;
  $2_1 = HEAP32[$4_1 + 380 >> 2];
  $52_1 = $2_1;
  $2_1 = HEAP32[$0_1 + 36 >> 2] + ($2_1 << 1 | $1_1 >>> 31) | 0;
  $1_1 = $1_1 << 1;
  $3_1 = $1_1;
  $1_1 = $1_1 + HEAP32[$0_1 + 32 >> 2] | 0;
  $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $38_1 = $1_1;
  HEAP32[$0_1 + 32 >> 2] = $1_1;
  $29_1 = $2_1;
  HEAP32[$0_1 + 36 >> 2] = $2_1;
  $6_1 = $0_1;
  $5_1 = HEAP32[$0_1 + 24 >> 2];
  $0_1 = HEAP32[$4_1 + 368 >> 2];
  $53_1 = $0_1;
  $1_1 = HEAP32[$4_1 + 372 >> 2];
  $54_1 = $1_1;
  $2_1 = HEAP32[$6_1 + 28 >> 2] + ($1_1 << 1 | $0_1 >>> 31) | 0;
  $0_1 = $0_1 << 1;
  $1_1 = $0_1;
  $0_1 = $0_1 + $5_1 | 0;
  $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $39_1 = $0_1;
  HEAP32[$6_1 + 24 >> 2] = $0_1;
  $35_1 = $2_1;
  HEAP32[$6_1 + 28 >> 2] = $2_1;
  $0_1 = HEAP32[$4_1 + 360 >> 2];
  $55_1 = $0_1;
  $1_1 = HEAP32[$4_1 + 364 >> 2];
  $56_1 = $1_1;
  $2_1 = HEAP32[$6_1 + 20 >> 2] + ($1_1 << 1 | $0_1 >>> 31) | 0;
  $0_1 = $0_1 << 1;
  $1_1 = $0_1;
  $0_1 = $0_1 + HEAP32[$6_1 + 16 >> 2] | 0;
  $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $40_1 = $0_1;
  HEAP32[$6_1 + 16 >> 2] = $0_1;
  $36_1 = $2_1;
  HEAP32[$6_1 + 20 >> 2] = $2_1;
  $0_1 = HEAP32[$4_1 + 352 >> 2];
  $57_1 = $0_1;
  $1_1 = HEAP32[$4_1 + 356 >> 2];
  $58_1 = $1_1;
  $3_1 = HEAP32[$6_1 + 12 >> 2] + ($1_1 << 1 | $0_1 >>> 31) | 0;
  $0_1 = $0_1 << 1;
  $1_1 = $0_1;
  $0_1 = $0_1 + HEAP32[$6_1 + 8 >> 2] | 0;
  $3_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $41_1 = $0_1;
  HEAP32[$6_1 + 8 >> 2] = $0_1;
  $20_1 = $3_1;
  HEAP32[$6_1 + 12 >> 2] = $3_1;
  $0_1 = HEAP32[$4_1 + 344 >> 2];
  $59_1 = $0_1;
  $1_1 = HEAP32[$4_1 + 348 >> 2];
  $60_1 = $1_1;
  $2_1 = HEAP32[$6_1 + 4 >> 2] + ($1_1 << 1 | $0_1 >>> 31) | 0;
  $0_1 = $0_1 << 1;
  $1_1 = $0_1;
  $0_1 = $0_1 + HEAP32[$6_1 >> 2] | 0;
  $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $42_1 = $0_1;
  HEAP32[$6_1 >> 2] = $0_1;
  $22_1 = $2_1;
  HEAP32[$6_1 + 4 >> 2] = $2_1;
  $24_1 = $4_1 + 104 | 0;
  $11_1 = $7_1;
  $5_1 = $10_1;
  $27_1 = $16_1 << 1;
  $25_1 = $15_1 << 1 | $16_1 >>> 31;
  $69($24_1, $7_1, $5_1, 0, 0, $27_1, $25_1, 0, 0);
  $17_1 = $4_1 + 168 | 0;
  $1_1 = $18_1;
  $0_1 = $21_1;
  $12_1 = $19_1 << 1;
  $7_1 = $13_1 << 1 | $19_1 >>> 31;
  $69($17_1, $1_1, $0_1, 0, 0, $12_1, $7_1, 0, 0);
  $18_1 = $4_1 + 328 | 0;
  $69($18_1, $8_1, $9_1, 0, 0, $8_1, $9_1, 0, 0);
  $14_1 = $4_1 + 312 | 0;
  $69($14_1, HEAP32[$4_1 + 328 >> 2], HEAP32[$4_1 + 332 >> 2], 0, 0, 15632, 16, 0, 0);
  $3_1 = $8_1;
  $2_1 = $9_1 << 1 | $3_1 >>> 31;
  $43_1 = $4_1 + 136 | 0;
  $30_1 = $3_1 << 1;
  $21_1 = $2_1;
  $69($43_1, $30_1, $2_1, 0, 0, $16_1, $15_1, 0, 0);
  $44_1 = $4_1 + 152 | 0;
  $69($44_1, $11_1, $5_1, 0, 0, $12_1, $7_1, 0, 0);
  $45_1 = $4_1 + 232 | 0;
  $69($45_1, $1_1, $0_1, 0, 0, $1_1, $0_1, 0, 0);
  $26_1 = $4_1 + 296 | 0;
  $2_1 = $18_1 + 8 | 0;
  $69($26_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
  $46_1 = $4_1 + 120 | 0;
  $69($46_1, $16_1, $15_1, 0, 0, $16_1, $15_1, 0, 0);
  $47_1 = $4_1 + 200 | 0;
  $69($47_1, $30_1, $21_1, 0, 0, $19_1, $13_1, 0, 0);
  $8_1 = $0_1;
  $18_1 = $1_1;
  $2_1 = $0_1 << 1 | $1_1 >>> 31;
  $48_1 = $4_1 + 248 | 0;
  $10_1 = $11_1;
  $9_1 = $5_1;
  $69($48_1, $10_1, $5_1, 0, 0, $1_1 << 1, $2_1, 0, 0);
  $15_1 = HEAP32[$4_1 + 108 >> 2];
  $2_1 = $15_1 + HEAP32[$4_1 + 172 >> 2] | 0;
  $5_1 = HEAP32[$4_1 + 104 >> 2];
  $0_1 = HEAP32[$4_1 + 168 >> 2];
  $3_1 = $5_1 + $0_1 | 0;
  $1_1 = HEAP32[$4_1 + 312 >> 2];
  $16_1 = $3_1 + $1_1 | 0;
  $0_1 = $0_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $0_1 + HEAP32[$4_1 + 316 >> 2] | 0;
  $1_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $7_1 = ($0_1 | 0) == ($1_1 | 0) & $3_1 >>> 0 > $16_1 >>> 0 | $0_1 >>> 0 > $1_1 >>> 0;
  $2_1 = $14_1 + 8 | 0;
  $12_1 = HEAP32[$2_1 >> 2];
  $11_1 = HEAP32[$2_1 + 4 >> 2];
  $5_1 = ($0_1 | 0) == ($15_1 | 0) & $3_1 >>> 0 < $5_1 >>> 0 | $0_1 >>> 0 < $15_1 >>> 0;
  $2_1 = $17_1 + 8 | 0;
  $3_1 = HEAP32[$2_1 >> 2];
  $0_1 = $24_1 + 8 | 0;
  $15_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
  $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
  $2_1 = $3_1 >>> 0 > $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = $5_1 + $15_1 | 0;
  $2_1 = ($0_1 >>> 0 < $15_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $11_1 | 0;
  $3_1 = $0_1;
  $0_1 = $0_1 + $12_1 | 0;
  $3_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $0_1;
  $0_1 = $0_1 + $7_1 | 0;
  $3_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $15_1 = $1_1;
  $11_1 = $0_1 << 12 | $1_1 >>> 20;
  $1_1 = $3_1 << 12 | $0_1 >>> 20;
  $49_1 = HEAP32[$4_1 + 152 >> 2];
  $0_1 = HEAP32[$4_1 + 232 >> 2];
  $7_1 = $49_1 + $0_1 | 0;
  $37_1 = HEAP32[$4_1 + 156 >> 2];
  $2_1 = $37_1 + HEAP32[$4_1 + 236 >> 2] | 0;
  $2_1 = $0_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = HEAP32[$4_1 + 136 >> 2];
  $12_1 = $0_1 + $7_1 | 0;
  $17_1 = $2_1;
  $2_1 = $2_1 + HEAP32[$4_1 + 140 >> 2] | 0;
  $2_1 = $0_1 >>> 0 > $12_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = HEAP32[$4_1 + 296 >> 2];
  $5_1 = $0_1 + $12_1 | 0;
  $14_1 = $2_1;
  $2_1 = $2_1 + HEAP32[$4_1 + 300 >> 2] | 0;
  $0_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $0_1 + $1_1 | 0;
  $50_1 = $4_1 + 40 | 0;
  $11_1 = $5_1 + $11_1 | 0;
  $1_1 = $11_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $28_1 = ($0_1 | 0) == ($1_1 | 0) & $5_1 >>> 0 > $11_1 >>> 0 | $0_1 >>> 0 > $1_1 >>> 0;
  $23_1 = ($0_1 | 0) == ($14_1 | 0) & $5_1 >>> 0 < $12_1 >>> 0 | $0_1 >>> 0 < $14_1 >>> 0;
  $0_1 = $26_1 + 8 | 0;
  $31_1 = HEAP32[$0_1 >> 2];
  $32_1 = HEAP32[$0_1 + 4 >> 2];
  $24_1 = ($14_1 | 0) == ($17_1 | 0) & $7_1 >>> 0 > $12_1 >>> 0 | $14_1 >>> 0 < $17_1 >>> 0;
  $0_1 = $43_1 + 8 | 0;
  $26_1 = HEAP32[$0_1 >> 2];
  $14_1 = HEAP32[$0_1 + 4 >> 2];
  $12_1 = ($17_1 | 0) == ($37_1 | 0) & $7_1 >>> 0 < $49_1 >>> 0 | $17_1 >>> 0 < $37_1 >>> 0;
  $2_1 = $45_1 + 8 | 0;
  $5_1 = HEAP32[$2_1 >> 2];
  $0_1 = $44_1 + 8 | 0;
  $7_1 = $5_1 + HEAP32[$0_1 >> 2] | 0;
  $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
  $2_1 = $5_1 >>> 0 > $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = $7_1 + $12_1 | 0;
  $2_1 = ($0_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $14_1 | 0;
  $5_1 = $0_1;
  $0_1 = $0_1 + $26_1 | 0;
  $2_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $5_1 = $0_1;
  $0_1 = $0_1 + $24_1 | 0;
  $2_1 = ($5_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $32_1 | 0;
  $5_1 = $0_1;
  $0_1 = $0_1 + $31_1 | 0;
  $2_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $5_1 = $0_1 + $23_1 | 0;
  $2_1 = $5_1 >>> 0 < $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $3_1 = $3_1 >>> 20 | 0;
  $0_1 = $3_1 + $5_1 | 0;
  $2_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $3_1 = $0_1;
  $0_1 = $0_1 + $28_1 | 0;
  $2_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $7_1 = $0_1 << 12 | $1_1 >>> 20;
  $3_1 = $2_1;
  $12_1 = $2_1 << 12 | $0_1 >>> 20;
  $28_1 = HEAP32[$4_1 + 204 >> 2];
  $2_1 = $28_1 + HEAP32[$4_1 + 252 >> 2] | 0;
  $23_1 = HEAP32[$4_1 + 200 >> 2];
  $0_1 = HEAP32[$4_1 + 248 >> 2];
  $5_1 = $23_1 + $0_1 | 0;
  $14_1 = $5_1;
  $7_1 = $5_1 + $7_1 | 0;
  $0_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $0_1 + $12_1 | 0;
  $5_1 = $7_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $5_1 << 4 | $7_1 >>> 28;
  $17_1 = $7_1 << 4 & -16;
  $12_1 = $1_1;
  $69($50_1, $17_1 | $1_1 >>> 16 & 15, $2_1 & 16777215, 0, 0, 977, 1, 0, 0);
  $31_1 = $4_1 + 24 | 0;
  $69($31_1, $19_1, $13_1, 0, 0, $27_1, $25_1, 0, 0);
  $32_1 = $4_1 + 216 | 0;
  $69($32_1, $30_1, $21_1, 0, 0, $18_1, $8_1, 0, 0);
  $24_1 = $4_1 + 280 | 0;
  $69($24_1, $10_1, $9_1, 0, 0, $10_1, $9_1, 0, 0);
  $26_1 = $4_1 + 88 | 0;
  $17_1 = ($0_1 | 0) == ($5_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $0_1 >>> 0 > $5_1 >>> 0;
  $7_1 = ($0_1 | 0) == ($28_1 | 0) & $14_1 >>> 0 < $23_1 >>> 0 | $0_1 >>> 0 < $28_1 >>> 0;
  $2_1 = $48_1 + 8 | 0;
  $1_1 = HEAP32[$2_1 >> 2];
  $0_1 = $47_1 + 8 | 0;
  $14_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
  $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
  $2_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = $3_1;
  $1_1 = $7_1 + $14_1 | 0;
  $2_1 = $1_1 >>> 0 < $14_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = $0_1 >>> 20 | 0;
  $3_1 = $0_1;
  $0_1 = $0_1 + $1_1 | 0;
  $2_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = $0_1;
  $0_1 = $0_1 + $17_1 | 0;
  $1_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $3_1 = $1_1 << 12 | $0_1 >>> 20;
  $7_1 = $0_1 << 12 | $5_1 >>> 20;
  $5_1 = $3_1;
  $17_1 = HEAP32[$4_1 + 216 >> 2];
  $0_1 = HEAP32[$4_1 + 280 >> 2];
  $3_1 = $17_1 + $0_1 | 0;
  $23_1 = HEAP32[$4_1 + 220 >> 2];
  $2_1 = $23_1 + HEAP32[$4_1 + 284 >> 2] | 0;
  $0_1 = $0_1 >>> 0 > $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $0_1 + $5_1 | 0;
  $5_1 = $7_1;
  $7_1 = $3_1;
  $3_1 = $5_1 + $3_1 | 0;
  $5_1 = $3_1 >>> 0 < $7_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $69($26_1, $3_1, $5_1 & 1048575, 0, 0, 15632, 16, 0, 0);
  $14_1 = $4_1 + 8 | 0;
  $69($14_1, $18_1, $8_1, 0, 0, $27_1, $25_1, 0, 0);
  $27_1 = $4_1 + 184 | 0;
  $69($27_1, $19_1, $13_1, 0, 0, $19_1, $13_1, 0, 0);
  $13_1 = $4_1 + 264 | 0;
  $69($13_1, $30_1, $21_1, 0, 0, $10_1, $9_1, 0, 0);
  $21_1 = $4_1 + 72 | 0;
  $9_1 = $21_1;
  $8_1 = ($0_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 < $7_1 >>> 0 | $0_1 >>> 0 > $5_1 >>> 0;
  $7_1 = ($0_1 | 0) == ($23_1 | 0) & $7_1 >>> 0 < $17_1 >>> 0 | $0_1 >>> 0 < $23_1 >>> 0;
  $3_1 = $24_1 + 8 | 0;
  $2_1 = HEAP32[$3_1 >> 2];
  $0_1 = $32_1 + 8 | 0;
  $10_1 = $2_1 + HEAP32[$0_1 >> 2] | 0;
  $3_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $2_1 = $2_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $3_1 = $7_1 + $10_1 | 0;
  $2_1 = $3_1 >>> 0 < $10_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = $1_1 >>> 20 | 0;
  $0_1 = $1_1 + $3_1 | 0;
  $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = $0_1;
  $0_1 = $0_1 + $8_1 | 0;
  $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $8_1 = $0_1 << 12 | $5_1 >>> 20;
  $5_1 = HEAP32[$4_1 + 264 >> 2];
  $10_1 = $8_1 + $5_1 | 0;
  $1_1 = $2_1;
  $0_1 = $2_1 << 12 | $0_1 >>> 20;
  $3_1 = $0_1 + HEAP32[$4_1 + 268 >> 2] | 0;
  $3_1 = $5_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $69($9_1, $10_1, $3_1, 0, 0, 15632, 16, 0, 0);
  $18_1 = $4_1 + 56 | 0;
  $7_1 = $18_1;
  $5_1 = ($0_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $10_1 >>> 0 | $0_1 >>> 0 > $3_1 >>> 0;
  $0_1 = $13_1 + 8 | 0;
  $3_1 = HEAP32[$0_1 >> 2];
  $2_1 = HEAP32[$0_1 + 4 >> 2];
  $1_1 = $1_1 >>> 20 | 0;
  $0_1 = $1_1 + $3_1 | 0;
  $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = $0_1;
  $0_1 = $0_1 + $5_1 | 0;
  $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $69($7_1, $0_1, $2_1, 0, 0, 64028672, 65536, 0, 0);
  $0_1 = $4_1;
  $3_1 = $29_1 + $52_1 | 0;
  $1_1 = $38_1 + $51_1 | 0;
  $3_1 = $1_1 >>> 0 < $38_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  HEAP32[$0_1 + 376 >> 2] = $1_1;
  HEAP32[$0_1 + 380 >> 2] = $3_1;
  $2_1 = $35_1 + $54_1 | 0;
  $1_1 = $39_1 + $53_1 | 0;
  $2_1 = $1_1 >>> 0 < $39_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$0_1 + 368 >> 2] = $1_1;
  HEAP32[$0_1 + 372 >> 2] = $2_1;
  $2_1 = $36_1 + $56_1 | 0;
  $1_1 = $40_1 + $55_1 | 0;
  $2_1 = $1_1 >>> 0 < $40_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$0_1 + 360 >> 2] = $1_1;
  HEAP32[$0_1 + 364 >> 2] = $2_1;
  $2_1 = $20_1 + $58_1 | 0;
  $1_1 = $41_1 + $57_1 | 0;
  $2_1 = $1_1 >>> 0 < $41_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$0_1 + 352 >> 2] = $1_1;
  HEAP32[$0_1 + 356 >> 2] = $2_1;
  $8_1 = $0_1;
  $2_1 = $22_1 + $60_1 | 0;
  $0_1 = $42_1 + $59_1 | 0;
  $2_1 = $0_1 >>> 0 < $42_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$4_1 + 344 >> 2] = $0_1;
  HEAP32[$4_1 + 348 >> 2] = $2_1;
  $34($6_1 + 40 | 0, $34_1, $33_1);
  $7_1 = $6_1;
  $6_1 = HEAP32[$6_1 + 40 >> 2];
  $2_1 = HEAP32[$7_1 + 44 >> 2];
  $5_1 = HEAP32[$4_1 + 40 >> 2];
  $1_1 = HEAP32[$4_1 + 120 >> 2];
  $0_1 = $5_1 + $1_1 | 0;
  $9_1 = HEAP32[$4_1 + 44 >> 2];
  $3_1 = $9_1 + HEAP32[$4_1 + 124 >> 2] | 0;
  $1_1 = $0_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $2_1 = $2_1 + ($1_1 & 1048575) | 0;
  $3_1 = $0_1 + $6_1 | 0;
  $2_1 = $3_1 >>> 0 < $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$7_1 + 40 >> 2] = -5862 - $3_1;
  HEAP32[$7_1 + 44 >> 2] = 6291449 - (($3_1 >>> 0 > 4294961434) + $2_1 | 0);
  $2_1 = $7_1 + 48 | 0;
  $13_1 = $2_1;
  $10_1 = HEAP32[$2_1 >> 2];
  $4_1 = HEAP32[$2_1 + 4 >> 2];
  $5_1 = ($1_1 | 0) == ($9_1 | 0) & $0_1 >>> 0 < $5_1 >>> 0 | $1_1 >>> 0 < $9_1 >>> 0;
  $2_1 = $46_1 + 8 | 0;
  $3_1 = HEAP32[$2_1 >> 2];
  $0_1 = $50_1 + 8 | 0;
  $6_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
  $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
  $3_1 = $3_1 >>> 0 > $6_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = $5_1 + $6_1 | 0;
  $3_1 = $0_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  $6_1 = $0_1 << 12 | $1_1 >>> 20;
  $5_1 = $3_1 << 12 | $0_1 >>> 20;
  $9_1 = HEAP32[$8_1 + 88 >> 2];
  $0_1 = HEAP32[$8_1 + 24 >> 2];
  $1_1 = $9_1 + $0_1 | 0;
  $20_1 = HEAP32[$8_1 + 92 >> 2];
  $2_1 = $20_1 + HEAP32[$8_1 + 28 >> 2] | 0;
  $2_1 = $0_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = $6_1;
  $6_1 = $1_1;
  $1_1 = $0_1 + $1_1 | 0;
  $0_1 = $2_1;
  $2_1 = $2_1 + $5_1 | 0;
  $5_1 = $1_1 >>> 0 < $6_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $4_1 + ($5_1 & 1048575) | 0;
  $10_1 = $1_1 + $10_1 | 0;
  $2_1 = $10_1 >>> 0 < $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$13_1 >> 2] = -6 - $10_1;
  HEAP32[$13_1 + 4 >> 2] = 6291455 - (($10_1 >>> 0 > 4294967290) + $2_1 | 0);
  $2_1 = $7_1 + 56 | 0;
  $22_1 = $2_1;
  $13_1 = HEAP32[$2_1 >> 2];
  $10_1 = HEAP32[$2_1 + 4 >> 2];
  $4_1 = ($0_1 | 0) == ($5_1 | 0) & $1_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 > $5_1 >>> 0;
  $6_1 = ($0_1 | 0) == ($20_1 | 0) & $6_1 >>> 0 < $9_1 >>> 0 | $0_1 >>> 0 < $20_1 >>> 0;
  $2_1 = $31_1 + 8 | 0;
  $1_1 = HEAP32[$2_1 >> 2];
  $0_1 = $26_1 + 8 | 0;
  $9_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
  $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
  $2_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = $6_1 + $9_1 | 0;
  $2_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $3_1 = $3_1 >>> 20 | 0;
  $0_1 = $1_1 + $3_1 | 0;
  $2_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = $0_1;
  $0_1 = $0_1 + $4_1 | 0;
  $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $5_1 = $0_1 << 12 | $5_1 >>> 20;
  $1_1 = $2_1;
  $3_1 = $2_1 << 12 | $0_1 >>> 20;
  $29_1 = HEAP32[$8_1 + 8 >> 2];
  $0_1 = HEAP32[$8_1 + 184 >> 2];
  $4_1 = $29_1 + $0_1 | 0;
  $25_1 = HEAP32[$8_1 + 12 >> 2];
  $2_1 = $25_1 + HEAP32[$8_1 + 188 >> 2] | 0;
  $2_1 = $0_1 >>> 0 > $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = HEAP32[$8_1 + 72 >> 2];
  $6_1 = $0_1 + $4_1 | 0;
  $9_1 = $2_1;
  $2_1 = $2_1 + HEAP32[$8_1 + 76 >> 2] | 0;
  $0_1 = $0_1 >>> 0 > $6_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $0_1 + $3_1 | 0;
  $5_1 = $5_1 + $6_1 | 0;
  $3_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $10_1 + ($3_1 & 1048575) | 0;
  $13_1 = $5_1 + $13_1 | 0;
  $2_1 = $13_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$22_1 >> 2] = -6 - $13_1;
  HEAP32[$22_1 + 4 >> 2] = 6291455 - (($13_1 >>> 0 > 4294967290) + $2_1 | 0);
  $2_1 = $7_1 - -64 | 0;
  $19_1 = $2_1;
  $35_1 = HEAP32[$2_1 >> 2];
  $36_1 = HEAP32[$2_1 + 4 >> 2];
  $20_1 = ($0_1 | 0) == ($3_1 | 0) & $5_1 >>> 0 < $6_1 >>> 0 | $0_1 >>> 0 > $3_1 >>> 0;
  $22_1 = ($0_1 | 0) == ($9_1 | 0) & $4_1 >>> 0 > $6_1 >>> 0 | $0_1 >>> 0 < $9_1 >>> 0;
  $0_1 = $21_1 + 8 | 0;
  $13_1 = HEAP32[$0_1 >> 2];
  $10_1 = HEAP32[$0_1 + 4 >> 2];
  $6_1 = ($9_1 | 0) == ($25_1 | 0) & $4_1 >>> 0 < $29_1 >>> 0 | $9_1 >>> 0 < $25_1 >>> 0;
  $2_1 = $27_1 + 8 | 0;
  $5_1 = HEAP32[$2_1 >> 2];
  $0_1 = $14_1 + 8 | 0;
  $4_1 = $5_1 + HEAP32[$0_1 >> 2] | 0;
  $2_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$2_1 + 4 >> 2] | 0;
  $2_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = $4_1 + $6_1 | 0;
  $2_1 = ($0_1 >>> 0 < $4_1 >>> 0 ? $2_1 + 1 | 0 : $2_1) + $10_1 | 0;
  $5_1 = $0_1;
  $0_1 = $0_1 + $13_1 | 0;
  $2_1 = $5_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $5_1 = $0_1 + $22_1 | 0;
  $2_1 = $5_1 >>> 0 < $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = $1_1 >>> 20 | 0;
  $0_1 = $1_1 + $5_1 | 0;
  $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = $0_1;
  $0_1 = $0_1 + $20_1 | 0;
  $2_1 = $1_1 >>> 0 > $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $5_1 = $0_1 << 12 | $3_1 >>> 20;
  $1_1 = $2_1;
  $4_1 = $2_1 << 12 | $0_1 >>> 20;
  $9_1 = HEAP32[$8_1 + 56 >> 2];
  $3_1 = $16_1 & -2;
  $0_1 = $9_1 + $3_1 | 0;
  $10_1 = HEAP32[$8_1 + 60 >> 2];
  $2_1 = $10_1 + ($15_1 & 1048575) | 0;
  $6_1 = $0_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $6_1 + $4_1 | 0;
  $3_1 = $5_1;
  $5_1 = $0_1;
  $3_1 = $3_1 + $0_1 | 0;
  $0_1 = $3_1 >>> 0 < $0_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $2_1 = $36_1 + ($0_1 & 1048575) | 0;
  $4_1 = $3_1 + $35_1 | 0;
  $2_1 = $4_1 >>> 0 < $3_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$19_1 >> 2] = -6 - $4_1;
  HEAP32[$19_1 + 4 >> 2] = 6291455 - (($4_1 >>> 0 > 4294967290) + $2_1 | 0);
  $2_1 = $7_1 + 72 | 0;
  $16_1 = $2_1;
  $15_1 = HEAP32[$2_1 >> 2];
  $7_1 = HEAP32[$2_1 + 4 >> 2];
  $12_1 = $12_1 & 65535;
  $4_1 = ($0_1 | 0) == ($6_1 | 0) & $3_1 >>> 0 < $5_1 >>> 0 | $0_1 >>> 0 < $6_1 >>> 0;
  $3_1 = ($6_1 | 0) == ($10_1 | 0) & $5_1 >>> 0 < $9_1 >>> 0 | $6_1 >>> 0 < $10_1 >>> 0;
  $2_1 = $18_1 + 8 | 0;
  $5_1 = $3_1 + HEAP32[$2_1 >> 2] | 0;
  $2_1 = HEAP32[$2_1 + 4 >> 2];
  $2_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $1_1 = $1_1 >>> 20 | 0;
  $3_1 = $1_1;
  $1_1 = $1_1 + $5_1 | 0;
  $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $3_1 = $1_1;
  $1_1 = $1_1 + $4_1 | 0;
  $2_1 = $3_1 >>> 0 > $1_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  $0_1 = $1_1 << 12 | $0_1 >>> 20;
  $5_1 = $0_1 + $11_1 | 0;
  $3_1 = $12_1 + ($2_1 << 12 | $1_1 >>> 20) | 0;
  $2_1 = ($0_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $7_1 | 0;
  $0_1 = $5_1 + $15_1 | 0;
  $2_1 = $0_1 >>> 0 < $5_1 >>> 0 ? $2_1 + 1 | 0 : $2_1;
  HEAP32[$16_1 >> 2] = -6 - $0_1;
  HEAP32[$16_1 + 4 >> 2] = 393215 - (($0_1 >>> 0 > 4294967290) + $2_1 | 0);
  global$0 = $8_1 + 464 | 0;
 }
 
 function $56($0_1, $1_1) {
  var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0;
  $7_1 = global$0 - 80 | 0;
  global$0 = $7_1;
  label$1 : {
   if (HEAP32[$1_1 + 120 >> 2]) {
    HEAP32[$0_1 + 80 >> 2] = 1;
    $68($0_1, 80);
    break label$1;
   }
   $11_1 = $1_1 + 88 | 0;
   $4_1 = HEAP32[$11_1 >> 2];
   $6_1 = HEAP32[$11_1 + 4 >> 2];
   $5_1 = HEAP32[$1_1 + 84 >> 2];
   $3_1 = $1_1 + 112 | 0;
   $14_1 = HEAP32[$3_1 >> 2];
   $8_1 = HEAP32[$3_1 + 4 >> 2];
   $15_1 = $8_1;
   $3_1 = HEAP32[$1_1 + 80 >> 2];
   $2_1 = __wasm_i64_mul($8_1 >>> 16 | 0, 0, 977, 1);
   $10_1 = $3_1 + $2_1 | 0;
   $5_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
   $3_1 = $6_1;
   $9_1 = $2_1 >>> 0 > $10_1 >>> 0 ? $5_1 + 1 | 0 : $5_1;
   $2_1 = $9_1 >>> 20 | 0;
   $6_1 = $2_1;
   $2_1 = $2_1 + $4_1 | 0;
   $6_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $16_1 = $6_1 & 1048575;
   $5_1 = $1_1 + 104 | 0;
   $13_1 = HEAP32[$5_1 >> 2];
   $17_1 = HEAP32[$5_1 + 4 >> 2];
   $5_1 = $1_1 + 96 | 0;
   $8_1 = HEAP32[$5_1 >> 2];
   $4_1 = HEAP32[$5_1 + 4 >> 2];
   $5_1 = $6_1 >>> 20 | 0;
   $8_1 = $5_1 + $8_1 | 0;
   $4_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $3_1 = $17_1;
   $12_1 = $4_1;
   $4_1 = $4_1 >>> 20 | 0;
   $5_1 = $4_1 + $13_1 | 0;
   $3_1 = $4_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $13_1 = $3_1 & 1048575;
   $17_1 = $1_1 + 80 | 0;
   $4_1 = $8_1;
   $12_1 = $12_1 & 1048575;
   $18_1 = ($2_1 & $4_1 & $5_1) == -1 & ($6_1 & $12_1 & $3_1) == 1048575;
   $6_1 = $3_1 >>> 20 | 0;
   $3_1 = $15_1 & 65535;
   $8_1 = $6_1 + $14_1 | 0;
   $6_1 = $8_1 >>> 0 < $6_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $9_1 & 1048575;
   $14_1 = $3_1;
   if ($18_1 & (($8_1 | 0) == -1 & ($6_1 | 0) == 65535) & (($3_1 | 0) == 1048574 & $10_1 >>> 0 > 4294966318 | $3_1 >>> 0 > 1048574) | $6_1 >>> 16) {
    $3_1 = $14_1 + 1 | 0;
    $10_1 = $10_1 + 977 | 0;
    $3_1 = $10_1 >>> 0 < 977 ? $3_1 + 1 | 0 : $3_1;
    $14_1 = $3_1 & 1048575;
    $9_1 = $3_1;
    $3_1 = $16_1;
    $9_1 = $9_1 >>> 20 | 0;
    $2_1 = $2_1 + $9_1 | 0;
    $3_1 = $9_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $16_1 = $3_1 & 1048575;
    $9_1 = $4_1;
    $15_1 = $3_1 >>> 20 | 0;
    $4_1 = $12_1;
    $3_1 = $9_1 + $15_1 | 0;
    $4_1 = $3_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $12_1 = $4_1 & 1048575;
    $9_1 = $4_1;
    $4_1 = $3_1;
    $3_1 = $13_1;
    $9_1 = $9_1 >>> 20 | 0;
    $5_1 = $5_1 + $9_1 | 0;
    $3_1 = $9_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $13_1 = $3_1 & 1048575;
    $9_1 = $3_1;
    $3_1 = $6_1;
    $6_1 = $8_1;
    $8_1 = ($9_1 >>> 20 | 0) + $8_1 | 0;
    $6_1 = ($6_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) & 65535;
   }
   HEAP32[$7_1 + 72 >> 2] = $6_1 >>> 8;
   HEAP32[$7_1 + 76 >> 2] = 0;
   $3_1 = $6_1 << 22 | $8_1 >>> 10;
   HEAP32[$7_1 + 64 >> 2] = $8_1 << 22 & -4194304 | (($13_1 & 1073741823) << 2 | $5_1 >>> 30);
   HEAP32[$7_1 + 68 >> 2] = $3_1 & 1073741823 | $13_1 >>> 30;
   HEAP32[$7_1 + 56 >> 2] = ($12_1 & 1048575) << 12 | $4_1 >>> 20;
   HEAP32[$7_1 + 60 >> 2] = $5_1 & 1073741823 | $12_1 >>> 20;
   $4_1 = $4_1 << 10 & 1073740800;
   HEAP32[$7_1 + 48 >> 2] = ($16_1 & 1023) << 22 | $2_1 >>> 10;
   HEAP32[$7_1 + 52 >> 2] = $16_1 >>> 10 | $4_1;
   HEAP32[$7_1 + 40 >> 2] = $10_1;
   HEAP32[$7_1 + 44 >> 2] = $14_1 | $2_1 << 20 & 1072693248;
   $10_1 = $7_1 + 40 | 0;
   $40($10_1, 690464);
   $5_1 = HEAP32[$7_1 + 44 >> 2];
   $4_1 = $5_1;
   HEAP32[$1_1 + 80 >> 2] = HEAP32[$7_1 + 40 >> 2];
   HEAP32[$1_1 + 84 >> 2] = $4_1 & 1048575;
   $5_1 = HEAP32[$7_1 + 72 >> 2] << 8;
   $8_1 = HEAP32[$7_1 + 68 >> 2];
   $3_1 = $8_1 >>> 22 | 0;
   $6_1 = HEAP32[$7_1 + 64 >> 2];
   HEAP32[$1_1 + 112 >> 2] = ($8_1 & 4194303) << 10 | $6_1 >>> 22;
   HEAP32[$1_1 + 116 >> 2] = $3_1 | $5_1;
   $2_1 = $6_1;
   $3_1 = $8_1 << 30 | $2_1 >>> 2;
   $6_1 = $2_1 << 30 & -1073741824;
   $2_1 = HEAP32[$7_1 + 56 >> 2];
   $5_1 = HEAP32[$7_1 + 60 >> 2];
   HEAP32[$1_1 + 104 >> 2] = $5_1 | $6_1;
   HEAP32[$1_1 + 108 >> 2] = $3_1 & 1048575;
   $5_1 = $5_1 << 20 | $2_1 >>> 12;
   $6_1 = $2_1 << 20 & -1048576;
   $8_1 = $5_1 & 1048575;
   $2_1 = HEAP32[$7_1 + 48 >> 2];
   $5_1 = HEAP32[$7_1 + 52 >> 2];
   HEAP32[$1_1 + 96 >> 2] = $5_1 >>> 10 | $6_1;
   HEAP32[$1_1 + 100 >> 2] = $8_1;
   $3_1 = $5_1 << 10 | $2_1 >>> 22;
   HEAP32[$1_1 + 88 >> 2] = $2_1 << 10 & -1024 | $4_1 >>> 20;
   HEAP32[$1_1 + 92 >> 2] = $3_1 & 1048575;
   $54($10_1, $17_1);
   $34($7_1, $17_1, $10_1);
   $34($1_1, $1_1, $10_1);
   $2_1 = $1_1 + 40 | 0;
   $34($2_1, $2_1, $7_1);
   HEAP32[$11_1 >> 2] = 0;
   HEAP32[$11_1 + 4 >> 2] = 0;
   $2_1 = $11_1 + 8 | 0;
   HEAP32[$2_1 >> 2] = 0;
   HEAP32[$2_1 + 4 >> 2] = 0;
   $2_1 = $11_1 + 16 | 0;
   HEAP32[$2_1 >> 2] = 0;
   HEAP32[$2_1 + 4 >> 2] = 0;
   $2_1 = $11_1 + 24 | 0;
   HEAP32[$2_1 >> 2] = 0;
   HEAP32[$2_1 + 4 >> 2] = 0;
   HEAP32[$0_1 + 80 >> 2] = 0;
   HEAP32[$1_1 + 80 >> 2] = 1;
   HEAP32[$1_1 + 84 >> 2] = 0;
   $2_1 = HEAP32[$1_1 + 4 >> 2];
   HEAP32[$0_1 >> 2] = HEAP32[$1_1 >> 2];
   HEAP32[$0_1 + 4 >> 2] = $2_1;
   $2_1 = $1_1 + 8 | 0;
   $5_1 = HEAP32[$2_1 + 4 >> 2];
   $4_1 = $0_1 + 8 | 0;
   HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
   HEAP32[$4_1 + 4 >> 2] = $5_1;
   $2_1 = $1_1 + 16 | 0;
   $5_1 = HEAP32[$2_1 + 4 >> 2];
   $4_1 = $0_1 + 16 | 0;
   HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
   HEAP32[$4_1 + 4 >> 2] = $5_1;
   $2_1 = $1_1 + 24 | 0;
   $5_1 = HEAP32[$2_1 + 4 >> 2];
   $4_1 = $0_1 + 24 | 0;
   HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
   HEAP32[$4_1 + 4 >> 2] = $5_1;
   $2_1 = $1_1 + 32 | 0;
   $5_1 = HEAP32[$2_1 + 4 >> 2];
   $4_1 = $0_1 + 32 | 0;
   HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
   HEAP32[$4_1 + 4 >> 2] = $5_1;
   $2_1 = $1_1 + 72 | 0;
   $5_1 = HEAP32[$2_1 + 4 >> 2];
   $4_1 = $0_1 + 72 | 0;
   HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
   HEAP32[$4_1 + 4 >> 2] = $5_1;
   $2_1 = $1_1 - -64 | 0;
   $5_1 = HEAP32[$2_1 + 4 >> 2];
   $4_1 = $0_1 - -64 | 0;
   HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
   HEAP32[$4_1 + 4 >> 2] = $5_1;
   $2_1 = $1_1 + 56 | 0;
   $5_1 = HEAP32[$2_1 + 4 >> 2];
   $4_1 = $0_1 + 56 | 0;
   HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
   HEAP32[$4_1 + 4 >> 2] = $5_1;
   $2_1 = $1_1 + 48 | 0;
   $5_1 = HEAP32[$2_1 + 4 >> 2];
   $4_1 = $0_1 + 48 | 0;
   HEAP32[$4_1 >> 2] = HEAP32[$2_1 >> 2];
   HEAP32[$4_1 + 4 >> 2] = $5_1;
   $2_1 = HEAP32[$1_1 + 44 >> 2];
   HEAP32[$0_1 + 40 >> 2] = HEAP32[$1_1 + 40 >> 2];
   HEAP32[$0_1 + 44 >> 2] = $2_1;
  }
  global$0 = $7_1 + 80 | 0;
 }
 
 function $57($0_1, $1_1, $2_1) {
  var $3_1 = 0, $4_1 = 0;
  $4_1 = global$0 - 128 | 0;
  global$0 = $4_1;
  label$1 : {
   if (!$1_1) {
    FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689638, HEAP32[$0_1 + 172 >> 2]);
    $0_1 = 0;
    break label$1;
   }
   HEAP8[$1_1 | 0] = 0;
   HEAP8[$1_1 + 1 | 0] = 0;
   HEAP8[$1_1 + 2 | 0] = 0;
   HEAP8[$1_1 + 3 | 0] = 0;
   HEAP8[$1_1 + 4 | 0] = 0;
   HEAP8[$1_1 + 5 | 0] = 0;
   HEAP8[$1_1 + 6 | 0] = 0;
   HEAP8[$1_1 + 7 | 0] = 0;
   $3_1 = $1_1 + 56 | 0;
   HEAP8[$3_1 | 0] = 0;
   HEAP8[$3_1 + 1 | 0] = 0;
   HEAP8[$3_1 + 2 | 0] = 0;
   HEAP8[$3_1 + 3 | 0] = 0;
   HEAP8[$3_1 + 4 | 0] = 0;
   HEAP8[$3_1 + 5 | 0] = 0;
   HEAP8[$3_1 + 6 | 0] = 0;
   HEAP8[$3_1 + 7 | 0] = 0;
   $3_1 = $1_1 + 48 | 0;
   HEAP8[$3_1 | 0] = 0;
   HEAP8[$3_1 + 1 | 0] = 0;
   HEAP8[$3_1 + 2 | 0] = 0;
   HEAP8[$3_1 + 3 | 0] = 0;
   HEAP8[$3_1 + 4 | 0] = 0;
   HEAP8[$3_1 + 5 | 0] = 0;
   HEAP8[$3_1 + 6 | 0] = 0;
   HEAP8[$3_1 + 7 | 0] = 0;
   $3_1 = $1_1 + 40 | 0;
   HEAP8[$3_1 | 0] = 0;
   HEAP8[$3_1 + 1 | 0] = 0;
   HEAP8[$3_1 + 2 | 0] = 0;
   HEAP8[$3_1 + 3 | 0] = 0;
   HEAP8[$3_1 + 4 | 0] = 0;
   HEAP8[$3_1 + 5 | 0] = 0;
   HEAP8[$3_1 + 6 | 0] = 0;
   HEAP8[$3_1 + 7 | 0] = 0;
   $3_1 = $1_1 + 32 | 0;
   HEAP8[$3_1 | 0] = 0;
   HEAP8[$3_1 + 1 | 0] = 0;
   HEAP8[$3_1 + 2 | 0] = 0;
   HEAP8[$3_1 + 3 | 0] = 0;
   HEAP8[$3_1 + 4 | 0] = 0;
   HEAP8[$3_1 + 5 | 0] = 0;
   HEAP8[$3_1 + 6 | 0] = 0;
   HEAP8[$3_1 + 7 | 0] = 0;
   $3_1 = $1_1 + 24 | 0;
   HEAP8[$3_1 | 0] = 0;
   HEAP8[$3_1 + 1 | 0] = 0;
   HEAP8[$3_1 + 2 | 0] = 0;
   HEAP8[$3_1 + 3 | 0] = 0;
   HEAP8[$3_1 + 4 | 0] = 0;
   HEAP8[$3_1 + 5 | 0] = 0;
   HEAP8[$3_1 + 6 | 0] = 0;
   HEAP8[$3_1 + 7 | 0] = 0;
   $3_1 = $1_1 + 16 | 0;
   HEAP8[$3_1 | 0] = 0;
   HEAP8[$3_1 + 1 | 0] = 0;
   HEAP8[$3_1 + 2 | 0] = 0;
   HEAP8[$3_1 + 3 | 0] = 0;
   HEAP8[$3_1 + 4 | 0] = 0;
   HEAP8[$3_1 + 5 | 0] = 0;
   HEAP8[$3_1 + 6 | 0] = 0;
   HEAP8[$3_1 + 7 | 0] = 0;
   $3_1 = $1_1 + 8 | 0;
   HEAP8[$3_1 | 0] = 0;
   HEAP8[$3_1 + 1 | 0] = 0;
   HEAP8[$3_1 + 2 | 0] = 0;
   HEAP8[$3_1 + 3 | 0] = 0;
   HEAP8[$3_1 + 4 | 0] = 0;
   HEAP8[$3_1 + 5 | 0] = 0;
   HEAP8[$3_1 + 6 | 0] = 0;
   HEAP8[$3_1 + 7 | 0] = 0;
   if (!$2_1) {
    FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689936, HEAP32[$0_1 + 172 >> 2]);
    $0_1 = 0;
    break label$1;
   }
   $0_1 = 0;
   if (!$32($4_1, $2_1)) {
    break label$1
   }
   $0_1 = 0;
   if (!$33($4_1 + 40 | 0, $4_1, 0)) {
    break label$1
   }
   $35($1_1, $4_1 + 40 | 0);
   $0_1 = 1;
  }
  global$0 = $4_1 + 128 | 0;
  return $0_1;
 }
 
 function $58($0_1, $1_1) {
  var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0;
  $3_1 = global$0 - 96 | 0;
  global$0 = $3_1;
  HEAP8[690885] = 0;
  HEAP8[690886] = 0;
  HEAP8[690887] = 0;
  HEAP8[690888] = 0;
  HEAP8[690889] = 0;
  HEAP8[690890] = 0;
  HEAP8[690891] = 0;
  HEAP8[690892] = 0;
  HEAP8[690909] = 0;
  HEAP8[690910] = 0;
  HEAP8[690911] = 0;
  HEAP8[690912] = 0;
  HEAP8[690913] = 0;
  HEAP8[690914] = 0;
  HEAP8[690915] = 0;
  HEAP8[690916] = 0;
  HEAP8[690901] = 0;
  HEAP8[690902] = 0;
  HEAP8[690903] = 0;
  HEAP8[690904] = 0;
  HEAP8[690905] = 0;
  HEAP8[690906] = 0;
  HEAP8[690907] = 0;
  HEAP8[690908] = 0;
  HEAP8[690893] = 0;
  HEAP8[690894] = 0;
  HEAP8[690895] = 0;
  HEAP8[690896] = 0;
  HEAP8[690897] = 0;
  HEAP8[690898] = 0;
  HEAP8[690899] = 0;
  HEAP8[690900] = 0;
  label$1 : {
   if (!$1_1) {
    FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689638, HEAP32[$0_1 + 172 >> 2]);
    break label$1;
   }
   $5_1 = HEAPU8[$1_1 + 60 | 0] | HEAPU8[$1_1 + 61 | 0] << 8 | (HEAPU8[$1_1 + 62 | 0] << 16 | HEAPU8[$1_1 + 63 | 0] << 24);
   $8_1 = $5_1 >>> 16 | 0;
   $4_1 = $3_1 + 80 | 0;
   $2_1 = HEAPU8[$1_1 + 56 | 0] | HEAPU8[$1_1 + 57 | 0] << 8 | (HEAPU8[$1_1 + 58 | 0] << 16 | HEAPU8[$1_1 + 59 | 0] << 24);
   HEAP32[$4_1 >> 2] = ($5_1 & 65535) << 16 | $2_1 >>> 16;
   HEAP32[$4_1 + 4 >> 2] = $8_1;
   $7_1 = $2_1 << 4 & 1048560;
   $4_1 = HEAPU8[$1_1 + 52 | 0] | HEAPU8[$1_1 + 53 | 0] << 8 | (HEAPU8[$1_1 + 54 | 0] << 16 | HEAPU8[$1_1 + 55 | 0] << 24);
   $2_1 = $4_1 >>> 28 | 0;
   $6_1 = $3_1 + 72 | 0;
   $5_1 = HEAPU8[$1_1 + 48 | 0] | HEAPU8[$1_1 + 49 | 0] << 8 | (HEAPU8[$1_1 + 50 | 0] << 16 | HEAPU8[$1_1 + 51 | 0] << 24);
   HEAP32[$6_1 >> 2] = ($4_1 & 268435455) << 4 | $5_1 >>> 28;
   HEAP32[$6_1 + 4 >> 2] = $2_1 | $7_1;
   $2_1 = $5_1;
   $8_1 = $4_1 << 24 | $2_1 >>> 8;
   $5_1 = HEAPU8[$1_1 + 40 | 0] | HEAPU8[$1_1 + 41 | 0] << 8 | (HEAPU8[$1_1 + 42 | 0] << 16 | HEAPU8[$1_1 + 43 | 0] << 24);
   $7_1 = $3_1 - -64 | 0;
   $4_1 = HEAPU8[$1_1 + 44 | 0] | HEAPU8[$1_1 + 45 | 0] << 8 | (HEAPU8[$1_1 + 46 | 0] << 16 | HEAPU8[$1_1 + 47 | 0] << 24);
   HEAP32[$7_1 >> 2] = $2_1 << 24 & -16777216 | $4_1 >>> 8;
   HEAP32[$7_1 + 4 >> 2] = $8_1 & 1048575;
   $2_1 = $5_1;
   $4_1 = ($4_1 << 12 | $2_1 >>> 20) & 1048575;
   $7_1 = HEAPU8[$1_1 + 32 | 0] | HEAPU8[$1_1 + 33 | 0] << 8 | (HEAPU8[$1_1 + 34 | 0] << 16 | HEAPU8[$1_1 + 35 | 0] << 24);
   $6_1 = $3_1 + 56 | 0;
   $9_1 = HEAPU8[$1_1 + 36 | 0] | HEAPU8[$1_1 + 37 | 0] << 8 | (HEAPU8[$1_1 + 38 | 0] << 16 | HEAPU8[$1_1 + 39 | 0] << 24);
   HEAP32[$6_1 >> 2] = $2_1 << 12 & -4096 | $9_1 >>> 20;
   HEAP32[$6_1 + 4 >> 2] = $4_1;
   HEAP32[$3_1 + 88 >> 2] = 0;
   HEAP32[$3_1 + 48 >> 2] = $7_1;
   HEAP32[$3_1 + 52 >> 2] = $9_1 & 1048575;
   $5_1 = HEAPU8[$1_1 + 12 | 0] | HEAPU8[$1_1 + 13 | 0] << 8 | (HEAPU8[$1_1 + 14 | 0] << 16 | HEAPU8[$1_1 + 15 | 0] << 24);
   $2_1 = HEAPU8[$1_1 + 8 | 0] | HEAPU8[$1_1 + 9 | 0] << 8 | (HEAPU8[$1_1 + 10 | 0] << 16 | HEAPU8[$1_1 + 11 | 0] << 24);
   $8_1 = $5_1 << 12 | $2_1 >>> 20;
   $4_1 = $2_1 << 12 & -4096;
   $2_1 = HEAPU8[$1_1 | 0] | HEAPU8[$1_1 + 1 | 0] << 8 | (HEAPU8[$1_1 + 2 | 0] << 16 | HEAPU8[$1_1 + 3 | 0] << 24);
   $9_1 = HEAPU8[$1_1 + 4 | 0] | HEAPU8[$1_1 + 5 | 0] << 8 | (HEAPU8[$1_1 + 6 | 0] << 16 | HEAPU8[$1_1 + 7 | 0] << 24);
   $10_1 = $9_1 >>> 20 | $4_1;
   HEAP32[$3_1 + 16 >> 2] = $10_1;
   $11_1 = $8_1 & 1048575;
   HEAP32[$3_1 + 20 >> 2] = $11_1;
   $4_1 = $2_1;
   HEAP32[$3_1 + 8 >> 2] = $2_1;
   $12_1 = $9_1 & 1048575;
   HEAP32[$3_1 + 12 >> 2] = $12_1;
   $6_1 = HEAPU8[$1_1 + 28 | 0] | HEAPU8[$1_1 + 29 | 0] << 8 | (HEAPU8[$1_1 + 30 | 0] << 16 | HEAPU8[$1_1 + 31 | 0] << 24);
   $2_1 = $6_1 >>> 16 | 0;
   $7_1 = HEAPU8[$1_1 + 24 | 0] | HEAPU8[$1_1 + 25 | 0] << 8 | (HEAPU8[$1_1 + 26 | 0] << 16 | HEAPU8[$1_1 + 27 | 0] << 24);
   $9_1 = ($6_1 & 65535) << 16 | $7_1 >>> 16;
   HEAP32[$3_1 + 40 >> 2] = $9_1;
   $6_1 = $2_1;
   HEAP32[$3_1 + 44 >> 2] = $2_1;
   $2_1 = HEAPU8[$1_1 + 16 | 0] | HEAPU8[$1_1 + 17 | 0] << 8 | (HEAPU8[$1_1 + 18 | 0] << 16 | HEAPU8[$1_1 + 19 | 0] << 24);
   $14_1 = $2_1;
   $13_1 = HEAPU8[$1_1 + 20 | 0] | HEAPU8[$1_1 + 21 | 0] << 8 | (HEAPU8[$1_1 + 22 | 0] << 16 | HEAPU8[$1_1 + 23 | 0] << 24);
   $1_1 = $2_1;
   $2_1 = $13_1 << 24 | $1_1 >>> 8;
   $5_1 = $1_1 << 24 & -16777216 | $5_1 >>> 8;
   HEAP32[$3_1 + 24 >> 2] = $5_1;
   $8_1 = $2_1 & 1048575;
   HEAP32[$3_1 + 28 >> 2] = $8_1;
   $1_1 = $13_1;
   $2_1 = $1_1 >>> 28 | 0;
   $1_1 = ($1_1 & 268435455) << 4 | $14_1 >>> 28;
   HEAP32[$3_1 + 32 >> 2] = $1_1;
   $2_1 = $2_1 | $7_1 << 4 & 1048560;
   HEAP32[$3_1 + 36 >> 2] = $2_1;
   if (!($4_1 | $10_1 | $9_1 | $5_1 | $1_1 | ($11_1 | $12_1 | $6_1 | $8_1 | $2_1))) {
    FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](690116, HEAP32[$0_1 + 172 >> 2]);
    break label$1;
   }
   $37(690885, $3_1 + 8 | 0);
   $15_1 = 1;
  }
  global$0 = $3_1 + 96 | 0;
  return $15_1;
 }
 
 function $59($0_1, $1_1, $2_1, $3_1) {
  var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0;
  $4_1 = global$0 - 96 | 0;
  global$0 = $4_1;
  label$1 : {
   if (!$1_1) {
    FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689586, HEAP32[$0_1 + 172 >> 2]);
    $0_1 = 0;
    break label$1;
   }
   if (!$3_1) {
    FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689638, HEAP32[$0_1 + 172 >> 2]);
    $0_1 = 0;
    break label$1;
   }
   $11_1 = HEAPU8[$3_1 + 60 | 0] | HEAPU8[$3_1 + 61 | 0] << 8 | (HEAPU8[$3_1 + 62 | 0] << 16 | HEAPU8[$3_1 + 63 | 0] << 24);
   $5_1 = $11_1 >>> 16 | 0;
   $6_1 = $4_1 + 80 | 0;
   $7_1 = HEAPU8[$3_1 + 56 | 0] | HEAPU8[$3_1 + 57 | 0] << 8 | (HEAPU8[$3_1 + 58 | 0] << 16 | HEAPU8[$3_1 + 59 | 0] << 24);
   $11_1 = ($11_1 & 65535) << 16 | $7_1 >>> 16;
   HEAP32[$6_1 >> 2] = $11_1;
   $24_1 = $5_1;
   HEAP32[$6_1 + 4 >> 2] = $5_1;
   $10_1 = $7_1 << 4 & 1048560;
   $8_1 = HEAPU8[$3_1 + 52 | 0] | HEAPU8[$3_1 + 53 | 0] << 8 | (HEAPU8[$3_1 + 54 | 0] << 16 | HEAPU8[$3_1 + 55 | 0] << 24);
   $5_1 = $8_1 >>> 28 | 0;
   $6_1 = $4_1 + 72 | 0;
   $7_1 = HEAPU8[$3_1 + 48 | 0] | HEAPU8[$3_1 + 49 | 0] << 8 | (HEAPU8[$3_1 + 50 | 0] << 16 | HEAPU8[$3_1 + 51 | 0] << 24);
   $13_1 = ($8_1 & 268435455) << 4 | $7_1 >>> 28;
   HEAP32[$6_1 >> 2] = $13_1;
   $16_1 = $5_1 | $10_1;
   HEAP32[$6_1 + 4 >> 2] = $16_1;
   $5_1 = $8_1 << 24 | $7_1 >>> 8;
   $10_1 = $7_1 << 24 & -16777216;
   $7_1 = HEAPU8[$3_1 + 40 | 0] | HEAPU8[$3_1 + 41 | 0] << 8 | (HEAPU8[$3_1 + 42 | 0] << 16 | HEAPU8[$3_1 + 43 | 0] << 24);
   $6_1 = $4_1 - -64 | 0;
   $8_1 = HEAPU8[$3_1 + 44 | 0] | HEAPU8[$3_1 + 45 | 0] << 8 | (HEAPU8[$3_1 + 46 | 0] << 16 | HEAPU8[$3_1 + 47 | 0] << 24);
   $14_1 = $8_1 >>> 8 | $10_1;
   HEAP32[$6_1 >> 2] = $14_1;
   $17_1 = $5_1 & 1048575;
   HEAP32[$6_1 + 4 >> 2] = $17_1;
   $5_1 = $7_1;
   $10_1 = $8_1 << 12 | $5_1 >>> 20;
   $7_1 = HEAPU8[$3_1 + 32 | 0] | HEAPU8[$3_1 + 33 | 0] << 8 | (HEAPU8[$3_1 + 34 | 0] << 16 | HEAPU8[$3_1 + 35 | 0] << 24);
   $6_1 = $4_1 + 56 | 0;
   $9_1 = HEAPU8[$3_1 + 36 | 0] | HEAPU8[$3_1 + 37 | 0] << 8 | (HEAPU8[$3_1 + 38 | 0] << 16 | HEAPU8[$3_1 + 39 | 0] << 24);
   $15_1 = $5_1 << 12 & -4096 | $9_1 >>> 20;
   HEAP32[$6_1 >> 2] = $15_1;
   $18_1 = $10_1 & 1048575;
   HEAP32[$6_1 + 4 >> 2] = $18_1;
   HEAP32[$4_1 + 88 >> 2] = 0;
   HEAP32[$4_1 + 48 >> 2] = $7_1;
   $19_1 = $9_1 & 1048575;
   HEAP32[$4_1 + 52 >> 2] = $19_1;
   $5_1 = HEAPU8[$3_1 + 12 | 0] | HEAPU8[$3_1 + 13 | 0] << 8 | (HEAPU8[$3_1 + 14 | 0] << 16 | HEAPU8[$3_1 + 15 | 0] << 24);
   $6_1 = $5_1;
   $8_1 = HEAPU8[$3_1 + 8 | 0] | HEAPU8[$3_1 + 9 | 0] << 8 | (HEAPU8[$3_1 + 10 | 0] << 16 | HEAPU8[$3_1 + 11 | 0] << 24);
   $9_1 = ($5_1 << 12 | $8_1 >>> 20) & 1048575;
   $5_1 = HEAPU8[$3_1 | 0] | HEAPU8[$3_1 + 1 | 0] << 8 | (HEAPU8[$3_1 + 2 | 0] << 16 | HEAPU8[$3_1 + 3 | 0] << 24);
   $12_1 = HEAPU8[$3_1 + 4 | 0] | HEAPU8[$3_1 + 5 | 0] << 8 | (HEAPU8[$3_1 + 6 | 0] << 16 | HEAPU8[$3_1 + 7 | 0] << 24);
   $20_1 = $8_1 << 12 & -4096 | $12_1 >>> 20;
   HEAP32[$4_1 + 16 >> 2] = $20_1;
   $25_1 = $9_1;
   HEAP32[$4_1 + 20 >> 2] = $9_1;
   $8_1 = $5_1;
   HEAP32[$4_1 + 8 >> 2] = $5_1;
   $21_1 = $12_1 & 1048575;
   HEAP32[$4_1 + 12 >> 2] = $21_1;
   $9_1 = HEAPU8[$3_1 + 28 | 0] | HEAPU8[$3_1 + 29 | 0] << 8 | (HEAPU8[$3_1 + 30 | 0] << 16 | HEAPU8[$3_1 + 31 | 0] << 24);
   $5_1 = $9_1 >>> 16 | 0;
   $10_1 = HEAPU8[$3_1 + 24 | 0] | HEAPU8[$3_1 + 25 | 0] << 8 | (HEAPU8[$3_1 + 26 | 0] << 16 | HEAPU8[$3_1 + 27 | 0] << 24);
   $12_1 = ($9_1 & 65535) << 16 | $10_1 >>> 16;
   HEAP32[$4_1 + 40 >> 2] = $12_1;
   $9_1 = $5_1;
   HEAP32[$4_1 + 44 >> 2] = $5_1;
   $5_1 = HEAPU8[$3_1 + 16 | 0] | HEAPU8[$3_1 + 17 | 0] << 8 | (HEAPU8[$3_1 + 18 | 0] << 16 | HEAPU8[$3_1 + 19 | 0] << 24);
   $26_1 = $5_1;
   $22_1 = HEAPU8[$3_1 + 20 | 0] | HEAPU8[$3_1 + 21 | 0] << 8 | (HEAPU8[$3_1 + 22 | 0] << 16 | HEAPU8[$3_1 + 23 | 0] << 24);
   $3_1 = $5_1;
   $23_1 = ($22_1 << 24 | $3_1 >>> 8) & 1048575;
   $6_1 = $3_1 << 24 & -16777216 | $6_1 >>> 8;
   HEAP32[$4_1 + 24 >> 2] = $6_1;
   HEAP32[$4_1 + 28 >> 2] = $23_1;
   $3_1 = $22_1;
   $5_1 = $3_1 >>> 28 | 0;
   $3_1 = ($3_1 & 268435455) << 4 | $26_1 >>> 28;
   HEAP32[$4_1 + 32 >> 2] = $3_1;
   $5_1 = $5_1 | $10_1 << 4 & 1048560;
   HEAP32[$4_1 + 36 >> 2] = $5_1;
   if (!($8_1 | $20_1 | $12_1 | $6_1 | $3_1 | ($25_1 | $21_1 | $9_1 | $23_1 | $5_1))) {
    FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](690116, HEAP32[$0_1 + 172 >> 2]);
    $0_1 = 0;
    break label$1;
   }
   if ($7_1 & 1) {
    HEAP32[$4_1 + 80 >> 2] = -4 - $11_1;
    HEAP32[$4_1 + 84 >> 2] = 262143 - (($11_1 >>> 0 > 4294967292) + $24_1 | 0);
    HEAP32[$4_1 + 72 >> 2] = -4 - $13_1;
    HEAP32[$4_1 + 76 >> 2] = 4194303 - (($13_1 >>> 0 > 4294967292) + $16_1 | 0);
    HEAP32[$4_1 + 64 >> 2] = -4 - $14_1;
    HEAP32[$4_1 + 68 >> 2] = 4194303 - (($14_1 >>> 0 > 4294967292) + $17_1 | 0);
    HEAP32[$4_1 + 56 >> 2] = -4 - $15_1;
    HEAP32[$4_1 + 60 >> 2] = 4194303 - (($15_1 >>> 0 > 4294967292) + $18_1 | 0);
    HEAP32[$4_1 + 48 >> 2] = -3908 - $7_1;
    HEAP32[$4_1 + 52 >> 2] = 4194299 - (($7_1 >>> 0 > 4294963388) + $19_1 | 0);
    $27_1 = 1;
   }
   if ($2_1) {
    HEAP32[$2_1 >> 2] = $27_1
   }
   $35($1_1, $4_1 + 8 | 0);
   $0_1 = 1;
  }
  global$0 = $4_1 + 96 | 0;
  return $0_1;
 }
 
 function $60($0_1, $1_1) {
  var $2_1 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0;
  $2_1 = global$0 - 256 | 0;
  global$0 = $2_1;
  label$1 : {
   if (!$1_1) {
    FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](689700, HEAP32[$0_1 + 172 >> 2]);
    break label$1;
   }
   $6_1 = $68($1_1, 96);
   if (!HEAP32[$0_1 >> 2]) {
    FUNCTION_TABLE[HEAP32[$0_1 + 168 >> 2]](690045, HEAP32[$0_1 + 172 >> 2]);
    break label$1;
   }
   $3_1 = $2_1 + 96 | 0;
   $7_1 = $2_1 + 128 | 0;
   $38($3_1, 690788, $7_1);
   $9_1 = HEAP32[$2_1 + 120 >> 2];
   $10_1 = HEAP32[$2_1 + 112 >> 2];
   $4_1 = HEAP32[$2_1 + 104 >> 2];
   $11_1 = HEAP32[$2_1 + 96 >> 2];
   $12_1 = HEAP32[$2_1 + 124 >> 2];
   $13_1 = HEAP32[$2_1 + 116 >> 2];
   $14_1 = HEAP32[$2_1 + 108 >> 2];
   $15_1 = HEAP32[$2_1 + 100 >> 2];
   $8_1 = HEAP32[$2_1 + 128 >> 2] | !($9_1 | ($10_1 | ($4_1 | $11_1)) | ($12_1 | ($13_1 | ($14_1 | $15_1))));
   $1_1 = $8_1 ? 0 : -1;
   HEAP32[$2_1 + 120 >> 2] = $1_1 & $9_1;
   HEAP32[$2_1 + 124 >> 2] = $1_1 & $12_1;
   HEAP32[$2_1 + 112 >> 2] = $1_1 & $10_1;
   HEAP32[$2_1 + 116 >> 2] = $1_1 & $13_1;
   HEAP32[$2_1 + 104 >> 2] = $1_1 & $4_1;
   HEAP32[$2_1 + 108 >> 2] = $1_1 & $14_1;
   $4_1 = ($8_1 | 0) != 0;
   HEAP32[$2_1 + 96 >> 2] = $4_1 | $1_1 & $11_1;
   HEAP32[$2_1 + 100 >> 2] = $1_1 & $15_1;
   $48($0_1, $7_1, $3_1);
   $0_1 = $2_1 + 8 | 0;
   $49($0_1, $7_1);
   $39($6_1, $3_1);
   $35($6_1 + 32 | 0, $0_1);
   HEAP32[$2_1 + 128 >> 2] = $4_1;
   $0_1 = HEAP32[$2_1 + 128 >> 2] - 1 | 0;
   while (1) {
    $1_1 = $5_1 + $6_1 | 0;
    HEAP8[$1_1 | 0] = HEAPU8[$1_1 | 0] & $0_1;
    $3_1 = $1_1 + 1 | 0;
    HEAP8[$3_1 | 0] = HEAPU8[$3_1 | 0] & $0_1;
    $3_1 = $1_1 + 2 | 0;
    HEAP8[$3_1 | 0] = HEAPU8[$3_1 | 0] & $0_1;
    $3_1 = $1_1 + 3 | 0;
    HEAP8[$3_1 | 0] = HEAPU8[$3_1 | 0] & $0_1;
    $3_1 = $1_1 + 4 | 0;
    HEAP8[$3_1 | 0] = HEAPU8[$3_1 | 0] & $0_1;
    $1_1 = $1_1 + 5 | 0;
    HEAP8[$1_1 | 0] = HEAPU8[$1_1 | 0] & $0_1;
    $5_1 = $5_1 + 6 | 0;
    if (($5_1 | 0) != 96) {
     continue
    }
    break;
   };
   $5_1 = !$8_1;
  }
  global$0 = $2_1 + 256 | 0;
  return $5_1;
 }
 
 function $61($0_1, $1_1, $2_1, $3_1, $4_1, $5_1, $6_1, $7_1) {
  $0_1 = $0_1 | 0;
  $1_1 = $1_1 | 0;
  $2_1 = $2_1 | 0;
  $3_1 = $3_1 | 0;
  $4_1 = $4_1 | 0;
  $5_1 = $5_1 | 0;
  $6_1 = $6_1 | 0;
  $7_1 = $7_1 | 0;
  var $8_1 = 0, $9_1 = 0;
  $8_1 = global$0 - 176 | 0;
  global$0 = $8_1;
  if ($5_1) {
   label$2 : {
    if (!$7_1) {
     HEAP8[$8_1 | 0] = HEAPU8[$3_1 | 0] ^ 84;
     HEAP8[$8_1 + 1 | 0] = HEAPU8[$3_1 + 1 | 0] ^ 241;
     HEAP8[$8_1 + 2 | 0] = HEAPU8[$3_1 + 2 | 0] ^ 105;
     HEAP8[$8_1 + 3 | 0] = HEAPU8[$3_1 + 3 | 0] ^ 207;
     HEAP8[$8_1 + 4 | 0] = HEAPU8[$3_1 + 4 | 0] ^ 201;
     HEAP8[$8_1 + 5 | 0] = HEAPU8[$3_1 + 5 | 0] ^ 226;
     HEAP8[$8_1 + 6 | 0] = HEAPU8[$3_1 + 6 | 0] ^ 229;
     HEAP8[$8_1 + 7 | 0] = HEAPU8[$3_1 + 7 | 0] ^ 114;
     HEAP8[$8_1 + 8 | 0] = HEAPU8[$3_1 + 8 | 0] ^ 116;
     HEAP8[$8_1 + 9 | 0] = HEAPU8[$3_1 + 9 | 0] ^ 128;
     HEAP8[$8_1 + 10 | 0] = HEAPU8[$3_1 + 10 | 0] ^ 68;
     HEAP8[$8_1 + 11 | 0] = HEAPU8[$3_1 + 11 | 0] ^ 31;
     HEAP8[$8_1 + 12 | 0] = HEAPU8[$3_1 + 12 | 0] ^ 144;
     HEAP8[$8_1 + 13 | 0] = HEAPU8[$3_1 + 13 | 0] ^ 186;
     HEAP8[$8_1 + 14 | 0] = HEAPU8[$3_1 + 14 | 0] ^ 37;
     HEAP8[$8_1 + 15 | 0] = HEAPU8[$3_1 + 15 | 0] ^ 196;
     HEAP8[$8_1 + 16 | 0] = HEAPU8[$3_1 + 16 | 0] ^ 136;
     HEAP8[$8_1 + 17 | 0] = HEAPU8[$3_1 + 17 | 0] ^ 244;
     HEAP8[$8_1 + 18 | 0] = HEAPU8[$3_1 + 18 | 0] ^ 97;
     HEAP8[$8_1 + 19 | 0] = HEAPU8[$3_1 + 19 | 0] ^ 199;
     HEAP8[$8_1 + 20 | 0] = HEAPU8[$3_1 + 20 | 0] ^ 11;
     HEAP8[$8_1 + 21 | 0] = HEAPU8[$3_1 + 21 | 0] ^ 94;
     HEAP8[$8_1 + 22 | 0] = HEAPU8[$3_1 + 22 | 0] ^ 165;
     HEAP8[$8_1 + 23 | 0] = HEAPU8[$3_1 + 23 | 0] ^ 220;
     HEAP8[$8_1 + 24 | 0] = HEAPU8[$3_1 + 24 | 0] ^ 170;
     HEAP8[$8_1 + 25 | 0] = HEAPU8[$3_1 + 25 | 0] ^ 247;
     HEAP8[$8_1 + 26 | 0] = HEAPU8[$3_1 + 26 | 0] ^ 175;
     HEAP8[$8_1 + 27 | 0] = HEAPU8[$3_1 + 27 | 0] ^ 105;
     HEAP8[$8_1 + 28 | 0] = HEAPU8[$3_1 + 28 | 0] ^ 39;
     HEAP8[$8_1 + 29 | 0] = HEAPU8[$3_1 + 29 | 0] ^ 10;
     HEAP8[$8_1 + 30 | 0] = HEAPU8[$3_1 + 30 | 0] ^ 165;
     HEAP8[$8_1 + 31 | 0] = HEAPU8[$3_1 + 31 | 0] ^ 20;
     break label$2;
    }
    HEAP32[$8_1 + 136 >> 2] = 64;
    HEAP32[$8_1 + 140 >> 2] = 0;
    HEAP32[$8_1 + 64 >> 2] = 1252796217;
    HEAP32[$8_1 + 68 >> 2] = 614368522;
    HEAP32[$8_1 + 56 >> 2] = 989586609;
    HEAP32[$8_1 + 60 >> 2] = 1279582103;
    HEAP32[$8_1 + 48 >> 2] = -904942663;
    HEAP32[$8_1 + 52 >> 2] = 262346349;
    HEAP32[$8_1 + 40 >> 2] = 618476057;
    HEAP32[$8_1 + 44 >> 2] = 1320844912;
    $9_1 = $8_1 + 40 | 0;
    $29($9_1, $7_1, 32);
    $30($9_1, $8_1);
    HEAP8[$8_1 | 0] = HEAPU8[$8_1 | 0] ^ HEAPU8[$3_1 | 0];
    HEAP8[$8_1 + 1 | 0] = HEAPU8[$8_1 + 1 | 0] ^ HEAPU8[$3_1 + 1 | 0];
    HEAP8[$8_1 + 2 | 0] = HEAPU8[$8_1 + 2 | 0] ^ HEAPU8[$3_1 + 2 | 0];
    HEAP8[$8_1 + 3 | 0] = HEAPU8[$8_1 + 3 | 0] ^ HEAPU8[$3_1 + 3 | 0];
    HEAP8[$8_1 + 4 | 0] = HEAPU8[$8_1 + 4 | 0] ^ HEAPU8[$3_1 + 4 | 0];
    HEAP8[$8_1 + 5 | 0] = HEAPU8[$8_1 + 5 | 0] ^ HEAPU8[$3_1 + 5 | 0];
    HEAP8[$8_1 + 6 | 0] = HEAPU8[$8_1 + 6 | 0] ^ HEAPU8[$3_1 + 6 | 0];
    HEAP8[$8_1 + 7 | 0] = HEAPU8[$8_1 + 7 | 0] ^ HEAPU8[$3_1 + 7 | 0];
    HEAP8[$8_1 + 8 | 0] = HEAPU8[$8_1 + 8 | 0] ^ HEAPU8[$3_1 + 8 | 0];
    HEAP8[$8_1 + 9 | 0] = HEAPU8[$8_1 + 9 | 0] ^ HEAPU8[$3_1 + 9 | 0];
    HEAP8[$8_1 + 10 | 0] = HEAPU8[$8_1 + 10 | 0] ^ HEAPU8[$3_1 + 10 | 0];
    HEAP8[$8_1 + 11 | 0] = HEAPU8[$8_1 + 11 | 0] ^ HEAPU8[$3_1 + 11 | 0];
    HEAP8[$8_1 + 12 | 0] = HEAPU8[$8_1 + 12 | 0] ^ HEAPU8[$3_1 + 12 | 0];
    HEAP8[$8_1 + 13 | 0] = HEAPU8[$8_1 + 13 | 0] ^ HEAPU8[$3_1 + 13 | 0];
    HEAP8[$8_1 + 14 | 0] = HEAPU8[$8_1 + 14 | 0] ^ HEAPU8[$3_1 + 14 | 0];
    HEAP8[$8_1 + 15 | 0] = HEAPU8[$8_1 + 15 | 0] ^ HEAPU8[$3_1 + 15 | 0];
    HEAP8[$8_1 + 16 | 0] = HEAPU8[$8_1 + 16 | 0] ^ HEAPU8[$3_1 + 16 | 0];
    HEAP8[$8_1 + 17 | 0] = HEAPU8[$8_1 + 17 | 0] ^ HEAPU8[$3_1 + 17 | 0];
    HEAP8[$8_1 + 18 | 0] = HEAPU8[$8_1 + 18 | 0] ^ HEAPU8[$3_1 + 18 | 0];
    HEAP8[$8_1 + 19 | 0] = HEAPU8[$8_1 + 19 | 0] ^ HEAPU8[$3_1 + 19 | 0];
    HEAP8[$8_1 + 20 | 0] = HEAPU8[$8_1 + 20 | 0] ^ HEAPU8[$3_1 + 20 | 0];
    HEAP8[$8_1 + 21 | 0] = HEAPU8[$8_1 + 21 | 0] ^ HEAPU8[$3_1 + 21 | 0];
    HEAP8[$8_1 + 22 | 0] = HEAPU8[$8_1 + 22 | 0] ^ HEAPU8[$3_1 + 22 | 0];
    HEAP8[$8_1 + 23 | 0] = HEAPU8[$8_1 + 23 | 0] ^ HEAPU8[$3_1 + 23 | 0];
    HEAP8[$8_1 + 24 | 0] = HEAPU8[$8_1 + 24 | 0] ^ HEAPU8[$3_1 + 24 | 0];
    HEAP8[$8_1 + 25 | 0] = HEAPU8[$8_1 + 25 | 0] ^ HEAPU8[$3_1 + 25 | 0];
    HEAP8[$8_1 + 26 | 0] = HEAPU8[$8_1 + 26 | 0] ^ HEAPU8[$3_1 + 26 | 0];
    HEAP8[$8_1 + 27 | 0] = HEAPU8[$8_1 + 27 | 0] ^ HEAPU8[$3_1 + 27 | 0];
    HEAP8[$8_1 + 28 | 0] = HEAPU8[$8_1 + 28 | 0] ^ HEAPU8[$3_1 + 28 | 0];
    HEAP8[$8_1 + 29 | 0] = HEAPU8[$8_1 + 29 | 0] ^ HEAPU8[$3_1 + 29 | 0];
    HEAP8[$8_1 + 30 | 0] = HEAPU8[$8_1 + 30 | 0] ^ HEAPU8[$3_1 + 30 | 0];
    HEAP8[$8_1 + 31 | 0] = HEAPU8[$8_1 + 31 | 0] ^ HEAPU8[$3_1 + 31 | 0];
   }
   label$4 : {
    if (($6_1 | 0) == 13) {
     label$6 : {
      if (HEAPU8[$5_1 | 0] != 66) {
       break label$6
      }
      if (HEAPU8[$5_1 + 1 | 0] != 73) {
       break label$6
      }
      if (HEAPU8[$5_1 + 2 | 0] != 80) {
       break label$6
      }
      if (HEAPU8[$5_1 + 3 | 0] != 48) {
       break label$6
      }
      if (HEAPU8[$5_1 + 4 | 0] != 51) {
       break label$6
      }
      if (HEAPU8[$5_1 + 5 | 0] != 52) {
       break label$6
      }
      if (HEAPU8[$5_1 + 6 | 0] != 48) {
       break label$6
      }
      if (HEAPU8[$5_1 + 7 | 0] != 47) {
       break label$6
      }
      if (HEAPU8[$5_1 + 8 | 0] != 110) {
       break label$6
      }
      if (HEAPU8[$5_1 + 9 | 0] != 111) {
       break label$6
      }
      if (HEAPU8[$5_1 + 10 | 0] != 110) {
       break label$6
      }
      if (HEAPU8[$5_1 + 11 | 0] != 99) {
       break label$6
      }
      if (HEAPU8[$5_1 + 12 | 0] != 101) {
       break label$6
      }
      HEAP32[$8_1 + 136 >> 2] = 64;
      HEAP32[$8_1 + 140 >> 2] = 0;
      HEAP32[$8_1 + 64 >> 2] = 564305492;
      HEAP32[$8_1 + 68 >> 2] = 1756396364;
      HEAP32[$8_1 + 56 >> 2] = 1612804480;
      HEAP32[$8_1 + 60 >> 2] = 1463125601;
      HEAP32[$8_1 + 48 >> 2] = -1618098575;
      HEAP32[$8_1 + 52 >> 2] = -2090698061;
      HEAP32[$8_1 + 40 >> 2] = 1180785461;
      HEAP32[$8_1 + 44 >> 2] = -188760073;
      break label$4;
     }
     HEAP32[$8_1 + 136 >> 2] = 0;
     HEAP32[$8_1 + 140 >> 2] = 0;
     HEAP32[$8_1 + 64 >> 2] = 528734635;
     HEAP32[$8_1 + 68 >> 2] = 1541459225;
     HEAP32[$8_1 + 56 >> 2] = 1359893119;
     HEAP32[$8_1 + 60 >> 2] = -1694144372;
     HEAP32[$8_1 + 48 >> 2] = 1013904242;
     HEAP32[$8_1 + 52 >> 2] = -1521486534;
     HEAP32[$8_1 + 40 >> 2] = 1779033703;
     HEAP32[$8_1 + 44 >> 2] = -1150833019;
     $3_1 = $8_1 + 40 | 0;
     $29($3_1, $5_1, 13);
     $5_1 = $8_1 + 144 | 0;
     $30($3_1, $5_1);
     HEAP32[$8_1 + 136 >> 2] = 0;
     HEAP32[$8_1 + 140 >> 2] = 0;
     HEAP32[$8_1 + 64 >> 2] = 528734635;
     HEAP32[$8_1 + 68 >> 2] = 1541459225;
     HEAP32[$8_1 + 56 >> 2] = 1359893119;
     HEAP32[$8_1 + 60 >> 2] = -1694144372;
     HEAP32[$8_1 + 48 >> 2] = 1013904242;
     HEAP32[$8_1 + 52 >> 2] = -1521486534;
     HEAP32[$8_1 + 40 >> 2] = 1779033703;
     HEAP32[$8_1 + 44 >> 2] = -1150833019;
     $29($3_1, $5_1, 32);
     $29($3_1, $5_1, 32);
     break label$4;
    }
    HEAP32[$8_1 + 136 >> 2] = 0;
    HEAP32[$8_1 + 140 >> 2] = 0;
    HEAP32[$8_1 + 64 >> 2] = 528734635;
    HEAP32[$8_1 + 68 >> 2] = 1541459225;
    HEAP32[$8_1 + 56 >> 2] = 1359893119;
    HEAP32[$8_1 + 60 >> 2] = -1694144372;
    HEAP32[$8_1 + 48 >> 2] = 1013904242;
    HEAP32[$8_1 + 52 >> 2] = -1521486534;
    HEAP32[$8_1 + 40 >> 2] = 1779033703;
    HEAP32[$8_1 + 44 >> 2] = -1150833019;
    $3_1 = $8_1 + 40 | 0;
    $29($3_1, $5_1, $6_1);
    $5_1 = $8_1 + 144 | 0;
    $30($3_1, $5_1);
    HEAP32[$8_1 + 136 >> 2] = 0;
    HEAP32[$8_1 + 140 >> 2] = 0;
    HEAP32[$8_1 + 64 >> 2] = 528734635;
    HEAP32[$8_1 + 68 >> 2] = 1541459225;
    HEAP32[$8_1 + 56 >> 2] = 1359893119;
    HEAP32[$8_1 + 60 >> 2] = -1694144372;
    HEAP32[$8_1 + 48 >> 2] = 1013904242;
    HEAP32[$8_1 + 52 >> 2] = -1521486534;
    HEAP32[$8_1 + 40 >> 2] = 1779033703;
    HEAP32[$8_1 + 44 >> 2] = -1150833019;
    $29($3_1, $5_1, 32);
    $29($3_1, $5_1, 32);
   }
   $3_1 = $8_1 + 40 | 0;
   $29($3_1, $8_1, 32);
   $29($3_1, $4_1, 32);
   $29($3_1, $1_1, $2_1);
   $30($3_1, $0_1);
   $0_1 = 1;
  } else {
   $0_1 = 0
  }
  global$0 = $8_1 + 176 | 0;
  return $0_1 | 0;
 }
 
 function $62($0_1, $1_1, $2_1) {
  var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0;
  $7_1 = global$0 - 32 | 0;
  global$0 = $7_1;
  $13_1 = $68($0_1, 516);
  $0_1 = $1_1 + 24 | 0;
  $10_1 = HEAP32[$0_1 >> 2];
  $0_1 = HEAP32[$0_1 + 4 >> 2];
  $4_1 = $7_1 + 24 | 0;
  HEAP32[$4_1 >> 2] = $10_1;
  HEAP32[$4_1 + 4 >> 2] = $0_1;
  $4_1 = $1_1 + 16 | 0;
  $3_1 = HEAP32[$4_1 + 4 >> 2];
  $5_1 = $7_1 + 16 | 0;
  HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
  HEAP32[$5_1 + 4 >> 2] = $3_1;
  $4_1 = $1_1 + 8 | 0;
  $3_1 = HEAP32[$4_1 + 4 >> 2];
  $5_1 = $7_1 + 8 | 0;
  HEAP32[$5_1 >> 2] = HEAP32[$4_1 >> 2];
  HEAP32[$5_1 + 4 >> 2] = $3_1;
  $4_1 = HEAP32[$1_1 + 4 >> 2];
  HEAP32[$7_1 >> 2] = HEAP32[$1_1 >> 2];
  HEAP32[$7_1 + 4 >> 2] = $4_1;
  $8_1 = 1;
  $4_1 = $0_1;
  if (($0_1 | 0) < 0) {
   $3_1 = HEAP32[$7_1 >> 2] ^ -1;
   $5_1 = $3_1 - 801750718 | 0;
   $6_1 = HEAP32[$7_1 + 4 >> 2] ^ -1;
   $1_1 = $6_1 - (($3_1 >>> 0 < 801750718) + 1076732275 | 0) | 0;
   HEAP32[$7_1 >> 2] = $5_1;
   HEAP32[$7_1 + 4 >> 2] = $1_1;
   $1_1 = ($1_1 | 0) == ($6_1 | 0) & $3_1 >>> 0 > $5_1 >>> 0 | $1_1 >>> 0 < $6_1 >>> 0;
   $0_1 = $7_1;
   $5_1 = HEAP32[$0_1 + 8 >> 2] ^ -1;
   $1_1 = $1_1 + $5_1 | 0;
   $6_1 = HEAP32[$0_1 + 12 >> 2] ^ -1;
   $3_1 = $6_1;
   $9_1 = $1_1 - 1354194885 | 0;
   HEAP32[$0_1 + 8 >> 2] = $9_1;
   $3_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $3_1 - (($1_1 >>> 0 < 1354194885) + 1162945305 | 0) | 0;
   HEAP32[$0_1 + 12 >> 2] = $8_1;
   $6_1 = ($3_1 | 0) == ($6_1 | 0) & $1_1 >>> 0 < $5_1 >>> 0 | $3_1 >>> 0 < $6_1 >>> 0;
   $5_1 = ($3_1 | 0) == ($8_1 | 0) & $1_1 >>> 0 > $9_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
   $1_1 = $6_1 + $5_1 | 0;
   $6_1 = HEAP32[$0_1 + 20 >> 2] ^ -1;
   $3_1 = $6_1 + ($1_1 >>> 0 < $5_1 >>> 0) | 0;
   $5_1 = HEAP32[$0_1 + 16 >> 2] ^ -1;
   $1_1 = $5_1 + $1_1 | 0;
   $9_1 = $1_1 - 2 | 0;
   HEAP32[$0_1 + 16 >> 2] = $9_1;
   $3_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $3_1 - ($1_1 >>> 0 < 2) | 0;
   HEAP32[$0_1 + 20 >> 2] = $8_1;
   $0_1 = ($3_1 | 0) == ($6_1 | 0) & $1_1 >>> 0 < $5_1 >>> 0 | $3_1 >>> 0 < $6_1 >>> 0;
   $3_1 = ($3_1 | 0) == ($8_1 | 0) & $1_1 >>> 0 > $9_1 >>> 0 | $3_1 >>> 0 > $8_1 >>> 0;
   $0_1 = $0_1 + $3_1 | 0;
   $1_1 = $0_1 >>> 0 < $3_1 >>> 0;
   $3_1 = $0_1 - $10_1 | 0;
   HEAP32[$7_1 + 24 >> 2] = $3_1 - 2;
   HEAP32[$7_1 + 28 >> 2] = ($1_1 - (($0_1 >>> 0 < $10_1 >>> 0) + $4_1 | 0) | 0) - ($3_1 >>> 0 < 2);
   $8_1 = -1;
  }
  $14_1 = $2_1 - 1 | 0;
  $10_1 = -1;
  $1_1 = 0;
  while (1) {
   $3_1 = $1_1 >>> 6 | 0;
   $12_1 = $3_1 << 3;
   $4_1 = $12_1 + $7_1 | 0;
   $0_1 = HEAP32[$4_1 >> 2];
   $5_1 = HEAP32[$4_1 + 4 >> 2];
   $6_1 = $1_1 & 63;
   $4_1 = $6_1 & 31;
   if ($6_1 >>> 0 >= 32) {
    $4_1 = $5_1 >>> $4_1 | 0
   } else {
    $4_1 = ((1 << $4_1) - 1 & $5_1) << 32 - $4_1 | $0_1 >>> $4_1
   }
   label$3 : {
    if (($11_1 | 0) == ($4_1 & 1)) {
     $0_1 = $1_1 + 1 | 0;
     break label$3;
    }
    $0_1 = 129 - $1_1 | 0;
    $9_1 = ($0_1 | 0) < ($2_1 | 0) ? $0_1 : $2_1;
    $0_1 = $9_1 + $1_1 | 0;
    if (($3_1 | 0) != ($0_1 - 1 >>> 6 | 0)) {
     $3_1 = ($7_1 + $12_1 | 0) + 8 | 0;
     $10_1 = HEAP32[$3_1 >> 2];
     $3_1 = 64 - $6_1 | 0;
     $6_1 = $3_1 & 31;
     $4_1 = (($3_1 & 63) >>> 0 < 32 ? $10_1 << $6_1 : 0) | $4_1;
    }
    $3_1 = $9_1 & 31;
    $4_1 = $11_1 + ($4_1 & ((($9_1 & 63) >>> 0 < 32 ? -1 << $3_1 : 0) ^ -1)) | 0;
    $11_1 = $4_1 >>> $14_1 & 1;
    HEAP32[$13_1 + ($1_1 << 2) >> 2] = Math_imul($4_1 - ($11_1 << $2_1) | 0, $8_1);
    $10_1 = $1_1;
   }
   $1_1 = $0_1;
   if (($1_1 | 0) < 129) {
    continue
   }
   break;
  };
  global$0 = $7_1 + 32 | 0;
  return $10_1 + 1 | 0;
 }
 
 function $63($0_1, $1_1, $2_1) {
  var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0;
  label$1 : {
   if (($2_1 | 0) > 0) {
    $3_1 = $1_1 + (($2_1 << 5) - 32 & -64) | 0;
    $1_1 = HEAP32[$3_1 >> 2];
    $2_1 = HEAP32[$3_1 + 4 >> 2] & 1048575;
    HEAP32[$0_1 >> 2] = $1_1;
    HEAP32[$0_1 + 4 >> 2] = $2_1;
    $1_1 = HEAP32[$3_1 + 8 >> 2];
    $2_1 = HEAP32[$3_1 + 12 >> 2] << 12 | $1_1 >>> 20;
    HEAP32[$0_1 + 8 >> 2] = $1_1 << 12 & -4096 | HEAP32[$3_1 + 4 >> 2] >>> 20;
    HEAP32[$0_1 + 12 >> 2] = $2_1 & 1048575;
    $1_1 = HEAP32[$3_1 + 16 >> 2];
    $2_1 = HEAP32[$3_1 + 20 >> 2] << 24 | $1_1 >>> 8;
    HEAP32[$0_1 + 16 >> 2] = $1_1 << 24 & -16777216 | HEAP32[$3_1 + 12 >> 2] >>> 8;
    HEAP32[$0_1 + 20 >> 2] = $2_1 & 1048575;
    $4_1 = HEAP32[$3_1 + 24 >> 2] << 4 & 1048560;
    $2_1 = HEAP32[$3_1 + 20 >> 2];
    $1_1 = $2_1 >>> 28 | 0;
    HEAP32[$0_1 + 24 >> 2] = ($2_1 & 268435455) << 4 | HEAP32[$3_1 + 16 >> 2] >>> 28;
    HEAP32[$0_1 + 28 >> 2] = $1_1 | $4_1;
    $1_1 = HEAP32[$3_1 + 28 >> 2];
    $2_1 = $1_1 >>> 16 | 0;
    HEAP32[$0_1 + 32 >> 2] = ($1_1 & 65535) << 16 | HEAP32[$3_1 + 24 >> 2] >>> 16;
    HEAP32[$0_1 + 36 >> 2] = $2_1;
    $1_1 = HEAP32[$3_1 + 36 >> 2] & 1048575;
    HEAP32[$0_1 + 40 >> 2] = HEAP32[$3_1 + 32 >> 2];
    HEAP32[$0_1 + 44 >> 2] = $1_1;
    $4_1 = $3_1 + 40 | 0;
    $1_1 = HEAP32[$4_1 >> 2];
    $2_1 = HEAP32[$4_1 + 4 >> 2] << 12 | $1_1 >>> 20;
    $5_1 = $0_1 + 48 | 0;
    HEAP32[$5_1 >> 2] = $1_1 << 12 & -4096 | HEAP32[$3_1 + 36 >> 2] >>> 20;
    HEAP32[$5_1 + 4 >> 2] = $2_1 & 1048575;
    $5_1 = $3_1 + 48 | 0;
    $1_1 = HEAP32[$5_1 >> 2];
    $2_1 = HEAP32[$5_1 + 4 >> 2] << 24 | $1_1 >>> 8;
    $6_1 = $0_1 + 56 | 0;
    HEAP32[$6_1 >> 2] = $1_1 << 24 & -16777216 | HEAP32[$4_1 + 4 >> 2] >>> 8;
    HEAP32[$6_1 + 4 >> 2] = $2_1 & 1048575;
    $3_1 = $3_1 + 56 | 0;
    $1_1 = HEAP32[$3_1 >> 2];
    $6_1 = $1_1 << 4 & 1048560;
    $2_1 = HEAP32[$5_1 + 4 >> 2];
    $1_1 = $2_1 >>> 28 | 0;
    $4_1 = $0_1 - -64 | 0;
    HEAP32[$4_1 >> 2] = ($2_1 & 268435455) << 4 | HEAP32[$5_1 >> 2] >>> 28;
    HEAP32[$4_1 + 4 >> 2] = $1_1 | $6_1;
    $1_1 = $0_1 + 72 | 0;
    $4_1 = HEAP32[$3_1 + 4 >> 2];
    HEAP32[$1_1 >> 2] = ($4_1 & 65535) << 16 | HEAP32[$3_1 >> 2] >>> 16;
    HEAP32[$1_1 + 4 >> 2] = $4_1 >>> 16;
    break label$1;
   }
   $3_1 = $1_1 + (($2_1 ^ -1) / 2 << 6) | 0;
   $1_1 = HEAP32[$3_1 >> 2];
   $2_1 = HEAP32[$3_1 + 4 >> 2] & 1048575;
   HEAP32[$0_1 >> 2] = $1_1;
   HEAP32[$0_1 + 4 >> 2] = $2_1;
   $1_1 = HEAP32[$3_1 + 8 >> 2];
   $2_1 = HEAP32[$3_1 + 12 >> 2] << 12 | $1_1 >>> 20;
   HEAP32[$0_1 + 8 >> 2] = $1_1 << 12 & -4096 | HEAP32[$3_1 + 4 >> 2] >>> 20;
   HEAP32[$0_1 + 12 >> 2] = $2_1 & 1048575;
   $1_1 = HEAP32[$3_1 + 16 >> 2];
   $2_1 = HEAP32[$3_1 + 20 >> 2] << 24 | $1_1 >>> 8;
   HEAP32[$0_1 + 16 >> 2] = $1_1 << 24 & -16777216 | HEAP32[$3_1 + 12 >> 2] >>> 8;
   HEAP32[$0_1 + 20 >> 2] = $2_1 & 1048575;
   $4_1 = HEAP32[$3_1 + 24 >> 2] << 4 & 1048560;
   $2_1 = HEAP32[$3_1 + 20 >> 2];
   $1_1 = $2_1 >>> 28 | 0;
   HEAP32[$0_1 + 24 >> 2] = ($2_1 & 268435455) << 4 | HEAP32[$3_1 + 16 >> 2] >>> 28;
   HEAP32[$0_1 + 28 >> 2] = $1_1 | $4_1;
   $1_1 = HEAP32[$3_1 + 28 >> 2];
   $2_1 = $1_1 >>> 16 | 0;
   HEAP32[$0_1 + 32 >> 2] = ($1_1 & 65535) << 16 | HEAP32[$3_1 + 24 >> 2] >>> 16;
   HEAP32[$0_1 + 36 >> 2] = $2_1;
   $6_1 = HEAP32[$3_1 + 36 >> 2] & 1048575;
   $9_1 = HEAP32[$3_1 + 32 >> 2];
   HEAP32[$0_1 + 40 >> 2] = $9_1;
   HEAP32[$0_1 + 44 >> 2] = $6_1;
   $4_1 = $3_1 + 40 | 0;
   $1_1 = HEAP32[$4_1 >> 2];
   $2_1 = HEAP32[$4_1 + 4 >> 2] << 12 | $1_1 >>> 20;
   $10_1 = $0_1 + 48 | 0;
   $5_1 = $10_1;
   $11_1 = $1_1 << 12 & -4096 | HEAP32[$3_1 + 36 >> 2] >>> 20;
   HEAP32[$5_1 >> 2] = $11_1;
   $13_1 = $2_1 & 1048575;
   HEAP32[$5_1 + 4 >> 2] = $13_1;
   $5_1 = $3_1 + 48 | 0;
   $1_1 = HEAP32[$5_1 >> 2];
   $2_1 = HEAP32[$5_1 + 4 >> 2] << 24 | $1_1 >>> 8;
   $7_1 = $0_1 + 56 | 0;
   $4_1 = $1_1 << 24 & -16777216 | HEAP32[$4_1 + 4 >> 2] >>> 8;
   HEAP32[$7_1 >> 2] = $4_1;
   $14_1 = $2_1 & 1048575;
   HEAP32[$7_1 + 4 >> 2] = $14_1;
   $3_1 = $3_1 + 56 | 0;
   $1_1 = HEAP32[$3_1 >> 2];
   $12_1 = $1_1 << 4 & 1048560;
   $2_1 = HEAP32[$5_1 + 4 >> 2];
   $1_1 = $2_1 >>> 28 | 0;
   $8_1 = $0_1 - -64 | 0;
   $2_1 = ($2_1 & 268435455) << 4 | HEAP32[$5_1 >> 2] >>> 28;
   HEAP32[$8_1 >> 2] = $2_1;
   $5_1 = $1_1 | $12_1;
   HEAP32[$8_1 + 4 >> 2] = $5_1;
   $12_1 = HEAP32[$3_1 >> 2];
   $1_1 = HEAP32[$3_1 + 4 >> 2];
   HEAP32[$8_1 >> 2] = -4 - $2_1;
   HEAP32[$8_1 + 4 >> 2] = 4194303 - (($2_1 >>> 0 > 4294967292) + $5_1 | 0);
   HEAP32[$7_1 >> 2] = -4 - $4_1;
   HEAP32[$7_1 + 4 >> 2] = 4194303 - (($4_1 >>> 0 > 4294967292) + $14_1 | 0);
   HEAP32[$10_1 >> 2] = -4 - $11_1;
   HEAP32[$10_1 + 4 >> 2] = 4194303 - (($11_1 >>> 0 > 4294967292) + $13_1 | 0);
   HEAP32[$0_1 + 40 >> 2] = -3908 - $9_1;
   HEAP32[$0_1 + 44 >> 2] = 4194299 - (($9_1 >>> 0 > 4294963388) + $6_1 | 0);
   $3_1 = $1_1 >>> 16 | 0;
   $2_1 = $0_1 + 72 | 0;
   $1_1 = ($1_1 & 65535) << 16 | $12_1 >>> 16;
   HEAP32[$2_1 >> 2] = -4 - $1_1;
   HEAP32[$2_1 + 4 >> 2] = 262143 - (($1_1 >>> 0 > 4294967292) + $3_1 | 0);
  }
  HEAP32[$0_1 + 80 >> 2] = 0;
 }
 
 function $64($0_1, $1_1, $2_1, $3_1) {
  var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0;
  $6_1 = global$0 - 1120 | 0;
  global$0 = $6_1;
  label$1 : {
   if (HEAP32[$1_1 + 120 >> 2]) {
    HEAP32[$0_1 + 120 >> 2] = HEAP32[$2_1 + 80 >> 2];
    $4_1 = $6_1 + 1080 | 0;
    $54($4_1, $3_1);
    $1_1 = $6_1 + 1040 | 0;
    $34($1_1, $4_1, $3_1);
    $34($0_1, $2_1, $4_1);
    $34($0_1 + 40 | 0, $2_1 + 40 | 0, $1_1);
    $1_1 = $0_1 + 88 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    HEAP32[$0_1 + 80 >> 2] = 1;
    HEAP32[$0_1 + 84 >> 2] = 0;
    $1_1 = $0_1 + 96 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $0_1 + 104 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $0_1 = $0_1 + 112 | 0;
    HEAP32[$0_1 >> 2] = 0;
    HEAP32[$0_1 + 4 >> 2] = 0;
    break label$1;
   }
   if (HEAP32[$2_1 + 80 >> 2]) {
    $70($0_1, $1_1, 128);
    break label$1;
   }
   $44_1 = $6_1 + 1080 | 0;
   $45_1 = $1_1 + 80 | 0;
   $34($44_1, $45_1, $3_1);
   $3_1 = HEAP32[$6_1 + 1084 >> 2];
   $15_1 = $3_1;
   $12_1 = HEAP32[$6_1 + 1080 >> 2];
   $4_1 = $12_1;
   $3_1 = $3_1 << 1 | $4_1 >>> 31;
   $13_1 = $6_1 + 408 | 0;
   $21_1 = HEAP32[$6_1 + 1104 >> 2];
   $19_1 = HEAP32[$6_1 + 1108 >> 2];
   $22_1 = $4_1 << 1;
   $27_1 = $3_1;
   $69($13_1, $21_1, $19_1, 0, 0, $22_1, $3_1, 0, 0);
   $3_1 = HEAP32[$6_1 + 1092 >> 2];
   $42_1 = $3_1;
   $41_1 = HEAP32[$6_1 + 1088 >> 2];
   $5_1 = $41_1;
   $3_1 = $3_1 << 1 | $5_1 >>> 31;
   $9_1 = $6_1 + 616 | 0;
   $18_1 = HEAP32[$6_1 + 1096 >> 2];
   $17_1 = HEAP32[$6_1 + 1100 >> 2];
   $5_1 = $5_1 << 1;
   $8_1 = $3_1;
   $69($9_1, $18_1, $17_1, 0, 0, $5_1, $3_1, 0, 0);
   $14_1 = $6_1 + 568 | 0;
   $4_1 = HEAP32[$6_1 + 1112 >> 2];
   $3_1 = HEAP32[$6_1 + 1116 >> 2];
   $69($14_1, $4_1, $3_1, 0, 0, $4_1, $3_1, 0, 0);
   $10_1 = $6_1 + 552 | 0;
   $69($10_1, HEAP32[$6_1 + 568 >> 2], HEAP32[$6_1 + 572 >> 2], 0, 0, 15632, 16, 0, 0);
   $3_1 = $3_1 << 1 | $4_1 >>> 31;
   $37_1 = $6_1 + 520 | 0;
   $28_1 = $4_1 << 1;
   $20_1 = $3_1;
   $69($37_1, $28_1, $3_1, 0, 0, $12_1, $15_1, 0, 0);
   $32_1 = $6_1 + 424 | 0;
   $69($32_1, $21_1, $19_1, 0, 0, $5_1, $8_1, 0, 0);
   $30_1 = $6_1 + 600 | 0;
   $69($30_1, $18_1, $17_1, 0, 0, $18_1, $17_1, 0, 0);
   $11_1 = $6_1 + 536 | 0;
   $3_1 = $14_1 + 8 | 0;
   $69($11_1, HEAP32[$3_1 >> 2], HEAP32[$3_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
   $39_1 = $6_1 + 664 | 0;
   $69($39_1, $12_1, $15_1, 0, 0, $12_1, $15_1, 0, 0);
   $38_1 = $6_1 + 504 | 0;
   $69($38_1, $28_1, $20_1, 0, 0, $41_1, $42_1, 0, 0);
   $35_1 = $6_1 + 440 | 0;
   $69($35_1, $21_1, $19_1, 0, 0, $18_1 << 1, $17_1 << 1 | $18_1 >>> 31, 0, 0);
   $15_1 = HEAP32[$6_1 + 412 >> 2];
   $3_1 = $15_1 + HEAP32[$6_1 + 620 >> 2] | 0;
   $7_1 = HEAP32[$6_1 + 408 >> 2];
   $5_1 = HEAP32[$6_1 + 616 >> 2];
   $4_1 = $7_1 + $5_1 | 0;
   $8_1 = HEAP32[$6_1 + 552 >> 2];
   $25_1 = $4_1 + $8_1 | 0;
   $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $5_1 + HEAP32[$6_1 + 556 >> 2] | 0;
   $8_1 = $8_1 >>> 0 > $25_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $12_1 = ($5_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $25_1 >>> 0 | $5_1 >>> 0 > $8_1 >>> 0;
   $3_1 = $10_1 + 8 | 0;
   $14_1 = HEAP32[$3_1 >> 2];
   $10_1 = HEAP32[$3_1 + 4 >> 2];
   $7_1 = ($5_1 | 0) == ($15_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 < $15_1 >>> 0;
   $5_1 = $9_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $13_1 + 8 | 0;
   $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $7_1 + $9_1 | 0;
   $3_1 = ($4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $10_1 | 0;
   $5_1 = $4_1;
   $4_1 = $4_1 + $14_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $12_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $33_1 = $8_1;
   $14_1 = $4_1 << 12 | $8_1 >>> 20;
   $5_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $29_1 = HEAP32[$6_1 + 424 >> 2];
   $4_1 = HEAP32[$6_1 + 600 >> 2];
   $12_1 = $29_1 + $4_1 | 0;
   $36_1 = HEAP32[$6_1 + 428 >> 2];
   $3_1 = $36_1 + HEAP32[$6_1 + 604 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 520 >> 2];
   $10_1 = $4_1 + $12_1 | 0;
   $13_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 524 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = HEAP32[$6_1 + 536 >> 2];
   $8_1 = $4_1 + $10_1 | 0;
   $9_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 540 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $7_1 | 0;
   $34_1 = $6_1 + 344 | 0;
   $31_1 = $34_1;
   $14_1 = $8_1 + $14_1 | 0;
   $7_1 = $14_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $26_1 = ($4_1 | 0) == ($7_1 | 0) & $8_1 >>> 0 > $14_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $23_1 = ($4_1 | 0) == ($9_1 | 0) & $8_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $9_1 >>> 0;
   $3_1 = $11_1 + 8 | 0;
   $24_1 = HEAP32[$3_1 >> 2];
   $16_1 = HEAP32[$3_1 + 4 >> 2];
   $15_1 = ($9_1 | 0) == ($13_1 | 0) & $12_1 >>> 0 > $10_1 >>> 0 | $9_1 >>> 0 < $13_1 >>> 0;
   $3_1 = $37_1 + 8 | 0;
   $11_1 = HEAP32[$3_1 >> 2];
   $9_1 = HEAP32[$3_1 + 4 >> 2];
   $10_1 = ($13_1 | 0) == ($36_1 | 0) & $12_1 >>> 0 < $29_1 >>> 0 | $13_1 >>> 0 < $36_1 >>> 0;
   $8_1 = $30_1 + 8 | 0;
   $4_1 = HEAP32[$8_1 >> 2];
   $3_1 = $32_1 + 8 | 0;
   $12_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $12_1 + $10_1 | 0;
   $3_1 = ($4_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $9_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + $11_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $4_1;
   $4_1 = $4_1 + $15_1 | 0;
   $3_1 = ($8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + $24_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $4_1 + $23_1 | 0;
   $3_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $8_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $26_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $7_1;
   $10_1 = $4_1 << 12 | $5_1 >>> 20;
   $8_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $15_1 = HEAP32[$6_1 + 504 >> 2];
   $4_1 = HEAP32[$6_1 + 440 >> 2];
   $13_1 = $15_1 + $4_1 | 0;
   $23_1 = HEAP32[$6_1 + 508 >> 2];
   $3_1 = $23_1 + HEAP32[$6_1 + 444 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $7_1 | 0;
   $10_1 = $10_1 + $13_1 | 0;
   $3_1 = $10_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $9_1 = $10_1 << 4 & -16;
   $7_1 = $3_1;
   $12_1 = ($3_1 << 4 | $10_1 >>> 28) & 16777215;
   $16_1 = $5_1;
   $69($31_1, $9_1 | $5_1 >>> 16 & 15, $12_1, 0, 0, 977, 1, 0, 0);
   $5_1 = $1_1 + 8 | 0;
   $3_1 = HEAP32[$5_1 + 4 >> 2];
   $12_1 = $6_1 + 1e3 | 0;
   $30_1 = $12_1 + 8 | 0;
   HEAP32[$30_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$30_1 + 4 >> 2] = $3_1;
   $5_1 = $1_1 + 16 | 0;
   $3_1 = HEAP32[$5_1 + 4 >> 2];
   $29_1 = $12_1 + 16 | 0;
   HEAP32[$29_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$29_1 + 4 >> 2] = $3_1;
   $5_1 = $1_1 + 24 | 0;
   $3_1 = HEAP32[$5_1 + 4 >> 2];
   $31_1 = $12_1 + 24 | 0;
   HEAP32[$31_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$31_1 + 4 >> 2] = $3_1;
   $5_1 = $1_1 + 32 | 0;
   $3_1 = HEAP32[$5_1 + 4 >> 2];
   $26_1 = $12_1 + 32 | 0;
   HEAP32[$26_1 >> 2] = HEAP32[$5_1 >> 2];
   HEAP32[$26_1 + 4 >> 2] = $3_1;
   $3_1 = HEAP32[$1_1 + 4 >> 2];
   HEAP32[$6_1 + 1e3 >> 2] = HEAP32[$1_1 >> 2];
   HEAP32[$6_1 + 1004 >> 2] = $3_1;
   $43_1 = HEAP32[$6_1 + 348 >> 2];
   $3_1 = $43_1 + HEAP32[$6_1 + 668 >> 2] | 0;
   $32_1 = HEAP32[$6_1 + 344 >> 2];
   $5_1 = HEAP32[$6_1 + 664 >> 2];
   $9_1 = $32_1 + $5_1 | 0;
   HEAP32[$6_1 + 1040 >> 2] = $9_1;
   $5_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$6_1 + 1044 >> 2] = $5_1 & 1048575;
   $46_1 = $6_1 + 648 | 0;
   $69($46_1, $41_1, $42_1, 0, 0, $22_1, $27_1, 0, 0);
   $40_1 = $6_1 + 488 | 0;
   $69($40_1, $28_1, $20_1, 0, 0, $18_1, $17_1, 0, 0);
   $36_1 = $6_1 + 456 | 0;
   $69($36_1, $21_1, $19_1, 0, 0, $21_1, $19_1, 0, 0);
   $37_1 = $6_1 + 392 | 0;
   $24_1 = $37_1;
   $11_1 = ($4_1 | 0) == ($7_1 | 0) & $10_1 >>> 0 < $13_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $13_1 = ($4_1 | 0) == ($23_1 | 0) & $13_1 >>> 0 < $15_1 >>> 0 | $4_1 >>> 0 < $23_1 >>> 0;
   $10_1 = $35_1 + 8 | 0;
   $4_1 = HEAP32[$10_1 >> 2];
   $3_1 = $38_1 + 8 | 0;
   $15_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $13_1 + $15_1 | 0;
   $3_1 = $10_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $8_1 >>> 20 | 0;
   $4_1 = $8_1 + $10_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $4_1;
   $4_1 = $4_1 + $11_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $13_1 = $4_1 << 12 | $7_1 >>> 20;
   $10_1 = $3_1;
   $7_1 = $3_1 << 12 | $4_1 >>> 20;
   $12_1 = HEAP32[$6_1 + 492 >> 2];
   $3_1 = $12_1 + HEAP32[$6_1 + 460 >> 2] | 0;
   $38_1 = HEAP32[$6_1 + 488 >> 2];
   $8_1 = HEAP32[$6_1 + 456 >> 2];
   $4_1 = $38_1 + $8_1 | 0;
   $23_1 = $4_1;
   $15_1 = $4_1 + $13_1 | 0;
   $8_1 = $4_1 >>> 0 < $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $8_1 + $7_1 | 0;
   $13_1 = $15_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($24_1, $15_1, $13_1 & 1048575, 0, 0, 15632, 16, 0, 0);
   $9_1 = ($5_1 | 0) == ($43_1 | 0) & $9_1 >>> 0 < $32_1 >>> 0 | $5_1 >>> 0 < $43_1 >>> 0;
   $7_1 = $39_1 + 8 | 0;
   $4_1 = HEAP32[$7_1 >> 2];
   $3_1 = $34_1 + 8 | 0;
   $11_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$7_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $9_1 + $11_1 | 0;
   $3_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $11_1 = $4_1 << 12 | $5_1 >>> 20;
   $7_1 = $3_1;
   $9_1 = $3_1 << 12 | $4_1 >>> 20;
   $39_1 = HEAP32[$6_1 + 396 >> 2];
   $3_1 = $39_1 + HEAP32[$6_1 + 652 >> 2] | 0;
   $35_1 = HEAP32[$6_1 + 392 >> 2];
   $5_1 = HEAP32[$6_1 + 648 >> 2];
   $4_1 = $35_1 + $5_1 | 0;
   $24_1 = $4_1;
   $11_1 = $4_1 + $11_1 | 0;
   $5_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $5_1 + $9_1 | 0;
   HEAP32[$6_1 + 1048 >> 2] = $11_1;
   $9_1 = $11_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$6_1 + 1052 >> 2] = $9_1 & 1048575;
   $34_1 = $6_1 + 584 | 0;
   $69($34_1, $18_1, $17_1, 0, 0, $22_1, $27_1, 0, 0);
   $32_1 = $6_1 + 632 | 0;
   $69($32_1, $41_1, $42_1, 0, 0, $41_1, $42_1, 0, 0);
   $27_1 = $6_1 + 472 | 0;
   $69($27_1, $28_1, $20_1, 0, 0, $21_1, $19_1, 0, 0);
   $22_1 = $6_1 + 376 | 0;
   $19_1 = $22_1;
   $17_1 = ($8_1 | 0) == ($13_1 | 0) & $15_1 >>> 0 < $23_1 >>> 0 | $8_1 >>> 0 > $13_1 >>> 0;
   $15_1 = ($8_1 | 0) == ($12_1 | 0) & $23_1 >>> 0 < $38_1 >>> 0 | $8_1 >>> 0 < $12_1 >>> 0;
   $8_1 = $36_1 + 8 | 0;
   $4_1 = HEAP32[$8_1 >> 2];
   $3_1 = $40_1 + 8 | 0;
   $21_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$8_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $15_1 + $21_1 | 0;
   $3_1 = $8_1 >>> 0 < $21_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $10_1 >>> 20 | 0;
   $4_1 = $8_1 + $10_1 | 0;
   $3_1 = $10_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $4_1;
   $4_1 = $4_1 + $17_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $20_1 = $4_1 << 12 | $13_1 >>> 20;
   $10_1 = HEAP32[$6_1 + 472 >> 2];
   $13_1 = $20_1 + $10_1 | 0;
   $8_1 = $3_1;
   $23_1 = $3_1 << 12 | $4_1 >>> 20;
   $3_1 = $23_1 + HEAP32[$6_1 + 476 >> 2] | 0;
   $15_1 = $10_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($19_1, $13_1, $15_1, 0, 0, 15632, 16, 0, 0);
   $11_1 = ($5_1 | 0) == ($9_1 | 0) & $11_1 >>> 0 < $24_1 >>> 0 | $5_1 >>> 0 > $9_1 >>> 0;
   $12_1 = ($5_1 | 0) == ($39_1 | 0) & $24_1 >>> 0 < $35_1 >>> 0 | $5_1 >>> 0 < $39_1 >>> 0;
   $5_1 = $46_1 + 8 | 0;
   $4_1 = HEAP32[$5_1 >> 2];
   $3_1 = $37_1 + 8 | 0;
   $17_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$5_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $12_1 + $17_1 | 0;
   $3_1 = $5_1 >>> 0 < $17_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $7_1 >>> 20 | 0;
   $4_1 = $5_1 + $7_1 | 0;
   $3_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $11_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $12_1 = $4_1 << 12 | $9_1 >>> 20;
   $5_1 = $3_1;
   $19_1 = $3_1 << 12 | $4_1 >>> 20;
   $18_1 = HEAP32[$6_1 + 584 >> 2];
   $4_1 = HEAP32[$6_1 + 632 >> 2];
   $9_1 = $18_1 + $4_1 | 0;
   $24_1 = HEAP32[$6_1 + 588 >> 2];
   $3_1 = $24_1 + HEAP32[$6_1 + 636 >> 2] | 0;
   $17_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $17_1 + HEAP32[$6_1 + 380 >> 2] | 0;
   $4_1 = HEAP32[$6_1 + 376 >> 2];
   $7_1 = $4_1 + $9_1 | 0;
   $11_1 = $7_1;
   $12_1 = $7_1 + $12_1 | 0;
   $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $4_1 + $19_1 | 0;
   HEAP32[$6_1 + 1056 >> 2] = $12_1;
   $7_1 = $12_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$6_1 + 1060 >> 2] = $7_1 & 1048575;
   $21_1 = $6_1 + 360 | 0;
   $19_1 = ($15_1 | 0) == ($23_1 | 0) & $13_1 >>> 0 < $20_1 >>> 0 | $15_1 >>> 0 < $23_1 >>> 0;
   $3_1 = $27_1 + 8 | 0;
   $15_1 = HEAP32[$3_1 >> 2];
   $3_1 = HEAP32[$3_1 + 4 >> 2];
   $8_1 = $8_1 >>> 20 | 0;
   $10_1 = $8_1;
   $8_1 = $8_1 + $15_1 | 0;
   $3_1 = $10_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $8_1;
   $8_1 = $8_1 + $19_1 | 0;
   $3_1 = $10_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($21_1, $8_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
   $19_1 = ($4_1 | 0) == ($7_1 | 0) & $12_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 > $7_1 >>> 0;
   $15_1 = ($4_1 | 0) == ($17_1 | 0) & $9_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 < $17_1 >>> 0;
   $3_1 = $22_1 + 8 | 0;
   $11_1 = HEAP32[$3_1 >> 2];
   $13_1 = HEAP32[$3_1 + 4 >> 2];
   $12_1 = ($17_1 | 0) == ($24_1 | 0) & $9_1 >>> 0 < $18_1 >>> 0 | $17_1 >>> 0 < $24_1 >>> 0;
   $10_1 = $32_1 + 8 | 0;
   $4_1 = HEAP32[$10_1 >> 2];
   $3_1 = $34_1 + 8 | 0;
   $9_1 = $4_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$10_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $9_1 + $12_1 | 0;
   $3_1 = ($4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $13_1 | 0;
   $8_1 = $4_1;
   $4_1 = $4_1 + $11_1 | 0;
   $3_1 = $8_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $4_1 + $15_1 | 0;
   $3_1 = $10_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $4_1 = $5_1 + $10_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $4_1;
   $4_1 = $4_1 + $19_1 | 0;
   $3_1 = $5_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $4_1 << 12 | $7_1 >>> 20;
   $5_1 = $3_1;
   $9_1 = $3_1 << 12 | $4_1 >>> 20;
   $11_1 = HEAP32[$6_1 + 360 >> 2];
   $7_1 = $25_1 & -2;
   $4_1 = $11_1 + $7_1 | 0;
   $15_1 = HEAP32[$6_1 + 364 >> 2];
   $3_1 = $15_1 + ($33_1 & 1048575) | 0;
   $12_1 = $4_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $12_1 + $9_1 | 0;
   $8_1 = $10_1;
   $10_1 = $4_1;
   $7_1 = $8_1 + $4_1 | 0;
   HEAP32[$6_1 + 1064 >> 2] = $7_1;
   $4_1 = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$6_1 + 1068 >> 2] = $4_1 & 1048575;
   $13_1 = $16_1 & 65535;
   $9_1 = ($4_1 | 0) == ($12_1 | 0) & $7_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $12_1 >>> 0;
   $7_1 = ($12_1 | 0) == ($15_1 | 0) & $10_1 >>> 0 < $11_1 >>> 0 | $12_1 >>> 0 < $15_1 >>> 0;
   $3_1 = $21_1 + 8 | 0;
   $10_1 = $7_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2];
   $3_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $5_1 >>> 20 | 0;
   $8_1 = $5_1;
   $5_1 = $5_1 + $10_1 | 0;
   $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $5_1;
   $5_1 = $5_1 + $9_1 | 0;
   $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $5_1 << 12 | $4_1 >>> 20;
   $7_1 = $4_1 + $14_1 | 0;
   $3_1 = $13_1 + ($3_1 << 12 | $5_1 >>> 20) | 0;
   HEAP32[$6_1 + 1072 >> 2] = $7_1;
   HEAP32[$6_1 + 1076 >> 2] = $4_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $14_1 = $30_1;
   $9_1 = HEAP32[$14_1 >> 2];
   $12_1 = HEAP32[$14_1 + 4 >> 2];
   $10_1 = HEAP32[$6_1 + 1004 >> 2];
   $7_1 = HEAP32[$26_1 >> 2];
   $4_1 = HEAP32[$26_1 + 4 >> 2];
   $11_1 = $4_1;
   $3_1 = HEAP32[$6_1 + 1e3 >> 2];
   $5_1 = __wasm_i64_mul($4_1 >>> 16 | 0, 0, 977, 1);
   $4_1 = $3_1 + $5_1 | 0;
   $3_1 = $10_1 + i64toi32_i32$HIGH_BITS | 0;
   $10_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $12_1;
   $5_1 = $10_1 >>> 20 | 0;
   $8_1 = $5_1;
   $5_1 = $5_1 + $9_1 | 0;
   $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $15_1 = $5_1;
   HEAP32[$14_1 >> 2] = $5_1;
   $30_1 = $3_1 & 1048575;
   HEAP32[$14_1 + 4 >> 2] = $30_1;
   $14_1 = $29_1;
   $9_1 = HEAP32[$14_1 >> 2];
   $5_1 = $3_1;
   $3_1 = HEAP32[$14_1 + 4 >> 2];
   $5_1 = $5_1 >>> 20 | 0;
   $8_1 = $5_1;
   $5_1 = $5_1 + $9_1 | 0;
   $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $13_1 = $5_1;
   HEAP32[$14_1 >> 2] = $5_1;
   $29_1 = $3_1 & 1048575;
   HEAP32[$14_1 + 4 >> 2] = $29_1;
   $14_1 = $31_1;
   $9_1 = HEAP32[$14_1 >> 2];
   $5_1 = $3_1;
   $3_1 = HEAP32[$14_1 + 4 >> 2];
   $5_1 = $5_1 >>> 20 | 0;
   $8_1 = $5_1;
   $5_1 = $5_1 + $9_1 | 0;
   $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $9_1 = $5_1;
   HEAP32[$14_1 >> 2] = $5_1;
   $31_1 = $3_1 & 1048575;
   HEAP32[$14_1 + 4 >> 2] = $31_1;
   $14_1 = $26_1;
   $5_1 = $3_1;
   $3_1 = $11_1 & 65535;
   $5_1 = $5_1 >>> 20 | 0;
   $8_1 = $5_1;
   $5_1 = $5_1 + $7_1 | 0;
   $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $21_1 = $5_1;
   HEAP32[$14_1 >> 2] = $5_1;
   $33_1 = $3_1;
   HEAP32[$14_1 + 4 >> 2] = $3_1;
   $14_1 = $4_1;
   HEAP32[$6_1 + 1e3 >> 2] = $4_1;
   $26_1 = $10_1 & 1048575;
   HEAP32[$6_1 + 1004 >> 2] = $26_1;
   $28_1 = $6_1 + 1040 | 0;
   $34($6_1 + 960 | 0, $2_1, $28_1);
   $17_1 = $6_1 + 920 | 0;
   $25_1 = $17_1 + 8 | 0;
   $3_1 = $1_1 + 48 | 0;
   $11_1 = HEAP32[$3_1 >> 2];
   $12_1 = HEAP32[$3_1 + 4 >> 2];
   $10_1 = HEAP32[$1_1 + 44 >> 2];
   $3_1 = $1_1 + 72 | 0;
   $7_1 = HEAP32[$3_1 >> 2];
   $4_1 = HEAP32[$3_1 + 4 >> 2];
   $16_1 = $4_1;
   $3_1 = HEAP32[$1_1 + 40 >> 2];
   $5_1 = __wasm_i64_mul($4_1 >>> 16 | 0, 0, 977, 1);
   $4_1 = $3_1 + $5_1 | 0;
   $3_1 = $10_1 + i64toi32_i32$HIGH_BITS | 0;
   $10_1 = $4_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $12_1;
   $5_1 = $10_1 >>> 20 | 0;
   $8_1 = $5_1;
   $5_1 = $5_1 + $11_1 | 0;
   $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $20_1 = $5_1;
   HEAP32[$25_1 >> 2] = $5_1;
   $23_1 = $3_1 & 1048575;
   HEAP32[$25_1 + 4 >> 2] = $23_1;
   $25_1 = $17_1 + 16 | 0;
   $5_1 = $1_1 + 56 | 0;
   $11_1 = HEAP32[$5_1 >> 2];
   $12_1 = HEAP32[$5_1 + 4 >> 2];
   $5_1 = $3_1;
   $3_1 = $12_1;
   $5_1 = $5_1 >>> 20 | 0;
   $8_1 = $5_1;
   $5_1 = $5_1 + $11_1 | 0;
   $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $18_1 = $5_1;
   HEAP32[$25_1 >> 2] = $5_1;
   $24_1 = $3_1 & 1048575;
   HEAP32[$25_1 + 4 >> 2] = $24_1;
   $25_1 = $17_1 + 24 | 0;
   $5_1 = $1_1 - -64 | 0;
   $11_1 = HEAP32[$5_1 >> 2];
   $12_1 = HEAP32[$5_1 + 4 >> 2];
   $5_1 = $3_1;
   $3_1 = $12_1;
   $5_1 = $5_1 >>> 20 | 0;
   $8_1 = $5_1;
   $5_1 = $5_1 + $11_1 | 0;
   $3_1 = $8_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $19_1 = $5_1;
   HEAP32[$25_1 >> 2] = $5_1;
   $27_1 = $3_1 & 1048575;
   HEAP32[$25_1 + 4 >> 2] = $27_1;
   $11_1 = $17_1 + 32 | 0;
   $5_1 = $3_1;
   $3_1 = $16_1 & 65535;
   $5_1 = $5_1 >>> 20 | 0;
   $7_1 = $5_1 + $7_1 | 0;
   $3_1 = $5_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $17_1 = $7_1;
   HEAP32[$11_1 >> 2] = $7_1;
   $5_1 = $3_1;
   HEAP32[$11_1 + 4 >> 2] = $3_1;
   $25_1 = $4_1;
   HEAP32[$6_1 + 920 >> 2] = $4_1;
   $22_1 = $10_1 & 1048575;
   HEAP32[$6_1 + 924 >> 2] = $22_1;
   $3_1 = $6_1 + 880 | 0;
   $34($3_1, $2_1 + 40 | 0, $28_1);
   $34($3_1, $3_1, $44_1);
   $4_1 = $6_1;
   $2_1 = HEAP32[$4_1 + 960 >> 2];
   $12_1 = ($2_1 - $14_1 | 0) - 3908 | 0;
   $3_1 = (HEAP32[$4_1 + 964 >> 2] - (($2_1 >>> 0 < $14_1 >>> 0) + $26_1 | 0) | 0) + 4194299 | 0;
   HEAP32[$4_1 + 840 >> 2] = $12_1;
   $10_1 = $12_1 >>> 0 < 4294963388 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$4_1 + 844 >> 2] = $10_1;
   $2_1 = HEAP32[$4_1 + 968 >> 2];
   $11_1 = ($2_1 - $15_1 | 0) - 4 | 0;
   $3_1 = (HEAP32[$4_1 + 972 >> 2] - (($2_1 >>> 0 < $15_1 >>> 0) + $30_1 | 0) | 0) + 4194303 | 0;
   HEAP32[$4_1 + 848 >> 2] = $11_1;
   $14_1 = $11_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$4_1 + 852 >> 2] = $14_1;
   $2_1 = HEAP32[$4_1 + 976 >> 2];
   $16_1 = ($2_1 - $13_1 | 0) - 4 | 0;
   $3_1 = (HEAP32[$4_1 + 980 >> 2] - (($2_1 >>> 0 < $13_1 >>> 0) + $29_1 | 0) | 0) + 4194303 | 0;
   HEAP32[$4_1 + 856 >> 2] = $16_1;
   $13_1 = $16_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$4_1 + 860 >> 2] = $13_1;
   $2_1 = HEAP32[$4_1 + 984 >> 2];
   $15_1 = ($2_1 - $9_1 | 0) - 4 | 0;
   $3_1 = (HEAP32[$4_1 + 988 >> 2] - (($2_1 >>> 0 < $9_1 >>> 0) + $31_1 | 0) | 0) + 4194303 | 0;
   HEAP32[$4_1 + 864 >> 2] = $15_1;
   $9_1 = $15_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$4_1 + 868 >> 2] = $9_1;
   $3_1 = HEAP32[$4_1 + 992 >> 2];
   $2_1 = ($3_1 - $21_1 | 0) - 4 | 0;
   $3_1 = (HEAP32[$4_1 + 996 >> 2] - (($3_1 >>> 0 < $21_1 >>> 0) + $33_1 | 0) | 0) + 262143 | 0;
   HEAP32[$4_1 + 872 >> 2] = $2_1;
   $7_1 = $2_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$4_1 + 876 >> 2] = $7_1;
   $3_1 = HEAP32[$4_1 + 912 >> 2];
   $33_1 = ($17_1 - $3_1 | 0) - 4 | 0;
   $3_1 = ($5_1 - (HEAP32[$4_1 + 916 >> 2] + ($3_1 >>> 0 > $17_1 >>> 0) | 0) | 0) + 262143 | 0;
   $5_1 = $33_1;
   HEAP32[$4_1 + 832 >> 2] = $5_1;
   $8_1 = $5_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$4_1 + 836 >> 2] = $8_1;
   $3_1 = HEAP32[$4_1 + 904 >> 2];
   $29_1 = ($19_1 - $3_1 | 0) - 4 | 0;
   $3_1 = ($27_1 - (HEAP32[$4_1 + 908 >> 2] + ($3_1 >>> 0 > $19_1 >>> 0) | 0) | 0) + 4194303 | 0;
   HEAP32[$4_1 + 824 >> 2] = $29_1;
   $21_1 = $29_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$4_1 + 828 >> 2] = $21_1;
   $3_1 = HEAP32[$4_1 + 896 >> 2];
   $31_1 = ($18_1 - $3_1 | 0) - 4 | 0;
   $3_1 = ($24_1 - (HEAP32[$4_1 + 900 >> 2] + ($3_1 >>> 0 > $18_1 >>> 0) | 0) | 0) + 4194303 | 0;
   HEAP32[$4_1 + 816 >> 2] = $31_1;
   $19_1 = $31_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$4_1 + 820 >> 2] = $19_1;
   $3_1 = HEAP32[$4_1 + 888 >> 2];
   $26_1 = ($20_1 - $3_1 | 0) - 4 | 0;
   $3_1 = ($23_1 - (HEAP32[$4_1 + 892 >> 2] + ($3_1 >>> 0 > $20_1 >>> 0) | 0) | 0) + 4194303 | 0;
   HEAP32[$4_1 + 808 >> 2] = $26_1;
   $17_1 = $26_1 >>> 0 < 4294967292 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$4_1 + 812 >> 2] = $17_1;
   $3_1 = HEAP32[$4_1 + 880 >> 2];
   $28_1 = ($25_1 - $3_1 | 0) - 3908 | 0;
   $3_1 = ($22_1 - (HEAP32[$4_1 + 884 >> 2] + ($3_1 >>> 0 > $25_1 >>> 0) | 0) | 0) + 4194299 | 0;
   HEAP32[$4_1 + 800 >> 2] = $28_1;
   $25_1 = $28_1 >>> 0 < 4294963388 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$4_1 + 804 >> 2] = $25_1;
   $4_1 = __wasm_i64_mul($7_1 >>> 16 | 0, 0, 977, 1) + $12_1 | 0;
   $3_1 = i64toi32_i32$HIGH_BITS + $10_1 | 0;
   $3_1 = $4_1 >>> 0 < $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $18_1 = $3_1 & 1048575;
   $35_1 = $18_1;
   label$4 : {
    $33_1 = $4_1;
    $34_1 = $4_1 ^ 976;
    $32_1 = $18_1 ^ 1;
    if ((($34_1 | 0) != -1 | ($32_1 | 0) != 1048575) & ($4_1 | $18_1) != 0) {
     break label$4
    }
    $30_1 = $7_1 & 65535;
    $4_1 = $3_1;
    $3_1 = $14_1;
    $4_1 = ($4_1 >>> 20 | 0) + $11_1 | 0;
    $3_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $23_1 = $4_1;
    $24_1 = $3_1;
    $3_1 = $13_1;
    $4_1 = ($24_1 >>> 20 | 0) + $16_1 | 0;
    $3_1 = $4_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $27_1 = $4_1;
    $22_1 = $3_1;
    $3_1 = $9_1;
    $4_1 = ($22_1 >>> 20 | 0) + $15_1 | 0;
    $3_1 = $4_1 >>> 0 < $15_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $20_1 = $4_1;
    $18_1 = $3_1;
    $3_1 = $30_1;
    $4_1 = $18_1 >>> 20 | 0;
    $30_1 = $4_1;
    $4_1 = $2_1 + $4_1 | 0;
    $3_1 = $30_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    if ($4_1 | ($20_1 | ($27_1 | ($23_1 | $33_1))) | ($3_1 | ($18_1 & 1048575 | ($22_1 & 1048575 | ($24_1 & 1048575 | $35_1))))) {
     if (($23_1 & $34_1 & $27_1 & $20_1 & $4_1) != -1) {
      $3_1 = 1
     } else {
      $3_1 = ($24_1 & $32_1 & $22_1 & $18_1 & ($3_1 ^ 983040)) != 1048575
     }
     if ($3_1) {
      break label$4
     }
    }
    $2_1 = __wasm_i64_mul($8_1 >>> 16 | 0, 0, 977, 1) + $28_1 | 0;
    $3_1 = i64toi32_i32$HIGH_BITS + $25_1 | 0;
    $3_1 = $2_1 >>> 0 < $28_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
    $7_1 = $3_1 & 1048575;
    $16_1 = $7_1;
    label$6 : {
     $4_1 = $2_1;
     $15_1 = $4_1 ^ 976;
     $11_1 = $7_1 ^ 1;
     if ((($15_1 | 0) != -1 | ($11_1 | 0) != 1048575) & ($4_1 | $7_1) != 0) {
      break label$6
     }
     $13_1 = $8_1 & 65535;
     $2_1 = $3_1;
     $3_1 = $17_1;
     $2_1 = ($2_1 >>> 20 | 0) + $26_1 | 0;
     $3_1 = $2_1 >>> 0 < $26_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
     $9_1 = $2_1;
     $12_1 = $3_1;
     $3_1 = $19_1;
     $2_1 = ($12_1 >>> 20 | 0) + $31_1 | 0;
     $3_1 = $2_1 >>> 0 < $31_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
     $14_1 = $2_1;
     $10_1 = $3_1;
     $3_1 = $21_1;
     $2_1 = ($10_1 >>> 20 | 0) + $29_1 | 0;
     $3_1 = $2_1 >>> 0 < $29_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
     $7_1 = $2_1;
     $8_1 = $3_1;
     $3_1 = $13_1;
     $2_1 = $8_1 >>> 20 | 0;
     $13_1 = $2_1;
     $2_1 = $2_1 + $5_1 | 0;
     $3_1 = $13_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
     if ($2_1 | ($7_1 | ($14_1 | ($4_1 | $9_1))) | ($3_1 | ($8_1 & 1048575 | ($10_1 & 1048575 | ($12_1 & 1048575 | $16_1))))) {
      if (($9_1 & $15_1 & $14_1 & $7_1 & $2_1) != -1) {
       $2_1 = 1
      } else {
       $2_1 = ($12_1 & $11_1 & $10_1 & $8_1 & ($3_1 ^ 983040)) != 1048575
      }
      if ($2_1) {
       break label$6
      }
     }
     if (HEAP32[$1_1 + 120 >> 2]) {
      HEAP32[$0_1 + 120 >> 2] = 1;
      $68($0_1, 120);
      break label$1;
     }
     $55($0_1, $1_1);
     break label$1;
    }
    HEAP32[$0_1 + 120 >> 2] = 1;
    $68($0_1, 120);
    break label$1;
   }
   HEAP32[$0_1 + 120 >> 2] = 0;
   $36_1 = $6_1 + 840 | 0;
   $34($0_1 + 80 | 0, $45_1, $36_1);
   $27_1 = $6_1 + 312 | 0;
   $8_1 = $15_1;
   $5_1 = $9_1;
   $19_1 = $12_1 << 1;
   $9_1 = $10_1;
   $21_1 = $9_1 << 1 | $12_1 >>> 31;
   $69($27_1, $8_1, $5_1, 0, 0, $19_1, $21_1, 0, 0);
   $20_1 = $6_1 + 232 | 0;
   $4_1 = $16_1;
   $1_1 = $13_1;
   $10_1 = $11_1 << 1;
   $15_1 = $14_1;
   $17_1 = $11_1;
   $14_1 = $14_1 << 1 | $11_1 >>> 31;
   $69($20_1, $4_1, $1_1, 0, 0, $10_1, $14_1, 0, 0);
   $11_1 = $6_1 + 168 | 0;
   $69($11_1, $2_1, $7_1, 0, 0, $2_1, $7_1, 0, 0);
   $16_1 = $6_1 + 152 | 0;
   $69($16_1, HEAP32[$6_1 + 168 >> 2], HEAP32[$6_1 + 172 >> 2], 0, 0, 15632, 16, 0, 0);
   $3_1 = $7_1 << 1 | $2_1 >>> 31;
   $37_1 = $6_1 + 120 | 0;
   $18_1 = $2_1 << 1;
   $25_1 = $3_1;
   $69($37_1, $18_1, $3_1, 0, 0, $12_1, $9_1, 0, 0);
   $38_1 = $6_1 + 280 | 0;
   $69($38_1, $8_1, $5_1, 0, 0, $10_1, $14_1, 0, 0);
   $35_1 = $6_1 + 216 | 0;
   $69($35_1, $4_1, $1_1, 0, 0, $4_1, $1_1, 0, 0);
   $22_1 = $6_1 + 136 | 0;
   $2_1 = $11_1 + 8 | 0;
   $69($22_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
   $34_1 = $6_1 + 328 | 0;
   $69($34_1, $12_1, $9_1, 0, 0, $12_1, $9_1, 0, 0);
   $32_1 = $6_1 + 104 | 0;
   $69($32_1, $18_1, $3_1, 0, 0, $17_1, $15_1, 0, 0);
   $9_1 = $1_1;
   $33_1 = $4_1;
   $3_1 = $1_1 << 1 | $4_1 >>> 31;
   $30_1 = $6_1 + 184 | 0;
   $11_1 = $8_1;
   $13_1 = $5_1;
   $69($30_1, $8_1, $5_1, 0, 0, $4_1 << 1, $3_1, 0, 0);
   $14_1 = HEAP32[$6_1 + 316 >> 2];
   $3_1 = $14_1 + HEAP32[$6_1 + 236 >> 2] | 0;
   $5_1 = HEAP32[$6_1 + 312 >> 2];
   $2_1 = HEAP32[$6_1 + 232 >> 2];
   $1_1 = $5_1 + $2_1 | 0;
   $4_1 = HEAP32[$6_1 + 152 >> 2];
   $12_1 = $1_1 + $4_1 | 0;
   $2_1 = $1_1 >>> 0 < $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $2_1 + HEAP32[$6_1 + 156 >> 2] | 0;
   $4_1 = $4_1 >>> 0 > $12_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = ($2_1 | 0) == ($4_1 | 0) & $1_1 >>> 0 > $12_1 >>> 0 | $2_1 >>> 0 > $4_1 >>> 0;
   $3_1 = $16_1 + 8 | 0;
   $7_1 = HEAP32[$3_1 >> 2];
   $8_1 = HEAP32[$3_1 + 4 >> 2];
   $5_1 = ($2_1 | 0) == ($14_1 | 0) & $1_1 >>> 0 < $5_1 >>> 0 | $2_1 >>> 0 < $14_1 >>> 0;
   $3_1 = $20_1 + 8 | 0;
   $2_1 = HEAP32[$3_1 >> 2];
   $1_1 = $27_1 + 8 | 0;
   $14_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
   $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
   $3_1 = $2_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $1_1 = $5_1 + $14_1 | 0;
   $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $8_1 | 0;
   $2_1 = $1_1;
   $1_1 = $1_1 + $7_1 | 0;
   $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $2_1 = $1_1;
   $1_1 = $1_1 + $10_1 | 0;
   $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $10_1 = $4_1;
   $8_1 = $1_1 << 12 | $4_1 >>> 20;
   $2_1 = $3_1;
   $5_1 = $3_1 << 12 | $1_1 >>> 20;
   $29_1 = HEAP32[$6_1 + 280 >> 2];
   $1_1 = HEAP32[$6_1 + 216 >> 2];
   $14_1 = $29_1 + $1_1 | 0;
   $40_1 = HEAP32[$6_1 + 284 >> 2];
   $3_1 = $40_1 + HEAP32[$6_1 + 220 >> 2] | 0;
   $3_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $1_1 = HEAP32[$6_1 + 120 >> 2];
   $7_1 = $1_1 + $14_1 | 0;
   $20_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 124 >> 2] | 0;
   $3_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $1_1 = HEAP32[$6_1 + 136 >> 2];
   $4_1 = $1_1 + $7_1 | 0;
   $16_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 140 >> 2] | 0;
   $1_1 = $1_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $1_1 + $5_1 | 0;
   $31_1 = $6_1 + 88 | 0;
   $5_1 = $4_1 + $8_1 | 0;
   $8_1 = $5_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $26_1 = ($1_1 | 0) == ($8_1 | 0) & $4_1 >>> 0 > $5_1 >>> 0 | $1_1 >>> 0 > $8_1 >>> 0;
   $28_1 = ($1_1 | 0) == ($16_1 | 0) & $4_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
   $1_1 = $22_1 + 8 | 0;
   $23_1 = HEAP32[$1_1 >> 2];
   $24_1 = HEAP32[$1_1 + 4 >> 2];
   $27_1 = ($16_1 | 0) == ($20_1 | 0) & $7_1 >>> 0 < $14_1 >>> 0 | $16_1 >>> 0 < $20_1 >>> 0;
   $1_1 = $37_1 + 8 | 0;
   $22_1 = HEAP32[$1_1 >> 2];
   $16_1 = HEAP32[$1_1 + 4 >> 2];
   $7_1 = ($20_1 | 0) == ($40_1 | 0) & $14_1 >>> 0 < $29_1 >>> 0 | $20_1 >>> 0 < $40_1 >>> 0;
   $3_1 = $35_1 + 8 | 0;
   $4_1 = HEAP32[$3_1 >> 2];
   $1_1 = $38_1 + 8 | 0;
   $14_1 = $4_1 + HEAP32[$1_1 >> 2] | 0;
   $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $1_1 = $7_1 + $14_1 | 0;
   $3_1 = ($1_1 >>> 0 < $14_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $16_1 | 0;
   $4_1 = $1_1;
   $1_1 = $1_1 + $22_1 | 0;
   $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $1_1;
   $1_1 = $1_1 + $27_1 | 0;
   $3_1 = ($4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $24_1 | 0;
   $4_1 = $1_1;
   $1_1 = $1_1 + $23_1 | 0;
   $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $1_1 + $28_1 | 0;
   $3_1 = $4_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $2_1 = $2_1 >>> 20 | 0;
   $1_1 = $2_1 + $4_1 | 0;
   $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $2_1 = $1_1;
   $1_1 = $1_1 + $26_1 | 0;
   $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $2_1 = $8_1;
   $7_1 = $1_1 << 12 | $2_1 >>> 20;
   $4_1 = $3_1;
   $8_1 = $3_1 << 12 | $1_1 >>> 20;
   $22_1 = HEAP32[$6_1 + 104 >> 2];
   $1_1 = HEAP32[$6_1 + 184 >> 2];
   $16_1 = $22_1 + $1_1 | 0;
   $26_1 = HEAP32[$6_1 + 108 >> 2];
   $3_1 = $26_1 + HEAP32[$6_1 + 188 >> 2] | 0;
   $1_1 = $1_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $1_1 + $8_1 | 0;
   $7_1 = $7_1 + $16_1 | 0;
   $3_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $20_1 = $7_1 << 4 & -16;
   $14_1 = $2_1;
   $8_1 = $3_1;
   $69($31_1, $20_1 | $2_1 >>> 16 & 15, ($3_1 << 4 | $7_1 >>> 28) & 16777215, 0, 0, 977, 1, 0, 0);
   $28_1 = $6_1 + 264 | 0;
   $69($28_1, $17_1, $15_1, 0, 0, $19_1, $21_1, 0, 0);
   $23_1 = $6_1 + 72 | 0;
   $69($23_1, $18_1, $25_1, 0, 0, $33_1, $9_1, 0, 0);
   $24_1 = $6_1 + 296 | 0;
   $69($24_1, $11_1, $13_1, 0, 0, $11_1, $13_1, 0, 0);
   $27_1 = $6_1 + 56 | 0;
   $20_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $16_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
   $7_1 = ($1_1 | 0) == ($26_1 | 0) & $16_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $26_1 >>> 0;
   $3_1 = $30_1 + 8 | 0;
   $2_1 = HEAP32[$3_1 >> 2];
   $1_1 = $32_1 + 8 | 0;
   $16_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
   $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
   $3_1 = $2_1 >>> 0 > $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $2_1 = $7_1 + $16_1 | 0;
   $3_1 = $2_1 >>> 0 < $16_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $4_1 >>> 20 | 0;
   $1_1 = $2_1 + $4_1 | 0;
   $3_1 = $4_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $2_1 = $1_1;
   $1_1 = $1_1 + $20_1 | 0;
   $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $1_1 << 12 | $8_1 >>> 20;
   $2_1 = $3_1;
   $4_1 = $3_1 << 12 | $1_1 >>> 20;
   $22_1 = HEAP32[$6_1 + 72 >> 2];
   $1_1 = HEAP32[$6_1 + 296 >> 2];
   $7_1 = $22_1 + $1_1 | 0;
   $26_1 = HEAP32[$6_1 + 76 >> 2];
   $3_1 = $26_1 + HEAP32[$6_1 + 300 >> 2] | 0;
   $1_1 = $1_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $1_1 + $4_1 | 0;
   $8_1 = $8_1 + $7_1 | 0;
   $3_1 = $8_1 >>> 0 < $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $4_1 = $3_1;
   $69($27_1, $8_1, $3_1 & 1048575, 0, 0, 15632, 16, 0, 0);
   $20_1 = $6_1 + 200 | 0;
   $69($20_1, $33_1, $9_1, 0, 0, $19_1, $21_1, 0, 0);
   $21_1 = $6_1 + 248 | 0;
   $69($21_1, $17_1, $15_1, 0, 0, $17_1, $15_1, 0, 0);
   $16_1 = $6_1 + 40 | 0;
   $69($16_1, $18_1, $25_1, 0, 0, $11_1, $13_1, 0, 0);
   $15_1 = $6_1 + 24 | 0;
   $13_1 = $15_1;
   $9_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 < $7_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
   $7_1 = ($1_1 | 0) == ($26_1 | 0) & $7_1 >>> 0 < $22_1 >>> 0 | $1_1 >>> 0 < $26_1 >>> 0;
   $3_1 = $24_1 + 8 | 0;
   $8_1 = HEAP32[$3_1 >> 2];
   $1_1 = $23_1 + 8 | 0;
   $11_1 = $8_1 + HEAP32[$1_1 >> 2] | 0;
   $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
   $3_1 = $8_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $7_1 + $11_1 | 0;
   $3_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $2_1 = $2_1 >>> 20 | 0;
   $1_1 = $2_1 + $8_1 | 0;
   $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $2_1 = $1_1;
   $1_1 = $1_1 + $9_1 | 0;
   $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $8_1 = $1_1 << 12 | $4_1 >>> 20;
   $4_1 = HEAP32[$6_1 + 40 >> 2];
   $9_1 = $8_1 + $4_1 | 0;
   $2_1 = $3_1;
   $1_1 = $3_1 << 12 | $1_1 >>> 20;
   $3_1 = $1_1 + HEAP32[$6_1 + 44 >> 2] | 0;
   $3_1 = $4_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($13_1, $9_1, $3_1, 0, 0, 15632, 16, 0, 0);
   $19_1 = $6_1 + 8 | 0;
   $7_1 = $19_1;
   $8_1 = ($1_1 | 0) == ($3_1 | 0) & $8_1 >>> 0 > $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
   $1_1 = $16_1 + 8 | 0;
   $4_1 = HEAP32[$1_1 >> 2];
   $3_1 = HEAP32[$1_1 + 4 >> 2];
   $2_1 = $2_1 >>> 20 | 0;
   $1_1 = $2_1 + $4_1 | 0;
   $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $2_1 = $1_1;
   $1_1 = $1_1 + $8_1 | 0;
   $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $69($7_1, $1_1, $3_1, 0, 0, 64028672, 65536, 0, 0);
   $9_1 = HEAP32[$6_1 + 92 >> 2];
   $3_1 = $9_1 + HEAP32[$6_1 + 332 >> 2] | 0;
   $7_1 = HEAP32[$6_1 + 88 >> 2];
   $2_1 = HEAP32[$6_1 + 328 >> 2];
   $1_1 = $7_1 + $2_1 | 0;
   HEAP32[$6_1 + 760 >> 2] = -3908 - $1_1;
   $4_1 = $1_1 >>> 0 < $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$6_1 + 764 >> 2] = 4194299 - (($4_1 & 1048575) + ($1_1 >>> 0 > 4294963388) | 0);
   $7_1 = ($4_1 | 0) == ($9_1 | 0) & $1_1 >>> 0 < $7_1 >>> 0 | $4_1 >>> 0 < $9_1 >>> 0;
   $3_1 = $34_1 + 8 | 0;
   $2_1 = HEAP32[$3_1 >> 2];
   $1_1 = $31_1 + 8 | 0;
   $9_1 = $2_1 + HEAP32[$1_1 >> 2] | 0;
   $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
   $3_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $1_1 = $7_1 + $9_1 | 0;
   $3_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $1_1 << 12 | $4_1 >>> 20;
   $2_1 = $3_1;
   $13_1 = $3_1 << 12 | $1_1 >>> 20;
   $16_1 = HEAP32[$6_1 + 60 >> 2];
   $3_1 = $16_1 + HEAP32[$6_1 + 268 >> 2] | 0;
   $11_1 = HEAP32[$6_1 + 56 >> 2];
   $1_1 = HEAP32[$6_1 + 264 >> 2];
   $4_1 = $11_1 + $1_1 | 0;
   $9_1 = $4_1;
   $7_1 = $4_1 + $7_1 | 0;
   $1_1 = $1_1 >>> 0 > $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $1_1 + $13_1 | 0;
   $4_1 = $7_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $7_1;
   HEAP32[$6_1 + 768 >> 2] = -4 - $3_1;
   HEAP32[$6_1 + 772 >> 2] = 4194303 - (($4_1 & 1048575) + ($3_1 >>> 0 > 4294967292) | 0);
   $13_1 = ($1_1 | 0) == ($4_1 | 0) & $3_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $4_1 >>> 0;
   $9_1 = ($1_1 | 0) == ($16_1 | 0) & $9_1 >>> 0 < $11_1 >>> 0 | $1_1 >>> 0 < $16_1 >>> 0;
   $3_1 = $28_1 + 8 | 0;
   $7_1 = HEAP32[$3_1 >> 2];
   $1_1 = $27_1 + 8 | 0;
   $11_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
   $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
   $3_1 = $7_1 >>> 0 > $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $9_1 + $11_1 | 0;
   $3_1 = $7_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $2_1 = $2_1 >>> 20 | 0;
   $1_1 = $2_1 + $7_1 | 0;
   $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $2_1 = $1_1;
   $1_1 = $1_1 + $13_1 | 0;
   $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $1_1 << 12 | $4_1 >>> 20;
   $2_1 = $3_1;
   $4_1 = $3_1 << 12 | $1_1 >>> 20;
   $17_1 = HEAP32[$6_1 + 200 >> 2];
   $1_1 = HEAP32[$6_1 + 248 >> 2];
   $13_1 = $17_1 + $1_1 | 0;
   $18_1 = HEAP32[$6_1 + 204 >> 2];
   $3_1 = $18_1 + HEAP32[$6_1 + 252 >> 2] | 0;
   $3_1 = $1_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $1_1 = HEAP32[$6_1 + 24 >> 2];
   $9_1 = $1_1 + $13_1 | 0;
   $11_1 = $3_1;
   $3_1 = $3_1 + HEAP32[$6_1 + 28 >> 2] | 0;
   $1_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $1_1 + $4_1 | 0;
   $7_1 = $7_1 + $9_1 | 0;
   $3_1 = $7_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$6_1 + 776 >> 2] = -4 - $7_1;
   $4_1 = $3_1;
   HEAP32[$6_1 + 780 >> 2] = 4194303 - (($3_1 & 1048575) + ($7_1 >>> 0 > 4294967292) | 0);
   $25_1 = ($1_1 | 0) == ($3_1 | 0) & $7_1 >>> 0 < $9_1 >>> 0 | $1_1 >>> 0 > $3_1 >>> 0;
   $33_1 = ($1_1 | 0) == ($11_1 | 0) & $9_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $11_1 >>> 0;
   $1_1 = $15_1 + 8 | 0;
   $16_1 = HEAP32[$1_1 >> 2];
   $15_1 = HEAP32[$1_1 + 4 >> 2];
   $9_1 = ($11_1 | 0) == ($18_1 | 0) & $13_1 >>> 0 < $17_1 >>> 0 | $11_1 >>> 0 < $18_1 >>> 0;
   $3_1 = $21_1 + 8 | 0;
   $7_1 = HEAP32[$3_1 >> 2];
   $1_1 = $20_1 + 8 | 0;
   $13_1 = $7_1 + HEAP32[$1_1 >> 2] | 0;
   $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
   $3_1 = $7_1 >>> 0 > $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $1_1 = $9_1 + $13_1 | 0;
   $3_1 = ($1_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) + $15_1 | 0;
   $8_1 = $1_1;
   $1_1 = $1_1 + $16_1 | 0;
   $3_1 = $8_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $1_1 + $33_1 | 0;
   $3_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $2_1 = $2_1 >>> 20 | 0;
   $1_1 = $2_1 + $7_1 | 0;
   $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $2_1 = $1_1;
   $1_1 = $1_1 + $25_1 | 0;
   $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $7_1 = $1_1 << 12 | $4_1 >>> 20;
   $2_1 = $3_1;
   $11_1 = $3_1 << 12 | $1_1 >>> 20;
   $15_1 = HEAP32[$6_1 + 12 >> 2];
   $3_1 = $15_1 + ($10_1 & 1048575) | 0;
   $13_1 = HEAP32[$6_1 + 8 >> 2];
   $4_1 = $12_1 & -2;
   $1_1 = $13_1 + $4_1 | 0;
   $12_1 = $1_1;
   $7_1 = $1_1 + $7_1 | 0;
   $9_1 = $1_1 >>> 0 < $4_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $9_1 + $11_1 | 0;
   HEAP32[$6_1 + 784 >> 2] = -4 - $7_1;
   $1_1 = $7_1 >>> 0 < $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$6_1 + 788 >> 2] = 4194303 - (($1_1 & 1048575) + ($7_1 >>> 0 > 4294967292) | 0);
   $4_1 = $6_1;
   $10_1 = $5_1;
   $14_1 = $14_1 & 65535;
   $7_1 = ($1_1 | 0) == ($9_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $1_1 >>> 0 < $9_1 >>> 0;
   $5_1 = ($9_1 | 0) == ($15_1 | 0) & $12_1 >>> 0 < $13_1 >>> 0 | $9_1 >>> 0 < $15_1 >>> 0;
   $3_1 = $19_1 + 8 | 0;
   $8_1 = $5_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2];
   $3_1 = $5_1 >>> 0 > $8_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $2_1 = $2_1 >>> 20 | 0;
   $5_1 = $2_1;
   $2_1 = $2_1 + $8_1 | 0;
   $3_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $2_1;
   $2_1 = $2_1 + $7_1 | 0;
   $3_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $1_1 = $2_1 << 12 | $1_1 >>> 20;
   $5_1 = $1_1 + $10_1 | 0;
   $3_1 = $14_1 + ($3_1 << 12 | $2_1 >>> 20) | 0;
   HEAP32[$4_1 + 792 >> 2] = -4 - $5_1;
   HEAP32[$4_1 + 796 >> 2] = 262143 - (($5_1 >>> 0 > 4294967292) + ($1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1) | 0);
   $23_1 = $4_1 + 720 | 0;
   $1_1 = $4_1 + 760 | 0;
   $34($23_1, $1_1, $36_1);
   $27_1 = $4_1 + 680 | 0;
   $34($27_1, $4_1 + 1e3 | 0, $1_1);
   $22_1 = $4_1 + 800 | 0;
   $54($0_1, $22_1);
   $1_1 = HEAP32[$4_1 + 752 >> 2];
   $5_1 = $1_1 + HEAP32[$0_1 + 32 >> 2] | 0;
   $3_1 = HEAP32[$0_1 + 36 >> 2] + HEAP32[$4_1 + 756 >> 2] | 0;
   $2_1 = $1_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $1_1 = HEAP32[$4_1 + 712 >> 2];
   $20_1 = $1_1;
   $3_1 = HEAP32[$4_1 + 716 >> 2];
   $18_1 = $3_1;
   $3_1 = ($3_1 << 1 | $1_1 >>> 31) + $2_1 | 0;
   $1_1 = $1_1 << 1;
   $2_1 = $1_1;
   $1_1 = $1_1 + $5_1 | 0;
   $3_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $11_1 = $1_1;
   HEAP32[$0_1 + 32 >> 2] = $1_1;
   $12_1 = $3_1;
   HEAP32[$0_1 + 36 >> 2] = $3_1;
   $1_1 = $0_1;
   $0_1 = HEAP32[$4_1 + 744 >> 2];
   $5_1 = $0_1 + HEAP32[$1_1 + 24 >> 2] | 0;
   $3_1 = HEAP32[$1_1 + 28 >> 2] + HEAP32[$4_1 + 748 >> 2] | 0;
   $2_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $0_1 = HEAP32[$4_1 + 704 >> 2];
   $21_1 = $0_1;
   $3_1 = HEAP32[$4_1 + 708 >> 2];
   $19_1 = $3_1;
   $3_1 = ($3_1 << 1 | $0_1 >>> 31) + $2_1 | 0;
   $0_1 = $0_1 << 1;
   $2_1 = $0_1;
   $0_1 = $0_1 + $5_1 | 0;
   $3_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $13_1 = $0_1;
   HEAP32[$1_1 + 24 >> 2] = $0_1;
   $14_1 = $3_1;
   HEAP32[$1_1 + 28 >> 2] = $3_1;
   $0_1 = HEAP32[$4_1 + 736 >> 2];
   $5_1 = $0_1 + HEAP32[$1_1 + 16 >> 2] | 0;
   $3_1 = HEAP32[$1_1 + 20 >> 2] + HEAP32[$4_1 + 740 >> 2] | 0;
   $2_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $0_1 = HEAP32[$4_1 + 696 >> 2];
   $17_1 = $0_1;
   $3_1 = HEAP32[$4_1 + 700 >> 2];
   $25_1 = $3_1;
   $3_1 = ($3_1 << 1 | $0_1 >>> 31) + $2_1 | 0;
   $0_1 = $0_1 << 1;
   $2_1 = $0_1;
   $0_1 = $0_1 + $5_1 | 0;
   $3_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $9_1 = $0_1;
   HEAP32[$1_1 + 16 >> 2] = $0_1;
   $10_1 = $3_1;
   HEAP32[$1_1 + 20 >> 2] = $3_1;
   $0_1 = HEAP32[$4_1 + 728 >> 2];
   $2_1 = $0_1 + HEAP32[$1_1 + 8 >> 2] | 0;
   $3_1 = HEAP32[$1_1 + 12 >> 2] + HEAP32[$4_1 + 732 >> 2] | 0;
   $0_1 = $0_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = HEAP32[$4_1 + 692 >> 2];
   $33_1 = $3_1;
   $24_1 = HEAP32[$4_1 + 688 >> 2];
   $5_1 = $24_1;
   $3_1 = ($3_1 << 1 | $5_1 >>> 31) + $0_1 | 0;
   $5_1 = $5_1 << 1;
   $7_1 = $2_1 + $5_1 | 0;
   $3_1 = $5_1 >>> 0 > $7_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$1_1 + 8 >> 2] = $7_1;
   $8_1 = $3_1;
   HEAP32[$1_1 + 12 >> 2] = $3_1;
   $0_1 = HEAP32[$4_1 + 720 >> 2];
   $5_1 = $0_1 + HEAP32[$1_1 >> 2] | 0;
   $3_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$4_1 + 724 >> 2] | 0;
   $2_1 = $0_1 >>> 0 > $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $0_1 = HEAP32[$4_1 + 680 >> 2];
   $16_1 = $0_1;
   $3_1 = HEAP32[$4_1 + 684 >> 2];
   $15_1 = $3_1;
   $3_1 = ($3_1 << 1 | $0_1 >>> 31) + $2_1 | 0;
   $0_1 = $0_1 << 1;
   $2_1 = $0_1;
   $0_1 = $0_1 + $5_1 | 0;
   $3_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $5_1 = $0_1;
   HEAP32[$1_1 >> 2] = $5_1;
   $2_1 = $3_1;
   HEAP32[$1_1 + 4 >> 2] = $3_1;
   $3_1 = $12_1 + $18_1 | 0;
   $4_1 = $11_1 + $20_1 | 0;
   $3_1 = $4_1 >>> 0 < $11_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$6_1 + 712 >> 2] = $4_1;
   HEAP32[$6_1 + 716 >> 2] = $3_1;
   $3_1 = $14_1 + $19_1 | 0;
   $4_1 = $13_1 + $21_1 | 0;
   $3_1 = $4_1 >>> 0 < $13_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$6_1 + 704 >> 2] = $4_1;
   HEAP32[$6_1 + 708 >> 2] = $3_1;
   $3_1 = $10_1 + $25_1 | 0;
   $4_1 = $9_1 + $17_1 | 0;
   $3_1 = $4_1 >>> 0 < $9_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$6_1 + 696 >> 2] = $4_1;
   HEAP32[$6_1 + 700 >> 2] = $3_1;
   $3_1 = $8_1 + $33_1 | 0;
   $4_1 = $7_1 + $24_1 | 0;
   $3_1 = $4_1 >>> 0 < $24_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$6_1 + 688 >> 2] = $4_1;
   HEAP32[$6_1 + 692 >> 2] = $3_1;
   $3_1 = $2_1 + $15_1 | 0;
   $0_1 = $5_1 + $16_1 | 0;
   $3_1 = $0_1 >>> 0 < $5_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   HEAP32[$6_1 + 680 >> 2] = $0_1;
   HEAP32[$6_1 + 684 >> 2] = $3_1;
   $34($1_1 + 40 | 0, $27_1, $22_1);
   $34($23_1, $23_1, $6_1 + 920 | 0);
   $3_1 = HEAP32[$1_1 + 44 >> 2] + HEAP32[$6_1 + 724 >> 2] | 0;
   $0_1 = HEAP32[$6_1 + 720 >> 2];
   $2_1 = $0_1 + HEAP32[$1_1 + 40 >> 2] | 0;
   HEAP32[$1_1 + 40 >> 2] = $2_1;
   HEAP32[$1_1 + 44 >> 2] = $0_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $1_1 + 48 | 0;
   $4_1 = $3_1;
   $0_1 = HEAP32[$6_1 + 728 >> 2];
   $2_1 = $0_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$6_1 + 732 >> 2] | 0;
   HEAP32[$4_1 >> 2] = $2_1;
   HEAP32[$4_1 + 4 >> 2] = $0_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $1_1 + 56 | 0;
   $4_1 = $3_1;
   $0_1 = HEAP32[$6_1 + 736 >> 2];
   $2_1 = $0_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$6_1 + 740 >> 2] | 0;
   HEAP32[$4_1 >> 2] = $2_1;
   HEAP32[$4_1 + 4 >> 2] = $0_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $3_1 = $1_1 - -64 | 0;
   $4_1 = $3_1;
   $0_1 = HEAP32[$6_1 + 744 >> 2];
   $2_1 = $0_1 + HEAP32[$3_1 >> 2] | 0;
   $3_1 = HEAP32[$3_1 + 4 >> 2] + HEAP32[$6_1 + 748 >> 2] | 0;
   HEAP32[$4_1 >> 2] = $2_1;
   HEAP32[$4_1 + 4 >> 2] = $0_1 >>> 0 > $2_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
   $0_1 = HEAP32[$6_1 + 752 >> 2];
   $2_1 = $1_1 + 72 | 0;
   $1_1 = $0_1 + HEAP32[$2_1 >> 2] | 0;
   $3_1 = HEAP32[$2_1 + 4 >> 2] + HEAP32[$6_1 + 756 >> 2] | 0;
   HEAP32[$2_1 >> 2] = $1_1;
   HEAP32[$2_1 + 4 >> 2] = $0_1 >>> 0 > $1_1 >>> 0 ? $3_1 + 1 | 0 : $3_1;
  }
  global$0 = $6_1 + 1120 | 0;
 }
 
 function $65($0_1, $1_1, $2_1, $3_1) {
  var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0;
  $8_1 = global$0 - 736 | 0;
  global$0 = $8_1;
  $4_1 = HEAP32[$2_1 + 80 >> 2];
  label$1 : {
   if (HEAP32[$1_1 + 120 >> 2]) {
    HEAP32[$0_1 + 120 >> 2] = $4_1;
    $1_1 = HEAP32[$2_1 + 4 >> 2];
    HEAP32[$0_1 >> 2] = HEAP32[$2_1 >> 2];
    HEAP32[$0_1 + 4 >> 2] = $1_1;
    $1_1 = $2_1 + 8 | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $0_1 + 8 | 0;
    HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
    HEAP32[$4_1 + 4 >> 2] = $3_1;
    $1_1 = $2_1 + 16 | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $0_1 + 16 | 0;
    HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
    HEAP32[$4_1 + 4 >> 2] = $3_1;
    $1_1 = $2_1 + 24 | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $0_1 + 24 | 0;
    HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
    HEAP32[$4_1 + 4 >> 2] = $3_1;
    $1_1 = $2_1 + 32 | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $0_1 + 32 | 0;
    HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
    HEAP32[$4_1 + 4 >> 2] = $3_1;
    $1_1 = HEAP32[$2_1 + 44 >> 2];
    HEAP32[$0_1 + 40 >> 2] = HEAP32[$2_1 + 40 >> 2];
    HEAP32[$0_1 + 44 >> 2] = $1_1;
    $1_1 = $2_1 + 48 | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $0_1 + 48 | 0;
    HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
    HEAP32[$4_1 + 4 >> 2] = $3_1;
    $1_1 = $2_1 + 56 | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $0_1 + 56 | 0;
    HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
    HEAP32[$4_1 + 4 >> 2] = $3_1;
    $1_1 = $2_1 - -64 | 0;
    $3_1 = HEAP32[$1_1 + 4 >> 2];
    $4_1 = $0_1 - -64 | 0;
    HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
    HEAP32[$4_1 + 4 >> 2] = $3_1;
    $1_1 = $2_1 + 72 | 0;
    $2_1 = HEAP32[$1_1 + 4 >> 2];
    $3_1 = $0_1 + 72 | 0;
    HEAP32[$3_1 >> 2] = HEAP32[$1_1 >> 2];
    HEAP32[$3_1 + 4 >> 2] = $2_1;
    $1_1 = $0_1 + 88 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    HEAP32[$0_1 + 80 >> 2] = 1;
    HEAP32[$0_1 + 84 >> 2] = 0;
    $1_1 = $0_1 + 96 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $1_1 = $0_1 + 104 | 0;
    HEAP32[$1_1 >> 2] = 0;
    HEAP32[$1_1 + 4 >> 2] = 0;
    $0_1 = $0_1 + 112 | 0;
    HEAP32[$0_1 >> 2] = 0;
    HEAP32[$0_1 + 4 >> 2] = 0;
    break label$1;
   }
   if ($4_1) {
    if ($3_1) {
     HEAP32[$3_1 + 8 >> 2] = 0;
     HEAP32[$3_1 + 12 >> 2] = 0;
     HEAP32[$3_1 >> 2] = 1;
     HEAP32[$3_1 + 4 >> 2] = 0;
     $2_1 = $3_1 + 16 | 0;
     HEAP32[$2_1 >> 2] = 0;
     HEAP32[$2_1 + 4 >> 2] = 0;
     $2_1 = $3_1 + 24 | 0;
     HEAP32[$2_1 >> 2] = 0;
     HEAP32[$2_1 + 4 >> 2] = 0;
     $2_1 = $3_1 + 32 | 0;
     HEAP32[$2_1 >> 2] = 0;
     HEAP32[$2_1 + 4 >> 2] = 0;
    }
    $70($0_1, $1_1, 128);
    break label$1;
   }
   $18_1 = $8_1 + 696 | 0;
   $30_1 = $1_1 + 80 | 0;
   $54($18_1, $30_1);
   $14_1 = $8_1 + 656 | 0;
   $10_1 = $14_1 + 8 | 0;
   $4_1 = $1_1 + 8 | 0;
   $7_1 = HEAP32[$4_1 >> 2];
   $12_1 = HEAP32[$4_1 + 4 >> 2];
   $6_1 = HEAP32[$1_1 + 4 >> 2];
   $4_1 = $1_1 + 32 | 0;
   $11_1 = HEAP32[$4_1 >> 2];
   $9_1 = HEAP32[$4_1 + 4 >> 2];
   $17_1 = $9_1;
   $4_1 = HEAP32[$1_1 >> 2];
   $9_1 = __wasm_i64_mul($9_1 >>> 16 | 0, 0, 977, 1);
   $5_1 = $4_1 + $9_1 | 0;
   $4_1 = $6_1 + i64toi32_i32$HIGH_BITS | 0;
   $9_1 = $5_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $12_1;
   $6_1 = $9_1 >>> 20 | 0;
   $12_1 = $6_1;
   $6_1 = $6_1 + $7_1 | 0;
   $4_1 = $12_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$10_1 >> 2] = $6_1;
   $19_1 = $4_1 & 1048575;
   HEAP32[$10_1 + 4 >> 2] = $19_1;
   $7_1 = $14_1 + 16 | 0;
   $10_1 = $1_1 + 16 | 0;
   $12_1 = HEAP32[$10_1 >> 2];
   $15_1 = HEAP32[$10_1 + 4 >> 2];
   $10_1 = $4_1;
   $4_1 = $15_1;
   $10_1 = $10_1 >>> 20 | 0;
   $13_1 = $10_1;
   $10_1 = $10_1 + $12_1 | 0;
   $4_1 = $13_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$7_1 >> 2] = $10_1;
   $28_1 = $4_1 & 1048575;
   HEAP32[$7_1 + 4 >> 2] = $28_1;
   $12_1 = $14_1 + 24 | 0;
   $7_1 = $1_1 + 24 | 0;
   $15_1 = HEAP32[$7_1 >> 2];
   $13_1 = HEAP32[$7_1 + 4 >> 2];
   $7_1 = $4_1;
   $4_1 = $13_1;
   $7_1 = $7_1 >>> 20 | 0;
   $13_1 = $7_1;
   $7_1 = $7_1 + $15_1 | 0;
   $4_1 = $13_1 >>> 0 > $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$12_1 >> 2] = $7_1;
   $24_1 = $4_1 & 1048575;
   HEAP32[$12_1 + 4 >> 2] = $24_1;
   $12_1 = $14_1 + 32 | 0;
   $14_1 = $4_1;
   $4_1 = $17_1 & 65535;
   $14_1 = $14_1 >>> 20 | 0;
   $17_1 = $11_1 + $14_1 | 0;
   $4_1 = $14_1 >>> 0 > $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$12_1 >> 2] = $17_1;
   $21_1 = $4_1;
   HEAP32[$12_1 + 4 >> 2] = $4_1;
   $11_1 = $5_1;
   HEAP32[$8_1 + 656 >> 2] = $5_1;
   $20_1 = $9_1 & 1048575;
   HEAP32[$8_1 + 660 >> 2] = $20_1;
   $34($8_1 + 616 | 0, $2_1, $18_1);
   $15_1 = $8_1 + 576 | 0;
   $12_1 = $15_1 + 8 | 0;
   $4_1 = $1_1 + 48 | 0;
   $16_1 = HEAP32[$4_1 >> 2];
   $22_1 = HEAP32[$4_1 + 4 >> 2];
   $14_1 = HEAP32[$1_1 + 44 >> 2];
   $4_1 = $1_1 + 72 | 0;
   $9_1 = HEAP32[$4_1 >> 2];
   $13_1 = HEAP32[$4_1 + 4 >> 2];
   $23_1 = $13_1;
   $4_1 = HEAP32[$1_1 + 40 >> 2];
   $13_1 = __wasm_i64_mul($13_1 >>> 16 | 0, 0, 977, 1);
   $5_1 = $4_1 + $13_1 | 0;
   $4_1 = $14_1 + i64toi32_i32$HIGH_BITS | 0;
   $14_1 = $5_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $22_1;
   $13_1 = $14_1 >>> 20 | 0;
   $22_1 = $13_1 + $16_1 | 0;
   $4_1 = $13_1 >>> 0 > $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$12_1 >> 2] = $22_1;
   $31_1 = $4_1 & 1048575;
   HEAP32[$12_1 + 4 >> 2] = $31_1;
   $13_1 = $15_1 + 16 | 0;
   $12_1 = $1_1 + 56 | 0;
   $16_1 = HEAP32[$12_1 >> 2];
   $25_1 = HEAP32[$12_1 + 4 >> 2];
   $12_1 = $4_1;
   $4_1 = $25_1;
   $12_1 = $12_1 >>> 20 | 0;
   $25_1 = $12_1 + $16_1 | 0;
   $4_1 = $12_1 >>> 0 > $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$13_1 >> 2] = $25_1;
   $27_1 = $4_1 & 1048575;
   HEAP32[$13_1 + 4 >> 2] = $27_1;
   $13_1 = $15_1 + 24 | 0;
   $12_1 = $1_1 - -64 | 0;
   $16_1 = HEAP32[$12_1 >> 2];
   $26_1 = HEAP32[$12_1 + 4 >> 2];
   $12_1 = $4_1;
   $4_1 = $26_1;
   $12_1 = $12_1 >>> 20 | 0;
   $26_1 = $12_1 + $16_1 | 0;
   $4_1 = $12_1 >>> 0 > $26_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$13_1 >> 2] = $26_1;
   $29_1 = $4_1 & 1048575;
   HEAP32[$13_1 + 4 >> 2] = $29_1;
   $15_1 = $15_1 + 32 | 0;
   $12_1 = $4_1;
   $4_1 = $23_1 & 65535;
   $12_1 = $12_1 >>> 20 | 0;
   $13_1 = $9_1 + $12_1 | 0;
   $4_1 = $12_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$15_1 >> 2] = $13_1;
   $16_1 = $4_1;
   HEAP32[$15_1 + 4 >> 2] = $4_1;
   $23_1 = $5_1;
   HEAP32[$8_1 + 576 >> 2] = $5_1;
   $32_1 = $14_1 & 1048575;
   HEAP32[$8_1 + 580 >> 2] = $32_1;
   $4_1 = $8_1 + 536 | 0;
   $34($4_1, $2_1 + 40 | 0, $18_1);
   $34($4_1, $4_1, $30_1);
   $2_1 = HEAP32[$8_1 + 616 >> 2];
   $9_1 = ($2_1 - $11_1 | 0) - 3908 | 0;
   $4_1 = (HEAP32[$8_1 + 620 >> 2] - (($2_1 >>> 0 < $11_1 >>> 0) + $20_1 | 0) | 0) + 4194299 | 0;
   HEAP32[$8_1 + 496 >> 2] = $9_1;
   $12_1 = $9_1 >>> 0 < 4294963388 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$8_1 + 500 >> 2] = $12_1;
   $2_1 = $8_1;
   $4_1 = HEAP32[$2_1 + 624 >> 2];
   $11_1 = ($4_1 - $6_1 | 0) - 4 | 0;
   $4_1 = (HEAP32[$2_1 + 628 >> 2] - (($4_1 >>> 0 < $6_1 >>> 0) + $19_1 | 0) | 0) + 4194303 | 0;
   HEAP32[$2_1 + 504 >> 2] = $11_1;
   $14_1 = $11_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$2_1 + 508 >> 2] = $14_1;
   $4_1 = HEAP32[$2_1 + 632 >> 2];
   $5_1 = ($4_1 - $10_1 | 0) - 4 | 0;
   $4_1 = (HEAP32[$2_1 + 636 >> 2] - (($4_1 >>> 0 < $10_1 >>> 0) + $28_1 | 0) | 0) + 4194303 | 0;
   HEAP32[$2_1 + 512 >> 2] = $5_1;
   $10_1 = $5_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$2_1 + 516 >> 2] = $10_1;
   $4_1 = HEAP32[$2_1 + 640 >> 2];
   $6_1 = ($4_1 - $7_1 | 0) - 4 | 0;
   $4_1 = (HEAP32[$2_1 + 644 >> 2] - (($4_1 >>> 0 < $7_1 >>> 0) + $24_1 | 0) | 0) + 4194303 | 0;
   HEAP32[$2_1 + 520 >> 2] = $6_1;
   $7_1 = $6_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$2_1 + 524 >> 2] = $7_1;
   $4_1 = HEAP32[$2_1 + 648 >> 2];
   $2_1 = ($4_1 - $17_1 | 0) - 4 | 0;
   $4_1 = (HEAP32[$8_1 + 652 >> 2] - (($4_1 >>> 0 < $17_1 >>> 0) + $21_1 | 0) | 0) + 262143 | 0;
   HEAP32[$8_1 + 528 >> 2] = $2_1;
   $17_1 = $2_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$8_1 + 532 >> 2] = $17_1;
   $4_1 = HEAP32[$8_1 + 568 >> 2];
   $21_1 = ($13_1 - $4_1 | 0) - 4 | 0;
   $4_1 = ($16_1 - (HEAP32[$8_1 + 572 >> 2] + ($4_1 >>> 0 > $13_1 >>> 0) | 0) | 0) + 262143 | 0;
   HEAP32[$8_1 + 488 >> 2] = $21_1;
   $13_1 = $21_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$8_1 + 492 >> 2] = $13_1;
   $4_1 = HEAP32[$8_1 + 560 >> 2];
   $16_1 = ($26_1 - $4_1 | 0) - 4 | 0;
   $4_1 = ($29_1 - (HEAP32[$8_1 + 564 >> 2] + ($4_1 >>> 0 > $26_1 >>> 0) | 0) | 0) + 4194303 | 0;
   $26_1 = $16_1;
   HEAP32[$8_1 + 480 >> 2] = $16_1;
   $29_1 = $16_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$8_1 + 484 >> 2] = $29_1;
   $4_1 = HEAP32[$8_1 + 552 >> 2];
   $16_1 = ($25_1 - $4_1 | 0) - 4 | 0;
   $4_1 = ($27_1 - (HEAP32[$8_1 + 556 >> 2] + ($4_1 >>> 0 > $25_1 >>> 0) | 0) | 0) + 4194303 | 0;
   $25_1 = $16_1;
   HEAP32[$8_1 + 472 >> 2] = $16_1;
   $27_1 = $16_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$8_1 + 476 >> 2] = $27_1;
   $4_1 = HEAP32[$8_1 + 544 >> 2];
   $16_1 = ($22_1 - $4_1 | 0) - 4 | 0;
   $4_1 = ($31_1 - (HEAP32[$8_1 + 548 >> 2] + ($4_1 >>> 0 > $22_1 >>> 0) | 0) | 0) + 4194303 | 0;
   HEAP32[$8_1 + 464 >> 2] = $16_1;
   $31_1 = $16_1 >>> 0 < 4294967292 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$8_1 + 468 >> 2] = $31_1;
   $4_1 = HEAP32[$8_1 + 536 >> 2];
   $15_1 = ($23_1 - $4_1 | 0) - 3908 | 0;
   $4_1 = ($32_1 - (HEAP32[$8_1 + 540 >> 2] + ($4_1 >>> 0 > $23_1 >>> 0) | 0) | 0) + 4194299 | 0;
   $22_1 = $15_1;
   HEAP32[$8_1 + 456 >> 2] = $15_1;
   $32_1 = $15_1 >>> 0 < 4294963388 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$8_1 + 460 >> 2] = $32_1;
   $15_1 = __wasm_i64_mul($17_1 >>> 16 | 0, 0, 977, 1) + $9_1 | 0;
   $4_1 = i64toi32_i32$HIGH_BITS + $12_1 | 0;
   $4_1 = $9_1 >>> 0 > $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $23_1 = $4_1 & 1048575;
   $33_1 = $23_1;
   label$5 : {
    $34_1 = $15_1;
    $35_1 = $15_1 ^ 976;
    $36_1 = $23_1 ^ 1;
    if ((($35_1 | 0) != -1 | ($36_1 | 0) != 1048575) & ($15_1 | $23_1) != 0) {
     break label$5
    }
    $20_1 = $17_1 & 65535;
    $15_1 = $4_1;
    $4_1 = $14_1;
    $15_1 = ($15_1 >>> 20 | 0) + $11_1 | 0;
    $23_1 = $15_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $10_1;
    $18_1 = ($23_1 >>> 20 | 0) + $5_1 | 0;
    $19_1 = $18_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $7_1;
    $28_1 = ($19_1 >>> 20 | 0) + $6_1 | 0;
    $24_1 = $28_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $4_1 = $20_1;
    $20_1 = $24_1 >>> 20 | 0;
    $37_1 = $20_1;
    $20_1 = $2_1 + $20_1 | 0;
    $4_1 = $37_1 >>> 0 > $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    if ($20_1 | ($28_1 | ($18_1 | ($15_1 | $34_1))) | ($4_1 | ($24_1 & 1048575 | ($19_1 & 1048575 | ($23_1 & 1048575 | $33_1))))) {
     if (($15_1 & $35_1 & $18_1 & $28_1 & $20_1) != -1) {
      $4_1 = 1
     } else {
      $4_1 = ($23_1 & $36_1 & $19_1 & $24_1 & ($4_1 ^ 983040)) != 1048575
     }
     if ($4_1) {
      break label$5
     }
    }
    $2_1 = __wasm_i64_mul($13_1 >>> 16 | 0, 0, 977, 1) + $22_1 | 0;
    $4_1 = i64toi32_i32$HIGH_BITS + $32_1 | 0;
    $4_1 = $2_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
    $5_1 = $4_1 & 1048575;
    $12_1 = $5_1;
    label$7 : {
     $14_1 = $2_1;
     $17_1 = $2_1 ^ 976;
     $15_1 = $5_1 ^ 1;
     if ((($17_1 | 0) != -1 | ($15_1 | 0) != 1048575) & ($2_1 | $5_1) != 0) {
      break label$7
     }
     $13_1 = $13_1 & 65535;
     $2_1 = $4_1;
     $4_1 = $31_1;
     $2_1 = ($2_1 >>> 20 | 0) + $16_1 | 0;
     $5_1 = $2_1 >>> 0 < $16_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $4_1 = $27_1;
     $6_1 = ($5_1 >>> 20 | 0) + $25_1 | 0;
     $11_1 = $6_1 >>> 0 < $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $4_1 = $29_1;
     $10_1 = ($11_1 >>> 20 | 0) + $26_1 | 0;
     $7_1 = $10_1 >>> 0 < $26_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     $4_1 = $13_1;
     $9_1 = $7_1 >>> 20 | 0;
     $13_1 = $9_1;
     $9_1 = $9_1 + $21_1 | 0;
     $4_1 = $13_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
     if ($9_1 | ($10_1 | ($6_1 | ($2_1 | $14_1))) | ($4_1 | ($7_1 & 1048575 | ($11_1 & 1048575 | ($5_1 & 1048575 | $12_1))))) {
      if (($2_1 & $17_1 & $6_1 & $10_1 & $9_1) != -1) {
       $2_1 = 1
      } else {
       $2_1 = ($5_1 & $15_1 & $11_1 & $7_1 & ($4_1 ^ 983040)) != 1048575
      }
      if ($2_1) {
       break label$7
      }
     }
     if (HEAP32[$1_1 + 120 >> 2]) {
      HEAP32[$0_1 + 120 >> 2] = 1;
      $68($0_1, 120);
      if (!$3_1) {
       break label$1
      }
      HEAP32[$3_1 + 8 >> 2] = 0;
      HEAP32[$3_1 + 12 >> 2] = 0;
      HEAP32[$3_1 >> 2] = 1;
      HEAP32[$3_1 + 4 >> 2] = 0;
      $0_1 = $3_1 + 16 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $3_1 + 24 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      $0_1 = $3_1 + 32 | 0;
      HEAP32[$0_1 >> 2] = 0;
      HEAP32[$0_1 + 4 >> 2] = 0;
      break label$1;
     }
     if ($3_1) {
      $2_1 = $1_1 + 40 | 0;
      $4_1 = HEAP32[$2_1 >> 2];
      $5_1 = HEAP32[$2_1 + 4 >> 2];
      HEAP32[$3_1 >> 2] = $4_1;
      HEAP32[$3_1 + 4 >> 2] = $5_1;
      $6_1 = $2_1 + 8 | 0;
      $11_1 = HEAP32[$6_1 >> 2];
      $14_1 = $11_1;
      $10_1 = HEAP32[$6_1 + 4 >> 2];
      $12_1 = $10_1;
      $6_1 = $3_1 + 8 | 0;
      HEAP32[$6_1 >> 2] = $11_1;
      HEAP32[$6_1 + 4 >> 2] = $10_1;
      $11_1 = $2_1 + 16 | 0;
      $10_1 = HEAP32[$11_1 >> 2];
      $17_1 = $10_1;
      $7_1 = HEAP32[$11_1 + 4 >> 2];
      $15_1 = $7_1;
      $11_1 = $3_1 + 16 | 0;
      HEAP32[$11_1 >> 2] = $10_1;
      HEAP32[$11_1 + 4 >> 2] = $7_1;
      $10_1 = $2_1 + 24 | 0;
      $7_1 = HEAP32[$10_1 >> 2];
      $13_1 = $7_1;
      $9_1 = HEAP32[$10_1 + 4 >> 2];
      $21_1 = $9_1;
      $10_1 = $3_1 + 24 | 0;
      HEAP32[$10_1 >> 2] = $7_1;
      HEAP32[$10_1 + 4 >> 2] = $9_1;
      $2_1 = $2_1 + 32 | 0;
      $7_1 = HEAP32[$2_1 >> 2];
      $2_1 = HEAP32[$2_1 + 4 >> 2];
      $9_1 = $3_1 + 32 | 0;
      HEAP32[$9_1 >> 2] = $7_1;
      HEAP32[$9_1 + 4 >> 2] = $2_1;
      $22_1 = __wasm_i64_mul($2_1 >>> 16 | 0, 0, 977, 1);
      $16_1 = $22_1 + $4_1 | 0;
      $4_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
      HEAP32[$3_1 >> 2] = $16_1;
      $4_1 = $16_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$3_1 + 4 >> 2] = $4_1 & 1048575;
      $3_1 = $4_1;
      $4_1 = $12_1;
      $3_1 = $3_1 >>> 20 | 0;
      $5_1 = $3_1;
      $3_1 = $3_1 + $14_1 | 0;
      $4_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$6_1 >> 2] = $3_1;
      HEAP32[$6_1 + 4 >> 2] = $4_1 & 1048575;
      $3_1 = $4_1;
      $4_1 = $15_1;
      $3_1 = $3_1 >>> 20 | 0;
      $5_1 = $3_1;
      $3_1 = $3_1 + $17_1 | 0;
      $4_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$11_1 >> 2] = $3_1;
      HEAP32[$11_1 + 4 >> 2] = $4_1 & 1048575;
      $3_1 = $4_1;
      $4_1 = $21_1;
      $3_1 = $3_1 >>> 20 | 0;
      $5_1 = $3_1;
      $3_1 = $3_1 + $13_1 | 0;
      $4_1 = $5_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$10_1 >> 2] = $3_1;
      HEAP32[$10_1 + 4 >> 2] = $4_1 & 1048575;
      $3_1 = $2_1 & 65535;
      $2_1 = $4_1;
      $4_1 = $3_1;
      $2_1 = $2_1 >>> 20 | 0;
      $3_1 = $2_1;
      $2_1 = $2_1 + $7_1 | 0;
      $4_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
      HEAP32[$9_1 >> 2] = $2_1;
      HEAP32[$9_1 + 4 >> 2] = $4_1;
     }
     $55($0_1, $1_1);
     break label$1;
    }
    if ($3_1) {
     HEAP32[$3_1 >> 2] = 0;
     HEAP32[$3_1 + 4 >> 2] = 0;
     $1_1 = $3_1 + 32 | 0;
     HEAP32[$1_1 >> 2] = 0;
     HEAP32[$1_1 + 4 >> 2] = 0;
     $1_1 = $3_1 + 24 | 0;
     HEAP32[$1_1 >> 2] = 0;
     HEAP32[$1_1 + 4 >> 2] = 0;
     $1_1 = $3_1 + 16 | 0;
     HEAP32[$1_1 >> 2] = 0;
     HEAP32[$1_1 + 4 >> 2] = 0;
     $1_1 = $3_1 + 8 | 0;
     HEAP32[$1_1 >> 2] = 0;
     HEAP32[$1_1 + 4 >> 2] = 0;
    }
    HEAP32[$0_1 + 120 >> 2] = 1;
    $68($0_1, 120);
    break label$1;
   }
   HEAP32[$0_1 + 120 >> 2] = 0;
   if ($3_1) {
    $1_1 = HEAP32[$8_1 + 500 >> 2];
    HEAP32[$3_1 >> 2] = HEAP32[$8_1 + 496 >> 2];
    HEAP32[$3_1 + 4 >> 2] = $1_1;
    $1_1 = $8_1 + 496 | 0;
    $4_1 = $1_1 + 32 | 0;
    $15_1 = HEAP32[$4_1 + 4 >> 2];
    $13_1 = $3_1 + 32 | 0;
    HEAP32[$13_1 >> 2] = HEAP32[$4_1 >> 2];
    HEAP32[$13_1 + 4 >> 2] = $15_1;
    $4_1 = $1_1 + 24 | 0;
    $15_1 = HEAP32[$4_1 + 4 >> 2];
    $13_1 = $3_1 + 24 | 0;
    HEAP32[$13_1 >> 2] = HEAP32[$4_1 >> 2];
    HEAP32[$13_1 + 4 >> 2] = $15_1;
    $4_1 = $1_1 + 16 | 0;
    $15_1 = HEAP32[$4_1 + 4 >> 2];
    $13_1 = $3_1 + 16 | 0;
    HEAP32[$13_1 >> 2] = HEAP32[$4_1 >> 2];
    HEAP32[$13_1 + 4 >> 2] = $15_1;
    $1_1 = $1_1 + 8 | 0;
    $4_1 = HEAP32[$1_1 + 4 >> 2];
    $3_1 = $3_1 + 8 | 0;
    HEAP32[$3_1 >> 2] = HEAP32[$1_1 >> 2];
    HEAP32[$3_1 + 4 >> 2] = $4_1;
   }
   $28_1 = $8_1 + 496 | 0;
   $34($0_1 + 80 | 0, $30_1, $28_1);
   $23_1 = $8_1 + 304 | 0;
   $15_1 = $9_1 << 1;
   $1_1 = $12_1;
   $12_1 = $1_1 << 1 | $9_1 >>> 31;
   $69($23_1, $6_1, $7_1, 0, 0, $15_1, $12_1, 0, 0);
   $18_1 = $8_1 + 224 | 0;
   $3_1 = $11_1 << 1;
   $21_1 = $14_1;
   $14_1 = $11_1;
   $13_1 = $21_1 << 1 | $11_1 >>> 31;
   $69($18_1, $5_1, $10_1, 0, 0, $3_1, $13_1, 0, 0);
   $16_1 = $8_1 + 160 | 0;
   $69($16_1, $2_1, $17_1, 0, 0, $2_1, $17_1, 0, 0);
   $19_1 = $8_1 + 144 | 0;
   $69($19_1, HEAP32[$8_1 + 160 >> 2], HEAP32[$8_1 + 164 >> 2], 0, 0, 15632, 16, 0, 0);
   $24_1 = $8_1 + 112 | 0;
   $11_1 = $2_1 << 1;
   $17_1 = $17_1 << 1 | $2_1 >>> 31;
   $69($24_1, $11_1, $17_1, 0, 0, $9_1, $1_1, 0, 0);
   $20_1 = $8_1 + 272 | 0;
   $69($20_1, $6_1, $7_1, 0, 0, $3_1, $13_1, 0, 0);
   $29_1 = $8_1 + 208 | 0;
   $69($29_1, $5_1, $10_1, 0, 0, $5_1, $10_1, 0, 0);
   $27_1 = $8_1 + 128 | 0;
   $2_1 = $16_1 + 8 | 0;
   $69($27_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, 64028672, 65536, 0, 0);
   $31_1 = $8_1 + 320 | 0;
   $69($31_1, $9_1, $1_1, 0, 0, $9_1, $1_1, 0, 0);
   $32_1 = $8_1 + 96 | 0;
   $69($32_1, $11_1, $17_1, 0, 0, $14_1, $21_1, 0, 0);
   $34_1 = $8_1 + 176 | 0;
   $16_1 = $6_1;
   $22_1 = $7_1;
   $25_1 = $10_1;
   $10_1 = $5_1;
   $69($34_1, $6_1, $7_1, 0, 0, $5_1 << 1, $25_1 << 1 | $5_1 >>> 31, 0, 0);
   $6_1 = HEAP32[$8_1 + 304 >> 2];
   $2_1 = HEAP32[$8_1 + 224 >> 2];
   $1_1 = $6_1 + $2_1 | 0;
   $5_1 = HEAP32[$8_1 + 308 >> 2];
   $4_1 = $5_1 + HEAP32[$8_1 + 228 >> 2] | 0;
   $2_1 = $1_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $2_1 + HEAP32[$8_1 + 148 >> 2] | 0;
   $3_1 = $1_1;
   $7_1 = HEAP32[$8_1 + 144 >> 2];
   $1_1 = $1_1 + $7_1 | 0;
   $26_1 = $1_1;
   $1_1 = $1_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $7_1 = ($2_1 | 0) == ($1_1 | 0) & $3_1 >>> 0 > $26_1 >>> 0 | $1_1 >>> 0 < $2_1 >>> 0;
   $4_1 = $19_1 + 8 | 0;
   $9_1 = HEAP32[$4_1 >> 2];
   $13_1 = HEAP32[$4_1 + 4 >> 2];
   $3_1 = ($2_1 | 0) == ($5_1 | 0) & $3_1 >>> 0 < $6_1 >>> 0 | $2_1 >>> 0 < $5_1 >>> 0;
   $4_1 = $18_1 + 8 | 0;
   $5_1 = HEAP32[$4_1 >> 2];
   $6_1 = $23_1 + 8 | 0;
   $2_1 = $5_1 + HEAP32[$6_1 >> 2] | 0;
   $4_1 = HEAP32[$6_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $2_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $2_1;
   $2_1 = $2_1 + $3_1 | 0;
   $4_1 = ($5_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $13_1 | 0;
   $3_1 = $2_1;
   $2_1 = $2_1 + $9_1 | 0;
   $4_1 = $3_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $3_1 = $2_1 + $7_1 | 0;
   $2_1 = $3_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $2_1 << 12 | $3_1 >>> 20;
   $23_1 = $1_1;
   $18_1 = $3_1 << 12 | $1_1 >>> 20;
   $30_1 = $5_1;
   $33_1 = HEAP32[$8_1 + 272 >> 2];
   $3_1 = HEAP32[$8_1 + 208 >> 2];
   $1_1 = $33_1 + $3_1 | 0;
   $19_1 = HEAP32[$8_1 + 276 >> 2];
   $4_1 = $19_1 + HEAP32[$8_1 + 212 >> 2] | 0;
   $4_1 = $1_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $7_1 = $1_1;
   $3_1 = HEAP32[$8_1 + 112 >> 2];
   $1_1 = $1_1 + $3_1 | 0;
   $5_1 = $4_1;
   $4_1 = $4_1 + HEAP32[$8_1 + 116 >> 2] | 0;
   $4_1 = $1_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $9_1 = $1_1;
   $3_1 = HEAP32[$8_1 + 128 >> 2];
   $1_1 = $1_1 + $3_1 | 0;
   $6_1 = $4_1;
   $4_1 = $4_1 + HEAP32[$8_1 + 132 >> 2] | 0;
   $3_1 = $1_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $3_1 + $30_1 | 0;
   $30_1 = $8_1 + 80 | 0;
   $13_1 = $1_1;
   $18_1 = $1_1 + $18_1 | 0;
   $1_1 = $1_1 >>> 0 > $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $3_1;
   $3_1 = $18_1;
   $18_1 = ($1_1 | 0) == ($4_1 | 0) & $3_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $4_1 >>> 0;
   $13_1 = ($4_1 | 0) == ($6_1 | 0) & $9_1 >>> 0 > $13_1 >>> 0 | $4_1 >>> 0 < $6_1 >>> 0;
   $4_1 = $27_1 + 8 | 0;
   $27_1 = HEAP32[$4_1 >> 2];
   $35_1 = HEAP32[$4_1 + 4 >> 2];
   $6_1 = ($5_1 | 0) == ($6_1 | 0) & $9_1 >>> 0 < $7_1 >>> 0 | $5_1 >>> 0 > $6_1 >>> 0;
   $4_1 = $24_1 + 8 | 0;
   $9_1 = HEAP32[$4_1 >> 2];
   $24_1 = HEAP32[$4_1 + 4 >> 2];
   $7_1 = ($5_1 | 0) == ($19_1 | 0) & $7_1 >>> 0 < $33_1 >>> 0 | $5_1 >>> 0 < $19_1 >>> 0;
   $4_1 = $29_1 + 8 | 0;
   $19_1 = HEAP32[$4_1 >> 2];
   $20_1 = $20_1 + 8 | 0;
   $5_1 = $19_1 + HEAP32[$20_1 >> 2] | 0;
   $4_1 = HEAP32[$20_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $5_1 >>> 0 < $19_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $20_1 = $5_1;
   $5_1 = $5_1 + $7_1 | 0;
   $4_1 = ($20_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $24_1 | 0;
   $7_1 = $5_1;
   $5_1 = $5_1 + $9_1 | 0;
   $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $7_1 = $5_1;
   $5_1 = $5_1 + $6_1 | 0;
   $4_1 = ($7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $35_1 | 0;
   $7_1 = $5_1;
   $5_1 = $5_1 + $27_1 | 0;
   $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $7_1 = $5_1;
   $5_1 = $5_1 + $13_1 | 0;
   $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $2_1 = $2_1 >>> 20 | 0;
   $7_1 = $2_1;
   $2_1 = $2_1 + $5_1 | 0;
   $4_1 = $7_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $2_1 + $18_1 | 0;
   $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $2_1 << 12 | $5_1 >>> 20;
   $7_1 = $5_1 << 12;
   $5_1 = $1_1;
   $9_1 = $7_1 | $1_1 >>> 20;
   $13_1 = $4_1;
   $19_1 = HEAP32[$8_1 + 96 >> 2];
   $6_1 = HEAP32[$8_1 + 176 >> 2];
   $1_1 = $19_1 + $6_1 | 0;
   $18_1 = HEAP32[$8_1 + 100 >> 2];
   $4_1 = $18_1 + HEAP32[$8_1 + 180 >> 2] | 0;
   $6_1 = $1_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $6_1 + $13_1 | 0;
   $7_1 = $1_1;
   $9_1 = $1_1 + $9_1 | 0;
   $4_1 = $1_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $24_1 = $9_1 << 4 & -16;
   $13_1 = $5_1;
   $1_1 = $4_1;
   $69($30_1, $24_1 | $5_1 >>> 16 & 15, ($4_1 << 4 | $9_1 >>> 28) & 16777215, 0, 0, 977, 1, 0, 0);
   $24_1 = $8_1 + 256 | 0;
   $69($24_1, $14_1, $21_1, 0, 0, $15_1, $12_1, 0, 0);
   $20_1 = $8_1 - -64 | 0;
   $69($20_1, $11_1, $17_1, 0, 0, $10_1, $25_1, 0, 0);
   $29_1 = $8_1 + 288 | 0;
   $69($29_1, $16_1, $22_1, 0, 0, $16_1, $22_1, 0, 0);
   $27_1 = $8_1 + 48 | 0;
   $9_1 = ($4_1 | 0) == ($6_1 | 0) & $9_1 >>> 0 < $7_1 >>> 0 | $4_1 >>> 0 < $6_1 >>> 0;
   $6_1 = ($6_1 | 0) == ($18_1 | 0) & $7_1 >>> 0 < $19_1 >>> 0 | $6_1 >>> 0 < $18_1 >>> 0;
   $4_1 = $34_1 + 8 | 0;
   $7_1 = HEAP32[$4_1 >> 2];
   $18_1 = $32_1 + 8 | 0;
   $5_1 = $7_1 + HEAP32[$18_1 >> 2] | 0;
   $4_1 = HEAP32[$18_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $5_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $7_1 = $5_1;
   $5_1 = $5_1 + $6_1 | 0;
   $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $2_1 = $2_1 >>> 20 | 0;
   $7_1 = $2_1;
   $2_1 = $2_1 + $5_1 | 0;
   $4_1 = $7_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $2_1 + $9_1 | 0;
   $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $2_1 << 12 | $5_1 >>> 20;
   $5_1 = $5_1 << 12 | $1_1 >>> 20;
   $7_1 = $6_1;
   $18_1 = HEAP32[$8_1 + 64 >> 2];
   $6_1 = HEAP32[$8_1 + 288 >> 2];
   $1_1 = $18_1 + $6_1 | 0;
   $9_1 = HEAP32[$8_1 + 68 >> 2];
   $4_1 = $9_1 + HEAP32[$8_1 + 292 >> 2] | 0;
   $4_1 = $1_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $1_1;
   $1_1 = $4_1;
   $4_1 = $4_1 + $7_1 | 0;
   $5_1 = $5_1 + $6_1 | 0;
   $4_1 = $5_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $7_1 = $5_1;
   $5_1 = $4_1;
   $69($27_1, $7_1, $4_1 & 1048575, 0, 0, 15632, 16, 0, 0);
   $19_1 = $8_1 + 192 | 0;
   $69($19_1, $10_1, $25_1, 0, 0, $15_1, $12_1, 0, 0);
   $12_1 = $8_1 + 240 | 0;
   $69($12_1, $14_1, $21_1, 0, 0, $14_1, $21_1, 0, 0);
   $10_1 = $8_1 + 32 | 0;
   $69($10_1, $11_1, $17_1, 0, 0, $16_1, $22_1, 0, 0);
   $17_1 = $8_1 + 16 | 0;
   $11_1 = $17_1;
   $7_1 = ($1_1 | 0) == ($4_1 | 0) & $6_1 >>> 0 > $7_1 >>> 0 | $1_1 >>> 0 > $4_1 >>> 0;
   $6_1 = ($1_1 | 0) == ($9_1 | 0) & $6_1 >>> 0 < $18_1 >>> 0 | $1_1 >>> 0 < $9_1 >>> 0;
   $4_1 = $29_1 + 8 | 0;
   $9_1 = HEAP32[$4_1 >> 2];
   $14_1 = $20_1 + 8 | 0;
   $1_1 = $9_1 + HEAP32[$14_1 >> 2] | 0;
   $4_1 = HEAP32[$14_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $14_1 = $1_1;
   $1_1 = $1_1 + $6_1 | 0;
   $4_1 = $14_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $2_1 = $2_1 >>> 20 | 0;
   $1_1 = $1_1 + $2_1 | 0;
   $4_1 = $2_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $2_1 = $1_1 + $7_1 | 0;
   $1_1 = $2_1 >>> 0 < $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $1_1 << 12 | $2_1 >>> 20;
   $7_1 = $2_1 << 12 | $5_1 >>> 20;
   $9_1 = HEAP32[$8_1 + 32 >> 2];
   $2_1 = $7_1 + $9_1 | 0;
   $5_1 = $6_1;
   $4_1 = $5_1 + HEAP32[$8_1 + 36 >> 2] | 0;
   $4_1 = $2_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $69($11_1, $2_1, $4_1, 0, 0, 15632, 16, 0, 0);
   $2_1 = ($4_1 | 0) == ($5_1 | 0) & $2_1 >>> 0 < $7_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
   $4_1 = $10_1 + 8 | 0;
   $5_1 = HEAP32[$4_1 >> 2];
   $4_1 = HEAP32[$4_1 + 4 >> 2];
   $1_1 = $1_1 >>> 20 | 0;
   $7_1 = $1_1;
   $1_1 = $1_1 + $5_1 | 0;
   $4_1 = $7_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $1_1;
   $1_1 = $1_1 + $2_1 | 0;
   $4_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $69($8_1, $1_1, $4_1, 0, 0, 64028672, 65536, 0, 0);
   $1_1 = $8_1;
   $11_1 = HEAP32[$1_1 + 80 >> 2];
   $2_1 = HEAP32[$1_1 + 320 >> 2];
   $5_1 = $11_1 + $2_1 | 0;
   $6_1 = HEAP32[$1_1 + 84 >> 2];
   $4_1 = $6_1 + HEAP32[$1_1 + 324 >> 2] | 0;
   HEAP32[$1_1 + 416 >> 2] = -3908 - $5_1;
   $2_1 = $2_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$1_1 + 420 >> 2] = 4194299 - (($2_1 & 1048575) + ($5_1 >>> 0 > 4294963388) | 0);
   $6_1 = ($2_1 | 0) == ($6_1 | 0) & $5_1 >>> 0 < $11_1 >>> 0 | $2_1 >>> 0 < $6_1 >>> 0;
   $4_1 = $31_1 + 8 | 0;
   $11_1 = HEAP32[$4_1 >> 2];
   $10_1 = $30_1 + 8 | 0;
   $5_1 = $11_1 + HEAP32[$10_1 >> 2] | 0;
   $4_1 = HEAP32[$10_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $5_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $5_1 + $6_1 | 0;
   $5_1 = $6_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $11_1 = $5_1 << 12 | $6_1 >>> 20;
   $6_1 = $6_1 << 12 | $2_1 >>> 20;
   $10_1 = $11_1;
   $9_1 = HEAP32[$1_1 + 48 >> 2];
   $11_1 = HEAP32[$1_1 + 256 >> 2];
   $2_1 = $9_1 + $11_1 | 0;
   $7_1 = HEAP32[$1_1 + 52 >> 2];
   $4_1 = $7_1 + HEAP32[$1_1 + 260 >> 2] | 0;
   $4_1 = $2_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $11_1 = $2_1;
   $2_1 = $4_1;
   $4_1 = $4_1 + $10_1 | 0;
   $6_1 = $6_1 + $11_1 | 0;
   $4_1 = $6_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $10_1 = $6_1;
   HEAP32[$1_1 + 424 >> 2] = -4 - $6_1;
   $6_1 = $4_1;
   HEAP32[$1_1 + 428 >> 2] = 4194303 - (($4_1 & 1048575) + ($10_1 >>> 0 > 4294967292) | 0);
   $10_1 = ($2_1 | 0) == ($4_1 | 0) & $10_1 >>> 0 < $11_1 >>> 0 | $2_1 >>> 0 > $4_1 >>> 0;
   $11_1 = ($2_1 | 0) == ($7_1 | 0) & $9_1 >>> 0 > $11_1 >>> 0 | $2_1 >>> 0 < $7_1 >>> 0;
   $4_1 = $24_1 + 8 | 0;
   $7_1 = HEAP32[$4_1 >> 2];
   $9_1 = $27_1 + 8 | 0;
   $2_1 = $7_1 + HEAP32[$9_1 >> 2] | 0;
   $4_1 = HEAP32[$9_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $2_1 >>> 0 < $7_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $7_1 = $2_1;
   $2_1 = $2_1 + $11_1 | 0;
   $4_1 = $7_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $5_1 >>> 20 | 0;
   $2_1 = $2_1 + $5_1 | 0;
   $4_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $2_1 + $10_1 | 0;
   $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $11_1 = $2_1 << 12 | $5_1 >>> 20;
   $9_1 = $5_1 << 12 | $6_1 >>> 20;
   $21_1 = HEAP32[$1_1 + 192 >> 2];
   $5_1 = HEAP32[$1_1 + 240 >> 2];
   $6_1 = $21_1 + $5_1 | 0;
   $14_1 = HEAP32[$1_1 + 196 >> 2];
   $4_1 = $14_1 + HEAP32[$1_1 + 244 >> 2] | 0;
   $4_1 = $5_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $7_1 = $6_1;
   $6_1 = HEAP32[$1_1 + 16 >> 2];
   $10_1 = $7_1 + $6_1 | 0;
   $5_1 = $4_1;
   $4_1 = $4_1 + HEAP32[$1_1 + 20 >> 2] | 0;
   $6_1 = $6_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $6_1 + $11_1 | 0;
   $11_1 = $9_1 + $10_1 | 0;
   $4_1 = $11_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $9_1 = $11_1;
   HEAP32[$1_1 + 432 >> 2] = -4 - $9_1;
   $11_1 = $4_1;
   HEAP32[$1_1 + 436 >> 2] = 4194303 - (($4_1 & 1048575) + ($9_1 >>> 0 > 4294967292) | 0);
   $9_1 = ($4_1 | 0) == ($6_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $4_1 >>> 0 < $6_1 >>> 0;
   $6_1 = ($5_1 | 0) == ($6_1 | 0) & $7_1 >>> 0 > $10_1 >>> 0 | $5_1 >>> 0 > $6_1 >>> 0;
   $4_1 = $17_1 + 8 | 0;
   $10_1 = HEAP32[$4_1 >> 2];
   $17_1 = HEAP32[$4_1 + 4 >> 2];
   $7_1 = ($5_1 | 0) == ($14_1 | 0) & $7_1 >>> 0 < $21_1 >>> 0 | $5_1 >>> 0 < $14_1 >>> 0;
   $4_1 = $12_1 + 8 | 0;
   $14_1 = HEAP32[$4_1 >> 2];
   $12_1 = $19_1 + 8 | 0;
   $5_1 = $14_1 + HEAP32[$12_1 >> 2] | 0;
   $4_1 = HEAP32[$12_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $5_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $12_1 = $5_1;
   $5_1 = $5_1 + $7_1 | 0;
   $4_1 = ($12_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $17_1 | 0;
   $7_1 = $5_1;
   $5_1 = $5_1 + $10_1 | 0;
   $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $7_1 = $5_1;
   $5_1 = $5_1 + $6_1 | 0;
   $4_1 = $7_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $2_1 = $2_1 >>> 20 | 0;
   $7_1 = $2_1;
   $2_1 = $2_1 + $5_1 | 0;
   $4_1 = $7_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $2_1 + $9_1 | 0;
   $2_1 = $5_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $2_1 << 12 | $5_1 >>> 20;
   $10_1 = $5_1 << 12 | $11_1 >>> 20;
   $14_1 = HEAP32[$1_1 >> 2];
   $5_1 = $26_1 & -2;
   $11_1 = $14_1 + $5_1 | 0;
   $9_1 = HEAP32[$1_1 + 4 >> 2];
   $4_1 = $9_1 + ($23_1 & 1048575) | 0;
   $5_1 = $5_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = $5_1 + $6_1 | 0;
   $10_1 = $10_1 + $11_1 | 0;
   $4_1 = $10_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$1_1 + 440 >> 2] = -4 - $10_1;
   $6_1 = $4_1;
   HEAP32[$1_1 + 444 >> 2] = 4194303 - (($4_1 & 1048575) + ($10_1 >>> 0 > 4294967292) | 0);
   $7_1 = $3_1;
   $12_1 = $13_1 & 65535;
   $10_1 = ($4_1 | 0) == ($5_1 | 0) & $10_1 >>> 0 < $11_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
   $5_1 = ($5_1 | 0) == ($9_1 | 0) & $11_1 >>> 0 < $14_1 >>> 0 | $5_1 >>> 0 < $9_1 >>> 0;
   $4_1 = $1_1 + 8 | 0;
   $3_1 = $5_1 + HEAP32[$4_1 >> 2] | 0;
   $4_1 = HEAP32[$4_1 + 4 >> 2];
   $4_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $2_1 = $2_1 >>> 20 | 0;
   $5_1 = $2_1;
   $2_1 = $2_1 + $3_1 | 0;
   $4_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $3_1 = $2_1;
   $2_1 = $2_1 + $10_1 | 0;
   $4_1 = $12_1 + (($3_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) << 12 | $2_1 >>> 20) | 0;
   $5_1 = $2_1 << 12 | $6_1 >>> 20;
   $2_1 = $5_1 + $7_1 | 0;
   HEAP32[$1_1 + 448 >> 2] = -4 - $2_1;
   HEAP32[$1_1 + 452 >> 2] = 262143 - (($2_1 >>> 0 > 4294967292) + ($2_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0);
   $15_1 = $1_1 + 376 | 0;
   $2_1 = $1_1 + 416 | 0;
   $34($15_1, $2_1, $28_1);
   $16_1 = $1_1 + 336 | 0;
   $34($16_1, $1_1 + 656 | 0, $2_1);
   $22_1 = $1_1 + 456 | 0;
   $54($0_1, $22_1);
   $3_1 = HEAP32[$1_1 + 408 >> 2];
   $2_1 = $3_1 + HEAP32[$0_1 + 32 >> 2] | 0;
   $4_1 = HEAP32[$0_1 + 36 >> 2] + HEAP32[$1_1 + 412 >> 2] | 0;
   $3_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = HEAP32[$1_1 + 372 >> 2];
   $25_1 = $4_1;
   $13_1 = HEAP32[$1_1 + 368 >> 2];
   $5_1 = $13_1;
   $4_1 = ($4_1 << 1 | $5_1 >>> 31) + $3_1 | 0;
   $5_1 = $5_1 << 1;
   $2_1 = $2_1 + $5_1 | 0;
   $4_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $6_1 = $2_1;
   HEAP32[$0_1 + 32 >> 2] = $2_1;
   $11_1 = $4_1;
   HEAP32[$0_1 + 36 >> 2] = $4_1;
   $3_1 = HEAP32[$1_1 + 400 >> 2];
   $2_1 = $3_1 + HEAP32[$0_1 + 24 >> 2] | 0;
   $4_1 = HEAP32[$0_1 + 28 >> 2] + HEAP32[$1_1 + 404 >> 2] | 0;
   $4_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $3_1 = $2_1;
   $5_1 = $4_1;
   $2_1 = HEAP32[$1_1 + 360 >> 2];
   $26_1 = $2_1;
   $4_1 = HEAP32[$1_1 + 364 >> 2];
   $23_1 = $4_1;
   $4_1 = ($4_1 << 1 | $2_1 >>> 31) + $5_1 | 0;
   $2_1 = $2_1 << 1;
   $5_1 = $2_1;
   $2_1 = $2_1 + $3_1 | 0;
   $4_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$0_1 + 24 >> 2] = $2_1;
   $10_1 = $4_1;
   HEAP32[$0_1 + 28 >> 2] = $4_1;
   $5_1 = HEAP32[$1_1 + 392 >> 2];
   $3_1 = $5_1 + HEAP32[$0_1 + 16 >> 2] | 0;
   $4_1 = HEAP32[$0_1 + 20 >> 2] + HEAP32[$1_1 + 396 >> 2] | 0;
   $4_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $3_1;
   $7_1 = $4_1;
   $3_1 = HEAP32[$1_1 + 352 >> 2];
   $18_1 = $3_1;
   $4_1 = HEAP32[$1_1 + 356 >> 2];
   $19_1 = $4_1;
   $4_1 = ($4_1 << 1 | $3_1 >>> 31) + $7_1 | 0;
   $3_1 = $3_1 << 1;
   $7_1 = $3_1;
   $3_1 = $3_1 + $5_1 | 0;
   $4_1 = $7_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$0_1 + 16 >> 2] = $3_1;
   $7_1 = $4_1;
   HEAP32[$0_1 + 20 >> 2] = $4_1;
   $9_1 = HEAP32[$1_1 + 384 >> 2];
   $5_1 = $9_1 + HEAP32[$0_1 + 8 >> 2] | 0;
   $4_1 = HEAP32[$0_1 + 12 >> 2] + HEAP32[$1_1 + 388 >> 2] | 0;
   $9_1 = $5_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $4_1 = HEAP32[$1_1 + 348 >> 2];
   $28_1 = $4_1;
   $21_1 = HEAP32[$1_1 + 344 >> 2];
   $14_1 = $21_1;
   $4_1 = ($4_1 << 1 | $14_1 >>> 31) + $9_1 | 0;
   $14_1 = $14_1 << 1;
   $5_1 = $5_1 + $14_1 | 0;
   $4_1 = $14_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $9_1 = $5_1;
   HEAP32[$0_1 + 8 >> 2] = $5_1;
   $14_1 = $4_1;
   HEAP32[$0_1 + 12 >> 2] = $4_1;
   $12_1 = HEAP32[$1_1 + 376 >> 2];
   $5_1 = $12_1 + HEAP32[$0_1 >> 2] | 0;
   $4_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$1_1 + 380 >> 2] | 0;
   $4_1 = $5_1 >>> 0 < $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $12_1 = $5_1;
   $17_1 = $4_1;
   $5_1 = HEAP32[$1_1 + 336 >> 2];
   $24_1 = $5_1;
   $4_1 = HEAP32[$1_1 + 340 >> 2];
   $20_1 = $4_1;
   $4_1 = ($4_1 << 1 | $5_1 >>> 31) + $17_1 | 0;
   $5_1 = $5_1 << 1;
   $17_1 = $5_1;
   $5_1 = $5_1 + $12_1 | 0;
   $4_1 = $17_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$0_1 >> 2] = $5_1;
   $12_1 = $4_1;
   HEAP32[$0_1 + 4 >> 2] = $4_1;
   $4_1 = $11_1 + $25_1 | 0;
   $6_1 = $6_1 + $13_1 | 0;
   $4_1 = $6_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$1_1 + 368 >> 2] = $6_1;
   HEAP32[$1_1 + 372 >> 2] = $4_1;
   $4_1 = $10_1 + $23_1 | 0;
   $6_1 = $2_1;
   $2_1 = $2_1 + $26_1 | 0;
   $4_1 = $6_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$1_1 + 360 >> 2] = $2_1;
   HEAP32[$1_1 + 364 >> 2] = $4_1;
   $4_1 = $7_1 + $19_1 | 0;
   $2_1 = $3_1 + $18_1 | 0;
   $4_1 = $2_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$1_1 + 352 >> 2] = $2_1;
   HEAP32[$1_1 + 356 >> 2] = $4_1;
   $4_1 = $14_1 + $28_1 | 0;
   $2_1 = $9_1 + $21_1 | 0;
   $4_1 = $2_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$1_1 + 344 >> 2] = $2_1;
   HEAP32[$1_1 + 348 >> 2] = $4_1;
   $4_1 = $12_1 + $20_1 | 0;
   $1_1 = $5_1 + $24_1 | 0;
   $4_1 = $1_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   HEAP32[$8_1 + 336 >> 2] = $1_1;
   HEAP32[$8_1 + 340 >> 2] = $4_1;
   $34($0_1 + 40 | 0, $16_1, $22_1);
   $34($15_1, $15_1, $8_1 + 576 | 0);
   $4_1 = HEAP32[$0_1 + 44 >> 2] + HEAP32[$8_1 + 380 >> 2] | 0;
   $2_1 = HEAP32[$8_1 + 376 >> 2];
   $1_1 = $2_1 + HEAP32[$0_1 + 40 >> 2] | 0;
   HEAP32[$0_1 + 40 >> 2] = $1_1;
   HEAP32[$0_1 + 44 >> 2] = $1_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $3_1 = HEAP32[$8_1 + 384 >> 2];
   $1_1 = $0_1 + 48 | 0;
   $2_1 = $3_1 + HEAP32[$1_1 >> 2] | 0;
   $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$8_1 + 388 >> 2] | 0;
   HEAP32[$1_1 >> 2] = $2_1;
   HEAP32[$1_1 + 4 >> 2] = $2_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $3_1 = HEAP32[$8_1 + 392 >> 2];
   $1_1 = $0_1 + 56 | 0;
   $2_1 = $3_1 + HEAP32[$1_1 >> 2] | 0;
   $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$8_1 + 396 >> 2] | 0;
   HEAP32[$1_1 >> 2] = $2_1;
   HEAP32[$1_1 + 4 >> 2] = $2_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $3_1 = HEAP32[$8_1 + 400 >> 2];
   $1_1 = $0_1 - -64 | 0;
   $2_1 = $3_1 + HEAP32[$1_1 >> 2] | 0;
   $4_1 = HEAP32[$1_1 + 4 >> 2] + HEAP32[$8_1 + 404 >> 2] | 0;
   HEAP32[$1_1 >> 2] = $2_1;
   HEAP32[$1_1 + 4 >> 2] = $2_1 >>> 0 < $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $2_1 = HEAP32[$8_1 + 408 >> 2];
   $0_1 = $0_1 + 72 | 0;
   $1_1 = $2_1 + HEAP32[$0_1 >> 2] | 0;
   $4_1 = HEAP32[$0_1 + 4 >> 2] + HEAP32[$8_1 + 412 >> 2] | 0;
   HEAP32[$0_1 >> 2] = $1_1;
   HEAP32[$0_1 + 4 >> 2] = $1_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  }
  global$0 = $8_1 + 736 | 0;
 }
 
 function $66($0_1, $1_1, $2_1) {
  var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0;
  $6_1 = global$0 - 256 | 0;
  global$0 = $6_1;
  $8_1 = $6_1 + 240 | 0;
  $69($8_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0);
  $3_1 = HEAP32[$6_1 + 244 >> 2];
  HEAP32[$0_1 >> 2] = HEAP32[$6_1 + 240 >> 2];
  HEAP32[$0_1 + 4 >> 2] = $3_1;
  $10_1 = $6_1 + 208 | 0;
  $69($10_1, HEAP32[$2_1 + 8 >> 2], HEAP32[$2_1 + 12 >> 2], 0, 0, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0);
  $7_1 = $6_1 + 224 | 0;
  $69($7_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, HEAP32[$1_1 + 8 >> 2], HEAP32[$1_1 + 12 >> 2], 0, 0);
  $14_1 = $0_1;
  $4_1 = HEAP32[$6_1 + 208 >> 2];
  $0_1 = $8_1 + 8 | 0;
  $3_1 = HEAP32[$0_1 >> 2];
  $13_1 = $4_1 + $3_1 | 0;
  $11_1 = HEAP32[$6_1 + 212 >> 2];
  $0_1 = $11_1 + HEAP32[$0_1 + 4 >> 2] | 0;
  $9_1 = $3_1 >>> 0 > $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = $9_1 + HEAP32[$6_1 + 228 >> 2] | 0;
  $3_1 = HEAP32[$6_1 + 224 >> 2];
  $8_1 = $3_1 + $13_1 | 0;
  HEAP32[$14_1 + 8 >> 2] = $8_1;
  $5_1 = $3_1 >>> 0 > $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  HEAP32[$14_1 + 12 >> 2] = $5_1;
  $17_1 = $6_1 + 160 | 0;
  $69($17_1, HEAP32[$2_1 + 16 >> 2], HEAP32[$2_1 + 20 >> 2], 0, 0, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0);
  $20_1 = $6_1 + 176 | 0;
  $69($20_1, HEAP32[$2_1 + 8 >> 2], HEAP32[$2_1 + 12 >> 2], 0, 0, HEAP32[$1_1 + 8 >> 2], HEAP32[$1_1 + 12 >> 2], 0, 0);
  $18_1 = $6_1 + 192 | 0;
  $69($18_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, HEAP32[$1_1 + 16 >> 2], HEAP32[$1_1 + 20 >> 2], 0, 0);
  $4_1 = ($9_1 | 0) == ($11_1 | 0) & $4_1 >>> 0 > $13_1 >>> 0 | $9_1 >>> 0 < $11_1 >>> 0;
  $0_1 = $10_1 + 8 | 0;
  $3_1 = $4_1 + HEAP32[$0_1 >> 2] | 0;
  $0_1 = HEAP32[$0_1 + 4 >> 2];
  $4_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $8_1 = ($5_1 | 0) == ($9_1 | 0) & $8_1 >>> 0 < $13_1 >>> 0 | $5_1 >>> 0 < $9_1 >>> 0;
  $0_1 = $7_1 + 8 | 0;
  $5_1 = $8_1 + HEAP32[$0_1 >> 2] | 0;
  $0_1 = HEAP32[$0_1 + 4 >> 2];
  $0_1 = ($5_1 >>> 0 < $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $4_1 | 0;
  $8_1 = $3_1 + $5_1 | 0;
  $0_1 = $8_1 >>> 0 < $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $11_1 = $8_1;
  $8_1 = HEAP32[$6_1 + 160 >> 2];
  $5_1 = $11_1 + $8_1 | 0;
  $15_1 = $0_1;
  $0_1 = $0_1 + HEAP32[$6_1 + 164 >> 2] | 0;
  $0_1 = $5_1 >>> 0 < $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $8_1 = HEAP32[$6_1 + 176 >> 2];
  $10_1 = $8_1 + $5_1 | 0;
  $16_1 = $0_1;
  $0_1 = $0_1 + HEAP32[$6_1 + 180 >> 2] | 0;
  $12_1 = $8_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = $12_1 + HEAP32[$6_1 + 196 >> 2] | 0;
  $8_1 = HEAP32[$6_1 + 192 >> 2];
  $9_1 = $8_1 + $10_1 | 0;
  HEAP32[$14_1 + 16 >> 2] = $9_1;
  $7_1 = $9_1 >>> 0 < $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  HEAP32[$14_1 + 20 >> 2] = $7_1;
  $25_1 = $6_1 + 96 | 0;
  $69($25_1, HEAP32[$2_1 + 24 >> 2], HEAP32[$2_1 + 28 >> 2], 0, 0, HEAP32[$1_1 >> 2], HEAP32[$1_1 + 4 >> 2], 0, 0);
  $23_1 = $6_1 + 112 | 0;
  $69($23_1, HEAP32[$2_1 + 16 >> 2], HEAP32[$2_1 + 20 >> 2], 0, 0, HEAP32[$1_1 + 8 >> 2], HEAP32[$1_1 + 12 >> 2], 0, 0);
  $24_1 = $6_1 + 128 | 0;
  $69($24_1, HEAP32[$2_1 + 8 >> 2], HEAP32[$2_1 + 12 >> 2], 0, 0, HEAP32[$1_1 + 16 >> 2], HEAP32[$1_1 + 20 >> 2], 0, 0);
  $22_1 = $6_1 + 144 | 0;
  $69($22_1, HEAP32[$2_1 >> 2], HEAP32[$2_1 + 4 >> 2], 0, 0, HEAP32[$1_1 + 24 >> 2], HEAP32[$1_1 + 28 >> 2], 0, 0);
  $8_1 = ($15_1 | 0) == ($16_1 | 0) & $5_1 >>> 0 < $11_1 >>> 0 | $15_1 >>> 0 > $16_1 >>> 0;
  $0_1 = $17_1 + 8 | 0;
  $13_1 = $8_1 + HEAP32[$0_1 >> 2] | 0;
  $0_1 = HEAP32[$0_1 + 4 >> 2];
  $3_1 = ($4_1 | 0) == ($15_1 | 0) & $3_1 >>> 0 > $11_1 >>> 0 | $4_1 >>> 0 > $15_1 >>> 0;
  $17_1 = $13_1 + $3_1 | 0;
  $0_1 = $8_1 >>> 0 > $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $8_1 = $0_1;
  $4_1 = $3_1 >>> 0 > $17_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $11_1 = $17_1;
  $3_1 = ($12_1 | 0) == ($16_1 | 0) & $5_1 >>> 0 > $10_1 >>> 0 | $12_1 >>> 0 < $16_1 >>> 0;
  $0_1 = $20_1 + 8 | 0;
  $5_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
  $0_1 = HEAP32[$0_1 + 4 >> 2];
  $0_1 = ($3_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $4_1 | 0;
  $21_1 = $5_1;
  $5_1 = $5_1 + $11_1 | 0;
  $3_1 = $21_1 >>> 0 > $5_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $20_1 = $5_1;
  $11_1 = $5_1;
  $5_1 = ($7_1 | 0) == ($12_1 | 0) & $9_1 >>> 0 < $10_1 >>> 0 | $7_1 >>> 0 < $12_1 >>> 0;
  $0_1 = $18_1 + 8 | 0;
  $9_1 = $5_1 + HEAP32[$0_1 >> 2] | 0;
  $0_1 = HEAP32[$0_1 + 4 >> 2];
  $0_1 = ($5_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $3_1 | 0;
  $5_1 = $9_1 + $11_1 | 0;
  $0_1 = $5_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $15_1 = $5_1;
  $5_1 = HEAP32[$6_1 + 96 >> 2];
  $16_1 = $15_1 + $5_1 | 0;
  $18_1 = $0_1;
  $0_1 = $0_1 + HEAP32[$6_1 + 100 >> 2] | 0;
  $0_1 = $5_1 >>> 0 > $16_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $5_1 = HEAP32[$6_1 + 112 >> 2];
  $12_1 = $5_1 + $16_1 | 0;
  $19_1 = $0_1;
  $0_1 = $0_1 + HEAP32[$6_1 + 116 >> 2] | 0;
  $0_1 = $5_1 >>> 0 > $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $5_1 = HEAP32[$6_1 + 128 >> 2];
  $7_1 = $5_1 + $12_1 | 0;
  $21_1 = $0_1;
  $0_1 = $0_1 + HEAP32[$6_1 + 132 >> 2] | 0;
  $10_1 = $5_1 >>> 0 > $7_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = $10_1 + HEAP32[$6_1 + 148 >> 2] | 0;
  $5_1 = HEAP32[$6_1 + 144 >> 2];
  $9_1 = $5_1 + $7_1 | 0;
  HEAP32[$14_1 + 24 >> 2] = $9_1;
  $0_1 = $5_1 >>> 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  HEAP32[$14_1 + 28 >> 2] = $0_1;
  $26_1 = $6_1 + 48 | 0;
  $69($26_1, HEAP32[$2_1 + 24 >> 2], HEAP32[$2_1 + 28 >> 2], 0, 0, HEAP32[$1_1 + 8 >> 2], HEAP32[$1_1 + 12 >> 2], 0, 0);
  $27_1 = $6_1 - -64 | 0;
  $69($27_1, HEAP32[$2_1 + 16 >> 2], HEAP32[$2_1 + 20 >> 2], 0, 0, HEAP32[$1_1 + 16 >> 2], HEAP32[$1_1 + 20 >> 2], 0, 0);
  $28_1 = $6_1 + 80 | 0;
  $69($28_1, HEAP32[$2_1 + 8 >> 2], HEAP32[$2_1 + 12 >> 2], 0, 0, HEAP32[$1_1 + 24 >> 2], HEAP32[$1_1 + 28 >> 2], 0, 0);
  $9_1 = ($0_1 | 0) == ($10_1 | 0) & $7_1 >>> 0 > $9_1 >>> 0 | $0_1 >>> 0 < $10_1 >>> 0;
  $0_1 = $22_1 + 8 | 0;
  $5_1 = $9_1 + HEAP32[$0_1 >> 2] | 0;
  $0_1 = HEAP32[$0_1 + 4 >> 2];
  $9_1 = $5_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $7_1 = ($10_1 | 0) == ($21_1 | 0) & $7_1 >>> 0 < $12_1 >>> 0 | $10_1 >>> 0 < $21_1 >>> 0;
  $0_1 = $24_1 + 8 | 0;
  $11_1 = $7_1 + HEAP32[$0_1 >> 2] | 0;
  $0_1 = HEAP32[$0_1 + 4 >> 2];
  $10_1 = $7_1 >>> 0 > $11_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $7_1 = ($3_1 | 0) == ($18_1 | 0) & $15_1 >>> 0 < $20_1 >>> 0 | $3_1 >>> 0 > $18_1 >>> 0;
  $0_1 = ($3_1 | 0) == ($4_1 | 0) & $17_1 >>> 0 > $20_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
  $3_1 = ($4_1 | 0) == ($8_1 | 0) & $13_1 >>> 0 > $17_1 >>> 0 | $4_1 >>> 0 < $8_1 >>> 0;
  $4_1 = $0_1 + $3_1 | 0;
  $0_1 = $3_1 >>> 0 > $4_1 >>> 0;
  $8_1 = $4_1 + $7_1 | 0;
  $13_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $3_1 = ($18_1 | 0) == ($19_1 | 0) & $15_1 >>> 0 > $16_1 >>> 0 | $18_1 >>> 0 > $19_1 >>> 0;
  $0_1 = $25_1 + 8 | 0;
  $4_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
  $0_1 = HEAP32[$0_1 + 4 >> 2];
  $0_1 = ($3_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $13_1 | 0;
  $7_1 = $4_1;
  $4_1 = $4_1 + $8_1 | 0;
  $3_1 = $7_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $18_1 = $4_1;
  $7_1 = $4_1;
  $4_1 = ($19_1 | 0) == ($21_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $19_1 >>> 0 > $21_1 >>> 0;
  $0_1 = $23_1 + 8 | 0;
  $12_1 = $4_1 + HEAP32[$0_1 >> 2] | 0;
  $0_1 = HEAP32[$0_1 + 4 >> 2];
  $0_1 = ($4_1 >>> 0 > $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $3_1 | 0;
  $7_1 = $7_1 + $12_1 | 0;
  $4_1 = $7_1 >>> 0 < $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = $4_1 + $10_1 | 0;
  $21_1 = $7_1;
  $16_1 = $7_1 + $11_1 | 0;
  $17_1 = $7_1 >>> 0 > $16_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = $17_1 + $9_1 | 0;
  $7_1 = $5_1 + $16_1 | 0;
  $0_1 = $7_1 >>> 0 < $16_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $20_1 = $7_1;
  $7_1 = HEAP32[$6_1 + 48 >> 2];
  $15_1 = $20_1 + $7_1 | 0;
  $22_1 = $0_1;
  $0_1 = $0_1 + HEAP32[$6_1 + 52 >> 2] | 0;
  $19_1 = $7_1 >>> 0 > $15_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = $19_1 + HEAP32[$6_1 + 68 >> 2] | 0;
  $10_1 = HEAP32[$6_1 + 64 >> 2];
  $7_1 = $10_1 + $15_1 | 0;
  $11_1 = HEAP32[$6_1 + 80 >> 2];
  $12_1 = $7_1 + $11_1 | 0;
  $10_1 = $7_1 >>> 0 < $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = $10_1 + HEAP32[$6_1 + 84 >> 2] | 0;
  HEAP32[$14_1 + 32 >> 2] = $12_1;
  $0_1 = $12_1 >>> 0 < $11_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  HEAP32[$14_1 + 36 >> 2] = $0_1;
  $23_1 = $6_1 + 16 | 0;
  $69($23_1, HEAP32[$2_1 + 24 >> 2], HEAP32[$2_1 + 28 >> 2], 0, 0, HEAP32[$1_1 + 16 >> 2], HEAP32[$1_1 + 20 >> 2], 0, 0);
  $24_1 = $6_1 + 32 | 0;
  $69($24_1, HEAP32[$2_1 + 16 >> 2], HEAP32[$2_1 + 20 >> 2], 0, 0, HEAP32[$1_1 + 24 >> 2], HEAP32[$1_1 + 28 >> 2], 0, 0);
  $11_1 = ($0_1 | 0) == ($10_1 | 0) & $7_1 >>> 0 > $12_1 >>> 0 | $0_1 >>> 0 < $10_1 >>> 0;
  $0_1 = $28_1 + 8 | 0;
  $12_1 = $11_1 + HEAP32[$0_1 >> 2] | 0;
  $0_1 = HEAP32[$0_1 + 4 >> 2];
  $11_1 = $12_1 >>> 0 < $11_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $7_1 = ($10_1 | 0) == ($19_1 | 0) & $7_1 >>> 0 < $15_1 >>> 0 | $10_1 >>> 0 < $19_1 >>> 0;
  $0_1 = $27_1 + 8 | 0;
  $10_1 = $7_1 + HEAP32[$0_1 >> 2] | 0;
  $0_1 = HEAP32[$0_1 + 4 >> 2];
  $7_1 = $7_1 >>> 0 > $10_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $9_1 = ($9_1 | 0) == ($22_1 | 0) & $5_1 >>> 0 > $20_1 >>> 0 | $9_1 >>> 0 > $22_1 >>> 0;
  $5_1 = ($4_1 | 0) == ($17_1 | 0) & $16_1 >>> 0 < $21_1 >>> 0 | $4_1 >>> 0 > $17_1 >>> 0;
  $0_1 = ($3_1 | 0) == ($4_1 | 0) & $18_1 >>> 0 > $21_1 >>> 0 | $3_1 >>> 0 > $4_1 >>> 0;
  $3_1 = ($3_1 | 0) == ($13_1 | 0) & $8_1 >>> 0 > $18_1 >>> 0 | $3_1 >>> 0 < $13_1 >>> 0;
  $4_1 = $0_1 + $3_1 | 0;
  $0_1 = $3_1 >>> 0 > $4_1 >>> 0;
  $3_1 = $4_1 + $5_1 | 0;
  $0_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $8_1 = $3_1 + $9_1 | 0;
  $5_1 = $8_1 >>> 0 < $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $3_1 = ($19_1 | 0) == ($22_1 | 0) & $15_1 >>> 0 < $20_1 >>> 0 | $19_1 >>> 0 < $22_1 >>> 0;
  $0_1 = $26_1 + 8 | 0;
  $4_1 = $3_1 + HEAP32[$0_1 >> 2] | 0;
  $0_1 = HEAP32[$0_1 + 4 >> 2];
  $0_1 = ($3_1 >>> 0 > $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $5_1 | 0;
  $3_1 = $4_1 + $8_1 | 0;
  $4_1 = $3_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = $4_1 + $7_1 | 0;
  $7_1 = $12_1;
  $16_1 = $3_1;
  $13_1 = $3_1 + $10_1 | 0;
  $12_1 = $13_1;
  $9_1 = $7_1 + $12_1 | 0;
  $3_1 = $3_1 >>> 0 > $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = $3_1 + $11_1 | 0;
  $13_1 = HEAP32[$6_1 + 16 >> 2];
  $10_1 = $13_1 + $9_1 | 0;
  $15_1 = $9_1 >>> 0 < $12_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = $15_1 + HEAP32[$6_1 + 20 >> 2] | 0;
  $11_1 = $10_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = $11_1 + HEAP32[$6_1 + 36 >> 2] | 0;
  $7_1 = HEAP32[$6_1 + 32 >> 2];
  $13_1 = $7_1 + $10_1 | 0;
  HEAP32[$14_1 + 40 >> 2] = $13_1;
  $7_1 = $7_1 >>> 0 > $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  HEAP32[$14_1 + 44 >> 2] = $7_1;
  $69($6_1, HEAP32[$2_1 + 24 >> 2], HEAP32[$2_1 + 28 >> 2], 0, 0, HEAP32[$1_1 + 24 >> 2], HEAP32[$1_1 + 28 >> 2], 0, 0);
  $2_1 = $14_1;
  $1_1 = ($11_1 | 0) == ($15_1 | 0) & $9_1 >>> 0 > $10_1 >>> 0 | $11_1 >>> 0 < $15_1 >>> 0;
  $0_1 = $23_1 + 8 | 0;
  $14_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
  $0_1 = HEAP32[$0_1 + 4 >> 2];
  $1_1 = $1_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $9_1 = ($3_1 | 0) == ($15_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $3_1 >>> 0 > $15_1 >>> 0;
  $0_1 = ($3_1 | 0) == ($4_1 | 0) & $12_1 >>> 0 < $16_1 >>> 0 | $3_1 >>> 0 < $4_1 >>> 0;
  $3_1 = ($4_1 | 0) == ($5_1 | 0) & $8_1 >>> 0 > $16_1 >>> 0 | $4_1 >>> 0 < $5_1 >>> 0;
  $4_1 = $0_1 + $3_1 | 0;
  $0_1 = $3_1 >>> 0 > $4_1 >>> 0;
  $8_1 = $4_1 + $9_1 | 0;
  $9_1 = $8_1 >>> 0 < $4_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = $9_1 + $1_1 | 0;
  $1_1 = $8_1 + $14_1 | 0;
  $3_1 = $1_1 >>> 0 < $8_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $5_1 = $1_1;
  $4_1 = $1_1;
  $1_1 = ($7_1 | 0) == ($11_1 | 0) & $10_1 >>> 0 > $13_1 >>> 0 | $7_1 >>> 0 < $11_1 >>> 0;
  $0_1 = $24_1 + 8 | 0;
  $14_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
  $0_1 = HEAP32[$0_1 + 4 >> 2];
  $0_1 = ($1_1 >>> 0 > $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $3_1 | 0;
  $4_1 = $4_1 + $14_1 | 0;
  $1_1 = $4_1 >>> 0 < $14_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = $1_1 + HEAP32[$6_1 + 4 >> 2] | 0;
  $14_1 = HEAP32[$6_1 >> 2];
  $13_1 = $14_1 + $4_1 | 0;
  HEAP32[$2_1 + 48 >> 2] = $13_1;
  $0_1 = $14_1 >>> 0 > $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  HEAP32[$2_1 + 52 >> 2] = $0_1;
  $14_1 = ($0_1 | 0) == ($1_1 | 0) & $4_1 >>> 0 > $13_1 >>> 0 | $0_1 >>> 0 < $1_1 >>> 0;
  $4_1 = ($1_1 | 0) == ($3_1 | 0) & $4_1 >>> 0 < $5_1 >>> 0 | $1_1 >>> 0 < $3_1 >>> 0;
  $1_1 = ($3_1 | 0) == ($9_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $3_1 >>> 0 < $9_1 >>> 0;
  $0_1 = $6_1 + 8 | 0;
  $3_1 = $1_1 + HEAP32[$0_1 >> 2] | 0;
  $0_1 = HEAP32[$0_1 + 4 >> 2];
  $0_1 = $1_1 >>> 0 > $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $1_1 = $3_1 + $4_1 | 0;
  $0_1 = $1_1 >>> 0 < $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $5_1 = $1_1;
  $1_1 = $1_1 + $14_1 | 0;
  $0_1 = $5_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  HEAP32[$2_1 + 56 >> 2] = $1_1;
  HEAP32[$2_1 + 60 >> 2] = $0_1;
  global$0 = $6_1 + 256 | 0;
 }
 
 function $67($0_1, $1_1, $2_1, $3_1) {
  var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0, $16_1 = 0, $17_1 = 0, $18_1 = 0, $19_1 = 0, $20_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $24_1 = 0, $25_1 = 0, $26_1 = 0, $27_1 = 0, $28_1 = 0, $29_1 = 0, $30_1 = 0, $31_1 = 0, $32_1 = 0, $33_1 = 0, $34_1 = 0, $35_1 = 0, $36_1 = 0, $37_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $41_1 = 0, $42_1 = 0, $43_1 = 0, $44_1 = 0, $45_1 = 0, $46_1 = 0, $47_1 = 0, $48_1 = 0, $49_1 = 0, $50_1 = 0;
  $7_1 = global$0 - 480 | 0;
  global$0 = $7_1;
  $4_1 = HEAP32[$2_1 + 4 >> 2];
  $30_1 = $4_1;
  $10_1 = $4_1 >> 31;
  $4_1 = HEAP32[$0_1 + 4 >> 2];
  $12_1 = $4_1;
  $4_1 = $4_1 >> 31;
  $35_1 = $7_1 + 352 | 0;
  $28_1 = HEAP32[$2_1 >> 2];
  $6_1 = HEAP32[$0_1 >> 2];
  $5_1 = $4_1;
  $69($35_1, $28_1, $30_1, $10_1, $10_1, $6_1, $12_1, $4_1, $4_1);
  $4_1 = HEAP32[$2_1 + 12 >> 2];
  $31_1 = $4_1;
  $13_1 = $4_1 >> 31;
  $4_1 = HEAP32[$1_1 + 4 >> 2];
  $11_1 = $4_1;
  $4_1 = $4_1 >> 31;
  $38_1 = $7_1 + 384 | 0;
  $16_1 = HEAP32[$2_1 + 8 >> 2];
  $15_1 = HEAP32[$1_1 >> 2];
  $9_1 = $4_1;
  $69($38_1, $16_1, $31_1, $13_1, $13_1, $15_1, $11_1, $4_1, $4_1);
  $4_1 = HEAP32[$2_1 + 20 >> 2];
  $17_1 = $4_1;
  $4_1 = $4_1 >> 31;
  $36_1 = $7_1 + 368 | 0;
  $32_1 = HEAP32[$2_1 + 16 >> 2];
  $23_1 = $4_1;
  $69($36_1, $32_1, $17_1, $4_1, $4_1, $6_1, $12_1, $5_1, $5_1);
  $37_1 = HEAP32[$2_1 + 24 >> 2];
  $2_1 = HEAP32[$2_1 + 28 >> 2];
  $18_1 = $2_1;
  $2_1 = $2_1 >> 31;
  $33_1 = $7_1 + 400 | 0;
  $27_1 = $2_1;
  $69($33_1, $37_1, $18_1, $2_1, $2_1, $15_1, $11_1, $9_1, $9_1);
  $43_1 = HEAP32[$1_1 + 32 >> 2];
  $2_1 = HEAP32[$1_1 + 36 >> 2];
  $50_1 = $2_1;
  $2_1 = $2_1 >> 31;
  $9_1 = $2_1;
  $5_1 = $2_1 & $16_1;
  $44_1 = HEAP32[$0_1 + 32 >> 2];
  $2_1 = HEAP32[$0_1 + 36 >> 2];
  $45_1 = $2_1;
  $2_1 = $2_1 >> 31;
  $4_1 = $5_1;
  $12_1 = $2_1;
  $5_1 = $2_1 & $28_1;
  $2_1 = $4_1 + $5_1 | 0;
  $4_1 = ($12_1 & $30_1) + ($9_1 & $31_1) | 0;
  $5_1 = $2_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $4_1 = HEAP32[$3_1 + 40 >> 2];
  $8_1 = $4_1;
  $21_1 = HEAP32[$7_1 + 388 >> 2];
  $4_1 = $21_1 + HEAP32[$7_1 + 356 >> 2] | 0;
  $24_1 = HEAP32[$3_1 + 44 >> 2];
  $22_1 = HEAP32[$7_1 + 384 >> 2];
  $6_1 = HEAP32[$7_1 + 352 >> 2];
  $11_1 = $22_1 + $6_1 | 0;
  $6_1 = $6_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $25_1 = __wasm_i64_mul($8_1, $24_1, $11_1, $6_1);
  $15_1 = $25_1 + $2_1 | 0;
  $4_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
  $29_1 = $2_1 - $15_1 | 0;
  $2_1 = $5_1 - ((($15_1 >>> 0 < $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) & 1073741823) + ($2_1 >>> 0 < $15_1 >>> 0) | 0) | 0;
  $25_1 = $2_1;
  $14_1 = $2_1 >> 31;
  $2_1 = HEAP32[$3_1 + 4 >> 2];
  $19_1 = $2_1;
  $2_1 = $2_1 >> 31;
  $39_1 = $7_1 + 320 | 0;
  $20_1 = HEAP32[$3_1 >> 2];
  $15_1 = $2_1;
  $69($39_1, $29_1, $25_1, $14_1, $14_1, $20_1, $19_1, $2_1, $2_1);
  $5_1 = $12_1 & $32_1;
  $2_1 = $5_1 + ($9_1 & $37_1) | 0;
  $4_1 = ($9_1 & $18_1) + ($12_1 & $17_1) | 0;
  $5_1 = $2_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $26_1 = HEAP32[$7_1 + 404 >> 2];
  $4_1 = $26_1 + HEAP32[$7_1 + 372 >> 2] | 0;
  $40_1 = HEAP32[$7_1 + 400 >> 2];
  $9_1 = HEAP32[$7_1 + 368 >> 2];
  $12_1 = $40_1 + $9_1 | 0;
  $9_1 = $9_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $24_1 = __wasm_i64_mul($12_1, $9_1, $8_1, $24_1);
  $8_1 = $24_1 + $2_1 | 0;
  $4_1 = $5_1 + i64toi32_i32$HIGH_BITS | 0;
  $34_1 = $2_1 - $8_1 | 0;
  $2_1 = $5_1 - ((($8_1 >>> 0 < $24_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) & 1073741823) + ($2_1 >>> 0 < $8_1 >>> 0) | 0) | 0;
  $24_1 = $2_1;
  $2_1 = $2_1 >> 31;
  $41_1 = $7_1 + 336 | 0;
  $42_1 = $2_1;
  $69($41_1, $34_1, $24_1, $2_1, $2_1, $20_1, $19_1, $15_1, $15_1);
  $2_1 = HEAP32[$0_1 + 12 >> 2];
  $8_1 = $2_1;
  $2_1 = $2_1 >> 31;
  $46_1 = $7_1 + 416 | 0;
  $15_1 = HEAP32[$0_1 + 8 >> 2];
  $5_1 = $2_1;
  $69($46_1, $28_1, $30_1, $10_1, $10_1, $15_1, $8_1, $2_1, $2_1);
  $2_1 = HEAP32[$1_1 + 12 >> 2];
  $19_1 = $2_1;
  $2_1 = $2_1 >> 31;
  $4_1 = $2_1;
  $47_1 = $7_1 + 448 | 0;
  $20_1 = HEAP32[$1_1 + 8 >> 2];
  $69($47_1, $16_1, $31_1, $13_1, $13_1, $20_1, $19_1, $4_1, $4_1);
  $48_1 = $7_1 + 432 | 0;
  $69($48_1, $32_1, $17_1, $23_1, $23_1, $15_1, $8_1, $5_1, $5_1);
  $49_1 = $7_1 + 464 | 0;
  $69($49_1, $37_1, $18_1, $27_1, $27_1, $20_1, $19_1, $4_1, $4_1);
  $2_1 = HEAP32[$7_1 + 336 >> 2];
  $8_1 = $2_1;
  $15_1 = HEAP32[$7_1 + 340 >> 2];
  $4_1 = $15_1 + $9_1 | 0;
  $2_1 = $2_1 + $12_1 | 0;
  $4_1 = $2_1 >>> 0 < $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $5_1 = $2_1;
  $2_1 = $4_1;
  $15_1 = ($15_1 | 0) == ($4_1 | 0) & $5_1 >>> 0 < $8_1 >>> 0 | $4_1 >>> 0 < $15_1 >>> 0;
  $4_1 = $41_1 + 8 | 0;
  $8_1 = HEAP32[$4_1 >> 2];
  $20_1 = HEAP32[$4_1 + 4 >> 2];
  $9_1 = ($9_1 | 0) == ($26_1 | 0) & $12_1 >>> 0 < $40_1 >>> 0 | $9_1 >>> 0 < $26_1 >>> 0;
  $4_1 = $36_1 + 8 | 0;
  $12_1 = HEAP32[$4_1 >> 2];
  $19_1 = $33_1 + 8 | 0;
  $5_1 = $12_1 + HEAP32[$19_1 >> 2] | 0;
  $4_1 = HEAP32[$19_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
  $4_1 = $5_1 >>> 0 < $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $12_1 = $5_1;
  $5_1 = $5_1 + $9_1 | 0;
  $4_1 = ($12_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $20_1 | 0;
  $9_1 = $5_1;
  $5_1 = $5_1 + $8_1 | 0;
  $4_1 = $9_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $9_1 = $5_1 + $15_1 | 0;
  $5_1 = $9_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $12_1 = $5_1 << 2 | $9_1 >>> 30;
  $15_1 = $9_1 << 2 | $2_1 >>> 30;
  $19_1 = HEAP32[$7_1 + 464 >> 2];
  $2_1 = HEAP32[$7_1 + 432 >> 2];
  $9_1 = $19_1 + $2_1 | 0;
  $8_1 = HEAP32[$7_1 + 468 >> 2];
  $4_1 = $8_1 + HEAP32[$7_1 + 436 >> 2] | 0;
  $2_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $4_1 = $2_1 + $12_1 | 0;
  $12_1 = $9_1 + $15_1 | 0;
  $15_1 = $12_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $20_1 = ($2_1 | 0) == ($15_1 | 0) & $9_1 >>> 0 > $12_1 >>> 0 | $2_1 >>> 0 > $15_1 >>> 0;
  $9_1 = ($2_1 | 0) == ($8_1 | 0) & $9_1 >>> 0 < $19_1 >>> 0 | $2_1 >>> 0 < $8_1 >>> 0;
  $4_1 = $48_1 + 8 | 0;
  $8_1 = HEAP32[$4_1 >> 2];
  $19_1 = $49_1 + 8 | 0;
  $2_1 = $8_1 + HEAP32[$19_1 >> 2] | 0;
  $4_1 = HEAP32[$19_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
  $4_1 = $2_1 >>> 0 < $8_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $8_1 = $2_1;
  $2_1 = $2_1 + $9_1 | 0;
  $4_1 = ($5_1 >> 31) + ($8_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
  $5_1 = $5_1 >> 30;
  $2_1 = $2_1 + $5_1 | 0;
  $4_1 = $5_1 >>> 0 > $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $9_1 = $2_1 + $20_1 | 0;
  $2_1 = $9_1 >>> 0 < $2_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $5_1 = HEAP32[$7_1 + 320 >> 2];
  $19_1 = $5_1;
  $20_1 = HEAP32[$7_1 + 324 >> 2];
  $4_1 = $20_1 + $6_1 | 0;
  $5_1 = $5_1 + $11_1 | 0;
  $4_1 = $5_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $8_1 = $5_1;
  $5_1 = $4_1;
  $8_1 = ($20_1 | 0) == ($4_1 | 0) & $8_1 >>> 0 < $19_1 >>> 0 | $4_1 >>> 0 < $20_1 >>> 0;
  $4_1 = $39_1 + 8 | 0;
  $20_1 = HEAP32[$4_1 >> 2];
  $19_1 = HEAP32[$4_1 + 4 >> 2];
  $11_1 = ($6_1 | 0) == ($21_1 | 0) & $11_1 >>> 0 < $22_1 >>> 0 | $6_1 >>> 0 < $21_1 >>> 0;
  $4_1 = $35_1 + 8 | 0;
  $21_1 = HEAP32[$4_1 >> 2];
  $26_1 = $38_1 + 8 | 0;
  $6_1 = $21_1 + HEAP32[$26_1 >> 2] | 0;
  $4_1 = HEAP32[$26_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
  $4_1 = $6_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $22_1 = $6_1;
  $6_1 = $6_1 + $11_1 | 0;
  $4_1 = ($22_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $19_1 | 0;
  $11_1 = $6_1;
  $6_1 = $6_1 + $20_1 | 0;
  $4_1 = $11_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $11_1 = $6_1 + $8_1 | 0;
  $6_1 = $11_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $8_1 = $6_1 << 2 | $11_1 >>> 30;
  $11_1 = $11_1 << 2 | $5_1 >>> 30;
  $19_1 = HEAP32[$7_1 + 448 >> 2];
  $21_1 = HEAP32[$7_1 + 416 >> 2];
  $5_1 = $19_1 + $21_1 | 0;
  $20_1 = HEAP32[$7_1 + 452 >> 2];
  $4_1 = $20_1 + HEAP32[$7_1 + 420 >> 2] | 0;
  $4_1 = $5_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $21_1 = $5_1;
  $5_1 = $4_1;
  $4_1 = $4_1 + $8_1 | 0;
  $8_1 = $11_1 + $21_1 | 0;
  $11_1 = $8_1 >>> 0 < $21_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $26_1 = ($5_1 | 0) == ($11_1 | 0) & $8_1 >>> 0 < $21_1 >>> 0 | $5_1 >>> 0 > $11_1 >>> 0;
  $21_1 = ($5_1 | 0) == ($20_1 | 0) & $19_1 >>> 0 > $21_1 >>> 0 | $5_1 >>> 0 < $20_1 >>> 0;
  $4_1 = $46_1 + 8 | 0;
  $20_1 = HEAP32[$4_1 >> 2];
  $19_1 = $47_1 + 8 | 0;
  $5_1 = $20_1 + HEAP32[$19_1 >> 2] | 0;
  $4_1 = HEAP32[$19_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
  $4_1 = $5_1 >>> 0 < $20_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $19_1 = $5_1;
  $5_1 = $5_1 + $21_1 | 0;
  $4_1 = ($6_1 >> 31) + ($19_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
  $6_1 = $6_1 >> 30;
  $5_1 = $5_1 + $6_1 | 0;
  $4_1 = $6_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $6_1 = $5_1 + $26_1 | 0;
  $5_1 = $6_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $21_1 = HEAP32[$1_1 + 24 >> 2];
  $20_1 = HEAP32[$1_1 + 28 >> 2];
  $19_1 = HEAP32[$1_1 + 16 >> 2];
  $26_1 = HEAP32[$1_1 + 20 >> 2];
  $35_1 = HEAP32[$0_1 + 24 >> 2];
  $38_1 = HEAP32[$0_1 + 28 >> 2];
  $36_1 = HEAP32[$0_1 + 16 >> 2];
  $33_1 = HEAP32[$0_1 + 20 >> 2];
  $4_1 = HEAP32[$3_1 + 8 >> 2];
  $22_1 = HEAP32[$3_1 + 12 >> 2];
  if ($4_1 | $22_1) {
   $41_1 = $7_1 + 304 | 0;
   $40_1 = $4_1;
   $4_1 = $22_1 >> 31;
   $69($41_1, $29_1, $25_1, $14_1, $14_1, $40_1, $22_1, $4_1, $4_1);
   $39_1 = $7_1 + 288 | 0;
   $69($39_1, $34_1, $24_1, $42_1, $42_1, $40_1, $22_1, $4_1, $4_1);
   $14_1 = $15_1;
   $22_1 = $12_1;
   $15_1 = HEAP32[$7_1 + 288 >> 2];
   $12_1 = $12_1 + $15_1 | 0;
   $4_1 = $14_1 + HEAP32[$7_1 + 292 >> 2] | 0;
   $15_1 = $12_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $14_1 = ($14_1 | 0) == ($15_1 | 0) & $12_1 >>> 0 < $22_1 >>> 0 | $14_1 >>> 0 > $15_1 >>> 0;
   $4_1 = $39_1 + 8 | 0;
   $22_1 = HEAP32[$4_1 >> 2];
   $9_1 = $22_1 + $9_1 | 0;
   $4_1 = $2_1 + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $9_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $2_1 = $9_1;
   $9_1 = $9_1 + $14_1 | 0;
   $2_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $14_1 = $11_1;
   $22_1 = $8_1;
   $11_1 = HEAP32[$7_1 + 304 >> 2];
   $8_1 = $8_1 + $11_1 | 0;
   $4_1 = $14_1 + HEAP32[$7_1 + 308 >> 2] | 0;
   $11_1 = $8_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $14_1 = ($14_1 | 0) == ($11_1 | 0) & $8_1 >>> 0 < $22_1 >>> 0 | $11_1 >>> 0 < $14_1 >>> 0;
   $4_1 = $41_1 + 8 | 0;
   $22_1 = HEAP32[$4_1 >> 2];
   $6_1 = $22_1 + $6_1 | 0;
   $4_1 = $5_1 + HEAP32[$4_1 + 4 >> 2] | 0;
   $4_1 = $6_1 >>> 0 < $22_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $5_1 = $6_1;
   $6_1 = $6_1 + $14_1 | 0;
   $5_1 = $5_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  }
  HEAP32[$0_1 >> 2] = $8_1;
  HEAP32[$0_1 + 4 >> 2] = $11_1 & 1073741823;
  HEAP32[$1_1 >> 2] = $12_1;
  HEAP32[$1_1 + 4 >> 2] = $15_1 & 1073741823;
  $4_1 = $33_1 >> 31;
  $8_1 = $4_1;
  $22_1 = $7_1 + 272 | 0;
  $14_1 = $28_1;
  $69($22_1, $14_1, $30_1, $10_1, $10_1, $36_1, $33_1, $4_1, $4_1);
  $42_1 = $7_1 + 240 | 0;
  $28_1 = $16_1;
  $10_1 = $13_1;
  $16_1 = $26_1;
  $4_1 = $16_1 >> 31;
  $69($42_1, $28_1, $31_1, $10_1, $10_1, $19_1, $16_1, $4_1, $4_1);
  $13_1 = $7_1 + 256 | 0;
  $69($13_1, $32_1, $17_1, $23_1, $23_1, $36_1, $33_1, $8_1, $8_1);
  $16_1 = $7_1 + 224 | 0;
  $69($16_1, $37_1, $18_1, $27_1, $27_1, $19_1, $26_1, $4_1, $4_1);
  $23_1 = HEAP32[$7_1 + 224 >> 2];
  $8_1 = HEAP32[$7_1 + 256 >> 2];
  $12_1 = $23_1 + $8_1 | 0;
  $10_1 = HEAP32[$7_1 + 228 >> 2];
  $4_1 = $10_1 + HEAP32[$7_1 + 260 >> 2] | 0;
  $8_1 = $8_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $23_1 = ($10_1 | 0) == ($8_1 | 0) & $12_1 >>> 0 < $23_1 >>> 0 | $8_1 >>> 0 < $10_1 >>> 0;
  $4_1 = $13_1 + 8 | 0;
  $13_1 = HEAP32[$4_1 >> 2];
  $16_1 = $16_1 + 8 | 0;
  $10_1 = $13_1 + HEAP32[$16_1 >> 2] | 0;
  $4_1 = HEAP32[$16_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
  $4_1 = $10_1 >>> 0 < $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $13_1 = $10_1;
  $10_1 = $10_1 + $23_1 | 0;
  $4_1 = ($2_1 >> 31) + ($13_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
  $16_1 = $2_1 >> 30;
  $10_1 = $10_1 + $16_1 | 0;
  $4_1 = $16_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $13_1 = $10_1;
  $10_1 = $4_1;
  $4_1 = $2_1 << 2 | $9_1 >>> 30;
  $2_1 = $9_1 << 2 | $15_1 >>> 30;
  $9_1 = $2_1 + $12_1 | 0;
  $4_1 = $4_1 + $8_1 | 0;
  $2_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $15_1 = ($8_1 | 0) == ($2_1 | 0) & $9_1 >>> 0 < $12_1 >>> 0 | $2_1 >>> 0 < $8_1 >>> 0;
  $12_1 = $15_1 + $13_1 | 0;
  $4_1 = $10_1;
  $15_1 = $12_1 >>> 0 < $15_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $16_1 = HEAP32[$7_1 + 240 >> 2];
  $10_1 = HEAP32[$7_1 + 272 >> 2];
  $8_1 = $16_1 + $10_1 | 0;
  $13_1 = HEAP32[$7_1 + 244 >> 2];
  $4_1 = $13_1 + HEAP32[$7_1 + 276 >> 2] | 0;
  $10_1 = $8_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $16_1 = ($13_1 | 0) == ($10_1 | 0) & $8_1 >>> 0 < $16_1 >>> 0 | $10_1 >>> 0 < $13_1 >>> 0;
  $4_1 = $22_1 + 8 | 0;
  $23_1 = HEAP32[$4_1 >> 2];
  $27_1 = $42_1 + 8 | 0;
  $13_1 = $23_1 + HEAP32[$27_1 >> 2] | 0;
  $4_1 = HEAP32[$27_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
  $4_1 = $13_1 >>> 0 < $23_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $19_1 = $13_1;
  $13_1 = $13_1 + $16_1 | 0;
  $4_1 = ($5_1 >> 31) + ($19_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
  $23_1 = $5_1 >> 30;
  $13_1 = $13_1 + $23_1 | 0;
  $4_1 = $23_1 >>> 0 > $13_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $16_1 = $13_1;
  $13_1 = $4_1;
  $4_1 = $5_1 << 2 | $6_1 >>> 30;
  $5_1 = $6_1 << 2 | $11_1 >>> 30;
  $6_1 = $5_1 + $8_1 | 0;
  $4_1 = $4_1 + $10_1 | 0;
  $5_1 = $5_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $8_1 = ($10_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 < $8_1 >>> 0 | $5_1 >>> 0 < $10_1 >>> 0;
  $11_1 = $8_1 + $16_1 | 0;
  $4_1 = $13_1;
  $8_1 = $8_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $13_1 = HEAP32[$3_1 + 16 >> 2];
  $16_1 = HEAP32[$3_1 + 20 >> 2];
  if ($13_1 | $16_1) {
   $4_1 = $16_1 >> 31;
   $23_1 = $7_1 + 208 | 0;
   $10_1 = $4_1;
   $4_1 = $25_1 >> 31;
   $69($23_1, $13_1, $16_1, $10_1, $10_1, $29_1, $25_1, $4_1, $4_1);
   $27_1 = $7_1 + 192 | 0;
   $4_1 = $24_1 >> 31;
   $69($27_1, $13_1, $16_1, $10_1, $10_1, $34_1, $24_1, $4_1, $4_1);
   $10_1 = HEAP32[$7_1 + 196 >> 2];
   $4_1 = $10_1 + $2_1 | 0;
   $2_1 = $9_1;
   $13_1 = HEAP32[$7_1 + 192 >> 2];
   $9_1 = $13_1 + $9_1 | 0;
   $2_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $13_1 = ($10_1 | 0) == ($2_1 | 0) & $9_1 >>> 0 < $13_1 >>> 0 | $2_1 >>> 0 < $10_1 >>> 0;
   $4_1 = $27_1 + 8 | 0;
   $10_1 = HEAP32[$4_1 >> 2] + $12_1 | 0;
   $4_1 = HEAP32[$4_1 + 4 >> 2] + $15_1 | 0;
   $4_1 = $12_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $12_1 = $10_1 + $13_1 | 0;
   $15_1 = $12_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $10_1 = HEAP32[$7_1 + 212 >> 2];
   $4_1 = $10_1 + $5_1 | 0;
   $5_1 = $6_1;
   $13_1 = HEAP32[$7_1 + 208 >> 2];
   $6_1 = $13_1 + $6_1 | 0;
   $5_1 = $5_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $13_1 = ($10_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 < $13_1 >>> 0 | $5_1 >>> 0 < $10_1 >>> 0;
   $4_1 = $23_1 + 8 | 0;
   $10_1 = HEAP32[$4_1 >> 2] + $11_1 | 0;
   $4_1 = HEAP32[$4_1 + 4 >> 2] + $8_1 | 0;
   $4_1 = $11_1 >>> 0 > $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $11_1 = $10_1 + $13_1 | 0;
   $8_1 = $11_1 >>> 0 < $10_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  }
  HEAP32[$0_1 + 8 >> 2] = $6_1;
  HEAP32[$0_1 + 12 >> 2] = $5_1 & 1073741823;
  HEAP32[$1_1 + 8 >> 2] = $9_1;
  HEAP32[$1_1 + 12 >> 2] = $2_1 & 1073741823;
  $4_1 = $30_1 >> 31;
  $10_1 = $4_1;
  $4_1 = $38_1 >> 31;
  $36_1 = $7_1 + 176 | 0;
  $16_1 = $14_1;
  $9_1 = $4_1;
  $69($36_1, $14_1, $30_1, $10_1, $10_1, $35_1, $38_1, $4_1, $4_1);
  $4_1 = $31_1 >> 31;
  $13_1 = $4_1;
  $4_1 = $20_1 >> 31;
  $33_1 = $7_1 + 144 | 0;
  $6_1 = $4_1;
  $69($33_1, $28_1, $31_1, $13_1, $13_1, $21_1, $20_1, $4_1, $4_1);
  $4_1 = $17_1;
  $23_1 = $4_1;
  $4_1 = $4_1 >> 31;
  $22_1 = $7_1 + 160 | 0;
  $27_1 = $4_1;
  $69($22_1, $32_1, $17_1, $4_1, $4_1, $35_1, $38_1, $9_1, $9_1);
  $4_1 = $18_1;
  $19_1 = $4_1;
  $4_1 = $4_1 >> 31;
  $35_1 = $7_1 + 128 | 0;
  $26_1 = $4_1;
  $69($35_1, $37_1, $18_1, $4_1, $4_1, $21_1, $20_1, $6_1, $6_1);
  $18_1 = HEAP32[$7_1 + 128 >> 2];
  $9_1 = HEAP32[$7_1 + 160 >> 2];
  $6_1 = $18_1 + $9_1 | 0;
  $17_1 = HEAP32[$7_1 + 132 >> 2];
  $4_1 = $17_1 + HEAP32[$7_1 + 164 >> 2] | 0;
  $9_1 = $6_1 >>> 0 < $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $14_1 = $15_1 << 2 | $12_1 >>> 30;
  $2_1 = $12_1 << 2 | $2_1 >>> 30;
  $12_1 = $2_1 + $6_1 | 0;
  $4_1 = $9_1 + $14_1 | 0;
  $2_1 = $2_1 >>> 0 > $12_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $4_1 = $9_1;
  $9_1 = $12_1;
  $14_1 = ($2_1 | 0) == ($4_1 | 0) & $6_1 >>> 0 > $9_1 >>> 0 | $2_1 >>> 0 < $4_1 >>> 0;
  $12_1 = ($4_1 | 0) == ($17_1 | 0) & $6_1 >>> 0 < $18_1 >>> 0 | $4_1 >>> 0 < $17_1 >>> 0;
  $4_1 = $22_1 + 8 | 0;
  $17_1 = HEAP32[$4_1 >> 2];
  $18_1 = $35_1 + 8 | 0;
  $6_1 = $17_1 + HEAP32[$18_1 >> 2] | 0;
  $4_1 = HEAP32[$18_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
  $4_1 = $6_1 >>> 0 < $17_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $18_1 = $6_1;
  $6_1 = $6_1 + $12_1 | 0;
  $4_1 = ($15_1 >> 31) + ($18_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
  $15_1 = $15_1 >> 30;
  $6_1 = $6_1 + $15_1 | 0;
  $4_1 = $15_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $12_1 = $6_1 + $14_1 | 0;
  $15_1 = $12_1 >>> 0 < $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $21_1 = HEAP32[$7_1 + 144 >> 2];
  $6_1 = HEAP32[$7_1 + 176 >> 2];
  $14_1 = $21_1 + $6_1 | 0;
  $18_1 = HEAP32[$7_1 + 148 >> 2];
  $4_1 = $18_1 + HEAP32[$7_1 + 180 >> 2] | 0;
  $6_1 = $6_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $17_1 = $8_1 << 2 | $11_1 >>> 30;
  $5_1 = $11_1 << 2 | $5_1 >>> 30;
  $11_1 = $5_1 + $14_1 | 0;
  $4_1 = $6_1 + $17_1 | 0;
  $5_1 = $5_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $4_1 = $6_1;
  $6_1 = $11_1;
  $17_1 = ($5_1 | 0) == ($4_1 | 0) & $14_1 >>> 0 > $6_1 >>> 0 | $4_1 >>> 0 > $5_1 >>> 0;
  $14_1 = ($4_1 | 0) == ($18_1 | 0) & $14_1 >>> 0 < $21_1 >>> 0 | $4_1 >>> 0 < $18_1 >>> 0;
  $4_1 = $36_1 + 8 | 0;
  $18_1 = HEAP32[$4_1 >> 2];
  $21_1 = $33_1 + 8 | 0;
  $11_1 = $18_1 + HEAP32[$21_1 >> 2] | 0;
  $4_1 = HEAP32[$21_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
  $4_1 = $11_1 >>> 0 < $18_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $18_1 = $11_1;
  $11_1 = $11_1 + $14_1 | 0;
  $4_1 = ($8_1 >> 31) + ($18_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
  $8_1 = $8_1 >> 30;
  $11_1 = $8_1 + $11_1 | 0;
  $4_1 = $8_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $8_1 = $11_1;
  $11_1 = $11_1 + $17_1 | 0;
  $8_1 = $8_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $17_1 = HEAP32[$3_1 + 24 >> 2];
  $18_1 = HEAP32[$3_1 + 28 >> 2];
  if ($17_1 | $18_1) {
   $4_1 = $18_1 >> 31;
   $21_1 = $7_1 + 112 | 0;
   $14_1 = $4_1;
   $4_1 = $25_1 >> 31;
   $69($21_1, $17_1, $18_1, $14_1, $14_1, $29_1, $25_1, $4_1, $4_1);
   $20_1 = $7_1 + 96 | 0;
   $4_1 = $24_1 >> 31;
   $69($20_1, $17_1, $18_1, $14_1, $14_1, $34_1, $24_1, $4_1, $4_1);
   $14_1 = HEAP32[$7_1 + 100 >> 2];
   $4_1 = $14_1 + $2_1 | 0;
   $2_1 = $9_1;
   $17_1 = HEAP32[$7_1 + 96 >> 2];
   $9_1 = $17_1 + $9_1 | 0;
   $2_1 = $2_1 >>> 0 > $9_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $17_1 = ($14_1 | 0) == ($2_1 | 0) & $9_1 >>> 0 < $17_1 >>> 0 | $2_1 >>> 0 < $14_1 >>> 0;
   $4_1 = $20_1 + 8 | 0;
   $14_1 = HEAP32[$4_1 >> 2] + $12_1 | 0;
   $4_1 = HEAP32[$4_1 + 4 >> 2] + $15_1 | 0;
   $4_1 = $12_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $12_1 = $14_1 + $17_1 | 0;
   $15_1 = $12_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $14_1 = HEAP32[$7_1 + 116 >> 2];
   $4_1 = $14_1 + $5_1 | 0;
   $5_1 = $6_1;
   $17_1 = HEAP32[$7_1 + 112 >> 2];
   $6_1 = $17_1 + $6_1 | 0;
   $5_1 = $5_1 >>> 0 > $6_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $17_1 = ($14_1 | 0) == ($5_1 | 0) & $6_1 >>> 0 < $17_1 >>> 0 | $5_1 >>> 0 < $14_1 >>> 0;
   $4_1 = $21_1 + 8 | 0;
   $14_1 = HEAP32[$4_1 >> 2] + $11_1 | 0;
   $4_1 = HEAP32[$4_1 + 4 >> 2] + $8_1 | 0;
   $4_1 = $11_1 >>> 0 > $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
   $11_1 = $14_1 + $17_1 | 0;
   $8_1 = $11_1 >>> 0 < $14_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  }
  HEAP32[$0_1 + 16 >> 2] = $6_1;
  HEAP32[$0_1 + 20 >> 2] = $5_1 & 1073741823;
  HEAP32[$1_1 + 16 >> 2] = $9_1;
  HEAP32[$1_1 + 20 >> 2] = $2_1 & 1073741823;
  $4_1 = $45_1 >> 31;
  $6_1 = $4_1;
  $17_1 = $7_1 + 80 | 0;
  $18_1 = $45_1;
  $69($17_1, $16_1, $30_1, $10_1, $10_1, $44_1, $18_1, $4_1, $4_1);
  $30_1 = $7_1 + 48 | 0;
  $10_1 = $13_1;
  $16_1 = $50_1;
  $4_1 = $16_1 >> 31;
  $69($30_1, $28_1, $31_1, $10_1, $10_1, $43_1, $16_1, $4_1, $4_1);
  $28_1 = $7_1 - -64 | 0;
  $69($28_1, $32_1, $23_1, $27_1, $27_1, $44_1, $18_1, $6_1, $6_1);
  $31_1 = $7_1 + 32 | 0;
  $69($31_1, $37_1, $19_1, $26_1, $26_1, $43_1, $16_1, $4_1, $4_1);
  $9_1 = HEAP32[$3_1 + 32 >> 2];
  $3_1 = HEAP32[$3_1 + 36 >> 2];
  $6_1 = $3_1;
  $3_1 = $6_1 >> 31;
  $4_1 = $25_1 >> 31;
  $69($7_1, $9_1, $6_1, $3_1, $3_1, $29_1, $25_1, $4_1, $4_1);
  $16_1 = $7_1 + 16 | 0;
  $4_1 = $24_1 >> 31;
  $69($16_1, $9_1, $6_1, $3_1, $3_1, $34_1, $24_1, $4_1, $4_1);
  $9_1 = $0_1;
  $18_1 = HEAP32[$7_1 + 48 >> 2];
  $0_1 = HEAP32[$7_1 + 80 >> 2];
  $3_1 = $18_1 + $0_1 | 0;
  $13_1 = HEAP32[$7_1 + 52 >> 2];
  $4_1 = $13_1 + HEAP32[$7_1 + 84 >> 2] | 0;
  $0_1 = $0_1 >>> 0 > $3_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $25_1 = $3_1;
  $5_1 = $11_1 << 2 | $5_1 >>> 30;
  $3_1 = $3_1 + $5_1 | 0;
  $4_1 = $0_1 + ($8_1 << 2 | $11_1 >>> 30) | 0;
  $6_1 = $3_1 >>> 0 < $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $4_1 = $6_1 + HEAP32[$7_1 + 4 >> 2] | 0;
  $29_1 = $3_1;
  $3_1 = HEAP32[$7_1 >> 2];
  $5_1 = $29_1 + $3_1 | 0;
  $10_1 = $5_1;
  HEAP32[$9_1 + 24 >> 2] = $5_1;
  $3_1 = $3_1 >>> 0 > $5_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  HEAP32[$9_1 + 28 >> 2] = $3_1 & 1073741823;
  $5_1 = $1_1;
  $1_1 = $12_1 << 2 | $2_1 >>> 30;
  $12_1 = $15_1 << 2 | $12_1 >>> 30;
  $32_1 = HEAP32[$7_1 + 32 >> 2];
  $2_1 = HEAP32[$7_1 + 64 >> 2];
  $11_1 = $32_1 + $2_1 | 0;
  $14_1 = HEAP32[$7_1 + 36 >> 2];
  $4_1 = $14_1 + HEAP32[$7_1 + 68 >> 2] | 0;
  $2_1 = $2_1 >>> 0 > $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $4_1 = $2_1 + $12_1 | 0;
  $1_1 = $1_1 + $11_1 | 0;
  $12_1 = $1_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $4_1 = $12_1 + HEAP32[$7_1 + 20 >> 2] | 0;
  $24_1 = $1_1;
  $1_1 = HEAP32[$7_1 + 16 >> 2];
  $34_1 = $24_1 + $1_1 | 0;
  HEAP32[$5_1 + 24 >> 2] = $34_1;
  $1_1 = $1_1 >>> 0 > $34_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  HEAP32[$5_1 + 28 >> 2] = $1_1 & 1073741823;
  $10_1 = ($3_1 | 0) == ($6_1 | 0) & $10_1 >>> 0 < $29_1 >>> 0 | $3_1 >>> 0 < $6_1 >>> 0;
  $4_1 = $7_1 + 8 | 0;
  $37_1 = HEAP32[$4_1 >> 2];
  $23_1 = HEAP32[$4_1 + 4 >> 2];
  $29_1 = ($0_1 | 0) == ($6_1 | 0) & $25_1 >>> 0 > $29_1 >>> 0 | $0_1 >>> 0 > $6_1 >>> 0;
  $6_1 = ($0_1 | 0) == ($13_1 | 0) & $18_1 >>> 0 > $25_1 >>> 0 | $0_1 >>> 0 < $13_1 >>> 0;
  $4_1 = $17_1 + 8 | 0;
  $25_1 = HEAP32[$4_1 >> 2];
  $13_1 = $30_1 + 8 | 0;
  $0_1 = $25_1 + HEAP32[$13_1 >> 2] | 0;
  $4_1 = HEAP32[$13_1 + 4 >> 2] + HEAP32[$4_1 + 4 >> 2] | 0;
  $4_1 = $0_1 >>> 0 < $25_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $13_1 = $0_1;
  $0_1 = $0_1 + $6_1 | 0;
  $4_1 = ($8_1 >> 31) + ($13_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
  $8_1 = $8_1 >> 30;
  $0_1 = $0_1 + $8_1 | 0;
  $4_1 = $8_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $6_1 = $0_1;
  $0_1 = $0_1 + $29_1 | 0;
  $4_1 = ($6_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $23_1 | 0;
  $6_1 = $0_1;
  $0_1 = $0_1 + $37_1 | 0;
  $4_1 = $6_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $6_1 = $0_1;
  $0_1 = $0_1 + $10_1 | 0;
  $6_1 = ($6_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) << 2 | $0_1 >>> 30;
  HEAP32[$9_1 + 32 >> 2] = $0_1 << 2 | $3_1 >>> 30;
  HEAP32[$9_1 + 36 >> 2] = $6_1;
  $9_1 = ($1_1 | 0) == ($12_1 | 0) & $24_1 >>> 0 > $34_1 >>> 0 | $1_1 >>> 0 < $12_1 >>> 0;
  $0_1 = $16_1 + 8 | 0;
  $6_1 = HEAP32[$0_1 >> 2];
  $8_1 = HEAP32[$0_1 + 4 >> 2];
  $12_1 = ($2_1 | 0) == ($12_1 | 0) & $11_1 >>> 0 > $24_1 >>> 0 | $2_1 >>> 0 > $12_1 >>> 0;
  $2_1 = ($2_1 | 0) == ($14_1 | 0) & $11_1 >>> 0 < $32_1 >>> 0 | $2_1 >>> 0 < $14_1 >>> 0;
  $3_1 = $28_1 + 8 | 0;
  $11_1 = HEAP32[$3_1 >> 2];
  $4_1 = $31_1 + 8 | 0;
  $0_1 = $11_1 + HEAP32[$4_1 >> 2] | 0;
  $4_1 = HEAP32[$4_1 + 4 >> 2] + HEAP32[$3_1 + 4 >> 2] | 0;
  $4_1 = $0_1 >>> 0 < $11_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $3_1 = $0_1;
  $0_1 = $0_1 + $2_1 | 0;
  $4_1 = ($15_1 >> 31) + ($3_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) | 0;
  $3_1 = $15_1 >> 30;
  $0_1 = $0_1 + $3_1 | 0;
  $4_1 = $3_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $2_1 = $0_1;
  $0_1 = $0_1 + $12_1 | 0;
  $4_1 = ($2_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) + $8_1 | 0;
  $2_1 = $0_1;
  $0_1 = $0_1 + $6_1 | 0;
  $4_1 = $2_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1;
  $2_1 = $0_1;
  $0_1 = $0_1 + $9_1 | 0;
  $2_1 = ($2_1 >>> 0 > $0_1 >>> 0 ? $4_1 + 1 | 0 : $4_1) << 2 | $0_1 >>> 30;
  HEAP32[$5_1 + 32 >> 2] = $0_1 << 2 | $1_1 >>> 30;
  HEAP32[$5_1 + 36 >> 2] = $2_1;
  global$0 = $7_1 + 480 | 0;
 }
 
 function $68($0_1, $1_1) {
  var $2_1 = 0, $3_1 = 0, $4_1 = 0;
  $2_1 = $1_1;
  label$1 : {
   if ($1_1 >>> 0 <= 15) {
    $1_1 = $0_1;
    break label$1;
   }
   $3_1 = 0 - $0_1 & 3;
   $4_1 = $3_1 + $0_1 | 0;
   if ($3_1) {
    $1_1 = $0_1;
    while (1) {
     HEAP8[$1_1 | 0] = 0;
     $1_1 = $1_1 + 1 | 0;
     if ($4_1 >>> 0 > $1_1 >>> 0) {
      continue
     }
     break;
    };
   }
   $2_1 = $2_1 - $3_1 | 0;
   $3_1 = $2_1 & -4;
   $1_1 = $3_1 + $4_1 | 0;
   if (($3_1 | 0) > 0) {
    while (1) {
     HEAP32[$4_1 >> 2] = 0;
     $4_1 = $4_1 + 4 | 0;
     if ($4_1 >>> 0 < $1_1 >>> 0) {
      continue
     }
     break;
    }
   }
   $2_1 = $2_1 & 3;
  }
  if ($2_1) {
   $2_1 = $1_1 + $2_1 | 0;
   while (1) {
    HEAP8[$1_1 | 0] = 0;
    $1_1 = $1_1 + 1 | 0;
    if ($2_1 >>> 0 > $1_1 >>> 0) {
     continue
    }
    break;
   };
  }
  return $0_1;
 }
 
 function $69($0_1, $1_1, $2_1, $3_1, $4_1, $5_1, $6_1, $7_1, $8_1) {
  var $9_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $14_1 = 0, $15_1 = 0;
  $9_1 = __wasm_i64_mul($5_1, 0, $1_1, 0);
  $12_1 = $0_1;
  $10_1 = i64toi32_i32$HIGH_BITS;
  $15_1 = $1_1;
  $1_1 = __wasm_i64_mul($1_1, 0, $6_1, 0);
  $11_1 = i64toi32_i32$HIGH_BITS;
  $13_1 = __wasm_i64_mul($5_1, 0, $2_1, 0);
  $14_1 = i64toi32_i32$HIGH_BITS;
  $0_1 = $11_1 + $14_1 | 0;
  $11_1 = $1_1 + $13_1 | 0;
  $1_1 = $11_1 >>> 0 < $13_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = $10_1 + $11_1 | 0;
  $0_1 = 0 > $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  HEAP32[$12_1 >> 2] = $9_1;
  HEAP32[$12_1 + 4 >> 2] = $0_1;
  $10_1 = ($0_1 | 0) == ($10_1 | 0) & $9_1 >>> 0 < $9_1 >>> 0 | $0_1 >>> 0 < $10_1 >>> 0;
  $0_1 = ($1_1 | 0) == ($14_1 | 0) & $11_1 >>> 0 < $13_1 >>> 0 | $1_1 >>> 0 < $14_1 >>> 0;
  $9_1 = $1_1;
  $1_1 = $1_1 + __wasm_i64_mul($2_1, 0, $6_1, 0) | 0;
  $0_1 = i64toi32_i32$HIGH_BITS + $0_1 | 0;
  $0_1 = $1_1 >>> 0 < $9_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $9_1 = $1_1;
  $1_1 = $1_1 + $10_1 | 0;
  $9_1 = $9_1 >>> 0 > $1_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  $0_1 = __wasm_i64_mul($15_1, $2_1, $7_1, $8_1);
  $7_1 = i64toi32_i32$HIGH_BITS;
  $3_1 = __wasm_i64_mul($3_1, $4_1, $5_1, $6_1);
  $2_1 = $3_1 + $0_1 | 0;
  $0_1 = $7_1 + i64toi32_i32$HIGH_BITS | 0;
  $0_1 = ($2_1 >>> 0 < $3_1 >>> 0 ? $0_1 + 1 | 0 : $0_1) + $9_1 | 0;
  $1_1 = $1_1 + $2_1 | 0;
  $0_1 = $1_1 >>> 0 < $2_1 >>> 0 ? $0_1 + 1 | 0 : $0_1;
  HEAP32[$12_1 + 8 >> 2] = $1_1;
  HEAP32[$12_1 + 12 >> 2] = $0_1;
 }
 
 function $70($0_1, $1_1, $2_1) {
  var $3_1 = 0, $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $10_1 = 0;
  $6_1 = $2_1;
  label$1 : {
   if ($2_1 >>> 0 <= 15) {
    $2_1 = $0_1;
    break label$1;
   }
   $5_1 = 0 - $0_1 & 3;
   $4_1 = $5_1 + $0_1 | 0;
   if ($5_1) {
    $2_1 = $0_1;
    $3_1 = $1_1;
    while (1) {
     HEAP8[$2_1 | 0] = HEAPU8[$3_1 | 0];
     $3_1 = $3_1 + 1 | 0;
     $2_1 = $2_1 + 1 | 0;
     if ($4_1 >>> 0 > $2_1 >>> 0) {
      continue
     }
     break;
    };
   }
   $6_1 = $6_1 - $5_1 | 0;
   $7_1 = $6_1 & -4;
   $2_1 = $7_1 + $4_1 | 0;
   $5_1 = $1_1 + $5_1 | 0;
   $3_1 = $5_1 & 3;
   label$5 : {
    if ($3_1) {
     if (($7_1 | 0) <= 0) {
      break label$5
     }
     $8_1 = $5_1 & -4;
     $1_1 = $8_1 + 4 | 0;
     $9_1 = $3_1 << 3;
     $10_1 = 0 - $9_1 & 24;
     $3_1 = HEAP32[$8_1 >> 2];
     while (1) {
      $8_1 = $3_1 >>> $9_1 | 0;
      $3_1 = HEAP32[$1_1 >> 2];
      HEAP32[$4_1 >> 2] = $8_1 | $3_1 << $10_1;
      $1_1 = $1_1 + 4 | 0;
      $4_1 = $4_1 + 4 | 0;
      if ($4_1 >>> 0 < $2_1 >>> 0) {
       continue
      }
      break;
     };
     break label$5;
    }
    if (($7_1 | 0) <= 0) {
     break label$5
    }
    $1_1 = $5_1;
    while (1) {
     HEAP32[$4_1 >> 2] = HEAP32[$1_1 >> 2];
     $1_1 = $1_1 + 4 | 0;
     $4_1 = $4_1 + 4 | 0;
     if ($4_1 >>> 0 < $2_1 >>> 0) {
      continue
     }
     break;
    };
   }
   $6_1 = $6_1 & 3;
   $1_1 = $5_1 + $7_1 | 0;
  }
  if ($6_1) {
   $3_1 = $2_1 + $6_1 | 0;
   while (1) {
    HEAP8[$2_1 | 0] = HEAPU8[$1_1 | 0];
    $1_1 = $1_1 + 1 | 0;
    $2_1 = $2_1 + 1 | 0;
    if ($3_1 >>> 0 > $2_1 >>> 0) {
     continue
    }
    break;
   };
  }
  return $0_1;
 }
 
 function __wasm_ctz_i64($0_1, $1_1) {
  var $2_1 = 0, $3_1 = 0;
  if ($0_1 | $1_1) {
   $2_1 = $1_1 - 1 | 0;
   $3_1 = $0_1 - 1 | 0;
   $2_1 = ($3_1 | 0) != -1 ? $2_1 + 1 | 0 : $2_1;
   $3_1 = $0_1 ^ $3_1;
   $0_1 = Math_clz32($1_1 ^ $2_1);
   if (($0_1 | 0) == 32) {
    $0_1 = Math_clz32($3_1) + 32 | 0
   }
   i64toi32_i32$HIGH_BITS = 0 - ($0_1 >>> 0 > 63) | 0;
   return 63 - $0_1 | 0;
  }
  i64toi32_i32$HIGH_BITS = 0;
  return 64;
 }
 
 function __wasm_i64_mul($0_1, $1_1, $2_1, $3_1) {
  var $4_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0;
  $4_1 = $2_1 & 65535;
  $5_1 = $0_1 & 65535;
  $6_1 = Math_imul($4_1, $5_1);
  $7_1 = $2_1 >>> 16 | 0;
  $9_1 = Math_imul($5_1, $7_1);
  $8_1 = $0_1 >>> 16 | 0;
  $5_1 = Math_imul($4_1, $8_1) + ($6_1 >>> 16 | 0) | 0;
  $4_1 = $9_1 + ($5_1 & 65535) | 0;
  i64toi32_i32$HIGH_BITS = (Math_imul($1_1, $2_1) + Math_imul($7_1, $8_1) | 0) + Math_imul($0_1, $3_1) + ($5_1 >>> 16) + ($4_1 >>> 16) | 0;
  return $6_1 & 65535 | $4_1 << 16;
 }
 
 function __wasm_rotl_i32($0_1, $1_1) {
  var $2_1 = 0, $3_1 = 0;
  $2_1 = $1_1 & 31;
  $3_1 = (-1 >>> $2_1 & $0_1) << $2_1;
  $2_1 = $0_1;
  $0_1 = 0 - $1_1 & 31;
  return $3_1 | ($2_1 & -1 << $0_1) >>> $0_1;
 }
 
 bufferView = HEAPU8;
 initActiveSegments(imports);
 var FUNCTION_TABLE = [null, $4, $0, $3, $44, $61, $28];
 function __wasm_memory_size() {
  return buffer.byteLength / 65536 | 0;
 }
 
 function __wasm_memory_grow(pagesToAdd) {
  pagesToAdd = pagesToAdd | 0;
  var oldPages = __wasm_memory_size() | 0;
  var newPages = oldPages + pagesToAdd | 0;
  if ((oldPages < newPages) && (newPages < 65536)) {
   var newBuffer = new ArrayBuffer(Math_imul(newPages, 65536));
   var newHEAP8 = new Int8Array(newBuffer);
   newHEAP8.set(HEAP8);
   HEAP8 = new Int8Array(newBuffer);
   HEAP16 = new Int16Array(newBuffer);
   HEAP32 = new Int32Array(newBuffer);
   HEAPU8 = new Uint8Array(newBuffer);
   HEAPU16 = new Uint16Array(newBuffer);
   HEAPU32 = new Uint32Array(newBuffer);
   HEAPF32 = new Float32Array(newBuffer);
   HEAPF64 = new Float64Array(newBuffer);
   buffer = newBuffer;
   bufferView = HEAPU8;
  }
  return oldPages;
 }
 
 return {
  "memory": Object.create(Object.prototype, {
   "grow": {
    "value": __wasm_memory_grow
   }, 
   "buffer": {
    "get": function () {
     return buffer;
    }
    
   }
  }), 
  "initializeContext": $7, 
  "isPoint": $8, 
  "PUBLIC_KEY_INPUT": {
   get value() {
    return global$1;
   }, 
   set value(_global$1) {
    global$1 = _global$1;
   }
  }, 
  "pointAdd": $9, 
  "PUBLIC_KEY_INPUT2": {
   get value() {
    return global$2;
   }, 
   set value(_global$2) {
    global$2 = _global$2;
   }
  }, 
  "pointAddScalar": $10, 
  "TWEAK_INPUT": {
   get value() {
    return global$3;
   }, 
   set value(_global$3) {
    global$3 = _global$3;
   }
  }, 
  "xOnlyPointAddTweak": $11, 
  "X_ONLY_PUBLIC_KEY_INPUT": {
   get value() {
    return global$4;
   }, 
   set value(_global$4) {
    global$4 = _global$4;
   }
  }, 
  "xOnlyPointAddTweakCheck": $12, 
  "X_ONLY_PUBLIC_KEY_INPUT2": {
   get value() {
    return global$5;
   }, 
   set value(_global$5) {
    global$5 = _global$5;
   }
  }, 
  "pointCompress": $13, 
  "pointFromScalar": $14, 
  "PRIVATE_INPUT": {
   get value() {
    return global$6;
   }, 
   set value(_global$6) {
    global$6 = _global$6;
   }
  }, 
  "xOnlyPointFromScalar": $15, 
  "xOnlyPointFromPoint": $16, 
  "pointMultiply": $17, 
  "privateAdd": $18, 
  "privateSub": $19, 
  "privateNegate": $20, 
  "sign": $21, 
  "HASH_INPUT": {
   get value() {
    return global$7;
   }, 
   set value(_global$7) {
    global$7 = _global$7;
   }
  }, 
  "EXTRA_DATA_INPUT": {
   get value() {
    return global$8;
   }, 
   set value(_global$8) {
    global$8 = _global$8;
   }
  }, 
  "SIGNATURE_INPUT": {
   get value() {
    return global$9;
   }, 
   set value(_global$9) {
    global$9 = _global$9;
   }
  }, 
  "signRecoverable": $22, 
  "signSchnorr": $23, 
  "verify": $24, 
  "recover": $25, 
  "verifySchnorr": $26, 
  "rustsecp256k1_v0_8_1_default_error_callback_fn": $28, 
  "rustsecp256k1_v0_8_1_default_illegal_callback_fn": $28, 
  "__data_end": {
   get value() {
    return global$10;
   }, 
   set value(_global$10) {
    global$10 = _global$10;
   }
  }, 
  "__heap_base": {
   get value() {
    return global$11;
   }, 
   set value(_global$11) {
    global$11 = _global$11;
   }
  }
 };
}

var retasmFunc = asmFunc({
  "./rand.js": rand_browser_namespaceObject,
  "./validate_error.js": validate_error_namespaceObject,
});
var memory = retasmFunc.memory;
var initializeContext = retasmFunc.initializeContext;
var secp256k1_asm_isPoint = retasmFunc.isPoint;
var PUBLIC_KEY_INPUT = retasmFunc.PUBLIC_KEY_INPUT;
var pointAdd = retasmFunc.pointAdd;
var PUBLIC_KEY_INPUT2 = retasmFunc.PUBLIC_KEY_INPUT2;
var pointAddScalar = retasmFunc.pointAddScalar;
var TWEAK_INPUT = retasmFunc.TWEAK_INPUT;
var xOnlyPointAddTweak = retasmFunc.xOnlyPointAddTweak;
var X_ONLY_PUBLIC_KEY_INPUT = retasmFunc.X_ONLY_PUBLIC_KEY_INPUT;
var xOnlyPointAddTweakCheck = retasmFunc.xOnlyPointAddTweakCheck;
var X_ONLY_PUBLIC_KEY_INPUT2 = retasmFunc.X_ONLY_PUBLIC_KEY_INPUT2;
var pointCompress = retasmFunc.pointCompress;
var pointFromScalar = retasmFunc.pointFromScalar;
var PRIVATE_INPUT = retasmFunc.PRIVATE_INPUT;
var xOnlyPointFromScalar = retasmFunc.xOnlyPointFromScalar;
var xOnlyPointFromPoint = retasmFunc.xOnlyPointFromPoint;
var pointMultiply = retasmFunc.pointMultiply;
var privateAdd = retasmFunc.privateAdd;
var privateSub = retasmFunc.privateSub;
var privateNegate = retasmFunc.privateNegate;
var sign = retasmFunc.sign;
var HASH_INPUT = retasmFunc.HASH_INPUT;
var EXTRA_DATA_INPUT = retasmFunc.EXTRA_DATA_INPUT;
var SIGNATURE_INPUT = retasmFunc.SIGNATURE_INPUT;
var signRecoverable = retasmFunc.signRecoverable;
var signSchnorr = retasmFunc.signSchnorr;
var verify = retasmFunc.verify;
var recover = retasmFunc.recover;
var verifySchnorr = retasmFunc.verifySchnorr;
var rustsecp256k1_v0_8_1_default_error_callback_fn = retasmFunc.rustsecp256k1_v0_8_1_default_error_callback_fn;
var rustsecp256k1_v0_8_1_default_illegal_callback_fn = retasmFunc.rustsecp256k1_v0_8_1_default_illegal_callback_fn;
var __data_end = retasmFunc.__data_end;
var __heap_base = retasmFunc.__heap_base;

;// CONCATENATED MODULE: ./node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/wasm_loader.js
// Suppress TS2792: Cannot find module './secp256k1.asm.js'.
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore

/* harmony default export */ var wasm_loader = (secp256k1_asm_namespaceObject);

;// CONCATENATED MODULE: ./node_modules/@bitcoin-js/tiny-secp256k1-asmjs/lib/index.js



const WASM_BUFFER = new Uint8Array(wasm_loader.memory.buffer);
const WASM_PRIVATE_KEY_PTR = wasm_loader.PRIVATE_INPUT.value;
const WASM_PUBLIC_KEY_INPUT_PTR = wasm_loader.PUBLIC_KEY_INPUT.value;
const WASM_PUBLIC_KEY_INPUT_PTR2 = wasm_loader.PUBLIC_KEY_INPUT2.value;
const WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR = wasm_loader.X_ONLY_PUBLIC_KEY_INPUT.value;
const WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR = wasm_loader.X_ONLY_PUBLIC_KEY_INPUT2.value;
const WASM_TWEAK_INPUT_PTR = wasm_loader.TWEAK_INPUT.value;
const WASM_HASH_INPUT_PTR = wasm_loader.HASH_INPUT.value;
const WASM_EXTRA_DATA_INPUT_PTR = wasm_loader.EXTRA_DATA_INPUT.value;
const WASM_SIGNATURE_INPUT_PTR = wasm_loader.SIGNATURE_INPUT.value;
const PRIVATE_KEY_INPUT = WASM_BUFFER.subarray(WASM_PRIVATE_KEY_PTR, WASM_PRIVATE_KEY_PTR + PRIVATE_KEY_SIZE);
const lib_PUBLIC_KEY_INPUT = WASM_BUFFER.subarray(WASM_PUBLIC_KEY_INPUT_PTR, WASM_PUBLIC_KEY_INPUT_PTR + PUBLIC_KEY_UNCOMPRESSED_SIZE);
const lib_PUBLIC_KEY_INPUT2 = WASM_BUFFER.subarray(WASM_PUBLIC_KEY_INPUT_PTR2, WASM_PUBLIC_KEY_INPUT_PTR2 + PUBLIC_KEY_UNCOMPRESSED_SIZE);
const lib_X_ONLY_PUBLIC_KEY_INPUT = WASM_BUFFER.subarray(WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR, WASM_X_ONLY_PUBLIC_KEY_INPUT_PTR + X_ONLY_PUBLIC_KEY_SIZE);
const lib_X_ONLY_PUBLIC_KEY_INPUT2 = WASM_BUFFER.subarray(WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR, WASM_X_ONLY_PUBLIC_KEY_INPUT2_PTR + X_ONLY_PUBLIC_KEY_SIZE);
const lib_TWEAK_INPUT = WASM_BUFFER.subarray(WASM_TWEAK_INPUT_PTR, WASM_TWEAK_INPUT_PTR + TWEAK_SIZE);
const lib_HASH_INPUT = WASM_BUFFER.subarray(WASM_HASH_INPUT_PTR, WASM_HASH_INPUT_PTR + HASH_SIZE);
const lib_EXTRA_DATA_INPUT = WASM_BUFFER.subarray(WASM_EXTRA_DATA_INPUT_PTR, WASM_EXTRA_DATA_INPUT_PTR + EXTRA_DATA_SIZE);
const lib_SIGNATURE_INPUT = WASM_BUFFER.subarray(WASM_SIGNATURE_INPUT_PTR, WASM_SIGNATURE_INPUT_PTR + SIGNATURE_SIZE);
function assumeCompression(compressed, p) {
    if (compressed === undefined) {
        return p !== undefined ? p.length : PUBLIC_KEY_COMPRESSED_SIZE;
    }
    return compressed
        ? PUBLIC_KEY_COMPRESSED_SIZE
        : PUBLIC_KEY_UNCOMPRESSED_SIZE;
}
function _isPoint(p) {
    try {
        lib_PUBLIC_KEY_INPUT.set(p);
        return wasm_loader.isPoint(p.length) === 1;
    }
    finally {
        lib_PUBLIC_KEY_INPUT.fill(0);
    }
}
function __initializeContext() {
    wasm_loader.initializeContext();
}
function lib_isPoint(p) {
    return isDERPoint(p) && _isPoint(p);
}
function lib_isPointCompressed(p) {
    return isPointCompressed(p) && _isPoint(p);
}
function lib_isXOnlyPoint(p) {
    return isXOnlyPoint(p) && _isPoint(p);
}
function lib_isPrivate(d) {
    return isPrivate(d);
}
function lib_pointAdd(pA, pB, compressed) {
    validatePoint(pA);
    validatePoint(pB);
    const outputlen = assumeCompression(compressed, pA);
    try {
        lib_PUBLIC_KEY_INPUT.set(pA);
        lib_PUBLIC_KEY_INPUT2.set(pB);
        return wasm_loader.pointAdd(pA.length, pB.length, outputlen) === 1
            ? lib_PUBLIC_KEY_INPUT.slice(0, outputlen)
            : null;
    }
    finally {
        lib_PUBLIC_KEY_INPUT.fill(0);
        lib_PUBLIC_KEY_INPUT2.fill(0);
    }
}
function lib_pointAddScalar(p, tweak, compressed) {
    validatePoint(p);
    validateTweak(tweak);
    const outputlen = assumeCompression(compressed, p);
    try {
        lib_PUBLIC_KEY_INPUT.set(p);
        lib_TWEAK_INPUT.set(tweak);
        return wasm_loader.pointAddScalar(p.length, outputlen) === 1
            ? lib_PUBLIC_KEY_INPUT.slice(0, outputlen)
            : null;
    }
    finally {
        lib_PUBLIC_KEY_INPUT.fill(0);
        lib_TWEAK_INPUT.fill(0);
    }
}
function lib_pointCompress(p, compressed) {
    validatePoint(p);
    const outputlen = assumeCompression(compressed, p);
    try {
        lib_PUBLIC_KEY_INPUT.set(p);
        wasm_loader.pointCompress(p.length, outputlen);
        return lib_PUBLIC_KEY_INPUT.slice(0, outputlen);
    }
    finally {
        lib_PUBLIC_KEY_INPUT.fill(0);
    }
}
function lib_pointFromScalar(d, compressed) {
    validatePrivate(d);
    const outputlen = assumeCompression(compressed);
    try {
        PRIVATE_KEY_INPUT.set(d);
        return wasm_loader.pointFromScalar(outputlen) === 1
            ? lib_PUBLIC_KEY_INPUT.slice(0, outputlen)
            : null;
    }
    finally {
        PRIVATE_KEY_INPUT.fill(0);
        lib_PUBLIC_KEY_INPUT.fill(0);
    }
}
function lib_xOnlyPointFromScalar(d) {
    validatePrivate(d);
    try {
        PRIVATE_KEY_INPUT.set(d);
        wasm_loader.xOnlyPointFromScalar();
        return lib_X_ONLY_PUBLIC_KEY_INPUT.slice(0, X_ONLY_PUBLIC_KEY_SIZE);
    }
    finally {
        PRIVATE_KEY_INPUT.fill(0);
        lib_X_ONLY_PUBLIC_KEY_INPUT.fill(0);
    }
}
function lib_xOnlyPointFromPoint(p) {
    validatePoint(p);
    try {
        lib_PUBLIC_KEY_INPUT.set(p);
        wasm_loader.xOnlyPointFromPoint(p.length);
        return lib_X_ONLY_PUBLIC_KEY_INPUT.slice(0, X_ONLY_PUBLIC_KEY_SIZE);
    }
    finally {
        lib_PUBLIC_KEY_INPUT.fill(0);
        lib_X_ONLY_PUBLIC_KEY_INPUT.fill(0);
    }
}
function lib_pointMultiply(p, tweak, compressed) {
    validatePoint(p);
    validateTweak(tweak);
    const outputlen = assumeCompression(compressed, p);
    try {
        lib_PUBLIC_KEY_INPUT.set(p);
        lib_TWEAK_INPUT.set(tweak);
        return wasm_loader.pointMultiply(p.length, outputlen) === 1
            ? lib_PUBLIC_KEY_INPUT.slice(0, outputlen)
            : null;
    }
    finally {
        lib_PUBLIC_KEY_INPUT.fill(0);
        lib_TWEAK_INPUT.fill(0);
    }
}
function lib_privateAdd(d, tweak) {
    validatePrivate(d);
    validateTweak(tweak);
    try {
        PRIVATE_KEY_INPUT.set(d);
        lib_TWEAK_INPUT.set(tweak);
        return wasm_loader.privateAdd() === 1
            ? PRIVATE_KEY_INPUT.slice(0, PRIVATE_KEY_SIZE)
            : null;
    }
    finally {
        PRIVATE_KEY_INPUT.fill(0);
        lib_TWEAK_INPUT.fill(0);
    }
}
function lib_privateSub(d, tweak) {
    validatePrivate(d);
    validateTweak(tweak);
    // We can not pass zero tweak to WASM, because WASM use `secp256k1_ec_seckey_negate` for tweak negate.
    // (zero is not valid seckey)
    if (isZero(tweak)) {
        return new Uint8Array(d);
    }
    try {
        PRIVATE_KEY_INPUT.set(d);
        lib_TWEAK_INPUT.set(tweak);
        return wasm_loader.privateSub() === 1
            ? PRIVATE_KEY_INPUT.slice(0, PRIVATE_KEY_SIZE)
            : null;
    }
    finally {
        PRIVATE_KEY_INPUT.fill(0);
        lib_TWEAK_INPUT.fill(0);
    }
}
function lib_privateNegate(d) {
    validatePrivate(d);
    try {
        PRIVATE_KEY_INPUT.set(d);
        wasm_loader.privateNegate();
        return PRIVATE_KEY_INPUT.slice(0, PRIVATE_KEY_SIZE);
    }
    finally {
        PRIVATE_KEY_INPUT.fill(0);
    }
}
function lib_xOnlyPointAddTweak(p, tweak) {
    validateXOnlyPoint(p);
    validateTweak(tweak);
    try {
        lib_X_ONLY_PUBLIC_KEY_INPUT.set(p);
        lib_TWEAK_INPUT.set(tweak);
        const parity = wasm_loader.xOnlyPointAddTweak();
        return parity !== -1
            ? {
                parity,
                xOnlyPubkey: lib_X_ONLY_PUBLIC_KEY_INPUT.slice(0, X_ONLY_PUBLIC_KEY_SIZE),
            }
            : null;
    }
    finally {
        lib_X_ONLY_PUBLIC_KEY_INPUT.fill(0);
        lib_TWEAK_INPUT.fill(0);
    }
}
function lib_xOnlyPointAddTweakCheck(point, tweak, resultToCheck, tweakParity) {
    validateXOnlyPoint(point);
    validateXOnlyPoint(resultToCheck);
    validateTweak(tweak);
    const hasParity = tweakParity !== undefined;
    if (hasParity)
        validateParity(tweakParity);
    try {
        lib_X_ONLY_PUBLIC_KEY_INPUT.set(point);
        lib_X_ONLY_PUBLIC_KEY_INPUT2.set(resultToCheck);
        lib_TWEAK_INPUT.set(tweak);
        if (hasParity) {
            return wasm_loader.xOnlyPointAddTweakCheck(tweakParity) === 1;
        }
        else {
            wasm_loader.xOnlyPointAddTweak();
            const newKey = lib_X_ONLY_PUBLIC_KEY_INPUT.slice(0, X_ONLY_PUBLIC_KEY_SIZE);
            return compare(newKey, resultToCheck) === 0;
        }
    }
    finally {
        lib_X_ONLY_PUBLIC_KEY_INPUT.fill(0);
        lib_X_ONLY_PUBLIC_KEY_INPUT2.fill(0);
        lib_TWEAK_INPUT.fill(0);
    }
}
function lib_sign(h, d, e) {
    validateHash(h);
    validatePrivate(d);
    validateExtraData(e);
    try {
        lib_HASH_INPUT.set(h);
        PRIVATE_KEY_INPUT.set(d);
        if (e !== undefined)
            lib_EXTRA_DATA_INPUT.set(e);
        wasm_loader.sign(e === undefined ? 0 : 1);
        return lib_SIGNATURE_INPUT.slice(0, SIGNATURE_SIZE);
    }
    finally {
        lib_HASH_INPUT.fill(0);
        PRIVATE_KEY_INPUT.fill(0);
        if (e !== undefined)
            lib_EXTRA_DATA_INPUT.fill(0);
        lib_SIGNATURE_INPUT.fill(0);
    }
}
function lib_signRecoverable(h, d, e) {
    validateHash(h);
    validatePrivate(d);
    validateExtraData(e);
    try {
        lib_HASH_INPUT.set(h);
        PRIVATE_KEY_INPUT.set(d);
        if (e !== undefined)
            lib_EXTRA_DATA_INPUT.set(e);
        const recoveryId = wasm_loader.signRecoverable(e === undefined ? 0 : 1);
        const signature = lib_SIGNATURE_INPUT.slice(0, SIGNATURE_SIZE);
        return {
            signature,
            recoveryId,
        };
    }
    finally {
        lib_HASH_INPUT.fill(0);
        PRIVATE_KEY_INPUT.fill(0);
        if (e !== undefined)
            lib_EXTRA_DATA_INPUT.fill(0);
        lib_SIGNATURE_INPUT.fill(0);
    }
}
function lib_signSchnorr(h, d, e) {
    validateHash(h);
    validatePrivate(d);
    validateExtraData(e);
    try {
        lib_HASH_INPUT.set(h);
        PRIVATE_KEY_INPUT.set(d);
        if (e !== undefined)
            lib_EXTRA_DATA_INPUT.set(e);
        wasm_loader.signSchnorr(e === undefined ? 0 : 1);
        return lib_SIGNATURE_INPUT.slice(0, SIGNATURE_SIZE);
    }
    finally {
        lib_HASH_INPUT.fill(0);
        PRIVATE_KEY_INPUT.fill(0);
        if (e !== undefined)
            lib_EXTRA_DATA_INPUT.fill(0);
        lib_SIGNATURE_INPUT.fill(0);
    }
}
function lib_verify(h, Q, signature, strict = false) {
    validateHash(h);
    validatePoint(Q);
    validateSignature(signature);
    try {
        lib_HASH_INPUT.set(h);
        lib_PUBLIC_KEY_INPUT.set(Q);
        lib_SIGNATURE_INPUT.set(signature);
        return wasm_loader.verify(Q.length, strict === true ? 1 : 0) === 1 ? true : false;
    }
    finally {
        lib_HASH_INPUT.fill(0);
        lib_PUBLIC_KEY_INPUT.fill(0);
        lib_SIGNATURE_INPUT.fill(0);
    }
}
function lib_recover(h, signature, recoveryId, compressed = false) {
    validateHash(h);
    validateSignature(signature);
    validateSignatureNonzeroRS(signature);
    if (recoveryId & 2) {
        validateSigrPMinusN(signature);
    }
    validateSignatureCustom(() => lib_isXOnlyPoint(signature.subarray(0, 32)));
    const outputlen = assumeCompression(compressed);
    try {
        lib_HASH_INPUT.set(h);
        lib_SIGNATURE_INPUT.set(signature);
        return wasm_loader.recover(outputlen, recoveryId) === 1
            ? lib_PUBLIC_KEY_INPUT.slice(0, outputlen)
            : null;
    }
    finally {
        lib_HASH_INPUT.fill(0);
        lib_SIGNATURE_INPUT.fill(0);
        lib_PUBLIC_KEY_INPUT.fill(0);
    }
}
function lib_verifySchnorr(h, Q, signature) {
    validateHash(h);
    validateXOnlyPoint(Q);
    validateSignature(signature);
    try {
        lib_HASH_INPUT.set(h);
        lib_X_ONLY_PUBLIC_KEY_INPUT.set(Q);
        lib_SIGNATURE_INPUT.set(signature);
        return wasm_loader.verifySchnorr() === 1 ? true : false;
    }
    finally {
        lib_HASH_INPUT.fill(0);
        lib_X_ONLY_PUBLIC_KEY_INPUT.fill(0);
        lib_SIGNATURE_INPUT.fill(0);
    }
}


/***/ })

}]);